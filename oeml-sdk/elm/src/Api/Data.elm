{-
   OEML - REST API
   This section will provide necessary information about the `CoinAPI OEML REST API` protocol. This API is also available in the Postman application: <a href=\"https://postman.coinapi.io/\" target=\"_blank\">https://postman.coinapi.io/</a>       

   The version of the OpenAPI document: v1
   Contact: support@coinapi.io

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git

   DO NOT EDIT THIS FILE MANUALLY.

   For more info on generating Elm code, see https://eriktim.github.io/openapi-elm/
-}


module Api.Data exposing
    ( Balance
    , BalanceData, BalanceDataLastUpdatedBy(..), balanceDataLastUpdatedByVariants
    , Fills
    , Message
    , OrdSide(..), ordSideVariants
    , OrdStatus(..), ordStatusVariants
    , OrdType(..), ordTypeVariants
    , OrderCancelAllRequest
    , OrderCancelSingleRequest
    , OrderExecutionReport, OrderExecutionReportExecInst(..), orderExecutionReportExecInstVariants
    , OrderNewSingleRequest, OrderNewSingleRequestExecInst(..), orderNewSingleRequestExecInstVariants
    , Position
    , PositionData
    , Severity(..), severityVariants
    , TimeInForce(..), timeInForceVariants
    , ValidationError
    , encodeBalance
    , encodeBalanceData
    , encodeFills
    , encodeMessage
    , encodeOrdSide
    , encodeOrdStatus
    , encodeOrdType
    , encodeOrderCancelAllRequest
    , encodeOrderCancelSingleRequest
    , encodeOrderExecutionReport
    , encodeOrderNewSingleRequest
    , encodePosition
    , encodePositionData
    , encodeSeverity
    , encodeTimeInForce
    , encodeValidationError
    , balanceDecoder
    , balanceDataDecoder
    , fillsDecoder
    , messageDecoder
    , ordSideDecoder
    , ordStatusDecoder
    , ordTypeDecoder
    , orderCancelAllRequestDecoder
    , orderCancelSingleRequestDecoder
    , orderExecutionReportDecoder
    , orderNewSingleRequestDecoder
    , positionDecoder
    , positionDataDecoder
    , severityDecoder
    , timeInForceDecoder
    , validationErrorDecoder
    )

import Api
import Dict
import Json.Decode
import Json.Encode


-- MODEL


type alias Balance =
    { exchangeId : Maybe String
    , data : Maybe (List (BalanceData))
    }


type alias BalanceData =
    { assetIdExchange : Maybe String
    , assetIdCoinapi : Maybe String
    , balance : Maybe Float
    , available : Maybe Float
    , locked : Maybe Float
    , lastUpdatedBy : Maybe BalanceDataLastUpdatedBy
    , rateUsd : Maybe Float
    , traded : Maybe Float
    }


type BalanceDataLastUpdatedBy
    = BalanceDataLastUpdatedByINITIALIZATION
    | BalanceDataLastUpdatedByBALANCEMANAGER
    | BalanceDataLastUpdatedByEXCHANGE


balanceDataLastUpdatedByVariants : List BalanceDataLastUpdatedBy
balanceDataLastUpdatedByVariants =
    [ BalanceDataLastUpdatedByINITIALIZATION
    , BalanceDataLastUpdatedByBALANCEMANAGER
    , BalanceDataLastUpdatedByEXCHANGE
    ]


type alias Fills =
    { time : Maybe Posix
    , price : Maybe Float
    , amount : Maybe Float
    }


type alias Message =
    { type_ : Maybe String
    , severity : Maybe Severity
    , exchangeId : Maybe String
    , message : Maybe String
    }


{-| Side of order. 
-}
type OrdSide
    = OrdSideBUY
    | OrdSideSELL


ordSideVariants : List OrdSide
ordSideVariants =
    [ OrdSideBUY
    , OrdSideSELL
    ]


{-| Order statuses and the lifecycle are documented in the separate section: <a href=\"#oeml-order-lifecycle\">OEML / Starter Guide / Order Lifecycle</a> 
-}
type OrdStatus
    = OrdStatusRECEIVED
    | OrdStatusROUTING
    | OrdStatusROUTED
    | OrdStatusNEW
    | OrdStatusPENDINGCANCEL
    | OrdStatusPARTIALLYFILLED
    | OrdStatusFILLED
    | OrdStatusCANCELED
    | OrdStatusREJECTED


ordStatusVariants : List OrdStatus
ordStatusVariants =
    [ OrdStatusRECEIVED
    , OrdStatusROUTING
    , OrdStatusROUTED
    , OrdStatusNEW
    , OrdStatusPENDINGCANCEL
    , OrdStatusPARTIALLYFILLED
    , OrdStatusFILLED
    , OrdStatusCANCELED
    , OrdStatusREJECTED
    ]


{-| Order types are documented in the separate section: <a href=\"#oeml-order-params-type\">OEML / Starter Guide / Order parameters / Order type</a> 
-}
type OrdType
    = OrdTypeLIMIT


ordTypeVariants : List OrdType
ordTypeVariants =
    [ OrdTypeLIMIT
    ]


{-| Cancel all orders request object.
-}
type alias OrderCancelAllRequest =
    { exchangeId : String
    }


{-| Cancel single order request object.
-}
type alias OrderCancelSingleRequest =
    { exchangeId : String
    , exchangeOrderId : Maybe String
    , clientOrderId : Maybe String
    }


{-| The order execution report object.
-}
type alias OrderExecutionReport =
    { exchangeId : String
    , clientOrderId : String
    , symbolIdExchange : Maybe String
    , symbolIdCoinapi : Maybe String
    , amountOrder : Float
    , price : Float
    , side : OrdSide
    , orderType : OrdType
    , timeInForce : TimeInForce
    , expireTime : Maybe Posix
    , execInst : Maybe (List OrderExecutionReportExecInst)
    , clientOrderIdFormatExchange : String
    , exchangeOrderId : Maybe String
    , amountOpen : Float
    , amountFilled : Float
    , avgPx : Maybe Float
    , status : OrdStatus
    , statusHistory : Maybe (List (List (String)))
    , errorMessage : Maybe String
    , fills : Maybe (List (Fills))
    }


type OrderExecutionReportExecInst
    = OrderExecutionReportExecInstMAKERORCANCEL
    | OrderExecutionReportExecInstAUCTIONONLY
    | OrderExecutionReportExecInstINDICATIONOFINTEREST


orderExecutionReportExecInstVariants : List OrderExecutionReportExecInst
orderExecutionReportExecInstVariants =
    [ OrderExecutionReportExecInstMAKERORCANCEL
    , OrderExecutionReportExecInstAUCTIONONLY
    , OrderExecutionReportExecInstINDICATIONOFINTEREST
    ]


{-| The new order message.
-}
type alias OrderNewSingleRequest =
    { exchangeId : String
    , clientOrderId : String
    , symbolIdExchange : Maybe String
    , symbolIdCoinapi : Maybe String
    , amountOrder : Float
    , price : Float
    , side : OrdSide
    , orderType : OrdType
    , timeInForce : TimeInForce
    , expireTime : Maybe Posix
    , execInst : Maybe (List OrderNewSingleRequestExecInst)
    }


type OrderNewSingleRequestExecInst
    = OrderNewSingleRequestExecInstMAKERORCANCEL
    | OrderNewSingleRequestExecInstAUCTIONONLY
    | OrderNewSingleRequestExecInstINDICATIONOFINTEREST


orderNewSingleRequestExecInstVariants : List OrderNewSingleRequestExecInst
orderNewSingleRequestExecInstVariants =
    [ OrderNewSingleRequestExecInstMAKERORCANCEL
    , OrderNewSingleRequestExecInstAUCTIONONLY
    , OrderNewSingleRequestExecInstINDICATIONOFINTEREST
    ]


type alias Position =
    { exchangeId : Maybe String
    , data : Maybe (List (PositionData))
    }


{-| The Position object.
-}
type alias PositionData =
    { symbolIdExchange : Maybe String
    , symbolIdCoinapi : Maybe String
    , avgEntryPrice : Maybe Float
    , quantity : Maybe Float
    , side : Maybe OrdSide
    , unrealizedPnl : Maybe Float
    , leverage : Maybe Float
    , crossMargin : Maybe Bool
    , liquidationPrice : Maybe Float
    , rawData : Maybe Object
    }


{-| Severity of the message.
-}
type Severity
    = SeverityINFO
    | SeverityWARNING
    | SeverityERROR


severityVariants : List Severity
severityVariants =
    [ SeverityINFO
    , SeverityWARNING
    , SeverityERROR
    ]


{-| Order time in force options are documented in the separate section: <a href=\"#oeml-order-params-tif\">OEML / Starter Guide / Order parameters / Time in force</a> 
-}
type TimeInForce
    = TimeInForceGOODTILLCANCEL
    | TimeInForceGOODTILLTIMEEXCHANGE
    | TimeInForceGOODTILLTIMEOMS
    | TimeInForceFILLORKILL
    | TimeInForceIMMEDIATEORCANCEL


timeInForceVariants : List TimeInForce
timeInForceVariants =
    [ TimeInForceGOODTILLCANCEL
    , TimeInForceGOODTILLTIMEEXCHANGE
    , TimeInForceGOODTILLTIMEOMS
    , TimeInForceFILLORKILL
    , TimeInForceIMMEDIATEORCANCEL
    ]


type alias ValidationError =
    { type_ : Maybe String
    , title : Maybe String
    , status : Maybe Float
    , traceId : Maybe String
    , errors : Maybe String
    }


-- ENCODER


encodeBalance : Balance -> Json.Encode.Value
encodeBalance =
    encodeObject << encodeBalancePairs


encodeBalanceWithTag : ( String, String ) -> Balance -> Json.Encode.Value
encodeBalanceWithTag (tagField, tag) model =
    encodeObject (encodeBalancePairs model ++ [ encode tagField Json.Encode.string tag ])


encodeBalancePairs : Balance -> List EncodedField
encodeBalancePairs model =
    let
        pairs =
            [ maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "data" (Json.Encode.list encodeBalanceData) model.data
            ]
    in
    pairs


encodeBalanceData : BalanceData -> Json.Encode.Value
encodeBalanceData =
    encodeObject << encodeBalanceDataPairs


encodeBalanceDataWithTag : ( String, String ) -> BalanceData -> Json.Encode.Value
encodeBalanceDataWithTag (tagField, tag) model =
    encodeObject (encodeBalanceDataPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeBalanceDataPairs : BalanceData -> List EncodedField
encodeBalanceDataPairs model =
    let
        pairs =
            [ maybeEncode "asset_id_exchange" Json.Encode.string model.assetIdExchange
            , maybeEncode "asset_id_coinapi" Json.Encode.string model.assetIdCoinapi
            , maybeEncode "balance" Json.Encode.float model.balance
            , maybeEncode "available" Json.Encode.float model.available
            , maybeEncode "locked" Json.Encode.float model.locked
            , maybeEncode "last_updated_by"  model.lastUpdatedBy
            , maybeEncode "rate_usd" Json.Encode.float model.rateUsd
            , maybeEncode "traded" Json.Encode.float model.traded
            ]
    in
    pairs

stringFromBalanceDataLastUpdatedBy : BalanceDataLastUpdatedBy -> String
stringFromBalanceDataLastUpdatedBy model =
    case model of
        BalanceDataLastUpdatedByINITIALIZATION ->
            "INITIALIZATION"

        BalanceDataLastUpdatedByBALANCEMANAGER ->
            "BALANCE_MANAGER"

        BalanceDataLastUpdatedByEXCHANGE ->
            "EXCHANGE"


encodeBalanceDataLastUpdatedBy : BalanceDataLastUpdatedBy -> Json.Encode.Value
encodeBalanceDataLastUpdatedBy =
    Json.Encode.string << stringFromBalanceDataLastUpdatedBy



encodeFills : Fills -> Json.Encode.Value
encodeFills =
    encodeObject << encodeFillsPairs


encodeFillsWithTag : ( String, String ) -> Fills -> Json.Encode.Value
encodeFillsWithTag (tagField, tag) model =
    encodeObject (encodeFillsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeFillsPairs : Fills -> List EncodedField
encodeFillsPairs model =
    let
        pairs =
            [ maybeEncode "time" encodePosix model.time
            , maybeEncode "price" Json.Encode.float model.price
            , maybeEncode "amount" Json.Encode.float model.amount
            ]
    in
    pairs


encodeMessage : Message -> Json.Encode.Value
encodeMessage =
    encodeObject << encodeMessagePairs


encodeMessageWithTag : ( String, String ) -> Message -> Json.Encode.Value
encodeMessageWithTag (tagField, tag) model =
    encodeObject (encodeMessagePairs model ++ [ encode tagField Json.Encode.string tag ])


encodeMessagePairs : Message -> List EncodedField
encodeMessagePairs model =
    let
        pairs =
            [ maybeEncode "type" Json.Encode.string model.type_
            , maybeEncode "severity" encodeSeverity model.severity
            , maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "message" Json.Encode.string model.message
            ]
    in
    pairs


stringFromOrdSide : OrdSide -> String
stringFromOrdSide model =
    case model of
        OrdSideBUY ->
            "BUY"

        OrdSideSELL ->
            "SELL"


encodeOrdSide : OrdSide -> Json.Encode.Value
encodeOrdSide =
    Json.Encode.string << stringFromOrdSide


stringFromOrdStatus : OrdStatus -> String
stringFromOrdStatus model =
    case model of
        OrdStatusRECEIVED ->
            "RECEIVED"

        OrdStatusROUTING ->
            "ROUTING"

        OrdStatusROUTED ->
            "ROUTED"

        OrdStatusNEW ->
            "NEW"

        OrdStatusPENDINGCANCEL ->
            "PENDING_CANCEL"

        OrdStatusPARTIALLYFILLED ->
            "PARTIALLY_FILLED"

        OrdStatusFILLED ->
            "FILLED"

        OrdStatusCANCELED ->
            "CANCELED"

        OrdStatusREJECTED ->
            "REJECTED"


encodeOrdStatus : OrdStatus -> Json.Encode.Value
encodeOrdStatus =
    Json.Encode.string << stringFromOrdStatus


stringFromOrdType : OrdType -> String
stringFromOrdType model =
    case model of
        OrdTypeLIMIT ->
            "LIMIT"


encodeOrdType : OrdType -> Json.Encode.Value
encodeOrdType =
    Json.Encode.string << stringFromOrdType


encodeOrderCancelAllRequest : OrderCancelAllRequest -> Json.Encode.Value
encodeOrderCancelAllRequest =
    encodeObject << encodeOrderCancelAllRequestPairs


encodeOrderCancelAllRequestWithTag : ( String, String ) -> OrderCancelAllRequest -> Json.Encode.Value
encodeOrderCancelAllRequestWithTag (tagField, tag) model =
    encodeObject (encodeOrderCancelAllRequestPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeOrderCancelAllRequestPairs : OrderCancelAllRequest -> List EncodedField
encodeOrderCancelAllRequestPairs model =
    let
        pairs =
            [ encode "exchange_id" Json.Encode.string model.exchangeId
            ]
    in
    pairs


encodeOrderCancelSingleRequest : OrderCancelSingleRequest -> Json.Encode.Value
encodeOrderCancelSingleRequest =
    encodeObject << encodeOrderCancelSingleRequestPairs


encodeOrderCancelSingleRequestWithTag : ( String, String ) -> OrderCancelSingleRequest -> Json.Encode.Value
encodeOrderCancelSingleRequestWithTag (tagField, tag) model =
    encodeObject (encodeOrderCancelSingleRequestPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeOrderCancelSingleRequestPairs : OrderCancelSingleRequest -> List EncodedField
encodeOrderCancelSingleRequestPairs model =
    let
        pairs =
            [ encode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "exchange_order_id" Json.Encode.string model.exchangeOrderId
            , maybeEncode "client_order_id" Json.Encode.string model.clientOrderId
            ]
    in
    pairs


encodeOrderExecutionReport : OrderExecutionReport -> Json.Encode.Value
encodeOrderExecutionReport =
    encodeObject << encodeOrderExecutionReportPairs


encodeOrderExecutionReportWithTag : ( String, String ) -> OrderExecutionReport -> Json.Encode.Value
encodeOrderExecutionReportWithTag (tagField, tag) model =
    encodeObject (encodeOrderExecutionReportPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeOrderExecutionReportPairs : OrderExecutionReport -> List EncodedField
encodeOrderExecutionReportPairs model =
    let
        pairs =
            [ encode "exchange_id" Json.Encode.string model.exchangeId
            , encode "client_order_id" Json.Encode.string model.clientOrderId
            , maybeEncode "symbol_id_exchange" Json.Encode.string model.symbolIdExchange
            , maybeEncode "symbol_id_coinapi" Json.Encode.string model.symbolIdCoinapi
            , encode "amount_order" Json.Encode.float model.amountOrder
            , encode "price" Json.Encode.float model.price
            , encode "side" encodeOrdSide model.side
            , encode "order_type" encodeOrdType model.orderType
            , encode "time_in_force" encodeTimeInForce model.timeInForce
            , maybeEncode "expire_time" encodePosix model.expireTime
            , maybeEncode "exec_inst" (Json.Encode.list ) model.execInst
            , encode "client_order_id_format_exchange" Json.Encode.string model.clientOrderIdFormatExchange
            , maybeEncode "exchange_order_id" Json.Encode.string model.exchangeOrderId
            , encode "amount_open" Json.Encode.float model.amountOpen
            , encode "amount_filled" Json.Encode.float model.amountFilled
            , maybeEncode "avg_px" Json.Encode.float model.avgPx
            , encode "status" encodeOrdStatus model.status
            , maybeEncode "status_history" (Json.Encode.list (Json.Encode.list Json.Encode.string)) model.statusHistory
            , maybeEncode "error_message" Json.Encode.string model.errorMessage
            , maybeEncode "fills" (Json.Encode.list encodeFills) model.fills
            ]
    in
    pairs

stringFromOrderExecutionReportExecInst : OrderExecutionReportExecInst -> String
stringFromOrderExecutionReportExecInst model =
    case model of
        OrderExecutionReportExecInstMAKERORCANCEL ->
            "MAKER_OR_CANCEL"

        OrderExecutionReportExecInstAUCTIONONLY ->
            "AUCTION_ONLY"

        OrderExecutionReportExecInstINDICATIONOFINTEREST ->
            "INDICATION_OF_INTEREST"


encodeOrderExecutionReportExecInst : OrderExecutionReportExecInst -> Json.Encode.Value
encodeOrderExecutionReportExecInst =
    Json.Encode.int << intFromOrderExecutionReportExecInst



encodeOrderNewSingleRequest : OrderNewSingleRequest -> Json.Encode.Value
encodeOrderNewSingleRequest =
    encodeObject << encodeOrderNewSingleRequestPairs


encodeOrderNewSingleRequestWithTag : ( String, String ) -> OrderNewSingleRequest -> Json.Encode.Value
encodeOrderNewSingleRequestWithTag (tagField, tag) model =
    encodeObject (encodeOrderNewSingleRequestPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeOrderNewSingleRequestPairs : OrderNewSingleRequest -> List EncodedField
encodeOrderNewSingleRequestPairs model =
    let
        pairs =
            [ encode "exchange_id" Json.Encode.string model.exchangeId
            , encode "client_order_id" Json.Encode.string model.clientOrderId
            , maybeEncode "symbol_id_exchange" Json.Encode.string model.symbolIdExchange
            , maybeEncode "symbol_id_coinapi" Json.Encode.string model.symbolIdCoinapi
            , encode "amount_order" Json.Encode.float model.amountOrder
            , encode "price" Json.Encode.float model.price
            , encode "side" encodeOrdSide model.side
            , encode "order_type" encodeOrdType model.orderType
            , encode "time_in_force" encodeTimeInForce model.timeInForce
            , maybeEncode "expire_time" encodePosix model.expireTime
            , maybeEncode "exec_inst" (Json.Encode.list ) model.execInst
            ]
    in
    pairs

stringFromOrderNewSingleRequestExecInst : OrderNewSingleRequestExecInst -> String
stringFromOrderNewSingleRequestExecInst model =
    case model of
        OrderNewSingleRequestExecInstMAKERORCANCEL ->
            "MAKER_OR_CANCEL"

        OrderNewSingleRequestExecInstAUCTIONONLY ->
            "AUCTION_ONLY"

        OrderNewSingleRequestExecInstINDICATIONOFINTEREST ->
            "INDICATION_OF_INTEREST"


encodeOrderNewSingleRequestExecInst : OrderNewSingleRequestExecInst -> Json.Encode.Value
encodeOrderNewSingleRequestExecInst =
    Json.Encode.int << intFromOrderNewSingleRequestExecInst



encodePosition : Position -> Json.Encode.Value
encodePosition =
    encodeObject << encodePositionPairs


encodePositionWithTag : ( String, String ) -> Position -> Json.Encode.Value
encodePositionWithTag (tagField, tag) model =
    encodeObject (encodePositionPairs model ++ [ encode tagField Json.Encode.string tag ])


encodePositionPairs : Position -> List EncodedField
encodePositionPairs model =
    let
        pairs =
            [ maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "data" (Json.Encode.list encodePositionData) model.data
            ]
    in
    pairs


encodePositionData : PositionData -> Json.Encode.Value
encodePositionData =
    encodeObject << encodePositionDataPairs


encodePositionDataWithTag : ( String, String ) -> PositionData -> Json.Encode.Value
encodePositionDataWithTag (tagField, tag) model =
    encodeObject (encodePositionDataPairs model ++ [ encode tagField Json.Encode.string tag ])


encodePositionDataPairs : PositionData -> List EncodedField
encodePositionDataPairs model =
    let
        pairs =
            [ maybeEncode "symbol_id_exchange" Json.Encode.string model.symbolIdExchange
            , maybeEncode "symbol_id_coinapi" Json.Encode.string model.symbolIdCoinapi
            , maybeEncode "avg_entry_price" Json.Encode.float model.avgEntryPrice
            , maybeEncode "quantity" Json.Encode.float model.quantity
            , maybeEncode "side" encodeOrdSide model.side
            , maybeEncode "unrealized_pnl" Json.Encode.float model.unrealizedPnl
            , maybeEncode "leverage" Json.Encode.float model.leverage
            , maybeEncode "cross_margin" Json.Encode.bool model.crossMargin
            , maybeEncode "liquidation_price" Json.Encode.float model.liquidationPrice
            , maybeEncode "raw_data" encodeObject model.rawData
            ]
    in
    pairs


stringFromSeverity : Severity -> String
stringFromSeverity model =
    case model of
        SeverityINFO ->
            "INFO"

        SeverityWARNING ->
            "WARNING"

        SeverityERROR ->
            "ERROR"


encodeSeverity : Severity -> Json.Encode.Value
encodeSeverity =
    Json.Encode.string << stringFromSeverity


stringFromTimeInForce : TimeInForce -> String
stringFromTimeInForce model =
    case model of
        TimeInForceGOODTILLCANCEL ->
            "GOOD_TILL_CANCEL"

        TimeInForceGOODTILLTIMEEXCHANGE ->
            "GOOD_TILL_TIME_EXCHANGE"

        TimeInForceGOODTILLTIMEOMS ->
            "GOOD_TILL_TIME_OMS"

        TimeInForceFILLORKILL ->
            "FILL_OR_KILL"

        TimeInForceIMMEDIATEORCANCEL ->
            "IMMEDIATE_OR_CANCEL"


encodeTimeInForce : TimeInForce -> Json.Encode.Value
encodeTimeInForce =
    Json.Encode.string << stringFromTimeInForce


encodeValidationError : ValidationError -> Json.Encode.Value
encodeValidationError =
    encodeObject << encodeValidationErrorPairs


encodeValidationErrorWithTag : ( String, String ) -> ValidationError -> Json.Encode.Value
encodeValidationErrorWithTag (tagField, tag) model =
    encodeObject (encodeValidationErrorPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeValidationErrorPairs : ValidationError -> List EncodedField
encodeValidationErrorPairs model =
    let
        pairs =
            [ maybeEncode "type" Json.Encode.string model.type_
            , maybeEncode "title" Json.Encode.string model.title
            , maybeEncode "status" Json.Encode.float model.status
            , maybeEncode "traceId" Json.Encode.string model.traceId
            , maybeEncode "errors" Json.Encode.string model.errors
            ]
    in
    pairs


-- DECODER


balanceDecoder : Json.Decode.Decoder Balance
balanceDecoder =
    Json.Decode.succeed Balance
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "data" (Json.Decode.list balanceDataDecoder) Nothing


balanceDataDecoder : Json.Decode.Decoder BalanceData
balanceDataDecoder =
    Json.Decode.succeed BalanceData
        |> maybeDecode "asset_id_exchange" Json.Decode.string Nothing
        |> maybeDecode "asset_id_coinapi" Json.Decode.string Nothing
        |> maybeDecode "balance" Json.Decode.float Nothing
        |> maybeDecode "available" Json.Decode.float Nothing
        |> maybeDecode "locked" Json.Decode.float Nothing
        |> maybeDecode "last_updated_by"  Nothing
        |> maybeDecode "rate_usd" Json.Decode.float Nothing
        |> maybeDecode "traded" Json.Decode.float Nothing


balanceDataLastUpdatedByDecoder : Json.Decode.Decoder BalanceDataLastUpdatedBy
balanceDataLastUpdatedByDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "INITIALIZATION" ->
                        Json.Decode.succeed BalanceDataLastUpdatedByINITIALIZATION

                    "BALANCE_MANAGER" ->
                        Json.Decode.succeed BalanceDataLastUpdatedByBALANCEMANAGER

                    "EXCHANGE" ->
                        Json.Decode.succeed BalanceDataLastUpdatedByEXCHANGE

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )



fillsDecoder : Json.Decode.Decoder Fills
fillsDecoder =
    Json.Decode.succeed Fills
        |> maybeDecode "time" posixDecoder Nothing
        |> maybeDecode "price" Json.Decode.float Nothing
        |> maybeDecode "amount" Json.Decode.float Nothing


messageDecoder : Json.Decode.Decoder Message
messageDecoder =
    Json.Decode.succeed Message
        |> maybeDecode "type" Json.Decode.string Nothing
        |> maybeDecode "severity" severityDecoder Nothing
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "message" Json.Decode.string Nothing


ordSideDecoder : Json.Decode.Decoder OrdSide
ordSideDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "BUY" ->
                        Json.Decode.succeed OrdSideBUY

                    "SELL" ->
                        Json.Decode.succeed OrdSideSELL

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )


ordStatusDecoder : Json.Decode.Decoder OrdStatus
ordStatusDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "RECEIVED" ->
                        Json.Decode.succeed OrdStatusRECEIVED

                    "ROUTING" ->
                        Json.Decode.succeed OrdStatusROUTING

                    "ROUTED" ->
                        Json.Decode.succeed OrdStatusROUTED

                    "NEW" ->
                        Json.Decode.succeed OrdStatusNEW

                    "PENDING_CANCEL" ->
                        Json.Decode.succeed OrdStatusPENDINGCANCEL

                    "PARTIALLY_FILLED" ->
                        Json.Decode.succeed OrdStatusPARTIALLYFILLED

                    "FILLED" ->
                        Json.Decode.succeed OrdStatusFILLED

                    "CANCELED" ->
                        Json.Decode.succeed OrdStatusCANCELED

                    "REJECTED" ->
                        Json.Decode.succeed OrdStatusREJECTED

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )


ordTypeDecoder : Json.Decode.Decoder OrdType
ordTypeDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "LIMIT" ->
                        Json.Decode.succeed OrdTypeLIMIT

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )


orderCancelAllRequestDecoder : Json.Decode.Decoder OrderCancelAllRequest
orderCancelAllRequestDecoder =
    Json.Decode.succeed OrderCancelAllRequest
        |> decode "exchange_id" Json.Decode.string 


orderCancelSingleRequestDecoder : Json.Decode.Decoder OrderCancelSingleRequest
orderCancelSingleRequestDecoder =
    Json.Decode.succeed OrderCancelSingleRequest
        |> decode "exchange_id" Json.Decode.string 
        |> maybeDecode "exchange_order_id" Json.Decode.string Nothing
        |> maybeDecode "client_order_id" Json.Decode.string Nothing


orderExecutionReportDecoder : Json.Decode.Decoder OrderExecutionReport
orderExecutionReportDecoder =
    Json.Decode.succeed OrderExecutionReport
        |> decode "exchange_id" Json.Decode.string 
        |> decode "client_order_id" Json.Decode.string 
        |> maybeDecode "symbol_id_exchange" Json.Decode.string Nothing
        |> maybeDecode "symbol_id_coinapi" Json.Decode.string Nothing
        |> decode "amount_order" Json.Decode.float 
        |> decode "price" Json.Decode.float 
        |> decode "side" ordSideDecoder 
        |> decode "order_type" ordTypeDecoder 
        |> decode "time_in_force" timeInForceDecoder 
        |> maybeDecode "expire_time" posixDecoder Nothing
        |> maybeDecode "exec_inst" (Json.Decode.list ) Nothing
        |> decode "client_order_id_format_exchange" Json.Decode.string 
        |> maybeDecode "exchange_order_id" Json.Decode.string Nothing
        |> decode "amount_open" Json.Decode.float 
        |> decode "amount_filled" Json.Decode.float 
        |> maybeDecode "avg_px" Json.Decode.float Nothing
        |> decode "status" ordStatusDecoder 
        |> maybeDecode "status_history" (Json.Decode.list (Json.Decode.list Json.Decode.string)) Nothing
        |> maybeDecode "error_message" Json.Decode.string Nothing
        |> maybeDecode "fills" (Json.Decode.list fillsDecoder) Nothing


orderExecutionReportExecInstDecoder : Json.Decode.Decoder OrderExecutionReportExecInst
orderExecutionReportExecInstDecoder =
    Json.Decode.int
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "MAKER_OR_CANCEL" ->
                        Json.Decode.succeed OrderExecutionReportExecInstMAKERORCANCEL

                    "AUCTION_ONLY" ->
                        Json.Decode.succeed OrderExecutionReportExecInstAUCTIONONLY

                    "INDICATION_OF_INTEREST" ->
                        Json.Decode.succeed OrderExecutionReportExecInstINDICATIONOFINTEREST

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ String.fromInt other
            )



orderNewSingleRequestDecoder : Json.Decode.Decoder OrderNewSingleRequest
orderNewSingleRequestDecoder =
    Json.Decode.succeed OrderNewSingleRequest
        |> decode "exchange_id" Json.Decode.string 
        |> decode "client_order_id" Json.Decode.string 
        |> maybeDecode "symbol_id_exchange" Json.Decode.string Nothing
        |> maybeDecode "symbol_id_coinapi" Json.Decode.string Nothing
        |> decode "amount_order" Json.Decode.float 
        |> decode "price" Json.Decode.float 
        |> decode "side" ordSideDecoder 
        |> decode "order_type" ordTypeDecoder 
        |> decode "time_in_force" timeInForceDecoder 
        |> maybeDecode "expire_time" posixDecoder Nothing
        |> maybeDecode "exec_inst" (Json.Decode.list ) Nothing


orderNewSingleRequestExecInstDecoder : Json.Decode.Decoder OrderNewSingleRequestExecInst
orderNewSingleRequestExecInstDecoder =
    Json.Decode.int
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "MAKER_OR_CANCEL" ->
                        Json.Decode.succeed OrderNewSingleRequestExecInstMAKERORCANCEL

                    "AUCTION_ONLY" ->
                        Json.Decode.succeed OrderNewSingleRequestExecInstAUCTIONONLY

                    "INDICATION_OF_INTEREST" ->
                        Json.Decode.succeed OrderNewSingleRequestExecInstINDICATIONOFINTEREST

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ String.fromInt other
            )



positionDecoder : Json.Decode.Decoder Position
positionDecoder =
    Json.Decode.succeed Position
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "data" (Json.Decode.list positionDataDecoder) Nothing


positionDataDecoder : Json.Decode.Decoder PositionData
positionDataDecoder =
    Json.Decode.succeed PositionData
        |> maybeDecode "symbol_id_exchange" Json.Decode.string Nothing
        |> maybeDecode "symbol_id_coinapi" Json.Decode.string Nothing
        |> maybeDecode "avg_entry_price" Json.Decode.float Nothing
        |> maybeDecode "quantity" Json.Decode.float Nothing
        |> maybeDecode "side" ordSideDecoder Nothing
        |> maybeDecode "unrealized_pnl" Json.Decode.float Nothing
        |> maybeDecode "leverage" Json.Decode.float Nothing
        |> maybeDecode "cross_margin" Json.Decode.bool Nothing
        |> maybeDecode "liquidation_price" Json.Decode.float Nothing
        |> maybeDecode "raw_data" objectDecoder Nothing


severityDecoder : Json.Decode.Decoder Severity
severityDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "INFO" ->
                        Json.Decode.succeed SeverityINFO

                    "WARNING" ->
                        Json.Decode.succeed SeverityWARNING

                    "ERROR" ->
                        Json.Decode.succeed SeverityERROR

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )


timeInForceDecoder : Json.Decode.Decoder TimeInForce
timeInForceDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "GOOD_TILL_CANCEL" ->
                        Json.Decode.succeed TimeInForceGOODTILLCANCEL

                    "GOOD_TILL_TIME_EXCHANGE" ->
                        Json.Decode.succeed TimeInForceGOODTILLTIMEEXCHANGE

                    "GOOD_TILL_TIME_OMS" ->
                        Json.Decode.succeed TimeInForceGOODTILLTIMEOMS

                    "FILL_OR_KILL" ->
                        Json.Decode.succeed TimeInForceFILLORKILL

                    "IMMEDIATE_OR_CANCEL" ->
                        Json.Decode.succeed TimeInForceIMMEDIATEORCANCEL

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )


validationErrorDecoder : Json.Decode.Decoder ValidationError
validationErrorDecoder =
    Json.Decode.succeed ValidationError
        |> maybeDecode "type" Json.Decode.string Nothing
        |> maybeDecode "title" Json.Decode.string Nothing
        |> maybeDecode "status" Json.Decode.float Nothing
        |> maybeDecode "traceId" Json.Decode.string Nothing
        |> maybeDecode "errors" Json.Decode.string Nothing




-- HELPER


type alias EncodedField =
    Maybe ( String, Json.Encode.Value )


encodeObject : List EncodedField -> Json.Encode.Value
encodeObject =
    Json.Encode.object << List.filterMap identity


encode : String -> (a -> Json.Encode.Value) -> a -> EncodedField
encode key encoder value =
    Just ( key, encoder value )


encodeNullable : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
encodeNullable key encoder value =
    Just ( key, Maybe.withDefault Json.Encode.null (Maybe.map encoder value) )


maybeEncode : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
maybeEncode key encoder =
    Maybe.map (Tuple.pair key << encoder)


maybeEncodeNullable : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
maybeEncodeNullable =
    encodeNullable


decode : String -> Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b
decode key decoder =
    decodeChain (Json.Decode.field key decoder)


decodeLazy : (a -> c) -> String -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeLazy f key decoder =
    decodeChainLazy f (Json.Decode.field key decoder)


decodeNullable : String -> Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
decodeNullable key decoder =
    decodeChain (maybeField key decoder Nothing)


decodeNullableLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeNullableLazy f key decoder =
    decodeChainLazy f (maybeField key decoder Nothing)


maybeDecode : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
maybeDecode key decoder fallback =
    -- let's be kind to null-values as well
    decodeChain (maybeField key decoder fallback)


maybeDecodeLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
maybeDecodeLazy f key decoder fallback =
    -- let's be kind to null-values as well
    decodeChainLazy f (maybeField key decoder fallback)


maybeDecodeNullable : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
maybeDecodeNullable key decoder fallback =
    decodeChain (maybeField key decoder fallback)


maybeDecodeNullableLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
maybeDecodeNullableLazy f key decoder fallback =
    decodeChainLazy f (maybeField key decoder fallback)


maybeField : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a)
maybeField key decoder fallback =
    let
        fieldDecoder =
            Json.Decode.field key Json.Decode.value

        valueDecoder =
            Json.Decode.oneOf [ Json.Decode.map Just decoder, Json.Decode.null fallback ]

        decodeObject rawObject =
            case Json.Decode.decodeValue fieldDecoder rawObject of
                Ok rawValue ->
                    case Json.Decode.decodeValue valueDecoder rawValue of
                        Ok value ->
                            Json.Decode.succeed value

                        Err error ->
                            Json.Decode.fail (Json.Decode.errorToString error)

                Err _ ->
                    Json.Decode.succeed fallback
    in
    Json.Decode.value
        |> Json.Decode.andThen decodeObject


decodeChain : Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b
decodeChain =
    Json.Decode.map2 (|>)


decodeChainLazy : (a -> c) -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeChainLazy f =
    decodeChain << Json.Decode.map f