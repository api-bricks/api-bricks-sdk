{-
   EMS - REST API
   This section will provide necessary information about the `CoinAPI EMS REST API` protocol. This API is also available in the Postman application: <a href=\"https://postman.coinapi.io/\" target=\"_blank\">https://postman.coinapi.io/</a>        Implemented Standards:    * [HTTP1.0](https://datatracker.ietf.org/doc/html/rfc1945)   * [HTTP1.1](https://datatracker.ietf.org/doc/html/rfc2616)   * [HTTP2.0](https://datatracker.ietf.org/doc/html/rfc7540)     ### Endpoints  <table>   <thead>     <tr>       <th>Deployment method</th>       <th>Environment</th>       <th>Url</th>     </tr>   </thead>   <tbody>     <tr>       <td>Managed Cloud</td>       <td>Production</td>       <td>Use <a href=\"#ems-docs-sh\">Managed Cloud REST API /v1/locations</a> to get specific endpoints to each server site where your deployments span</td>     </tr>     <tr>       <td>Self Hosted</td>       <td>Production</td>       <td>IP Address of the <code>ems-gateway</code> container/excecutable in the closest server site to the caller location</td>     </tr>   </tbody> </table>  ### Authentication If the software is deployed as `Self-Hosted` then API do not require authentication as inside your infrastructure, your company is responsible for the security and access controls.  If the software is deployed in our `Managed Cloud`, there are 2 methods for authenticating with us, you only need to use one:   1. Custom authorization header named `X-CoinAPI-Key` with the API Key  2. Query string parameter named `apikey` with the API Key  3. <a href=\"#certificate\">TLS Client Certificate</a> from the `Managed Cloud REST API` (/v1/certificate/pem endpoint) while establishing a TLS session with us.  #### Custom authorization header You can authorize by providing additional custom header named `X-CoinAPI-Key` and API key as its value. Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY`, then the authorization header you should send to us will look like: `X-CoinAPI-Key: 73034021-THIS-IS-SAMPLE-KEY` <aside class=\"success\">This method is recommended by us and you should use it in production environments.</aside> #### Query string authorization parameter You can authorize by providing an additional parameter named `apikey` with a value equal to your API key in the query string of your HTTP request. Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY` and that you want to request all balances, then your query string should look like this: `GET /v1/balances?apikey=73034021-THIS-IS-SAMPLE-KEY` <aside class=\"notice\">Query string method may be more practical for development activities.</aside> 

   The version of the OpenAPI document: v1
   Contact: support@coinapi.io

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git

   DO NOT EDIT THIS FILE MANUALLY.

   For more info on generating Elm code, see https://eriktim.github.io/openapi-elm/
-}


module Api.Data exposing
    ( Balance
    , BalanceDataInner, BalanceDataInnerLastUpdatedBy(..), balanceDataInnerLastUpdatedByVariants
    , Fills
    , MessageError
    , MessageReject
    , OrdSide(..), ordSideVariants
    , OrdStatus(..), ordStatusVariants
    , OrdType(..), ordTypeVariants
    , OrderCancelAllRequest
    , OrderCancelSingleRequest
    , OrderExecutionReport, OrderExecutionReportExecInst(..), orderExecutionReportExecInstVariants
    , OrderHistory
    , OrderNewSingleRequest, OrderNewSingleRequestExecInst(..), orderNewSingleRequestExecInstVariants
    , Position
    , PositionDataInner
    , RejectReason(..), rejectReasonVariants
    , TimeInForce(..), timeInForceVariants
    , ValidationError
    , encodeBalance
    , encodeBalanceDataInner
    , encodeFills
    , encodeMessageError
    , encodeMessageReject
    , encodeOrdSide
    , encodeOrdStatus
    , encodeOrdType
    , encodeOrderCancelAllRequest
    , encodeOrderCancelSingleRequest
    , encodeOrderExecutionReport
    , encodeOrderHistory
    , encodeOrderNewSingleRequest
    , encodePosition
    , encodePositionDataInner
    , encodeRejectReason
    , encodeTimeInForce
    , encodeValidationError
    , stringFromOrdSide
    , stringFromOrdStatus
    , stringFromOrdType
    , stringFromRejectReason
    , stringFromTimeInForce
    , balanceDecoder
    , balanceDataInnerDecoder
    , fillsDecoder
    , messageErrorDecoder
    , messageRejectDecoder
    , ordSideDecoder
    , ordStatusDecoder
    , ordTypeDecoder
    , orderCancelAllRequestDecoder
    , orderCancelSingleRequestDecoder
    , orderExecutionReportDecoder
    , orderHistoryDecoder
    , orderNewSingleRequestDecoder
    , positionDecoder
    , positionDataInnerDecoder
    , rejectReasonDecoder
    , timeInForceDecoder
    , validationErrorDecoder
    )

import Api
import Dict
import Json.Decode
import Json.Encode


-- MODEL


type alias Balance =
    { exchangeId : Maybe String
    , data : Maybe ( List BalanceDataInner )
    }


type alias BalanceDataInner =
    { assetIdExchange : Maybe String
    , assetIdCoinapi : Maybe String
    , balance : Maybe Float
    , available : Maybe Float
    , locked : Maybe Float
    , lastUpdatedBy : Maybe BalanceDataInnerLastUpdatedBy
    , rateUsd : Maybe Float
    , traded : Maybe Float
    }


type BalanceDataInnerLastUpdatedBy
    = BalanceDataInnerLastUpdatedByINITIALIZATION
    | BalanceDataInnerLastUpdatedByBALANCEMANAGER
    | BalanceDataInnerLastUpdatedByEXCHANGE


balanceDataInnerLastUpdatedByVariants : List BalanceDataInnerLastUpdatedBy
balanceDataInnerLastUpdatedByVariants =
    [ BalanceDataInnerLastUpdatedByINITIALIZATION
    , BalanceDataInnerLastUpdatedByBALANCEMANAGER
    , BalanceDataInnerLastUpdatedByEXCHANGE
    ]


type alias Fills =
    { time : Maybe Posix
    , price : Maybe Float
    , amount : Maybe Float
    }


type alias MessageError =
    { message : Maybe String
    }


type alias MessageReject =
    { type_ : Maybe String
    , rejectReason : Maybe RejectReason
    , exchangeId : Maybe String
    , message : Maybe String
    , rejectedMessage : Maybe String
    }


{-| Side of order. 
-}
type OrdSide
    = OrdSideBUY
    | OrdSideSELL


ordSideVariants : List OrdSide
ordSideVariants =
    [ OrdSideBUY
    , OrdSideSELL
    ]


{-| Order statuses and the lifecycle are documented in the separate section: <a href=\"#ems-order-lifecycle\">EMS / Starter Guide / Order Lifecycle</a> 
-}
type OrdStatus
    = OrdStatusRECEIVED
    | OrdStatusROUTING
    | OrdStatusROUTED
    | OrdStatusNEW
    | OrdStatusPENDINGCANCEL
    | OrdStatusPARTIALLYFILLED
    | OrdStatusFILLED
    | OrdStatusCANCELED
    | OrdStatusREJECTED


ordStatusVariants : List OrdStatus
ordStatusVariants =
    [ OrdStatusRECEIVED
    , OrdStatusROUTING
    , OrdStatusROUTED
    , OrdStatusNEW
    , OrdStatusPENDINGCANCEL
    , OrdStatusPARTIALLYFILLED
    , OrdStatusFILLED
    , OrdStatusCANCELED
    , OrdStatusREJECTED
    ]


{-| Order types are documented in the separate section: <a href=\"#ems-order-params-type\">EMS / Starter Guide / Order parameters / Order type</a> 
-}
type OrdType
    = OrdTypeLIMIT


ordTypeVariants : List OrdType
ordTypeVariants =
    [ OrdTypeLIMIT
    ]


{-| Cancel all orders request object.
-}
type alias OrderCancelAllRequest =
    { exchangeId : String
    }


{-| Cancel single order request object.
-}
type alias OrderCancelSingleRequest =
    { exchangeId : String
    , exchangeOrderId : Maybe String
    , clientOrderId : Maybe String
    }


{-| The order execution report object.
-}
type alias OrderExecutionReport =
    { exchangeId : String
    , clientOrderId : String
    , symbolIdExchange : Maybe String
    , symbolIdCoinapi : Maybe String
    , amountOrder : Float
    , price : Float
    , side : OrdSide
    , orderType : OrdType
    , timeInForce : TimeInForce
    , expireTime : Maybe Posix
    , execInst : Maybe ( List OrderExecutionReportExecInst )
    , clientOrderIdFormatExchange : String
    , exchangeOrderId : Maybe String
    , amountOpen : Float
    , amountFilled : Float
    , avgPx : Maybe Float
    , status : OrdStatus
    , statusHistory : Maybe ( List (List String) )
    , errorMessage : Maybe String
    , fills : Maybe ( List Fills )
    }


type OrderExecutionReportExecInst
    = OrderExecutionReportExecInstMAKERORCANCEL
    | OrderExecutionReportExecInstAUCTIONONLY
    | OrderExecutionReportExecInstINDICATIONOFINTEREST


orderExecutionReportExecInstVariants : List OrderExecutionReportExecInst
orderExecutionReportExecInstVariants =
    [ OrderExecutionReportExecInstMAKERORCANCEL
    , OrderExecutionReportExecInstAUCTIONONLY
    , OrderExecutionReportExecInstINDICATIONOFINTEREST
    ]


type alias OrderHistory =
    { apikey : Maybe String
    , exchangeId : Maybe String
    , clientOrderId : Maybe String
    , symbolIdExchange : Maybe String
    , symbolIdCoinapi : Maybe String
    , amountOrder : Maybe Float
    , price : Maybe Float
    , side : Maybe Float
    , orderType : Maybe String
    , timeInForce : Maybe String
    , expireTime : Maybe Posix
    , execInst : Maybe ( List String )
    , clientOrderIdFormatExchange : Maybe String
    , exchangeOrderId : Maybe String
    , amountOpen : Maybe Float
    , amountFilled : Maybe Float
    , avgPx : Maybe Float
    , status : Maybe String
    , statusHistoryStatus : Maybe ( List String )
    , statusHistoryTime : Maybe ( List Posix )
    , errorMessageResult : Maybe String
    , errorMessageReason : Maybe String
    , errorMessageMessage : Maybe String
    , fillsTime : Maybe ( List Posix )
    , fillsPrice : Maybe ( List Float )
    , fillsAmount : Maybe ( List Float )
    , createdTime : Maybe Posix
    }


{-| The new order message.
-}
type alias OrderNewSingleRequest =
    { exchangeId : String
    , clientOrderId : String
    , symbolIdExchange : Maybe String
    , symbolIdCoinapi : Maybe String
    , amountOrder : Float
    , price : Float
    , side : OrdSide
    , orderType : OrdType
    , timeInForce : TimeInForce
    , expireTime : Maybe Posix
    , execInst : Maybe ( List OrderNewSingleRequestExecInst )
    }


type OrderNewSingleRequestExecInst
    = OrderNewSingleRequestExecInstMAKERORCANCEL
    | OrderNewSingleRequestExecInstAUCTIONONLY
    | OrderNewSingleRequestExecInstINDICATIONOFINTEREST


orderNewSingleRequestExecInstVariants : List OrderNewSingleRequestExecInst
orderNewSingleRequestExecInstVariants =
    [ OrderNewSingleRequestExecInstMAKERORCANCEL
    , OrderNewSingleRequestExecInstAUCTIONONLY
    , OrderNewSingleRequestExecInstINDICATIONOFINTEREST
    ]


type alias Position =
    { exchangeId : Maybe String
    , data : Maybe ( List PositionDataInner )
    }


{-| The Position object.
-}
type alias PositionDataInner =
    { symbolIdExchange : Maybe String
    , symbolIdCoinapi : Maybe String
    , avgEntryPrice : Maybe Float
    , quantity : Maybe Float
    , side : Maybe OrdSide
    , unrealizedPnl : Maybe Float
    , leverage : Maybe Float
    , crossMargin : Maybe Bool
    , liquidationPrice : Maybe Float
    , rawData : Maybe Object
    }


{-| Cause of rejection.
-}
type RejectReason
    = RejectReasonOTHER
    | RejectReasonEXCHANGEUNREACHABLE
    | RejectReasonEXCHANGERESPONSETIMEOUT
    | RejectReasonORDERIDNOTFOUND
    | RejectReasonINVALIDTYPE
    | RejectReasonMETHODNOTSUPPORTED
    | RejectReasonJSONERROR


rejectReasonVariants : List RejectReason
rejectReasonVariants =
    [ RejectReasonOTHER
    , RejectReasonEXCHANGEUNREACHABLE
    , RejectReasonEXCHANGERESPONSETIMEOUT
    , RejectReasonORDERIDNOTFOUND
    , RejectReasonINVALIDTYPE
    , RejectReasonMETHODNOTSUPPORTED
    , RejectReasonJSONERROR
    ]


{-| Order time in force options are documented in the separate section: <a href=\"#ems-order-params-tif\">EMS / Starter Guide / Order parameters / Time in force</a> 
-}
type TimeInForce
    = TimeInForceGOODTILLCANCEL
    | TimeInForceGOODTILLTIMEEXCHANGE
    | TimeInForceGOODTILLTIMEOMS
    | TimeInForceFILLORKILL
    | TimeInForceIMMEDIATEORCANCEL


timeInForceVariants : List TimeInForce
timeInForceVariants =
    [ TimeInForceGOODTILLCANCEL
    , TimeInForceGOODTILLTIMEEXCHANGE
    , TimeInForceGOODTILLTIMEOMS
    , TimeInForceFILLORKILL
    , TimeInForceIMMEDIATEORCANCEL
    ]


type alias ValidationError =
    { type_ : Maybe String
    , title : Maybe String
    , status : Maybe Float
    , traceId : Maybe String
    , errors : Maybe String
    }


-- ENCODER


encodeBalance : Balance -> Json.Encode.Value
encodeBalance =
    encodeObject << encodeBalancePairs


encodeBalanceWithTag : ( String, String ) -> Balance -> Json.Encode.Value
encodeBalanceWithTag (tagField, tag) model =
    encodeObject (encodeBalancePairs model ++ [ encode tagField Json.Encode.string tag ])


encodeBalancePairs : Balance -> List EncodedField
encodeBalancePairs model =
    let
        pairs =
            [ maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "data" (Json.Encode.list encodeBalanceDataInner) model.data
            ]
    in
    pairs


encodeBalanceDataInner : BalanceDataInner -> Json.Encode.Value
encodeBalanceDataInner =
    encodeObject << encodeBalanceDataInnerPairs


encodeBalanceDataInnerWithTag : ( String, String ) -> BalanceDataInner -> Json.Encode.Value
encodeBalanceDataInnerWithTag (tagField, tag) model =
    encodeObject (encodeBalanceDataInnerPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeBalanceDataInnerPairs : BalanceDataInner -> List EncodedField
encodeBalanceDataInnerPairs model =
    let
        pairs =
            [ maybeEncode "asset_id_exchange" Json.Encode.string model.assetIdExchange
            , maybeEncode "asset_id_coinapi" Json.Encode.string model.assetIdCoinapi
            , maybeEncode "balance" Json.Encode.float model.balance
            , maybeEncode "available" Json.Encode.float model.available
            , maybeEncode "locked" Json.Encode.float model.locked
            , maybeEncode "last_updated_by" encodeBalanceDataInnerLastUpdatedBy model.lastUpdatedBy
            , maybeEncode "rate_usd" Json.Encode.float model.rateUsd
            , maybeEncode "traded" Json.Encode.float model.traded
            ]
    in
    pairs

stringFromBalanceDataInnerLastUpdatedBy : BalanceDataInnerLastUpdatedBy -> String
stringFromBalanceDataInnerLastUpdatedBy model =
    case model of
        BalanceDataInnerLastUpdatedByINITIALIZATION ->
            "INITIALIZATION"

        BalanceDataInnerLastUpdatedByBALANCEMANAGER ->
            "BALANCE_MANAGER"

        BalanceDataInnerLastUpdatedByEXCHANGE ->
            "EXCHANGE"


encodeBalanceDataInnerLastUpdatedBy : BalanceDataInnerLastUpdatedBy -> Json.Encode.Value
encodeBalanceDataInnerLastUpdatedBy =
    Json.Encode.string << stringFromBalanceDataInnerLastUpdatedBy



encodeFills : Fills -> Json.Encode.Value
encodeFills =
    encodeObject << encodeFillsPairs


encodeFillsWithTag : ( String, String ) -> Fills -> Json.Encode.Value
encodeFillsWithTag (tagField, tag) model =
    encodeObject (encodeFillsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeFillsPairs : Fills -> List EncodedField
encodeFillsPairs model =
    let
        pairs =
            [ maybeEncode "time" encodePosix model.time
            , maybeEncode "price" Json.Encode.float model.price
            , maybeEncode "amount" Json.Encode.float model.amount
            ]
    in
    pairs


encodeMessageError : MessageError -> Json.Encode.Value
encodeMessageError =
    encodeObject << encodeMessageErrorPairs


encodeMessageErrorWithTag : ( String, String ) -> MessageError -> Json.Encode.Value
encodeMessageErrorWithTag (tagField, tag) model =
    encodeObject (encodeMessageErrorPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeMessageErrorPairs : MessageError -> List EncodedField
encodeMessageErrorPairs model =
    let
        pairs =
            [ maybeEncode "message" Json.Encode.string model.message
            ]
    in
    pairs


encodeMessageReject : MessageReject -> Json.Encode.Value
encodeMessageReject =
    encodeObject << encodeMessageRejectPairs


encodeMessageRejectWithTag : ( String, String ) -> MessageReject -> Json.Encode.Value
encodeMessageRejectWithTag (tagField, tag) model =
    encodeObject (encodeMessageRejectPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeMessageRejectPairs : MessageReject -> List EncodedField
encodeMessageRejectPairs model =
    let
        pairs =
            [ maybeEncode "type" Json.Encode.string model.type_
            , maybeEncode "reject_reason" encodeRejectReason model.rejectReason
            , maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "message" Json.Encode.string model.message
            , maybeEncode "rejected_message" Json.Encode.string model.rejectedMessage
            ]
    in
    pairs


stringFromOrdSide : OrdSide -> String
stringFromOrdSide model =
    case model of
        OrdSideBUY ->
            "BUY"

        OrdSideSELL ->
            "SELL"


encodeOrdSide : OrdSide -> Json.Encode.Value
encodeOrdSide =
    Json.Encode.string << stringFromOrdSide


stringFromOrdStatus : OrdStatus -> String
stringFromOrdStatus model =
    case model of
        OrdStatusRECEIVED ->
            "RECEIVED"

        OrdStatusROUTING ->
            "ROUTING"

        OrdStatusROUTED ->
            "ROUTED"

        OrdStatusNEW ->
            "NEW"

        OrdStatusPENDINGCANCEL ->
            "PENDING_CANCEL"

        OrdStatusPARTIALLYFILLED ->
            "PARTIALLY_FILLED"

        OrdStatusFILLED ->
            "FILLED"

        OrdStatusCANCELED ->
            "CANCELED"

        OrdStatusREJECTED ->
            "REJECTED"


encodeOrdStatus : OrdStatus -> Json.Encode.Value
encodeOrdStatus =
    Json.Encode.string << stringFromOrdStatus


stringFromOrdType : OrdType -> String
stringFromOrdType model =
    case model of
        OrdTypeLIMIT ->
            "LIMIT"


encodeOrdType : OrdType -> Json.Encode.Value
encodeOrdType =
    Json.Encode.string << stringFromOrdType


encodeOrderCancelAllRequest : OrderCancelAllRequest -> Json.Encode.Value
encodeOrderCancelAllRequest =
    encodeObject << encodeOrderCancelAllRequestPairs


encodeOrderCancelAllRequestWithTag : ( String, String ) -> OrderCancelAllRequest -> Json.Encode.Value
encodeOrderCancelAllRequestWithTag (tagField, tag) model =
    encodeObject (encodeOrderCancelAllRequestPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeOrderCancelAllRequestPairs : OrderCancelAllRequest -> List EncodedField
encodeOrderCancelAllRequestPairs model =
    let
        pairs =
            [ encode "exchange_id" Json.Encode.string model.exchangeId
            ]
    in
    pairs


encodeOrderCancelSingleRequest : OrderCancelSingleRequest -> Json.Encode.Value
encodeOrderCancelSingleRequest =
    encodeObject << encodeOrderCancelSingleRequestPairs


encodeOrderCancelSingleRequestWithTag : ( String, String ) -> OrderCancelSingleRequest -> Json.Encode.Value
encodeOrderCancelSingleRequestWithTag (tagField, tag) model =
    encodeObject (encodeOrderCancelSingleRequestPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeOrderCancelSingleRequestPairs : OrderCancelSingleRequest -> List EncodedField
encodeOrderCancelSingleRequestPairs model =
    let
        pairs =
            [ encode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "exchange_order_id" Json.Encode.string model.exchangeOrderId
            , maybeEncode "client_order_id" Json.Encode.string model.clientOrderId
            ]
    in
    pairs


encodeOrderExecutionReport : OrderExecutionReport -> Json.Encode.Value
encodeOrderExecutionReport =
    encodeObject << encodeOrderExecutionReportPairs


encodeOrderExecutionReportWithTag : ( String, String ) -> OrderExecutionReport -> Json.Encode.Value
encodeOrderExecutionReportWithTag (tagField, tag) model =
    encodeObject (encodeOrderExecutionReportPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeOrderExecutionReportPairs : OrderExecutionReport -> List EncodedField
encodeOrderExecutionReportPairs model =
    let
        pairs =
            [ encode "exchange_id" Json.Encode.string model.exchangeId
            , encode "client_order_id" Json.Encode.string model.clientOrderId
            , maybeEncode "symbol_id_exchange" Json.Encode.string model.symbolIdExchange
            , maybeEncode "symbol_id_coinapi" Json.Encode.string model.symbolIdCoinapi
            , encode "amount_order" Json.Encode.float model.amountOrder
            , encode "price" Json.Encode.float model.price
            , encode "side" encodeOrdSide model.side
            , encode "order_type" encodeOrdType model.orderType
            , encode "time_in_force" encodeTimeInForce model.timeInForce
            , maybeEncode "expire_time" encodePosix model.expireTime
            , maybeEncode "exec_inst" (Json.Encode.list encodeOrderExecutionReportExecInst) model.execInst
            , encode "client_order_id_format_exchange" Json.Encode.string model.clientOrderIdFormatExchange
            , maybeEncode "exchange_order_id" Json.Encode.string model.exchangeOrderId
            , encode "amount_open" Json.Encode.float model.amountOpen
            , encode "amount_filled" Json.Encode.float model.amountFilled
            , maybeEncode "avg_px" Json.Encode.float model.avgPx
            , encode "status" encodeOrdStatus model.status
            , maybeEncode "status_history" (Json.Encode.list (Json.Encode.list Json.Encode.string)) model.statusHistory
            , maybeEncode "error_message" Json.Encode.string model.errorMessage
            , maybeEncode "fills" (Json.Encode.list encodeFills) model.fills
            ]
    in
    pairs

stringFromOrderExecutionReportExecInst : OrderExecutionReportExecInst -> String
stringFromOrderExecutionReportExecInst model =
    case model of
        OrderExecutionReportExecInstMAKERORCANCEL ->
            "MAKER_OR_CANCEL"

        OrderExecutionReportExecInstAUCTIONONLY ->
            "AUCTION_ONLY"

        OrderExecutionReportExecInstINDICATIONOFINTEREST ->
            "INDICATION_OF_INTEREST"


encodeOrderExecutionReportExecInst : OrderExecutionReportExecInst -> Json.Encode.Value
encodeOrderExecutionReportExecInst =
    Json.Encode.int << intFromOrderExecutionReportExecInst



encodeOrderHistory : OrderHistory -> Json.Encode.Value
encodeOrderHistory =
    encodeObject << encodeOrderHistoryPairs


encodeOrderHistoryWithTag : ( String, String ) -> OrderHistory -> Json.Encode.Value
encodeOrderHistoryWithTag (tagField, tag) model =
    encodeObject (encodeOrderHistoryPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeOrderHistoryPairs : OrderHistory -> List EncodedField
encodeOrderHistoryPairs model =
    let
        pairs =
            [ maybeEncode "apikey" Json.Encode.string model.apikey
            , maybeEncode "exchangeId" Json.Encode.string model.exchangeId
            , maybeEncode "clientOrderId" Json.Encode.string model.clientOrderId
            , maybeEncode "symbolIdExchange" Json.Encode.string model.symbolIdExchange
            , maybeEncode "symbolIdCoinapi" Json.Encode.string model.symbolIdCoinapi
            , maybeEncode "amountOrder" Json.Encode.float model.amountOrder
            , maybeEncode "price" Json.Encode.float model.price
            , maybeEncode "side" Json.Encode.float model.side
            , maybeEncode "orderType" Json.Encode.string model.orderType
            , maybeEncode "timeInForce" Json.Encode.string model.timeInForce
            , maybeEncode "expireTime" encodePosix model.expireTime
            , maybeEncode "execInst" (Json.Encode.list Json.Encode.string) model.execInst
            , maybeEncode "clientOrderIdFormatExchange" Json.Encode.string model.clientOrderIdFormatExchange
            , maybeEncode "exchangeOrderId" Json.Encode.string model.exchangeOrderId
            , maybeEncode "amountOpen" Json.Encode.float model.amountOpen
            , maybeEncode "amountFilled" Json.Encode.float model.amountFilled
            , maybeEncode "avgPx" Json.Encode.float model.avgPx
            , maybeEncode "status" Json.Encode.string model.status
            , maybeEncode "statusHistoryStatus" (Json.Encode.list Json.Encode.string) model.statusHistoryStatus
            , maybeEncode "statusHistoryTime" (Json.Encode.list encodePosix) model.statusHistoryTime
            , maybeEncode "errorMessageResult" Json.Encode.string model.errorMessageResult
            , maybeEncode "errorMessageReason" Json.Encode.string model.errorMessageReason
            , maybeEncode "errorMessageMessage" Json.Encode.string model.errorMessageMessage
            , maybeEncode "fillsTime" (Json.Encode.list encodePosix) model.fillsTime
            , maybeEncode "fillsPrice" (Json.Encode.list Json.Encode.float) model.fillsPrice
            , maybeEncode "fillsAmount" (Json.Encode.list Json.Encode.float) model.fillsAmount
            , maybeEncode "createdTime" encodePosix model.createdTime
            ]
    in
    pairs


encodeOrderNewSingleRequest : OrderNewSingleRequest -> Json.Encode.Value
encodeOrderNewSingleRequest =
    encodeObject << encodeOrderNewSingleRequestPairs


encodeOrderNewSingleRequestWithTag : ( String, String ) -> OrderNewSingleRequest -> Json.Encode.Value
encodeOrderNewSingleRequestWithTag (tagField, tag) model =
    encodeObject (encodeOrderNewSingleRequestPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeOrderNewSingleRequestPairs : OrderNewSingleRequest -> List EncodedField
encodeOrderNewSingleRequestPairs model =
    let
        pairs =
            [ encode "exchange_id" Json.Encode.string model.exchangeId
            , encode "client_order_id" Json.Encode.string model.clientOrderId
            , maybeEncode "symbol_id_exchange" Json.Encode.string model.symbolIdExchange
            , maybeEncode "symbol_id_coinapi" Json.Encode.string model.symbolIdCoinapi
            , encode "amount_order" Json.Encode.float model.amountOrder
            , encode "price" Json.Encode.float model.price
            , encode "side" encodeOrdSide model.side
            , encode "order_type" encodeOrdType model.orderType
            , encode "time_in_force" encodeTimeInForce model.timeInForce
            , maybeEncode "expire_time" encodePosix model.expireTime
            , maybeEncode "exec_inst" (Json.Encode.list encodeOrderNewSingleRequestExecInst) model.execInst
            ]
    in
    pairs

stringFromOrderNewSingleRequestExecInst : OrderNewSingleRequestExecInst -> String
stringFromOrderNewSingleRequestExecInst model =
    case model of
        OrderNewSingleRequestExecInstMAKERORCANCEL ->
            "MAKER_OR_CANCEL"

        OrderNewSingleRequestExecInstAUCTIONONLY ->
            "AUCTION_ONLY"

        OrderNewSingleRequestExecInstINDICATIONOFINTEREST ->
            "INDICATION_OF_INTEREST"


encodeOrderNewSingleRequestExecInst : OrderNewSingleRequestExecInst -> Json.Encode.Value
encodeOrderNewSingleRequestExecInst =
    Json.Encode.int << intFromOrderNewSingleRequestExecInst



encodePosition : Position -> Json.Encode.Value
encodePosition =
    encodeObject << encodePositionPairs


encodePositionWithTag : ( String, String ) -> Position -> Json.Encode.Value
encodePositionWithTag (tagField, tag) model =
    encodeObject (encodePositionPairs model ++ [ encode tagField Json.Encode.string tag ])


encodePositionPairs : Position -> List EncodedField
encodePositionPairs model =
    let
        pairs =
            [ maybeEncode "exchange_id" Json.Encode.string model.exchangeId
            , maybeEncode "data" (Json.Encode.list encodePositionDataInner) model.data
            ]
    in
    pairs


encodePositionDataInner : PositionDataInner -> Json.Encode.Value
encodePositionDataInner =
    encodeObject << encodePositionDataInnerPairs


encodePositionDataInnerWithTag : ( String, String ) -> PositionDataInner -> Json.Encode.Value
encodePositionDataInnerWithTag (tagField, tag) model =
    encodeObject (encodePositionDataInnerPairs model ++ [ encode tagField Json.Encode.string tag ])


encodePositionDataInnerPairs : PositionDataInner -> List EncodedField
encodePositionDataInnerPairs model =
    let
        pairs =
            [ maybeEncode "symbol_id_exchange" Json.Encode.string model.symbolIdExchange
            , maybeEncode "symbol_id_coinapi" Json.Encode.string model.symbolIdCoinapi
            , maybeEncode "avg_entry_price" Json.Encode.float model.avgEntryPrice
            , maybeEncode "quantity" Json.Encode.float model.quantity
            , maybeEncode "side" encodeOrdSide model.side
            , maybeEncode "unrealized_pnl" Json.Encode.float model.unrealizedPnl
            , maybeEncode "leverage" Json.Encode.float model.leverage
            , maybeEncode "cross_margin" Json.Encode.bool model.crossMargin
            , maybeEncode "liquidation_price" Json.Encode.float model.liquidationPrice
            , maybeEncode "raw_data" encodeObject model.rawData
            ]
    in
    pairs


stringFromRejectReason : RejectReason -> String
stringFromRejectReason model =
    case model of
        RejectReasonOTHER ->
            "OTHER"

        RejectReasonEXCHANGEUNREACHABLE ->
            "EXCHANGE_UNREACHABLE"

        RejectReasonEXCHANGERESPONSETIMEOUT ->
            "EXCHANGE_RESPONSE_TIMEOUT"

        RejectReasonORDERIDNOTFOUND ->
            "ORDER_ID_NOT_FOUND"

        RejectReasonINVALIDTYPE ->
            "INVALID_TYPE"

        RejectReasonMETHODNOTSUPPORTED ->
            "METHOD_NOT_SUPPORTED"

        RejectReasonJSONERROR ->
            "JSON_ERROR"


encodeRejectReason : RejectReason -> Json.Encode.Value
encodeRejectReason =
    Json.Encode.string << stringFromRejectReason


stringFromTimeInForce : TimeInForce -> String
stringFromTimeInForce model =
    case model of
        TimeInForceGOODTILLCANCEL ->
            "GOOD_TILL_CANCEL"

        TimeInForceGOODTILLTIMEEXCHANGE ->
            "GOOD_TILL_TIME_EXCHANGE"

        TimeInForceGOODTILLTIMEOMS ->
            "GOOD_TILL_TIME_OMS"

        TimeInForceFILLORKILL ->
            "FILL_OR_KILL"

        TimeInForceIMMEDIATEORCANCEL ->
            "IMMEDIATE_OR_CANCEL"


encodeTimeInForce : TimeInForce -> Json.Encode.Value
encodeTimeInForce =
    Json.Encode.string << stringFromTimeInForce


encodeValidationError : ValidationError -> Json.Encode.Value
encodeValidationError =
    encodeObject << encodeValidationErrorPairs


encodeValidationErrorWithTag : ( String, String ) -> ValidationError -> Json.Encode.Value
encodeValidationErrorWithTag (tagField, tag) model =
    encodeObject (encodeValidationErrorPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeValidationErrorPairs : ValidationError -> List EncodedField
encodeValidationErrorPairs model =
    let
        pairs =
            [ maybeEncode "type" Json.Encode.string model.type_
            , maybeEncode "title" Json.Encode.string model.title
            , maybeEncode "status" Json.Encode.float model.status
            , maybeEncode "traceId" Json.Encode.string model.traceId
            , maybeEncode "errors" Json.Encode.string model.errors
            ]
    in
    pairs


-- DECODER


balanceDecoder : Json.Decode.Decoder Balance
balanceDecoder =
    Json.Decode.succeed Balance
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "data" (Json.Decode.list balanceDataInnerDecoder) Nothing


balanceDataInnerDecoder : Json.Decode.Decoder BalanceDataInner
balanceDataInnerDecoder =
    Json.Decode.succeed BalanceDataInner
        |> maybeDecode "asset_id_exchange" Json.Decode.string Nothing
        |> maybeDecode "asset_id_coinapi" Json.Decode.string Nothing
        |> maybeDecode "balance" Json.Decode.float Nothing
        |> maybeDecode "available" Json.Decode.float Nothing
        |> maybeDecode "locked" Json.Decode.float Nothing
        |> maybeDecode "last_updated_by" balanceDataInnerLastUpdatedByDecoder Nothing
        |> maybeDecode "rate_usd" Json.Decode.float Nothing
        |> maybeDecode "traded" Json.Decode.float Nothing


balanceDataInnerLastUpdatedByDecoder : Json.Decode.Decoder BalanceDataInnerLastUpdatedBy
balanceDataInnerLastUpdatedByDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "INITIALIZATION" ->
                        Json.Decode.succeed BalanceDataInnerLastUpdatedByINITIALIZATION

                    "BALANCE_MANAGER" ->
                        Json.Decode.succeed BalanceDataInnerLastUpdatedByBALANCEMANAGER

                    "EXCHANGE" ->
                        Json.Decode.succeed BalanceDataInnerLastUpdatedByEXCHANGE

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )



fillsDecoder : Json.Decode.Decoder Fills
fillsDecoder =
    Json.Decode.succeed Fills
        |> maybeDecode "time" posixDecoder Nothing
        |> maybeDecode "price" Json.Decode.float Nothing
        |> maybeDecode "amount" Json.Decode.float Nothing


messageErrorDecoder : Json.Decode.Decoder MessageError
messageErrorDecoder =
    Json.Decode.succeed MessageError
        |> maybeDecode "message" Json.Decode.string Nothing


messageRejectDecoder : Json.Decode.Decoder MessageReject
messageRejectDecoder =
    Json.Decode.succeed MessageReject
        |> maybeDecode "type" Json.Decode.string Nothing
        |> maybeDecode "reject_reason" rejectReasonDecoder Nothing
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "message" Json.Decode.string Nothing
        |> maybeDecode "rejected_message" Json.Decode.string Nothing


ordSideDecoder : Json.Decode.Decoder OrdSide
ordSideDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "BUY" ->
                        Json.Decode.succeed OrdSideBUY

                    "SELL" ->
                        Json.Decode.succeed OrdSideSELL

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )


ordStatusDecoder : Json.Decode.Decoder OrdStatus
ordStatusDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "RECEIVED" ->
                        Json.Decode.succeed OrdStatusRECEIVED

                    "ROUTING" ->
                        Json.Decode.succeed OrdStatusROUTING

                    "ROUTED" ->
                        Json.Decode.succeed OrdStatusROUTED

                    "NEW" ->
                        Json.Decode.succeed OrdStatusNEW

                    "PENDING_CANCEL" ->
                        Json.Decode.succeed OrdStatusPENDINGCANCEL

                    "PARTIALLY_FILLED" ->
                        Json.Decode.succeed OrdStatusPARTIALLYFILLED

                    "FILLED" ->
                        Json.Decode.succeed OrdStatusFILLED

                    "CANCELED" ->
                        Json.Decode.succeed OrdStatusCANCELED

                    "REJECTED" ->
                        Json.Decode.succeed OrdStatusREJECTED

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )


ordTypeDecoder : Json.Decode.Decoder OrdType
ordTypeDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "LIMIT" ->
                        Json.Decode.succeed OrdTypeLIMIT

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )


orderCancelAllRequestDecoder : Json.Decode.Decoder OrderCancelAllRequest
orderCancelAllRequestDecoder =
    Json.Decode.succeed OrderCancelAllRequest
        |> decode "exchange_id" Json.Decode.string 


orderCancelSingleRequestDecoder : Json.Decode.Decoder OrderCancelSingleRequest
orderCancelSingleRequestDecoder =
    Json.Decode.succeed OrderCancelSingleRequest
        |> decode "exchange_id" Json.Decode.string 
        |> maybeDecode "exchange_order_id" Json.Decode.string Nothing
        |> maybeDecode "client_order_id" Json.Decode.string Nothing


orderExecutionReportDecoder : Json.Decode.Decoder OrderExecutionReport
orderExecutionReportDecoder =
    Json.Decode.succeed OrderExecutionReport
        |> decode "exchange_id" Json.Decode.string 
        |> decode "client_order_id" Json.Decode.string 
        |> maybeDecode "symbol_id_exchange" Json.Decode.string Nothing
        |> maybeDecode "symbol_id_coinapi" Json.Decode.string Nothing
        |> decode "amount_order" Json.Decode.float 
        |> decode "price" Json.Decode.float 
        |> decode "side" ordSideDecoder 
        |> decode "order_type" ordTypeDecoder 
        |> decode "time_in_force" timeInForceDecoder 
        |> maybeDecode "expire_time" posixDecoder Nothing
        |> maybeDecode "exec_inst" (Json.Decode.list orderExecutionReportExecInstDecoder) Nothing
        |> decode "client_order_id_format_exchange" Json.Decode.string 
        |> maybeDecode "exchange_order_id" Json.Decode.string Nothing
        |> decode "amount_open" Json.Decode.float 
        |> decode "amount_filled" Json.Decode.float 
        |> maybeDecode "avg_px" Json.Decode.float Nothing
        |> decode "status" ordStatusDecoder 
        |> maybeDecode "status_history" (Json.Decode.list (Json.Decode.list Json.Decode.string)) Nothing
        |> maybeDecode "error_message" Json.Decode.string Nothing
        |> maybeDecode "fills" (Json.Decode.list fillsDecoder) Nothing


orderExecutionReportExecInstDecoder : Json.Decode.Decoder OrderExecutionReportExecInst
orderExecutionReportExecInstDecoder =
    Json.Decode.int
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "MAKER_OR_CANCEL" ->
                        Json.Decode.succeed OrderExecutionReportExecInstMAKERORCANCEL

                    "AUCTION_ONLY" ->
                        Json.Decode.succeed OrderExecutionReportExecInstAUCTIONONLY

                    "INDICATION_OF_INTEREST" ->
                        Json.Decode.succeed OrderExecutionReportExecInstINDICATIONOFINTEREST

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ String.fromInt other
            )



orderHistoryDecoder : Json.Decode.Decoder OrderHistory
orderHistoryDecoder =
    Json.Decode.succeed OrderHistory
        |> maybeDecode "apikey" Json.Decode.string Nothing
        |> maybeDecode "exchangeId" Json.Decode.string Nothing
        |> maybeDecode "clientOrderId" Json.Decode.string Nothing
        |> maybeDecode "symbolIdExchange" Json.Decode.string Nothing
        |> maybeDecode "symbolIdCoinapi" Json.Decode.string Nothing
        |> maybeDecode "amountOrder" Json.Decode.float Nothing
        |> maybeDecode "price" Json.Decode.float Nothing
        |> maybeDecode "side" Json.Decode.float Nothing
        |> maybeDecode "orderType" Json.Decode.string Nothing
        |> maybeDecode "timeInForce" Json.Decode.string Nothing
        |> maybeDecode "expireTime" posixDecoder Nothing
        |> maybeDecode "execInst" (Json.Decode.list Json.Decode.string) Nothing
        |> maybeDecode "clientOrderIdFormatExchange" Json.Decode.string Nothing
        |> maybeDecode "exchangeOrderId" Json.Decode.string Nothing
        |> maybeDecode "amountOpen" Json.Decode.float Nothing
        |> maybeDecode "amountFilled" Json.Decode.float Nothing
        |> maybeDecode "avgPx" Json.Decode.float Nothing
        |> maybeDecode "status" Json.Decode.string Nothing
        |> maybeDecode "statusHistoryStatus" (Json.Decode.list Json.Decode.string) Nothing
        |> maybeDecode "statusHistoryTime" (Json.Decode.list posixDecoder) Nothing
        |> maybeDecode "errorMessageResult" Json.Decode.string Nothing
        |> maybeDecode "errorMessageReason" Json.Decode.string Nothing
        |> maybeDecode "errorMessageMessage" Json.Decode.string Nothing
        |> maybeDecode "fillsTime" (Json.Decode.list posixDecoder) Nothing
        |> maybeDecode "fillsPrice" (Json.Decode.list Json.Decode.float) Nothing
        |> maybeDecode "fillsAmount" (Json.Decode.list Json.Decode.float) Nothing
        |> maybeDecode "createdTime" posixDecoder Nothing


orderNewSingleRequestDecoder : Json.Decode.Decoder OrderNewSingleRequest
orderNewSingleRequestDecoder =
    Json.Decode.succeed OrderNewSingleRequest
        |> decode "exchange_id" Json.Decode.string 
        |> decode "client_order_id" Json.Decode.string 
        |> maybeDecode "symbol_id_exchange" Json.Decode.string Nothing
        |> maybeDecode "symbol_id_coinapi" Json.Decode.string Nothing
        |> decode "amount_order" Json.Decode.float 
        |> decode "price" Json.Decode.float 
        |> decode "side" ordSideDecoder 
        |> decode "order_type" ordTypeDecoder 
        |> decode "time_in_force" timeInForceDecoder 
        |> maybeDecode "expire_time" posixDecoder Nothing
        |> maybeDecode "exec_inst" (Json.Decode.list orderNewSingleRequestExecInstDecoder) Nothing


orderNewSingleRequestExecInstDecoder : Json.Decode.Decoder OrderNewSingleRequestExecInst
orderNewSingleRequestExecInstDecoder =
    Json.Decode.int
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "MAKER_OR_CANCEL" ->
                        Json.Decode.succeed OrderNewSingleRequestExecInstMAKERORCANCEL

                    "AUCTION_ONLY" ->
                        Json.Decode.succeed OrderNewSingleRequestExecInstAUCTIONONLY

                    "INDICATION_OF_INTEREST" ->
                        Json.Decode.succeed OrderNewSingleRequestExecInstINDICATIONOFINTEREST

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ String.fromInt other
            )



positionDecoder : Json.Decode.Decoder Position
positionDecoder =
    Json.Decode.succeed Position
        |> maybeDecode "exchange_id" Json.Decode.string Nothing
        |> maybeDecode "data" (Json.Decode.list positionDataInnerDecoder) Nothing


positionDataInnerDecoder : Json.Decode.Decoder PositionDataInner
positionDataInnerDecoder =
    Json.Decode.succeed PositionDataInner
        |> maybeDecode "symbol_id_exchange" Json.Decode.string Nothing
        |> maybeDecode "symbol_id_coinapi" Json.Decode.string Nothing
        |> maybeDecode "avg_entry_price" Json.Decode.float Nothing
        |> maybeDecode "quantity" Json.Decode.float Nothing
        |> maybeDecode "side" ordSideDecoder Nothing
        |> maybeDecode "unrealized_pnl" Json.Decode.float Nothing
        |> maybeDecode "leverage" Json.Decode.float Nothing
        |> maybeDecode "cross_margin" Json.Decode.bool Nothing
        |> maybeDecode "liquidation_price" Json.Decode.float Nothing
        |> maybeDecode "raw_data" objectDecoder Nothing


rejectReasonDecoder : Json.Decode.Decoder RejectReason
rejectReasonDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "OTHER" ->
                        Json.Decode.succeed RejectReasonOTHER

                    "EXCHANGE_UNREACHABLE" ->
                        Json.Decode.succeed RejectReasonEXCHANGEUNREACHABLE

                    "EXCHANGE_RESPONSE_TIMEOUT" ->
                        Json.Decode.succeed RejectReasonEXCHANGERESPONSETIMEOUT

                    "ORDER_ID_NOT_FOUND" ->
                        Json.Decode.succeed RejectReasonORDERIDNOTFOUND

                    "INVALID_TYPE" ->
                        Json.Decode.succeed RejectReasonINVALIDTYPE

                    "METHOD_NOT_SUPPORTED" ->
                        Json.Decode.succeed RejectReasonMETHODNOTSUPPORTED

                    "JSON_ERROR" ->
                        Json.Decode.succeed RejectReasonJSONERROR

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )


timeInForceDecoder : Json.Decode.Decoder TimeInForce
timeInForceDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "GOOD_TILL_CANCEL" ->
                        Json.Decode.succeed TimeInForceGOODTILLCANCEL

                    "GOOD_TILL_TIME_EXCHANGE" ->
                        Json.Decode.succeed TimeInForceGOODTILLTIMEEXCHANGE

                    "GOOD_TILL_TIME_OMS" ->
                        Json.Decode.succeed TimeInForceGOODTILLTIMEOMS

                    "FILL_OR_KILL" ->
                        Json.Decode.succeed TimeInForceFILLORKILL

                    "IMMEDIATE_OR_CANCEL" ->
                        Json.Decode.succeed TimeInForceIMMEDIATEORCANCEL

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )


validationErrorDecoder : Json.Decode.Decoder ValidationError
validationErrorDecoder =
    Json.Decode.succeed ValidationError
        |> maybeDecode "type" Json.Decode.string Nothing
        |> maybeDecode "title" Json.Decode.string Nothing
        |> maybeDecode "status" Json.Decode.float Nothing
        |> maybeDecode "traceId" Json.Decode.string Nothing
        |> maybeDecode "errors" Json.Decode.string Nothing




-- HELPER


type alias EncodedField =
    Maybe ( String, Json.Encode.Value )


encodeObject : List EncodedField -> Json.Encode.Value
encodeObject =
    Json.Encode.object << List.filterMap identity


encode : String -> (a -> Json.Encode.Value) -> a -> EncodedField
encode key encoder value =
    Just ( key, encoder value )


encodeNullable : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
encodeNullable key encoder value =
    Just ( key, Maybe.withDefault Json.Encode.null (Maybe.map encoder value) )


maybeEncode : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
maybeEncode key encoder =
    Maybe.map (Tuple.pair key << encoder)


maybeEncodeNullable : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
maybeEncodeNullable =
    encodeNullable


decode : String -> Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b
decode key decoder =
    decodeChain (Json.Decode.field key decoder)


decodeLazy : (a -> c) -> String -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeLazy f key decoder =
    decodeChainLazy f (Json.Decode.field key decoder)


decodeNullable : String -> Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
decodeNullable key decoder =
    decodeChain (maybeField key decoder Nothing)


decodeNullableLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeNullableLazy f key decoder =
    decodeChainLazy f (maybeField key decoder Nothing)


maybeDecode : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
maybeDecode key decoder fallback =
    -- let's be kind to null-values as well
    decodeChain (maybeField key decoder fallback)


maybeDecodeLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
maybeDecodeLazy f key decoder fallback =
    -- let's be kind to null-values as well
    decodeChainLazy f (maybeField key decoder fallback)


maybeDecodeNullable : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
maybeDecodeNullable key decoder fallback =
    decodeChain (maybeField key decoder fallback)


maybeDecodeNullableLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
maybeDecodeNullableLazy f key decoder fallback =
    decodeChainLazy f (maybeField key decoder fallback)


maybeField : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a)
maybeField key decoder fallback =
    let
        fieldDecoder =
            Json.Decode.field key Json.Decode.value

        valueDecoder =
            Json.Decode.oneOf [ Json.Decode.map Just decoder, Json.Decode.null fallback ]

        decodeObject rawObject =
            case Json.Decode.decodeValue fieldDecoder rawObject of
                Ok rawValue ->
                    case Json.Decode.decodeValue valueDecoder rawValue of
                        Ok value ->
                            Json.Decode.succeed value

                        Err error ->
                            Json.Decode.fail (Json.Decode.errorToString error)

                Err _ ->
                    Json.Decode.succeed fallback
    in
    Json.Decode.value
        |> Json.Decode.andThen decodeObject


decodeChain : Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b
decodeChain =
    Json.Decode.map2 (|>)


decodeChainLazy : (a -> c) -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeChainLazy f =
    decodeChain << Json.Decode.map f