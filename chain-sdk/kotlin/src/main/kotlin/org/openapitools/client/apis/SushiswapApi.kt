/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.CurveExchangeDTO
import org.openapitools.client.models.DexTradeDTO
import org.openapitools.client.models.SushiswapBundleDTO
import org.openapitools.client.models.SushiswapBurnDTO
import org.openapitools.client.models.SushiswapDayDataDTO
import org.openapitools.client.models.SushiswapFactoryDTO
import org.openapitools.client.models.SushiswapHourDataDTO
import org.openapitools.client.models.SushiswapLiquidityPositionDTO
import org.openapitools.client.models.SushiswapLiquidityPositionSnapshotDTO
import org.openapitools.client.models.SushiswapMintDTO
import org.openapitools.client.models.SushiswapPairDTO
import org.openapitools.client.models.SushiswapPairDayDataDTO
import org.openapitools.client.models.SushiswapPairHourDataDTO
import org.openapitools.client.models.SushiswapSwapDTO
import org.openapitools.client.models.SushiswapTokenDTO
import org.openapitools.client.models.SushiswapTokenDayDataDTO
import org.openapitools.client.models.SushiswapTransactionDTO
import org.openapitools.client.models.SushiswapUserDTO

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class SushiswapApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://onchain.coinapi.io")
        }
    }

    /**
     * Exchanges (current) ðŸ”¥
     * Gets exchanges.
     * @return kotlin.collections.List<CurveExchangeDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun curveGetExchangesCurrent() : kotlin.collections.List<CurveExchangeDTO> {
        val localVarResponse = curveGetExchangesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CurveExchangeDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Exchanges (current) ðŸ”¥
     * Gets exchanges.
     * @return ApiResponse<kotlin.collections.List<CurveExchangeDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun curveGetExchangesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<CurveExchangeDTO>?> {
        val localVariableConfig = curveGetExchangesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<CurveExchangeDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation curveGetExchangesCurrent
     *
     * @return RequestConfig
     */
    fun curveGetExchangesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/exchanges/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Trades (current) ðŸ”¥
     * Gets trades.
     * @return kotlin.collections.List<DexTradeDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun dexGetTradesCurrent() : kotlin.collections.List<DexTradeDTO> {
        val localVarResponse = dexGetTradesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DexTradeDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Trades (current) ðŸ”¥
     * Gets trades.
     * @return ApiResponse<kotlin.collections.List<DexTradeDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun dexGetTradesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<DexTradeDTO>?> {
        val localVariableConfig = dexGetTradesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<DexTradeDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dexGetTradesCurrent
     *
     * @return RequestConfig
     */
    fun dexGetTradesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/trades/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Bundles (historical) ðŸ”¥
     * Gets bundles.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Hardcoded to &#39;1&#39;. (optional)
     * @return kotlin.collections.List<SushiswapBundleDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetBundlesHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<SushiswapBundleDTO> {
        val localVarResponse = sushiswapGetBundlesHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapBundleDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Bundles (historical) ðŸ”¥
     * Gets bundles.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Hardcoded to &#39;1&#39;. (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapBundleDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetBundlesHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapBundleDTO>?> {
        val localVariableConfig = sushiswapGetBundlesHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<SushiswapBundleDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetBundlesHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Hardcoded to &#39;1&#39;. (optional)
     * @return RequestConfig
     */
    fun sushiswapGetBundlesHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/bundles/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Burns (historical) ðŸ”¥
     * Gets burns.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @return kotlin.collections.List<SushiswapBurnDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetBurnsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pair: kotlin.String? = null) : kotlin.collections.List<SushiswapBurnDTO> {
        val localVarResponse = sushiswapGetBurnsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pair = pair)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapBurnDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Burns (historical) ðŸ”¥
     * Gets burns.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapBurnDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetBurnsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pair: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapBurnDTO>?> {
        val localVariableConfig = sushiswapGetBurnsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pair = pair)

        return request<Unit, kotlin.collections.List<SushiswapBurnDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetBurnsHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @return RequestConfig
     */
    fun sushiswapGetBurnsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pair: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pair != null) {
                    put("pair", listOf(pair.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/burns/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * DayDatas (historical) ðŸ”¥
     * Gets daydatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Unix timestamp for start of day / 86400 giving a unique day index. (optional)
     * @return kotlin.collections.List<SushiswapDayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetDayDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<SushiswapDayDataDTO> {
        val localVarResponse = sushiswapGetDayDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapDayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DayDatas (historical) ðŸ”¥
     * Gets daydatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Unix timestamp for start of day / 86400 giving a unique day index. (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapDayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetDayDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapDayDataDTO>?> {
        val localVariableConfig = sushiswapGetDayDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<SushiswapDayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetDayDatasHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Unix timestamp for start of day / 86400 giving a unique day index. (optional)
     * @return RequestConfig
     */
    fun sushiswapGetDayDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/daydatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Factorys (historical) ðŸ”¥
     * Gets factorys.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Factory address. (optional)
     * @return kotlin.collections.List<SushiswapFactoryDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetFactorysHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<SushiswapFactoryDTO> {
        val localVarResponse = sushiswapGetFactorysHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapFactoryDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Factorys (historical) ðŸ”¥
     * Gets factorys.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Factory address. (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapFactoryDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetFactorysHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapFactoryDTO>?> {
        val localVariableConfig = sushiswapGetFactorysHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<SushiswapFactoryDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetFactorysHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Factory address. (optional)
     * @return RequestConfig
     */
    fun sushiswapGetFactorysHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/factorys/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * HourDatas (historical) ðŸ”¥
     * Gets hourdatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Start of hour timestamp. (optional)
     * @return kotlin.collections.List<SushiswapHourDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetHourDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<SushiswapHourDataDTO> {
        val localVarResponse = sushiswapGetHourDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapHourDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * HourDatas (historical) ðŸ”¥
     * Gets hourdatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Start of hour timestamp. (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapHourDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetHourDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapHourDataDTO>?> {
        val localVariableConfig = sushiswapGetHourDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<SushiswapHourDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetHourDatasHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Start of hour timestamp. (optional)
     * @return RequestConfig
     */
    fun sushiswapGetHourDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/hourdatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * LiquidityPositionSnapshots (historical) ðŸ”¥
     * Gets liquiditypositionsnapshots.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param user  (optional)
     * @param pair  (optional)
     * @return kotlin.collections.List<SushiswapLiquidityPositionSnapshotDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetLiquidityPositionSnapshotsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, user: kotlin.String? = null, pair: kotlin.String? = null) : kotlin.collections.List<SushiswapLiquidityPositionSnapshotDTO> {
        val localVarResponse = sushiswapGetLiquidityPositionSnapshotsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, user = user, pair = pair)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapLiquidityPositionSnapshotDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * LiquidityPositionSnapshots (historical) ðŸ”¥
     * Gets liquiditypositionsnapshots.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param user  (optional)
     * @param pair  (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapLiquidityPositionSnapshotDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetLiquidityPositionSnapshotsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, user: kotlin.String?, pair: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapLiquidityPositionSnapshotDTO>?> {
        val localVariableConfig = sushiswapGetLiquidityPositionSnapshotsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, user = user, pair = pair)

        return request<Unit, kotlin.collections.List<SushiswapLiquidityPositionSnapshotDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetLiquidityPositionSnapshotsHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param user  (optional)
     * @param pair  (optional)
     * @return RequestConfig
     */
    fun sushiswapGetLiquidityPositionSnapshotsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, user: kotlin.String?, pair: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
                if (pair != null) {
                    put("pair", listOf(pair.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/liquiditypositionsnapshots/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * LiquidityPositions (historical) ðŸ”¥
     * Gets liquiditypositions.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param user  (optional)
     * @param pair  (optional)
     * @return kotlin.collections.List<SushiswapLiquidityPositionDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetLiquidityPositionsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, user: kotlin.String? = null, pair: kotlin.String? = null) : kotlin.collections.List<SushiswapLiquidityPositionDTO> {
        val localVarResponse = sushiswapGetLiquidityPositionsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, user = user, pair = pair)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapLiquidityPositionDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * LiquidityPositions (historical) ðŸ”¥
     * Gets liquiditypositions.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param user  (optional)
     * @param pair  (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapLiquidityPositionDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetLiquidityPositionsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, user: kotlin.String?, pair: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapLiquidityPositionDTO>?> {
        val localVariableConfig = sushiswapGetLiquidityPositionsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, user = user, pair = pair)

        return request<Unit, kotlin.collections.List<SushiswapLiquidityPositionDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetLiquidityPositionsHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param user  (optional)
     * @param pair  (optional)
     * @return RequestConfig
     */
    fun sushiswapGetLiquidityPositionsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, user: kotlin.String?, pair: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
                if (pair != null) {
                    put("pair", listOf(pair.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/liquiditypositions/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Mints (historical) ðŸ”¥
     * Gets mints.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @return kotlin.collections.List<SushiswapMintDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetMintsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pair: kotlin.String? = null) : kotlin.collections.List<SushiswapMintDTO> {
        val localVarResponse = sushiswapGetMintsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pair = pair)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapMintDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Mints (historical) ðŸ”¥
     * Gets mints.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapMintDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetMintsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pair: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapMintDTO>?> {
        val localVariableConfig = sushiswapGetMintsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pair = pair)

        return request<Unit, kotlin.collections.List<SushiswapMintDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetMintsHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @return RequestConfig
     */
    fun sushiswapGetMintsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pair: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pair != null) {
                    put("pair", listOf(pair.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/mints/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PairDayDatas (historical) ðŸ”¥
     * Gets pairdaydatas.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @param token0  (optional)
     * @param token1  (optional)
     * @return kotlin.collections.List<SushiswapPairDayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetPairDayDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pair: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<SushiswapPairDayDataDTO> {
        val localVarResponse = sushiswapGetPairDayDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pair = pair, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapPairDayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PairDayDatas (historical) ðŸ”¥
     * Gets pairdaydatas.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @param token0  (optional)
     * @param token1  (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapPairDayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetPairDayDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pair: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapPairDayDataDTO>?> {
        val localVariableConfig = sushiswapGetPairDayDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pair = pair, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<SushiswapPairDayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetPairDayDatasHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @param token0  (optional)
     * @param token1  (optional)
     * @return RequestConfig
     */
    fun sushiswapGetPairDayDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pair: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pair != null) {
                    put("pair", listOf(pair.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/pairdaydatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PairHourDatas (historical) ðŸ”¥
     * Gets pairhourdatas.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @return kotlin.collections.List<SushiswapPairHourDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetPairHourDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pair: kotlin.String? = null) : kotlin.collections.List<SushiswapPairHourDataDTO> {
        val localVarResponse = sushiswapGetPairHourDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pair = pair)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapPairHourDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PairHourDatas (historical) ðŸ”¥
     * Gets pairhourdatas.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapPairHourDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetPairHourDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pair: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapPairHourDataDTO>?> {
        val localVariableConfig = sushiswapGetPairHourDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pair = pair)

        return request<Unit, kotlin.collections.List<SushiswapPairHourDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetPairHourDatasHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pair  (optional)
     * @return RequestConfig
     */
    fun sushiswapGetPairHourDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pair: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pair != null) {
                    put("pair", listOf(pair.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/pairhourdatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Pairs (historical) ðŸ”¥
     * Gets pairs.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param name  (optional)
     * @param token0  (optional)
     * @param token1  (optional)
     * @return kotlin.collections.List<SushiswapPairDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetPairsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, name: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<SushiswapPairDTO> {
        val localVarResponse = sushiswapGetPairsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, name = name, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapPairDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pairs (historical) ðŸ”¥
     * Gets pairs.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param name  (optional)
     * @param token0  (optional)
     * @param token1  (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapPairDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetPairsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, name: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapPairDTO>?> {
        val localVariableConfig = sushiswapGetPairsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, name = name, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<SushiswapPairDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetPairsHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param name  (optional)
     * @param token0  (optional)
     * @param token1  (optional)
     * @return RequestConfig
     */
    fun sushiswapGetPairsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, name: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/pairs/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Pools (current) ðŸ”¥
     * Gets pools.
     * @return kotlin.collections.List<SushiswapPairDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetPoolsCurrent() : kotlin.collections.List<SushiswapPairDTO> {
        val localVarResponse = sushiswapGetPoolsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapPairDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pools (current) ðŸ”¥
     * Gets pools.
     * @return ApiResponse<kotlin.collections.List<SushiswapPairDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetPoolsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<SushiswapPairDTO>?> {
        val localVariableConfig = sushiswapGetPoolsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<SushiswapPairDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetPoolsCurrent
     *
     * @return RequestConfig
     */
    fun sushiswapGetPoolsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/pools/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Swaps (current) ðŸ”¥
     * Gets swaps.
     * @return kotlin.collections.List<SushiswapSwapDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetSwapsCurrent() : kotlin.collections.List<SushiswapSwapDTO> {
        val localVarResponse = sushiswapGetSwapsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapSwapDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Swaps (current) ðŸ”¥
     * Gets swaps.
     * @return ApiResponse<kotlin.collections.List<SushiswapSwapDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetSwapsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<SushiswapSwapDTO>?> {
        val localVariableConfig = sushiswapGetSwapsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<SushiswapSwapDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetSwapsCurrent
     *
     * @return RequestConfig
     */
    fun sushiswapGetSwapsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/swaps/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Swaps (historical) ðŸ”¥
     * Gets swaps.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash plus index in Transaction swap array. (optional)
     * @param pair Reference to pair. (optional)
     * @return kotlin.collections.List<SushiswapSwapDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetSwapsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pair: kotlin.String? = null) : kotlin.collections.List<SushiswapSwapDTO> {
        val localVarResponse = sushiswapGetSwapsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pair = pair)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapSwapDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Swaps (historical) ðŸ”¥
     * Gets swaps.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash plus index in Transaction swap array. (optional)
     * @param pair Reference to pair. (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapSwapDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetSwapsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pair: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapSwapDTO>?> {
        val localVariableConfig = sushiswapGetSwapsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pair = pair)

        return request<Unit, kotlin.collections.List<SushiswapSwapDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetSwapsHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash plus index in Transaction swap array. (optional)
     * @param pair Reference to pair. (optional)
     * @return RequestConfig
     */
    fun sushiswapGetSwapsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pair: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pair != null) {
                    put("pair", listOf(pair.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/swaps/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TokenDayDatas (historical) ðŸ”¥
     * Gets tokendaydatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Identifier, day start timestamp in unix / 86400. (optional)
     * @return kotlin.collections.List<SushiswapTokenDayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetTokenDayDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<SushiswapTokenDayDataDTO> {
        val localVarResponse = sushiswapGetTokenDayDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapTokenDayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TokenDayDatas (historical) ðŸ”¥
     * Gets tokendaydatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Identifier, day start timestamp in unix / 86400. (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapTokenDayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetTokenDayDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapTokenDayDataDTO>?> {
        val localVariableConfig = sushiswapGetTokenDayDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<SushiswapTokenDayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetTokenDayDatasHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Identifier, day start timestamp in unix / 86400. (optional)
     * @return RequestConfig
     */
    fun sushiswapGetTokenDayDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/tokendaydatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Tokens (current) ðŸ”¥
     * Gets tokens.
     * @return kotlin.collections.List<SushiswapTokenDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetTokensCurrent() : kotlin.collections.List<SushiswapTokenDTO> {
        val localVarResponse = sushiswapGetTokensCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapTokenDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Tokens (current) ðŸ”¥
     * Gets tokens.
     * @return ApiResponse<kotlin.collections.List<SushiswapTokenDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetTokensCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<SushiswapTokenDTO>?> {
        val localVariableConfig = sushiswapGetTokensCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<SushiswapTokenDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetTokensCurrent
     *
     * @return RequestConfig
     */
    fun sushiswapGetTokensCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/tokens/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Tokens (historical) ðŸ”¥
     * Gets tokens.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address. (optional)
     * @param symbol Token symbol. (optional)
     * @param name Token name. (optional)
     * @return kotlin.collections.List<SushiswapTokenDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetTokensHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, symbol: kotlin.String? = null, name: kotlin.String? = null) : kotlin.collections.List<SushiswapTokenDTO> {
        val localVarResponse = sushiswapGetTokensHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, symbol = symbol, name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapTokenDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Tokens (historical) ðŸ”¥
     * Gets tokens.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address. (optional)
     * @param symbol Token symbol. (optional)
     * @param name Token name. (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapTokenDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetTokensHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, symbol: kotlin.String?, name: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapTokenDTO>?> {
        val localVariableConfig = sushiswapGetTokensHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, symbol = symbol, name = name)

        return request<Unit, kotlin.collections.List<SushiswapTokenDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetTokensHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address. (optional)
     * @param symbol Token symbol. (optional)
     * @param name Token name. (optional)
     * @return RequestConfig
     */
    fun sushiswapGetTokensHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, symbol: kotlin.String?, name: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (symbol != null) {
                    put("symbol", listOf(symbol.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/tokens/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Transactions (historical) ðŸ”¥
     * Gets transactions.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Ethereum transaction hash. (optional)
     * @return kotlin.collections.List<SushiswapTransactionDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetTransactionsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<SushiswapTransactionDTO> {
        val localVarResponse = sushiswapGetTransactionsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapTransactionDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Transactions (historical) ðŸ”¥
     * Gets transactions.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Ethereum transaction hash. (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapTransactionDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetTransactionsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapTransactionDTO>?> {
        val localVariableConfig = sushiswapGetTransactionsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<SushiswapTransactionDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetTransactionsHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Ethereum transaction hash. (optional)
     * @return RequestConfig
     */
    fun sushiswapGetTransactionsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/transactions/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Users (historical) ðŸ”¥
     * Gets users.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id User address. (optional)
     * @return kotlin.collections.List<SushiswapUserDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sushiswapGetUsersHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<SushiswapUserDTO> {
        val localVarResponse = sushiswapGetUsersHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SushiswapUserDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Users (historical) ðŸ”¥
     * Gets users.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id User address. (optional)
     * @return ApiResponse<kotlin.collections.List<SushiswapUserDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sushiswapGetUsersHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<SushiswapUserDTO>?> {
        val localVariableConfig = sushiswapGetUsersHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<SushiswapUserDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sushiswapGetUsersHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id User address. (optional)
     * @return RequestConfig
     */
    fun sushiswapGetUsersHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/sushiswap/users/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
