/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.UniswapV3BundleV3DTO
import org.openapitools.client.models.UniswapV3BurnV3DTO
import org.openapitools.client.models.UniswapV3FactoryV3DTO
import org.openapitools.client.models.UniswapV3MintV3DTO
import org.openapitools.client.models.UniswapV3PoolDayDataV3DTO
import org.openapitools.client.models.UniswapV3PoolHourDataV3DTO
import org.openapitools.client.models.UniswapV3PoolV3DTO
import org.openapitools.client.models.UniswapV3PositionSnapshotV3DTO
import org.openapitools.client.models.UniswapV3PositionV3DTO
import org.openapitools.client.models.UniswapV3SwapV3DTO
import org.openapitools.client.models.UniswapV3TickDayDataV3DTO
import org.openapitools.client.models.UniswapV3TickV3DTO
import org.openapitools.client.models.UniswapV3TokenHourDataV3DTO
import org.openapitools.client.models.UniswapV3TokenV3DTO
import org.openapitools.client.models.UniswapV3TokenV3DayDataDTO
import org.openapitools.client.models.UniswapV3TransactionV3DTO
import org.openapitools.client.models.UniswapV3UniswapDayDataV3DTO

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class UniswapV3Api(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://onchain.coinapi.io")
        }
    }

    /**
     * BundleV3s (historical) ðŸ”¥
     * Gets bundlev3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id  (optional)
     * @return kotlin.collections.List<UniswapV3BundleV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetBundleV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3BundleV3DTO> {
        val localVarResponse = uniswapV3GetBundleV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3BundleV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * BundleV3s (historical) ðŸ”¥
     * Gets bundlev3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3BundleV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetBundleV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3BundleV3DTO>?> {
        val localVariableConfig = uniswapV3GetBundleV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3BundleV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetBundleV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetBundleV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/bundlev3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Bundles (current)
     * Gets bundles.
     * @return kotlin.collections.List<UniswapV3BundleV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetBundlesCurrent() : kotlin.collections.List<UniswapV3BundleV3DTO> {
        val localVarResponse = uniswapV3GetBundlesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3BundleV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Bundles (current)
     * Gets bundles.
     * @return ApiResponse<kotlin.collections.List<UniswapV3BundleV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetBundlesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3BundleV3DTO>?> {
        val localVariableConfig = uniswapV3GetBundlesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3BundleV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetBundlesCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3GetBundlesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/bundles/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * BurnV3s (historical) ðŸ”¥
     * Gets burnv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return kotlin.collections.List<UniswapV3BurnV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetBurnV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<UniswapV3BurnV3DTO> {
        val localVarResponse = uniswapV3GetBurnV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3BurnV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * BurnV3s (historical) ðŸ”¥
     * Gets burnv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3BurnV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetBurnV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3BurnV3DTO>?> {
        val localVariableConfig = uniswapV3GetBurnV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<UniswapV3BurnV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetBurnV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetBurnV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/burnv3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Burns (current)
     * Gets burns.
     * @param filterPoolId  (optional)
     * @return kotlin.collections.List<UniswapV3BurnV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetBurnsCurrent(filterPoolId: kotlin.String? = null) : kotlin.collections.List<UniswapV3BurnV3DTO> {
        val localVarResponse = uniswapV3GetBurnsCurrentWithHttpInfo(filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3BurnV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Burns (current)
     * Gets burns.
     * @param filterPoolId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3BurnV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetBurnsCurrentWithHttpInfo(filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3BurnV3DTO>?> {
        val localVariableConfig = uniswapV3GetBurnsCurrentRequestConfig(filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<UniswapV3BurnV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetBurnsCurrent
     *
     * @param filterPoolId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetBurnsCurrentRequestConfig(filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/burns/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * DayData (current)
     * Gets uniswapv3 day data.
     * @return kotlin.collections.List<UniswapV3UniswapDayDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetDayDataCurrent() : kotlin.collections.List<UniswapV3UniswapDayDataV3DTO> {
        val localVarResponse = uniswapV3GetDayDataCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3UniswapDayDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DayData (current)
     * Gets uniswapv3 day data.
     * @return ApiResponse<kotlin.collections.List<UniswapV3UniswapDayDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetDayDataCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3UniswapDayDataV3DTO>?> {
        val localVariableConfig = uniswapV3GetDayDataCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3UniswapDayDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetDayDataCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3GetDayDataCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/dayData/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Factory (current)
     * Gets factory.
     * @return kotlin.collections.List<UniswapV3FactoryV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetFactoryCurrent() : kotlin.collections.List<UniswapV3FactoryV3DTO> {
        val localVarResponse = uniswapV3GetFactoryCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3FactoryV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Factory (current)
     * Gets factory.
     * @return ApiResponse<kotlin.collections.List<UniswapV3FactoryV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetFactoryCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3FactoryV3DTO>?> {
        val localVariableConfig = uniswapV3GetFactoryCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3FactoryV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetFactoryCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3GetFactoryCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/factory/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * FactoryV3s (historical) ðŸ”¥
     * Gets factoryv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Factory address. (optional)
     * @return kotlin.collections.List<UniswapV3FactoryV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetFactoryV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3FactoryV3DTO> {
        val localVarResponse = uniswapV3GetFactoryV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3FactoryV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * FactoryV3s (historical) ðŸ”¥
     * Gets factoryv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Factory address. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3FactoryV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetFactoryV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3FactoryV3DTO>?> {
        val localVariableConfig = uniswapV3GetFactoryV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3FactoryV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetFactoryV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Factory address. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetFactoryV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/factoryv3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * MintV3s (historical) ðŸ”¥
     * Gets mintv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return kotlin.collections.List<UniswapV3MintV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetMintV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<UniswapV3MintV3DTO> {
        val localVarResponse = uniswapV3GetMintV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3MintV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * MintV3s (historical) ðŸ”¥
     * Gets mintv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3MintV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetMintV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3MintV3DTO>?> {
        val localVariableConfig = uniswapV3GetMintV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<UniswapV3MintV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetMintV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetMintV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/mintv3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Mints (current)
     * Gets mints.
     * @param filterPoolId  (optional)
     * @return kotlin.collections.List<UniswapV3MintV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetMintsCurrent(filterPoolId: kotlin.String? = null) : kotlin.collections.List<UniswapV3MintV3DTO> {
        val localVarResponse = uniswapV3GetMintsCurrentWithHttpInfo(filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3MintV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Mints (current)
     * Gets mints.
     * @param filterPoolId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3MintV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetMintsCurrentWithHttpInfo(filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3MintV3DTO>?> {
        val localVariableConfig = uniswapV3GetMintsCurrentRequestConfig(filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<UniswapV3MintV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetMintsCurrent
     *
     * @param filterPoolId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetMintsCurrentRequestConfig(filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/mints/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PoolDayDataV3s (historical) ðŸ”¥
     * Gets pooldaydatav3s.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return kotlin.collections.List<UniswapV3PoolDayDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPoolDayDataV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3PoolDayDataV3DTO> {
        val localVarResponse = uniswapV3GetPoolDayDataV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolDayDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PoolDayDataV3s (historical) ðŸ”¥
     * Gets pooldaydatav3s.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolDayDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPoolDayDataV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PoolDayDataV3DTO>?> {
        val localVariableConfig = uniswapV3GetPoolDayDataV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3PoolDayDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPoolDayDataV3sHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPoolDayDataV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/pooldaydatav3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PoolHourDataV3s (historical) ðŸ”¥
     * Gets poolhourdatav3s.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return kotlin.collections.List<UniswapV3PoolHourDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPoolHourDataV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3PoolHourDataV3DTO> {
        val localVarResponse = uniswapV3GetPoolHourDataV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolHourDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PoolHourDataV3s (historical) ðŸ”¥
     * Gets poolhourdatav3s.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolHourDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPoolHourDataV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PoolHourDataV3DTO>?> {
        val localVariableConfig = uniswapV3GetPoolHourDataV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3PoolHourDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPoolHourDataV3sHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPoolHourDataV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/poolhourdatav3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PoolV3s (historical) ðŸ”¥
     * Gets poolv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return kotlin.collections.List<UniswapV3PoolV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPoolV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<UniswapV3PoolV3DTO> {
        val localVarResponse = uniswapV3GetPoolV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PoolV3s (historical) ðŸ”¥
     * Gets poolv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPoolV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PoolV3DTO>?> {
        val localVariableConfig = uniswapV3GetPoolV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<UniswapV3PoolV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPoolV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPoolV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/poolv3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Pools (current) ðŸ”¥
     * Gets pools.
     * @param filterPoolId  (optional)
     * @return kotlin.collections.List<UniswapV3PoolV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPoolsCurrent(filterPoolId: kotlin.String? = null) : kotlin.collections.List<UniswapV3PoolV3DTO> {
        val localVarResponse = uniswapV3GetPoolsCurrentWithHttpInfo(filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pools (current) ðŸ”¥
     * Gets pools.
     * @param filterPoolId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPoolsCurrentWithHttpInfo(filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PoolV3DTO>?> {
        val localVariableConfig = uniswapV3GetPoolsCurrentRequestConfig(filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<UniswapV3PoolV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPoolsCurrent
     *
     * @param filterPoolId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPoolsCurrentRequestConfig(filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/pools/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PoolsDayData (current)
     * Gets pools day data.
     * @param filterPoolId  (optional)
     * @return kotlin.collections.List<UniswapV3PoolDayDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPoolsDayDataCurrent(filterPoolId: kotlin.String? = null) : kotlin.collections.List<UniswapV3PoolDayDataV3DTO> {
        val localVarResponse = uniswapV3GetPoolsDayDataCurrentWithHttpInfo(filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolDayDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PoolsDayData (current)
     * Gets pools day data.
     * @param filterPoolId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolDayDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPoolsDayDataCurrentWithHttpInfo(filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PoolDayDataV3DTO>?> {
        val localVariableConfig = uniswapV3GetPoolsDayDataCurrentRequestConfig(filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<UniswapV3PoolDayDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPoolsDayDataCurrent
     *
     * @param filterPoolId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPoolsDayDataCurrentRequestConfig(filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/poolsDayData/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PoolsHourData (current)
     * Gets pools hour data.
     * @param filterPoolId  (optional)
     * @return kotlin.collections.List<UniswapV3PoolHourDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPoolsHourDataCurrent(filterPoolId: kotlin.String? = null) : kotlin.collections.List<UniswapV3PoolHourDataV3DTO> {
        val localVarResponse = uniswapV3GetPoolsHourDataCurrentWithHttpInfo(filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolHourDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PoolsHourData (current)
     * Gets pools hour data.
     * @param filterPoolId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolHourDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPoolsHourDataCurrentWithHttpInfo(filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PoolHourDataV3DTO>?> {
        val localVariableConfig = uniswapV3GetPoolsHourDataCurrentRequestConfig(filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<UniswapV3PoolHourDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPoolsHourDataCurrent
     *
     * @param filterPoolId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPoolsHourDataCurrentRequestConfig(filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/poolsHourData/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PositionSnapshotV3s (historical) ðŸ”¥
     * Gets positionsnapshotv3s.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return kotlin.collections.List<UniswapV3PositionSnapshotV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPositionSnapshotV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3PositionSnapshotV3DTO> {
        val localVarResponse = uniswapV3GetPositionSnapshotV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PositionSnapshotV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PositionSnapshotV3s (historical) ðŸ”¥
     * Gets positionsnapshotv3s.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PositionSnapshotV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPositionSnapshotV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PositionSnapshotV3DTO>?> {
        val localVariableConfig = uniswapV3GetPositionSnapshotV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3PositionSnapshotV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPositionSnapshotV3sHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPositionSnapshotV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/positionsnapshotv3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PositionV3s (historical) ðŸ”¥
     * Gets positionv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id NFT token identifier. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return kotlin.collections.List<UniswapV3PositionV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPositionV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<UniswapV3PositionV3DTO> {
        val localVarResponse = uniswapV3GetPositionV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PositionV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PositionV3s (historical) ðŸ”¥
     * Gets positionv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id NFT token identifier. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PositionV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPositionV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PositionV3DTO>?> {
        val localVariableConfig = uniswapV3GetPositionV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<UniswapV3PositionV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPositionV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id NFT token identifier. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPositionV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/positionv3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Positions (current)
     * Gets positions.
     * @param filterPoolId  (optional)
     * @return kotlin.collections.List<UniswapV3PositionV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPositionsCurrent(filterPoolId: kotlin.String? = null) : kotlin.collections.List<UniswapV3PositionV3DTO> {
        val localVarResponse = uniswapV3GetPositionsCurrentWithHttpInfo(filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PositionV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Positions (current)
     * Gets positions.
     * @param filterPoolId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PositionV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPositionsCurrentWithHttpInfo(filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PositionV3DTO>?> {
        val localVariableConfig = uniswapV3GetPositionsCurrentRequestConfig(filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<UniswapV3PositionV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPositionsCurrent
     *
     * @param filterPoolId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPositionsCurrentRequestConfig(filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/positions/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PositionsSnapshots (current)
     * Gets positions snapshots.
     * @param filterPoolId  (optional)
     * @return kotlin.collections.List<UniswapV3PositionSnapshotV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPositionsSnapshotsCurrent(filterPoolId: kotlin.String? = null) : kotlin.collections.List<UniswapV3PositionSnapshotV3DTO> {
        val localVarResponse = uniswapV3GetPositionsSnapshotsCurrentWithHttpInfo(filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PositionSnapshotV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PositionsSnapshots (current)
     * Gets positions snapshots.
     * @param filterPoolId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PositionSnapshotV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPositionsSnapshotsCurrentWithHttpInfo(filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PositionSnapshotV3DTO>?> {
        val localVariableConfig = uniswapV3GetPositionsSnapshotsCurrentRequestConfig(filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<UniswapV3PositionSnapshotV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPositionsSnapshotsCurrent
     *
     * @param filterPoolId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPositionsSnapshotsCurrentRequestConfig(filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/positionSnapshots/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * SwapV3s (historical) ðŸ”¥
     * Gets swapv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Identifier, format: transaction hash + \&quot;#\&quot; + index in swaps Transaction array. (optional)
     * @param pool Pool swap occured within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return kotlin.collections.List<UniswapV3SwapV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetSwapV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<UniswapV3SwapV3DTO> {
        val localVarResponse = uniswapV3GetSwapV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3SwapV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * SwapV3s (historical) ðŸ”¥
     * Gets swapv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Identifier, format: transaction hash + \&quot;#\&quot; + index in swaps Transaction array. (optional)
     * @param pool Pool swap occured within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3SwapV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetSwapV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3SwapV3DTO>?> {
        val localVariableConfig = uniswapV3GetSwapV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<UniswapV3SwapV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetSwapV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Identifier, format: transaction hash + \&quot;#\&quot; + index in swaps Transaction array. (optional)
     * @param pool Pool swap occured within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetSwapV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/swapv3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Swaps (current) ðŸ”¥
     * Gets swaps.
     * @param filterPoolId  (optional)
     * @return kotlin.collections.List<UniswapV3SwapV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetSwapsCurrent(filterPoolId: kotlin.String? = null) : kotlin.collections.List<UniswapV3SwapV3DTO> {
        val localVarResponse = uniswapV3GetSwapsCurrentWithHttpInfo(filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3SwapV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Swaps (current) ðŸ”¥
     * Gets swaps.
     * @param filterPoolId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3SwapV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetSwapsCurrentWithHttpInfo(filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3SwapV3DTO>?> {
        val localVariableConfig = uniswapV3GetSwapsCurrentRequestConfig(filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<UniswapV3SwapV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetSwapsCurrent
     *
     * @param filterPoolId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetSwapsCurrentRequestConfig(filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/swaps/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TickDayDataV3s (historical) ðŸ”¥
     * Gets tickdaydatav3s.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return kotlin.collections.List<UniswapV3TickDayDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTickDayDataV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3TickDayDataV3DTO> {
        val localVarResponse = uniswapV3GetTickDayDataV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TickDayDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TickDayDataV3s (historical) ðŸ”¥
     * Gets tickdaydatav3s.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TickDayDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTickDayDataV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TickDayDataV3DTO>?> {
        val localVariableConfig = uniswapV3GetTickDayDataV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3TickDayDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTickDayDataV3sHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTickDayDataV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tickdaydatav3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TickV3s (historical) ðŸ”¥
     * Gets tickv3s.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return kotlin.collections.List<UniswapV3TickV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTickV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3TickV3DTO> {
        val localVarResponse = uniswapV3GetTickV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TickV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TickV3s (historical) ðŸ”¥
     * Gets tickv3s.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TickV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTickV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TickV3DTO>?> {
        val localVariableConfig = uniswapV3GetTickV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3TickV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTickV3sHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTickV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tickv3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Ticks (current)
     * Gets ticks.
     * @param filterPoolId  (optional)
     * @return kotlin.collections.List<UniswapV3TickV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTicksCurrent(filterPoolId: kotlin.String? = null) : kotlin.collections.List<UniswapV3TickV3DTO> {
        val localVarResponse = uniswapV3GetTicksCurrentWithHttpInfo(filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TickV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Ticks (current)
     * Gets ticks.
     * @param filterPoolId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TickV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTicksCurrentWithHttpInfo(filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TickV3DTO>?> {
        val localVariableConfig = uniswapV3GetTicksCurrentRequestConfig(filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<UniswapV3TickV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTicksCurrent
     *
     * @param filterPoolId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTicksCurrentRequestConfig(filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/ticks/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TicksDayData (current)
     * Gets ticks day data.
     * @param filterPoolId  (optional)
     * @return kotlin.collections.List<UniswapV3TickDayDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTicksDayDataCurrent(filterPoolId: kotlin.String? = null) : kotlin.collections.List<UniswapV3TickDayDataV3DTO> {
        val localVarResponse = uniswapV3GetTicksDayDataCurrentWithHttpInfo(filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TickDayDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TicksDayData (current)
     * Gets ticks day data.
     * @param filterPoolId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TickDayDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTicksDayDataCurrentWithHttpInfo(filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TickDayDataV3DTO>?> {
        val localVariableConfig = uniswapV3GetTicksDayDataCurrentRequestConfig(filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<UniswapV3TickDayDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTicksDayDataCurrent
     *
     * @param filterPoolId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTicksDayDataCurrentRequestConfig(filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/ticksDayData/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TokenHourDataV3s (historical) ðŸ”¥
     * Gets tokenhourdatav3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return kotlin.collections.List<UniswapV3TokenHourDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTokenHourDataV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3TokenHourDataV3DTO> {
        val localVarResponse = uniswapV3GetTokenHourDataV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenHourDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TokenHourDataV3s (historical) ðŸ”¥
     * Gets tokenhourdatav3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenHourDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTokenHourDataV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TokenHourDataV3DTO>?> {
        val localVariableConfig = uniswapV3GetTokenHourDataV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3TokenHourDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTokenHourDataV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTokenHourDataV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokenhourdatav3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TokenV3DayDatas (historical) ðŸ”¥
     * Gets tokenv3daydatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return kotlin.collections.List<UniswapV3TokenV3DayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTokenV3DayDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3TokenV3DayDataDTO> {
        val localVarResponse = uniswapV3GetTokenV3DayDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenV3DayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TokenV3DayDatas (historical) ðŸ”¥
     * Gets tokenv3daydatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenV3DayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTokenV3DayDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TokenV3DayDataDTO>?> {
        val localVariableConfig = uniswapV3GetTokenV3DayDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3TokenV3DayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTokenV3DayDatasHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTokenV3DayDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokenv3daydatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TokenV3s (historical) ðŸ”¥
     * Gets tokenv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address. (optional)
     * @param symbol Token symbol. (optional)
     * @param name Token name. (optional)
     * @return kotlin.collections.List<UniswapV3TokenV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTokenV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, symbol: kotlin.String? = null, name: kotlin.String? = null) : kotlin.collections.List<UniswapV3TokenV3DTO> {
        val localVarResponse = uniswapV3GetTokenV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, symbol = symbol, name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TokenV3s (historical) ðŸ”¥
     * Gets tokenv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address. (optional)
     * @param symbol Token symbol. (optional)
     * @param name Token name. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTokenV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, symbol: kotlin.String?, name: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TokenV3DTO>?> {
        val localVariableConfig = uniswapV3GetTokenV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, symbol = symbol, name = name)

        return request<Unit, kotlin.collections.List<UniswapV3TokenV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTokenV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address. (optional)
     * @param symbol Token symbol. (optional)
     * @param name Token name. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTokenV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, symbol: kotlin.String?, name: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (symbol != null) {
                    put("symbol", listOf(symbol.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokenv3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Tokens (current) ðŸ”¥
     * Gets tokens.
     * @param filterTokenId  (optional)
     * @return kotlin.collections.List<UniswapV3TokenV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTokensCurrent(filterTokenId: kotlin.String? = null) : kotlin.collections.List<UniswapV3TokenV3DTO> {
        val localVarResponse = uniswapV3GetTokensCurrentWithHttpInfo(filterTokenId = filterTokenId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Tokens (current) ðŸ”¥
     * Gets tokens.
     * @param filterTokenId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTokensCurrentWithHttpInfo(filterTokenId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TokenV3DTO>?> {
        val localVariableConfig = uniswapV3GetTokensCurrentRequestConfig(filterTokenId = filterTokenId)

        return request<Unit, kotlin.collections.List<UniswapV3TokenV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTokensCurrent
     *
     * @param filterTokenId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTokensCurrentRequestConfig(filterTokenId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterTokenId != null) {
                    put("filter_token_id", listOf(filterTokenId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokens/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TokensDayData (current)
     * Gets tokens day data.
     * @param filterTokenId  (optional)
     * @return kotlin.collections.List<UniswapV3TokenV3DayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTokensDayDataCurrent(filterTokenId: kotlin.String? = null) : kotlin.collections.List<UniswapV3TokenV3DayDataDTO> {
        val localVarResponse = uniswapV3GetTokensDayDataCurrentWithHttpInfo(filterTokenId = filterTokenId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenV3DayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TokensDayData (current)
     * Gets tokens day data.
     * @param filterTokenId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenV3DayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTokensDayDataCurrentWithHttpInfo(filterTokenId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TokenV3DayDataDTO>?> {
        val localVariableConfig = uniswapV3GetTokensDayDataCurrentRequestConfig(filterTokenId = filterTokenId)

        return request<Unit, kotlin.collections.List<UniswapV3TokenV3DayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTokensDayDataCurrent
     *
     * @param filterTokenId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTokensDayDataCurrentRequestConfig(filterTokenId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterTokenId != null) {
                    put("filter_token_id", listOf(filterTokenId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokensDayData/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TokensHourData (current)
     * Gets tokens hour data.
     * @param filterTokenId  (optional)
     * @return kotlin.collections.List<UniswapV3TokenHourDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTokensHourDataCurrent(filterTokenId: kotlin.String? = null) : kotlin.collections.List<UniswapV3TokenHourDataV3DTO> {
        val localVarResponse = uniswapV3GetTokensHourDataCurrentWithHttpInfo(filterTokenId = filterTokenId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenHourDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TokensHourData (current)
     * Gets tokens hour data.
     * @param filterTokenId  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenHourDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTokensHourDataCurrentWithHttpInfo(filterTokenId: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TokenHourDataV3DTO>?> {
        val localVariableConfig = uniswapV3GetTokensHourDataCurrentRequestConfig(filterTokenId = filterTokenId)

        return request<Unit, kotlin.collections.List<UniswapV3TokenHourDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTokensHourDataCurrent
     *
     * @param filterTokenId  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTokensHourDataCurrentRequestConfig(filterTokenId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterTokenId != null) {
                    put("filter_token_id", listOf(filterTokenId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokensHourData/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TransactionV3s (historical) ðŸ”¥
     * Gets transactionv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash. (optional)
     * @return kotlin.collections.List<UniswapV3TransactionV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTransactionV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3TransactionV3DTO> {
        val localVarResponse = uniswapV3GetTransactionV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TransactionV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TransactionV3s (historical) ðŸ”¥
     * Gets transactionv3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TransactionV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTransactionV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TransactionV3DTO>?> {
        val localVariableConfig = uniswapV3GetTransactionV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3TransactionV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTransactionV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTransactionV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/transactionv3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * UniswapDayDataV3s (historical) ðŸ”¥
     * Gets uniswapdaydatav3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Timestamp rounded to current day by dividing by 86400. (optional)
     * @return kotlin.collections.List<UniswapV3UniswapDayDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetUniswapDayDataV3sHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3UniswapDayDataV3DTO> {
        val localVarResponse = uniswapV3GetUniswapDayDataV3sHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3UniswapDayDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * UniswapDayDataV3s (historical) ðŸ”¥
     * Gets uniswapdaydatav3s.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Timestamp rounded to current day by dividing by 86400. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3UniswapDayDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetUniswapDayDataV3sHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3UniswapDayDataV3DTO>?> {
        val localVariableConfig = uniswapV3GetUniswapDayDataV3sHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3UniswapDayDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetUniswapDayDataV3sHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Timestamp rounded to current day by dividing by 86400. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetUniswapDayDataV3sHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/uniswapdaydatav3s/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
