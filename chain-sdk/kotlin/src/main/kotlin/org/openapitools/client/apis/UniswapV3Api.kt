/**
 * OnChain API
 *
 *  This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.BundleV3DTO
import org.openapitools.client.models.BurnV3DTO
import org.openapitools.client.models.FactoryV3DTO
import org.openapitools.client.models.MintV3DTO
import org.openapitools.client.models.PoolDayDataV3DTO
import org.openapitools.client.models.PoolHourDataV3DTO
import org.openapitools.client.models.PoolV3DTO
import org.openapitools.client.models.PositionSnapshotV3DTO
import org.openapitools.client.models.PositionV3DTO
import org.openapitools.client.models.SwapV3DTO
import org.openapitools.client.models.TickDayDataV3DTO
import org.openapitools.client.models.TickV3DTO
import org.openapitools.client.models.TokenHourDataV3DTO
import org.openapitools.client.models.TokenV3DTO
import org.openapitools.client.models.TokenV3DayDataDTO
import org.openapitools.client.models.UniswapDayDataV3DTO

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class UniswapV3Api(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://onchain.coinapi.io")
        }
    }

    /**
     * GetBundles
     * 
     * @param chainId Chain id
     * @return kotlin.collections.List<BundleV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3BundleCurrentGet(chainId: kotlin.String) : kotlin.collections.List<BundleV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3BundleCurrentGetWithHttpInfo(chainId = chainId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BundleV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetBundles
     * 
     * @param chainId Chain id
     * @return ApiResponse<kotlin.collections.List<BundleV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3BundleCurrentGetWithHttpInfo(chainId: kotlin.String) : ApiResponse<kotlin.collections.List<BundleV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3BundleCurrentGetRequestConfig(chainId = chainId)

        return request<Unit, kotlin.collections.List<BundleV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3BundleCurrentGet
     *
     * @param chainId Chain id
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3BundleCurrentGetRequestConfig(chainId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/bundle/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetBurns
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return kotlin.collections.List<BurnV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3BurnsCurrentGet(chainId: kotlin.String, filterPoolId: kotlin.String? = null) : kotlin.collections.List<BurnV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3BurnsCurrentGetWithHttpInfo(chainId = chainId, filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BurnV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetBurns
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return ApiResponse<kotlin.collections.List<BurnV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3BurnsCurrentGetWithHttpInfo(chainId: kotlin.String, filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<BurnV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3BurnsCurrentGetRequestConfig(chainId = chainId, filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<BurnV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3BurnsCurrentGet
     *
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3BurnsCurrentGetRequestConfig(chainId: kotlin.String, filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/burns/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetFactory
     * 
     * @param chainId Chain id
     * @return kotlin.collections.List<FactoryV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3FactoryCurrentGet(chainId: kotlin.String) : kotlin.collections.List<FactoryV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3FactoryCurrentGetWithHttpInfo(chainId = chainId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<FactoryV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetFactory
     * 
     * @param chainId Chain id
     * @return ApiResponse<kotlin.collections.List<FactoryV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3FactoryCurrentGetWithHttpInfo(chainId: kotlin.String) : ApiResponse<kotlin.collections.List<FactoryV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3FactoryCurrentGetRequestConfig(chainId = chainId)

        return request<Unit, kotlin.collections.List<FactoryV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3FactoryCurrentGet
     *
     * @param chainId Chain id
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3FactoryCurrentGetRequestConfig(chainId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/factory/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetMints
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return kotlin.collections.List<MintV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3MintsCurrentGet(chainId: kotlin.String, filterPoolId: kotlin.String? = null) : kotlin.collections.List<MintV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3MintsCurrentGetWithHttpInfo(chainId = chainId, filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MintV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetMints
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return ApiResponse<kotlin.collections.List<MintV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3MintsCurrentGetWithHttpInfo(chainId: kotlin.String, filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<MintV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3MintsCurrentGetRequestConfig(chainId = chainId, filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<MintV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3MintsCurrentGet
     *
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3MintsCurrentGetRequestConfig(chainId: kotlin.String, filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/mints/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetPools
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return kotlin.collections.List<PoolV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3PoolsCurrentGet(chainId: kotlin.String, filterPoolId: kotlin.String? = null) : kotlin.collections.List<PoolV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3PoolsCurrentGetWithHttpInfo(chainId = chainId, filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PoolV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetPools
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return ApiResponse<kotlin.collections.List<PoolV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3PoolsCurrentGetWithHttpInfo(chainId: kotlin.String, filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<PoolV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3PoolsCurrentGetRequestConfig(chainId = chainId, filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<PoolV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3PoolsCurrentGet
     *
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3PoolsCurrentGetRequestConfig(chainId: kotlin.String, filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/pools/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetPoolsDayData
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return kotlin.collections.List<PoolDayDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3PoolsDayDataCurrentGet(chainId: kotlin.String, filterPoolId: kotlin.String? = null) : kotlin.collections.List<PoolDayDataV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3PoolsDayDataCurrentGetWithHttpInfo(chainId = chainId, filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PoolDayDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetPoolsDayData
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return ApiResponse<kotlin.collections.List<PoolDayDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3PoolsDayDataCurrentGetWithHttpInfo(chainId: kotlin.String, filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<PoolDayDataV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3PoolsDayDataCurrentGetRequestConfig(chainId = chainId, filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<PoolDayDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3PoolsDayDataCurrentGet
     *
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3PoolsDayDataCurrentGetRequestConfig(chainId: kotlin.String, filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/poolsDayData/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetPoolsHourData
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return kotlin.collections.List<PoolHourDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3PoolsHourDataCurrentGet(chainId: kotlin.String, filterPoolId: kotlin.String? = null) : kotlin.collections.List<PoolHourDataV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3PoolsHourDataCurrentGetWithHttpInfo(chainId = chainId, filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PoolHourDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetPoolsHourData
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return ApiResponse<kotlin.collections.List<PoolHourDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3PoolsHourDataCurrentGetWithHttpInfo(chainId: kotlin.String, filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<PoolHourDataV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3PoolsHourDataCurrentGetRequestConfig(chainId = chainId, filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<PoolHourDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3PoolsHourDataCurrentGet
     *
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3PoolsHourDataCurrentGetRequestConfig(chainId: kotlin.String, filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/poolsHourData/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetPositionSnapshot
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return kotlin.collections.List<PositionSnapshotV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3PositionSnapshotsCurrentGet(chainId: kotlin.String, filterPoolId: kotlin.String? = null) : kotlin.collections.List<PositionSnapshotV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetWithHttpInfo(chainId = chainId, filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PositionSnapshotV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetPositionSnapshot
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return ApiResponse<kotlin.collections.List<PositionSnapshotV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetWithHttpInfo(chainId: kotlin.String, filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<PositionSnapshotV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetRequestConfig(chainId = chainId, filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<PositionSnapshotV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3PositionSnapshotsCurrentGet
     *
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetRequestConfig(chainId: kotlin.String, filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/positionSnapshots/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetPositions
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return kotlin.collections.List<PositionV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3PositionsCurrentGet(chainId: kotlin.String, filterPoolId: kotlin.String? = null) : kotlin.collections.List<PositionV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3PositionsCurrentGetWithHttpInfo(chainId = chainId, filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PositionV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetPositions
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return ApiResponse<kotlin.collections.List<PositionV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3PositionsCurrentGetWithHttpInfo(chainId: kotlin.String, filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<PositionV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3PositionsCurrentGetRequestConfig(chainId = chainId, filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<PositionV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3PositionsCurrentGet
     *
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3PositionsCurrentGetRequestConfig(chainId: kotlin.String, filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/positions/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetSwaps
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return kotlin.collections.List<SwapV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3SwapsCurrentGet(chainId: kotlin.String, filterPoolId: kotlin.String? = null) : kotlin.collections.List<SwapV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3SwapsCurrentGetWithHttpInfo(chainId = chainId, filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SwapV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetSwaps
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return ApiResponse<kotlin.collections.List<SwapV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3SwapsCurrentGetWithHttpInfo(chainId: kotlin.String, filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<SwapV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3SwapsCurrentGetRequestConfig(chainId = chainId, filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<SwapV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3SwapsCurrentGet
     *
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3SwapsCurrentGetRequestConfig(chainId: kotlin.String, filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/swaps/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetTicks
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return kotlin.collections.List<TickV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3TicksCurrentGet(chainId: kotlin.String, filterPoolId: kotlin.String? = null) : kotlin.collections.List<TickV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3TicksCurrentGetWithHttpInfo(chainId = chainId, filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TickV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetTicks
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return ApiResponse<kotlin.collections.List<TickV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3TicksCurrentGetWithHttpInfo(chainId: kotlin.String, filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<TickV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3TicksCurrentGetRequestConfig(chainId = chainId, filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<TickV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3TicksCurrentGet
     *
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3TicksCurrentGetRequestConfig(chainId: kotlin.String, filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/ticks/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetTicksDayData
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return kotlin.collections.List<TickDayDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3TicksDayDataCurrentGet(chainId: kotlin.String, filterPoolId: kotlin.String? = null) : kotlin.collections.List<TickDayDataV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3TicksDayDataCurrentGetWithHttpInfo(chainId = chainId, filterPoolId = filterPoolId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TickDayDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetTicksDayData
     * 
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return ApiResponse<kotlin.collections.List<TickDayDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3TicksDayDataCurrentGetWithHttpInfo(chainId: kotlin.String, filterPoolId: kotlin.String?) : ApiResponse<kotlin.collections.List<TickDayDataV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3TicksDayDataCurrentGetRequestConfig(chainId = chainId, filterPoolId = filterPoolId)

        return request<Unit, kotlin.collections.List<TickDayDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3TicksDayDataCurrentGet
     *
     * @param chainId Chain id
     * @param filterPoolId Filter pool id (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3TicksDayDataCurrentGetRequestConfig(chainId: kotlin.String, filterPoolId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterPoolId != null) {
                    put("filter_pool_id", listOf(filterPoolId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/ticksDayData/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetTokens
     * 
     * @param chainId Chain id
     * @param filterTokenId  (optional)
     * @return kotlin.collections.List<TokenV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3TokensCurrentGet(chainId: kotlin.String, filterTokenId: kotlin.String? = null) : kotlin.collections.List<TokenV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3TokensCurrentGetWithHttpInfo(chainId = chainId, filterTokenId = filterTokenId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TokenV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetTokens
     * 
     * @param chainId Chain id
     * @param filterTokenId  (optional)
     * @return ApiResponse<kotlin.collections.List<TokenV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3TokensCurrentGetWithHttpInfo(chainId: kotlin.String, filterTokenId: kotlin.String?) : ApiResponse<kotlin.collections.List<TokenV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3TokensCurrentGetRequestConfig(chainId = chainId, filterTokenId = filterTokenId)

        return request<Unit, kotlin.collections.List<TokenV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3TokensCurrentGet
     *
     * @param chainId Chain id
     * @param filterTokenId  (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3TokensCurrentGetRequestConfig(chainId: kotlin.String, filterTokenId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterTokenId != null) {
                    put("filter_token_id", listOf(filterTokenId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/tokens/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetTokensDayData
     * 
     * @param chainId Chain id
     * @param filterTokenId  (optional)
     * @return kotlin.collections.List<TokenV3DayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3TokensDayDataCurrentGet(chainId: kotlin.String, filterTokenId: kotlin.String? = null) : kotlin.collections.List<TokenV3DayDataDTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3TokensDayDataCurrentGetWithHttpInfo(chainId = chainId, filterTokenId = filterTokenId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TokenV3DayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetTokensDayData
     * 
     * @param chainId Chain id
     * @param filterTokenId  (optional)
     * @return ApiResponse<kotlin.collections.List<TokenV3DayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3TokensDayDataCurrentGetWithHttpInfo(chainId: kotlin.String, filterTokenId: kotlin.String?) : ApiResponse<kotlin.collections.List<TokenV3DayDataDTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3TokensDayDataCurrentGetRequestConfig(chainId = chainId, filterTokenId = filterTokenId)

        return request<Unit, kotlin.collections.List<TokenV3DayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3TokensDayDataCurrentGet
     *
     * @param chainId Chain id
     * @param filterTokenId  (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3TokensDayDataCurrentGetRequestConfig(chainId: kotlin.String, filterTokenId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterTokenId != null) {
                    put("filter_token_id", listOf(filterTokenId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/tokensDayData/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetTokensHourData
     * 
     * @param chainId Chain id
     * @param filterTokenId  (optional)
     * @return kotlin.collections.List<TokenHourDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3TokensHourDataCurrentGet(chainId: kotlin.String, filterTokenId: kotlin.String? = null) : kotlin.collections.List<TokenHourDataV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3TokensHourDataCurrentGetWithHttpInfo(chainId = chainId, filterTokenId = filterTokenId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TokenHourDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetTokensHourData
     * 
     * @param chainId Chain id
     * @param filterTokenId  (optional)
     * @return ApiResponse<kotlin.collections.List<TokenHourDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3TokensHourDataCurrentGetWithHttpInfo(chainId: kotlin.String, filterTokenId: kotlin.String?) : ApiResponse<kotlin.collections.List<TokenHourDataV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3TokensHourDataCurrentGetRequestConfig(chainId = chainId, filterTokenId = filterTokenId)

        return request<Unit, kotlin.collections.List<TokenHourDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3TokensHourDataCurrentGet
     *
     * @param chainId Chain id
     * @param filterTokenId  (optional)
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3TokensHourDataCurrentGetRequestConfig(chainId: kotlin.String, filterTokenId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filterTokenId != null) {
                    put("filter_token_id", listOf(filterTokenId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/tokensHourData/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * GetUniswapDayData
     * 
     * @param chainId Chain id
     * @return kotlin.collections.List<UniswapDayDataV3DTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chainsChainIdDappsUniswapv3UniswapDayDataCurrentGet(chainId: kotlin.String) : kotlin.collections.List<UniswapDayDataV3DTO> {
        val localVarResponse = chainsChainIdDappsUniswapv3UniswapDayDataCurrentGetWithHttpInfo(chainId = chainId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapDayDataV3DTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GetUniswapDayData
     * 
     * @param chainId Chain id
     * @return ApiResponse<kotlin.collections.List<UniswapDayDataV3DTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chainsChainIdDappsUniswapv3UniswapDayDataCurrentGetWithHttpInfo(chainId: kotlin.String) : ApiResponse<kotlin.collections.List<UniswapDayDataV3DTO>?> {
        val localVariableConfig = chainsChainIdDappsUniswapv3UniswapDayDataCurrentGetRequestConfig(chainId = chainId)

        return request<Unit, kotlin.collections.List<UniswapDayDataV3DTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chainsChainIdDappsUniswapv3UniswapDayDataCurrentGet
     *
     * @param chainId Chain id
     * @return RequestConfig
     */
    fun chainsChainIdDappsUniswapv3UniswapDayDataCurrentGetRequestConfig(chainId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/chains/{chain_id}/dapps/uniswapv3/uniswapDayData/current".replace("{"+"chain_id"+"}", encodeURIComponent(chainId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
