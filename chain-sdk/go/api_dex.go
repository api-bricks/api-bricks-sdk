/*
OnChain API

 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

API version: v1
Contact: support@coinapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"
)


// DexApiService DexApi service
type DexApiService service

type ApiDexGetBatchsHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetBatchsHistoricalRequest) StartBlock(startBlock int64) ApiDexGetBatchsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetBatchsHistoricalRequest) EndBlock(endBlock int64) ApiDexGetBatchsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetBatchsHistoricalRequest) StartDate(startDate time.Time) ApiDexGetBatchsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetBatchsHistoricalRequest) EndDate(endDate time.Time) ApiDexGetBatchsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Identifier.
func (r ApiDexGetBatchsHistoricalRequest) Id(id string) ApiDexGetBatchsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetBatchsHistoricalRequest) Execute() ([]DexBatchDTO, *http.Response, error) {
	return r.ApiService.DexGetBatchsHistoricalExecute(r)
}

/*
DexGetBatchsHistorical Batchs (historical) ðŸ”¥

Gets batchs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetBatchsHistoricalRequest
*/
func (a *DexApiService) DexGetBatchsHistorical(ctx context.Context) ApiDexGetBatchsHistoricalRequest {
	return ApiDexGetBatchsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexBatchDTO
func (a *DexApiService) DexGetBatchsHistoricalExecute(r ApiDexGetBatchsHistoricalRequest) ([]DexBatchDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexBatchDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetBatchsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/batchs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetDepositsHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
}

func (r ApiDexGetDepositsHistoricalRequest) StartBlock(startBlock int64) ApiDexGetDepositsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) EndBlock(endBlock int64) ApiDexGetDepositsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) StartDate(startDate time.Time) ApiDexGetDepositsHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) EndDate(endDate time.Time) ApiDexGetDepositsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) Id(id string) ApiDexGetDepositsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) User(user string) ApiDexGetDepositsHistoricalRequest {
	r.user = &user
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) Execute() ([]DexDepositDTO, *http.Response, error) {
	return r.ApiService.DexGetDepositsHistoricalExecute(r)
}

/*
DexGetDepositsHistorical Deposits (historical) ðŸ”¥

Gets deposits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetDepositsHistoricalRequest
*/
func (a *DexApiService) DexGetDepositsHistorical(ctx context.Context) ApiDexGetDepositsHistoricalRequest {
	return ApiDexGetDepositsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexDepositDTO
func (a *DexApiService) DexGetDepositsHistoricalExecute(r ApiDexGetDepositsHistoricalRequest) ([]DexDepositDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexDepositDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetDepositsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/deposits/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetOrdersHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	buyToken *string
	sellToken *string
}

func (r ApiDexGetOrdersHistoricalRequest) StartBlock(startBlock int64) ApiDexGetOrdersHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) EndBlock(endBlock int64) ApiDexGetOrdersHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) StartDate(startDate time.Time) ApiDexGetOrdersHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) EndDate(endDate time.Time) ApiDexGetOrdersHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) Id(id string) ApiDexGetOrdersHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) BuyToken(buyToken string) ApiDexGetOrdersHistoricalRequest {
	r.buyToken = &buyToken
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) SellToken(sellToken string) ApiDexGetOrdersHistoricalRequest {
	r.sellToken = &sellToken
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) Execute() ([]DexOrderDTO, *http.Response, error) {
	return r.ApiService.DexGetOrdersHistoricalExecute(r)
}

/*
DexGetOrdersHistorical Orders (historical) ðŸ”¥

Gets orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetOrdersHistoricalRequest
*/
func (a *DexApiService) DexGetOrdersHistorical(ctx context.Context) ApiDexGetOrdersHistoricalRequest {
	return ApiDexGetOrdersHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexOrderDTO
func (a *DexApiService) DexGetOrdersHistoricalExecute(r ApiDexGetOrdersHistoricalRequest) ([]DexOrderDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexOrderDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetOrdersHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/orders/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.buyToken != nil {
		localVarQueryParams.Add("buy_token", parameterToString(*r.buyToken, ""))
	}
	if r.sellToken != nil {
		localVarQueryParams.Add("sell_token", parameterToString(*r.sellToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetPricesHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

func (r ApiDexGetPricesHistoricalRequest) StartBlock(startBlock int64) ApiDexGetPricesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiDexGetPricesHistoricalRequest) EndBlock(endBlock int64) ApiDexGetPricesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiDexGetPricesHistoricalRequest) StartDate(startDate time.Time) ApiDexGetPricesHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDexGetPricesHistoricalRequest) EndDate(endDate time.Time) ApiDexGetPricesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDexGetPricesHistoricalRequest) Id(id string) ApiDexGetPricesHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetPricesHistoricalRequest) Execute() ([]DexPriceDTO, *http.Response, error) {
	return r.ApiService.DexGetPricesHistoricalExecute(r)
}

/*
DexGetPricesHistorical Prices (historical) ðŸ”¥

Gets prices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetPricesHistoricalRequest
*/
func (a *DexApiService) DexGetPricesHistorical(ctx context.Context) ApiDexGetPricesHistoricalRequest {
	return ApiDexGetPricesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexPriceDTO
func (a *DexApiService) DexGetPricesHistoricalExecute(r ApiDexGetPricesHistoricalRequest) ([]DexPriceDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexPriceDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetPricesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/prices/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetSolutionsHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetSolutionsHistoricalRequest) StartBlock(startBlock int64) ApiDexGetSolutionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetSolutionsHistoricalRequest) EndBlock(endBlock int64) ApiDexGetSolutionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetSolutionsHistoricalRequest) StartDate(startDate time.Time) ApiDexGetSolutionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetSolutionsHistoricalRequest) EndDate(endDate time.Time) ApiDexGetSolutionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiDexGetSolutionsHistoricalRequest) Id(id string) ApiDexGetSolutionsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetSolutionsHistoricalRequest) Execute() ([]DexSolutionDTO, *http.Response, error) {
	return r.ApiService.DexGetSolutionsHistoricalExecute(r)
}

/*
DexGetSolutionsHistorical Solutions (historical) ðŸ”¥

Gets solutions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetSolutionsHistoricalRequest
*/
func (a *DexApiService) DexGetSolutionsHistorical(ctx context.Context) ApiDexGetSolutionsHistoricalRequest {
	return ApiDexGetSolutionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexSolutionDTO
func (a *DexApiService) DexGetSolutionsHistoricalExecute(r ApiDexGetSolutionsHistoricalRequest) ([]DexSolutionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexSolutionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetSolutionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/solutions/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetStatssHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetStatssHistoricalRequest) StartBlock(startBlock int64) ApiDexGetStatssHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetStatssHistoricalRequest) EndBlock(endBlock int64) ApiDexGetStatssHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetStatssHistoricalRequest) StartDate(startDate time.Time) ApiDexGetStatssHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetStatssHistoricalRequest) EndDate(endDate time.Time) ApiDexGetStatssHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiDexGetStatssHistoricalRequest) Id(id string) ApiDexGetStatssHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetStatssHistoricalRequest) Execute() ([]DexStatsDTO, *http.Response, error) {
	return r.ApiService.DexGetStatssHistoricalExecute(r)
}

/*
DexGetStatssHistorical Statss (historical) ðŸ”¥

Gets statss.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetStatssHistoricalRequest
*/
func (a *DexApiService) DexGetStatssHistorical(ctx context.Context) ApiDexGetStatssHistoricalRequest {
	return ApiDexGetStatssHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexStatsDTO
func (a *DexApiService) DexGetStatssHistoricalExecute(r ApiDexGetStatssHistoricalRequest) ([]DexStatsDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexStatsDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetStatssHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/statss/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
	symbol *string
	name *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetTokensHistoricalRequest) StartBlock(startBlock int64) ApiDexGetTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetTokensHistoricalRequest) EndBlock(endBlock int64) ApiDexGetTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetTokensHistoricalRequest) StartDate(startDate time.Time) ApiDexGetTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetTokensHistoricalRequest) EndDate(endDate time.Time) ApiDexGetTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiDexGetTokensHistoricalRequest) Id(id string) ApiDexGetTokensHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiDexGetTokensHistoricalRequest) Address(address string) ApiDexGetTokensHistoricalRequest {
	r.address = &address
	return r
}

// 
func (r ApiDexGetTokensHistoricalRequest) Symbol(symbol string) ApiDexGetTokensHistoricalRequest {
	r.symbol = &symbol
	return r
}

// 
func (r ApiDexGetTokensHistoricalRequest) Name(name string) ApiDexGetTokensHistoricalRequest {
	r.name = &name
	return r
}

func (r ApiDexGetTokensHistoricalRequest) Execute() ([]DexTokenDTO, *http.Response, error) {
	return r.ApiService.DexGetTokensHistoricalExecute(r)
}

/*
DexGetTokensHistorical Tokens (historical) ðŸ”¥

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetTokensHistoricalRequest
*/
func (a *DexApiService) DexGetTokensHistorical(ctx context.Context) ApiDexGetTokensHistoricalRequest {
	return ApiDexGetTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexTokenDTO
func (a *DexApiService) DexGetTokensHistoricalExecute(r ApiDexGetTokensHistoricalRequest) ([]DexTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/tokens/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetTradesHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	buyToken *string
	sellToken *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetTradesHistoricalRequest) StartBlock(startBlock int64) ApiDexGetTradesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetTradesHistoricalRequest) EndBlock(endBlock int64) ApiDexGetTradesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetTradesHistoricalRequest) StartDate(startDate time.Time) ApiDexGetTradesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetTradesHistoricalRequest) EndDate(endDate time.Time) ApiDexGetTradesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiDexGetTradesHistoricalRequest) Id(id string) ApiDexGetTradesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiDexGetTradesHistoricalRequest) BuyToken(buyToken string) ApiDexGetTradesHistoricalRequest {
	r.buyToken = &buyToken
	return r
}

// 
func (r ApiDexGetTradesHistoricalRequest) SellToken(sellToken string) ApiDexGetTradesHistoricalRequest {
	r.sellToken = &sellToken
	return r
}

func (r ApiDexGetTradesHistoricalRequest) Execute() ([]DexTradeDTO, *http.Response, error) {
	return r.ApiService.DexGetTradesHistoricalExecute(r)
}

/*
DexGetTradesHistorical Trades (historical) ðŸ”¥

Gets trades.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetTradesHistoricalRequest
*/
func (a *DexApiService) DexGetTradesHistorical(ctx context.Context) ApiDexGetTradesHistoricalRequest {
	return ApiDexGetTradesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexTradeDTO
func (a *DexApiService) DexGetTradesHistoricalExecute(r ApiDexGetTradesHistoricalRequest) ([]DexTradeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexTradeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetTradesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/trades/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.buyToken != nil {
		localVarQueryParams.Add("buy_token", parameterToString(*r.buyToken, ""))
	}
	if r.sellToken != nil {
		localVarQueryParams.Add("sell_token", parameterToString(*r.sellToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetUsersHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetUsersHistoricalRequest) StartBlock(startBlock int64) ApiDexGetUsersHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetUsersHistoricalRequest) EndBlock(endBlock int64) ApiDexGetUsersHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetUsersHistoricalRequest) StartDate(startDate time.Time) ApiDexGetUsersHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetUsersHistoricalRequest) EndDate(endDate time.Time) ApiDexGetUsersHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiDexGetUsersHistoricalRequest) Id(id string) ApiDexGetUsersHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetUsersHistoricalRequest) Execute() ([]DexUserDTO, *http.Response, error) {
	return r.ApiService.DexGetUsersHistoricalExecute(r)
}

/*
DexGetUsersHistorical Users (historical) ðŸ”¥

Gets users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetUsersHistoricalRequest
*/
func (a *DexApiService) DexGetUsersHistorical(ctx context.Context) ApiDexGetUsersHistoricalRequest {
	return ApiDexGetUsersHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexUserDTO
func (a *DexApiService) DexGetUsersHistoricalExecute(r ApiDexGetUsersHistoricalRequest) ([]DexUserDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexUserDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetUsersHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/users/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetWithdrawRequestsHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) StartBlock(startBlock int64) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) EndBlock(endBlock int64) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) StartDate(startDate time.Time) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) EndDate(endDate time.Time) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) Id(id string) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) User(user string) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.user = &user
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) Execute() ([]DexWithdrawRequestDTO, *http.Response, error) {
	return r.ApiService.DexGetWithdrawRequestsHistoricalExecute(r)
}

/*
DexGetWithdrawRequestsHistorical WithdrawRequests (historical) ðŸ”¥

Gets withdrawrequests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetWithdrawRequestsHistoricalRequest
*/
func (a *DexApiService) DexGetWithdrawRequestsHistorical(ctx context.Context) ApiDexGetWithdrawRequestsHistoricalRequest {
	return ApiDexGetWithdrawRequestsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexWithdrawRequestDTO
func (a *DexApiService) DexGetWithdrawRequestsHistoricalExecute(r ApiDexGetWithdrawRequestsHistoricalRequest) ([]DexWithdrawRequestDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexWithdrawRequestDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetWithdrawRequestsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/withdrawrequests/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetWithdrawsHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
}

func (r ApiDexGetWithdrawsHistoricalRequest) StartBlock(startBlock int64) ApiDexGetWithdrawsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) EndBlock(endBlock int64) ApiDexGetWithdrawsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) StartDate(startDate time.Time) ApiDexGetWithdrawsHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) EndDate(endDate time.Time) ApiDexGetWithdrawsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) Id(id string) ApiDexGetWithdrawsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) User(user string) ApiDexGetWithdrawsHistoricalRequest {
	r.user = &user
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) Execute() ([]DexWithdrawDTO, *http.Response, error) {
	return r.ApiService.DexGetWithdrawsHistoricalExecute(r)
}

/*
DexGetWithdrawsHistorical Withdraws (historical) ðŸ”¥

Gets withdraws.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetWithdrawsHistoricalRequest
*/
func (a *DexApiService) DexGetWithdrawsHistorical(ctx context.Context) ApiDexGetWithdrawsHistoricalRequest {
	return ApiDexGetWithdrawsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexWithdrawDTO
func (a *DexApiService) DexGetWithdrawsHistoricalExecute(r ApiDexGetWithdrawsHistoricalRequest) ([]DexWithdrawDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexWithdrawDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetWithdrawsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/withdraws/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
