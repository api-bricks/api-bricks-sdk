/*
OnChain API

 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

API version: v1
Contact: support@coinapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"
)


// DexApiService DexApi service
type DexApiService service

type ApiDexBatchsCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexBatchsCurrentRequest) Execute() ([]DexBatchDTO, *http.Response, error) {
	return r.ApiService.DexBatchsCurrentExecute(r)
}

/*
DexBatchsCurrent Batchs (current)

Gets batchs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexBatchsCurrentRequest
*/
func (a *DexApiService) DexBatchsCurrent(ctx context.Context) ApiDexBatchsCurrentRequest {
	return ApiDexBatchsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexBatchDTO
func (a *DexApiService) DexBatchsCurrentExecute(r ApiDexBatchsCurrentRequest) ([]DexBatchDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexBatchDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexBatchsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/batchs/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexDepositsCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexDepositsCurrentRequest) Execute() ([]DexDepositDTO, *http.Response, error) {
	return r.ApiService.DexDepositsCurrentExecute(r)
}

/*
DexDepositsCurrent Deposits (current)

Gets deposits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexDepositsCurrentRequest
*/
func (a *DexApiService) DexDepositsCurrent(ctx context.Context) ApiDexDepositsCurrentRequest {
	return ApiDexDepositsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexDepositDTO
func (a *DexApiService) DexDepositsCurrentExecute(r ApiDexDepositsCurrentRequest) ([]DexDepositDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexDepositDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexDepositsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/deposits/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetBatchsHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetBatchsHistoricalRequest) StartBlock(startBlock int64) ApiDexGetBatchsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetBatchsHistoricalRequest) EndBlock(endBlock int64) ApiDexGetBatchsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetBatchsHistoricalRequest) StartDate(startDate time.Time) ApiDexGetBatchsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetBatchsHistoricalRequest) EndDate(endDate time.Time) ApiDexGetBatchsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Identifier.
func (r ApiDexGetBatchsHistoricalRequest) Id(id string) ApiDexGetBatchsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetBatchsHistoricalRequest) Execute() ([]DexBatchDTO, *http.Response, error) {
	return r.ApiService.DexGetBatchsHistoricalExecute(r)
}

/*
DexGetBatchsHistorical Batchs (historical)

Gets batchs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetBatchsHistoricalRequest
*/
func (a *DexApiService) DexGetBatchsHistorical(ctx context.Context) ApiDexGetBatchsHistoricalRequest {
	return ApiDexGetBatchsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexBatchDTO
func (a *DexApiService) DexGetBatchsHistoricalExecute(r ApiDexGetBatchsHistoricalRequest) ([]DexBatchDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexBatchDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetBatchsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/batchs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetDepositsHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
}

func (r ApiDexGetDepositsHistoricalRequest) StartBlock(startBlock int64) ApiDexGetDepositsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) EndBlock(endBlock int64) ApiDexGetDepositsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) StartDate(startDate time.Time) ApiDexGetDepositsHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) EndDate(endDate time.Time) ApiDexGetDepositsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) Id(id string) ApiDexGetDepositsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) User(user string) ApiDexGetDepositsHistoricalRequest {
	r.user = &user
	return r
}

func (r ApiDexGetDepositsHistoricalRequest) Execute() ([]DexDepositDTO, *http.Response, error) {
	return r.ApiService.DexGetDepositsHistoricalExecute(r)
}

/*
DexGetDepositsHistorical Deposits (historical)

Gets deposits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetDepositsHistoricalRequest
*/
func (a *DexApiService) DexGetDepositsHistorical(ctx context.Context) ApiDexGetDepositsHistoricalRequest {
	return ApiDexGetDepositsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexDepositDTO
func (a *DexApiService) DexGetDepositsHistoricalExecute(r ApiDexGetDepositsHistoricalRequest) ([]DexDepositDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexDepositDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetDepositsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/deposits/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetOrdersHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	buyToken *string
	sellToken *string
}

func (r ApiDexGetOrdersHistoricalRequest) StartBlock(startBlock int64) ApiDexGetOrdersHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) EndBlock(endBlock int64) ApiDexGetOrdersHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) StartDate(startDate time.Time) ApiDexGetOrdersHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) EndDate(endDate time.Time) ApiDexGetOrdersHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) Id(id string) ApiDexGetOrdersHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) BuyToken(buyToken string) ApiDexGetOrdersHistoricalRequest {
	r.buyToken = &buyToken
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) SellToken(sellToken string) ApiDexGetOrdersHistoricalRequest {
	r.sellToken = &sellToken
	return r
}

func (r ApiDexGetOrdersHistoricalRequest) Execute() ([]DexOrderDTO, *http.Response, error) {
	return r.ApiService.DexGetOrdersHistoricalExecute(r)
}

/*
DexGetOrdersHistorical Orders (historical)

Gets orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetOrdersHistoricalRequest
*/
func (a *DexApiService) DexGetOrdersHistorical(ctx context.Context) ApiDexGetOrdersHistoricalRequest {
	return ApiDexGetOrdersHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexOrderDTO
func (a *DexApiService) DexGetOrdersHistoricalExecute(r ApiDexGetOrdersHistoricalRequest) ([]DexOrderDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexOrderDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetOrdersHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/orders/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.buyToken != nil {
		localVarQueryParams.Add("buy_token", parameterToString(*r.buyToken, ""))
	}
	if r.sellToken != nil {
		localVarQueryParams.Add("sell_token", parameterToString(*r.sellToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetPricesHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

func (r ApiDexGetPricesHistoricalRequest) StartBlock(startBlock int64) ApiDexGetPricesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiDexGetPricesHistoricalRequest) EndBlock(endBlock int64) ApiDexGetPricesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiDexGetPricesHistoricalRequest) StartDate(startDate time.Time) ApiDexGetPricesHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDexGetPricesHistoricalRequest) EndDate(endDate time.Time) ApiDexGetPricesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDexGetPricesHistoricalRequest) Id(id string) ApiDexGetPricesHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetPricesHistoricalRequest) Execute() ([]DexPriceDTO, *http.Response, error) {
	return r.ApiService.DexGetPricesHistoricalExecute(r)
}

/*
DexGetPricesHistorical Prices (historical)

Gets prices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetPricesHistoricalRequest
*/
func (a *DexApiService) DexGetPricesHistorical(ctx context.Context) ApiDexGetPricesHistoricalRequest {
	return ApiDexGetPricesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexPriceDTO
func (a *DexApiService) DexGetPricesHistoricalExecute(r ApiDexGetPricesHistoricalRequest) ([]DexPriceDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexPriceDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetPricesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/prices/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetSolutionsHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetSolutionsHistoricalRequest) StartBlock(startBlock int64) ApiDexGetSolutionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetSolutionsHistoricalRequest) EndBlock(endBlock int64) ApiDexGetSolutionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetSolutionsHistoricalRequest) StartDate(startDate time.Time) ApiDexGetSolutionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetSolutionsHistoricalRequest) EndDate(endDate time.Time) ApiDexGetSolutionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiDexGetSolutionsHistoricalRequest) Id(id string) ApiDexGetSolutionsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetSolutionsHistoricalRequest) Execute() ([]DexSolutionDTO, *http.Response, error) {
	return r.ApiService.DexGetSolutionsHistoricalExecute(r)
}

/*
DexGetSolutionsHistorical Solutions (historical)

Gets solutions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetSolutionsHistoricalRequest
*/
func (a *DexApiService) DexGetSolutionsHistorical(ctx context.Context) ApiDexGetSolutionsHistoricalRequest {
	return ApiDexGetSolutionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexSolutionDTO
func (a *DexApiService) DexGetSolutionsHistoricalExecute(r ApiDexGetSolutionsHistoricalRequest) ([]DexSolutionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexSolutionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetSolutionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/solutions/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetStatssHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetStatssHistoricalRequest) StartBlock(startBlock int64) ApiDexGetStatssHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetStatssHistoricalRequest) EndBlock(endBlock int64) ApiDexGetStatssHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetStatssHistoricalRequest) StartDate(startDate time.Time) ApiDexGetStatssHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetStatssHistoricalRequest) EndDate(endDate time.Time) ApiDexGetStatssHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiDexGetStatssHistoricalRequest) Id(id string) ApiDexGetStatssHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetStatssHistoricalRequest) Execute() ([]DexStatsDTO, *http.Response, error) {
	return r.ApiService.DexGetStatssHistoricalExecute(r)
}

/*
DexGetStatssHistorical Statss (historical)

Gets statss.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetStatssHistoricalRequest
*/
func (a *DexApiService) DexGetStatssHistorical(ctx context.Context) ApiDexGetStatssHistoricalRequest {
	return ApiDexGetStatssHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexStatsDTO
func (a *DexApiService) DexGetStatssHistoricalExecute(r ApiDexGetStatssHistoricalRequest) ([]DexStatsDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexStatsDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetStatssHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/statss/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
	symbol *string
	name *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetTokensHistoricalRequest) StartBlock(startBlock int64) ApiDexGetTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetTokensHistoricalRequest) EndBlock(endBlock int64) ApiDexGetTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetTokensHistoricalRequest) StartDate(startDate time.Time) ApiDexGetTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetTokensHistoricalRequest) EndDate(endDate time.Time) ApiDexGetTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiDexGetTokensHistoricalRequest) Id(id string) ApiDexGetTokensHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiDexGetTokensHistoricalRequest) Address(address string) ApiDexGetTokensHistoricalRequest {
	r.address = &address
	return r
}

// 
func (r ApiDexGetTokensHistoricalRequest) Symbol(symbol string) ApiDexGetTokensHistoricalRequest {
	r.symbol = &symbol
	return r
}

// 
func (r ApiDexGetTokensHistoricalRequest) Name(name string) ApiDexGetTokensHistoricalRequest {
	r.name = &name
	return r
}

func (r ApiDexGetTokensHistoricalRequest) Execute() ([]DexTokenDTO, *http.Response, error) {
	return r.ApiService.DexGetTokensHistoricalExecute(r)
}

/*
DexGetTokensHistorical Tokens (historical)

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetTokensHistoricalRequest
*/
func (a *DexApiService) DexGetTokensHistorical(ctx context.Context) ApiDexGetTokensHistoricalRequest {
	return ApiDexGetTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexTokenDTO
func (a *DexApiService) DexGetTokensHistoricalExecute(r ApiDexGetTokensHistoricalRequest) ([]DexTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/tokens/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetTradesHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	buyToken *string
	sellToken *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetTradesHistoricalRequest) StartBlock(startBlock int64) ApiDexGetTradesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetTradesHistoricalRequest) EndBlock(endBlock int64) ApiDexGetTradesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetTradesHistoricalRequest) StartDate(startDate time.Time) ApiDexGetTradesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetTradesHistoricalRequest) EndDate(endDate time.Time) ApiDexGetTradesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiDexGetTradesHistoricalRequest) Id(id string) ApiDexGetTradesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiDexGetTradesHistoricalRequest) BuyToken(buyToken string) ApiDexGetTradesHistoricalRequest {
	r.buyToken = &buyToken
	return r
}

// 
func (r ApiDexGetTradesHistoricalRequest) SellToken(sellToken string) ApiDexGetTradesHistoricalRequest {
	r.sellToken = &sellToken
	return r
}

func (r ApiDexGetTradesHistoricalRequest) Execute() ([]DexTradeDTO, *http.Response, error) {
	return r.ApiService.DexGetTradesHistoricalExecute(r)
}

/*
DexGetTradesHistorical Trades (historical)

Gets trades.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetTradesHistoricalRequest
*/
func (a *DexApiService) DexGetTradesHistorical(ctx context.Context) ApiDexGetTradesHistoricalRequest {
	return ApiDexGetTradesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexTradeDTO
func (a *DexApiService) DexGetTradesHistoricalExecute(r ApiDexGetTradesHistoricalRequest) ([]DexTradeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexTradeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetTradesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/trades/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.buyToken != nil {
		localVarQueryParams.Add("buy_token", parameterToString(*r.buyToken, ""))
	}
	if r.sellToken != nil {
		localVarQueryParams.Add("sell_token", parameterToString(*r.sellToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetUsersHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiDexGetUsersHistoricalRequest) StartBlock(startBlock int64) ApiDexGetUsersHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiDexGetUsersHistoricalRequest) EndBlock(endBlock int64) ApiDexGetUsersHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiDexGetUsersHistoricalRequest) StartDate(startDate time.Time) ApiDexGetUsersHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiDexGetUsersHistoricalRequest) EndDate(endDate time.Time) ApiDexGetUsersHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiDexGetUsersHistoricalRequest) Id(id string) ApiDexGetUsersHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetUsersHistoricalRequest) Execute() ([]DexUserDTO, *http.Response, error) {
	return r.ApiService.DexGetUsersHistoricalExecute(r)
}

/*
DexGetUsersHistorical Users (historical)

Gets users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetUsersHistoricalRequest
*/
func (a *DexApiService) DexGetUsersHistorical(ctx context.Context) ApiDexGetUsersHistoricalRequest {
	return ApiDexGetUsersHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexUserDTO
func (a *DexApiService) DexGetUsersHistoricalExecute(r ApiDexGetUsersHistoricalRequest) ([]DexUserDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexUserDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetUsersHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/users/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetWithdrawRequestsHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) StartBlock(startBlock int64) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) EndBlock(endBlock int64) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) StartDate(startDate time.Time) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) EndDate(endDate time.Time) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) Id(id string) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) User(user string) ApiDexGetWithdrawRequestsHistoricalRequest {
	r.user = &user
	return r
}

func (r ApiDexGetWithdrawRequestsHistoricalRequest) Execute() ([]DexWithdrawRequestDTO, *http.Response, error) {
	return r.ApiService.DexGetWithdrawRequestsHistoricalExecute(r)
}

/*
DexGetWithdrawRequestsHistorical WithdrawRequests (historical)

Gets withdrawRequests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetWithdrawRequestsHistoricalRequest
*/
func (a *DexApiService) DexGetWithdrawRequestsHistorical(ctx context.Context) ApiDexGetWithdrawRequestsHistoricalRequest {
	return ApiDexGetWithdrawRequestsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexWithdrawRequestDTO
func (a *DexApiService) DexGetWithdrawRequestsHistoricalExecute(r ApiDexGetWithdrawRequestsHistoricalRequest) ([]DexWithdrawRequestDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexWithdrawRequestDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetWithdrawRequestsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/withdrawRequests/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexGetWithdrawsHistoricalRequest struct {
	ctx context.Context
	ApiService *DexApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
}

func (r ApiDexGetWithdrawsHistoricalRequest) StartBlock(startBlock int64) ApiDexGetWithdrawsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) EndBlock(endBlock int64) ApiDexGetWithdrawsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) StartDate(startDate time.Time) ApiDexGetWithdrawsHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) EndDate(endDate time.Time) ApiDexGetWithdrawsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) Id(id string) ApiDexGetWithdrawsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) User(user string) ApiDexGetWithdrawsHistoricalRequest {
	r.user = &user
	return r
}

func (r ApiDexGetWithdrawsHistoricalRequest) Execute() ([]DexWithdrawDTO, *http.Response, error) {
	return r.ApiService.DexGetWithdrawsHistoricalExecute(r)
}

/*
DexGetWithdrawsHistorical Withdraws (historical)

Gets withdraws.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexGetWithdrawsHistoricalRequest
*/
func (a *DexApiService) DexGetWithdrawsHistorical(ctx context.Context) ApiDexGetWithdrawsHistoricalRequest {
	return ApiDexGetWithdrawsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexWithdrawDTO
func (a *DexApiService) DexGetWithdrawsHistoricalExecute(r ApiDexGetWithdrawsHistoricalRequest) ([]DexWithdrawDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexWithdrawDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexGetWithdrawsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/withdraws/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexOrdersCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexOrdersCurrentRequest) Execute() ([]DexOrderDTO, *http.Response, error) {
	return r.ApiService.DexOrdersCurrentExecute(r)
}

/*
DexOrdersCurrent Orders (current)

Gets orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexOrdersCurrentRequest
*/
func (a *DexApiService) DexOrdersCurrent(ctx context.Context) ApiDexOrdersCurrentRequest {
	return ApiDexOrdersCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexOrderDTO
func (a *DexApiService) DexOrdersCurrentExecute(r ApiDexOrdersCurrentRequest) ([]DexOrderDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexOrderDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexOrdersCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/orders/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexPricesCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexPricesCurrentRequest) Execute() ([]DexPriceDTO, *http.Response, error) {
	return r.ApiService.DexPricesCurrentExecute(r)
}

/*
DexPricesCurrent Prices (current)

Gets prices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexPricesCurrentRequest
*/
func (a *DexApiService) DexPricesCurrent(ctx context.Context) ApiDexPricesCurrentRequest {
	return ApiDexPricesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexPriceDTO
func (a *DexApiService) DexPricesCurrentExecute(r ApiDexPricesCurrentRequest) ([]DexPriceDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexPriceDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexPricesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/prices/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexSolutionsCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexSolutionsCurrentRequest) Execute() ([]DexSolutionDTO, *http.Response, error) {
	return r.ApiService.DexSolutionsCurrentExecute(r)
}

/*
DexSolutionsCurrent Solutions (current)

Gets solutions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexSolutionsCurrentRequest
*/
func (a *DexApiService) DexSolutionsCurrent(ctx context.Context) ApiDexSolutionsCurrentRequest {
	return ApiDexSolutionsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexSolutionDTO
func (a *DexApiService) DexSolutionsCurrentExecute(r ApiDexSolutionsCurrentRequest) ([]DexSolutionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexSolutionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexSolutionsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/solutions/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexStatssCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexStatssCurrentRequest) Execute() ([]DexStatsDTO, *http.Response, error) {
	return r.ApiService.DexStatssCurrentExecute(r)
}

/*
DexStatssCurrent Statss (current)

Gets statss.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexStatssCurrentRequest
*/
func (a *DexApiService) DexStatssCurrent(ctx context.Context) ApiDexStatssCurrentRequest {
	return ApiDexStatssCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexStatsDTO
func (a *DexApiService) DexStatssCurrentExecute(r ApiDexStatssCurrentRequest) ([]DexStatsDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexStatsDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexStatssCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/statss/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexTokensCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexTokensCurrentRequest) Execute() ([]DexTokenDTO, *http.Response, error) {
	return r.ApiService.DexTokensCurrentExecute(r)
}

/*
DexTokensCurrent Tokens (current)

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexTokensCurrentRequest
*/
func (a *DexApiService) DexTokensCurrent(ctx context.Context) ApiDexTokensCurrentRequest {
	return ApiDexTokensCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexTokenDTO
func (a *DexApiService) DexTokensCurrentExecute(r ApiDexTokensCurrentRequest) ([]DexTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexTokensCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/tokens/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexTradesCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexTradesCurrentRequest) Execute() ([]DexTradeDTO, *http.Response, error) {
	return r.ApiService.DexTradesCurrentExecute(r)
}

/*
DexTradesCurrent Trades (current)

Gets trades.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexTradesCurrentRequest
*/
func (a *DexApiService) DexTradesCurrent(ctx context.Context) ApiDexTradesCurrentRequest {
	return ApiDexTradesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexTradeDTO
func (a *DexApiService) DexTradesCurrentExecute(r ApiDexTradesCurrentRequest) ([]DexTradeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexTradeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexTradesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/trades/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexUsersCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexUsersCurrentRequest) Execute() ([]DexUserDTO, *http.Response, error) {
	return r.ApiService.DexUsersCurrentExecute(r)
}

/*
DexUsersCurrent Users (current)

Gets users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexUsersCurrentRequest
*/
func (a *DexApiService) DexUsersCurrent(ctx context.Context) ApiDexUsersCurrentRequest {
	return ApiDexUsersCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexUserDTO
func (a *DexApiService) DexUsersCurrentExecute(r ApiDexUsersCurrentRequest) ([]DexUserDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexUserDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexUsersCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/users/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexWithdrawRequestsCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexWithdrawRequestsCurrentRequest) Execute() ([]DexWithdrawRequestDTO, *http.Response, error) {
	return r.ApiService.DexWithdrawRequestsCurrentExecute(r)
}

/*
DexWithdrawRequestsCurrent WithdrawRequests (current)

Gets withdrawRequests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexWithdrawRequestsCurrentRequest
*/
func (a *DexApiService) DexWithdrawRequestsCurrent(ctx context.Context) ApiDexWithdrawRequestsCurrentRequest {
	return ApiDexWithdrawRequestsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexWithdrawRequestDTO
func (a *DexApiService) DexWithdrawRequestsCurrentExecute(r ApiDexWithdrawRequestsCurrentRequest) ([]DexWithdrawRequestDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexWithdrawRequestDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexWithdrawRequestsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/withdrawRequests/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDexWithdrawsCurrentRequest struct {
	ctx context.Context
	ApiService *DexApiService
}

func (r ApiDexWithdrawsCurrentRequest) Execute() ([]DexWithdrawDTO, *http.Response, error) {
	return r.ApiService.DexWithdrawsCurrentExecute(r)
}

/*
DexWithdrawsCurrent Withdraws (current)

Gets withdraws.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDexWithdrawsCurrentRequest
*/
func (a *DexApiService) DexWithdrawsCurrent(ctx context.Context) ApiDexWithdrawsCurrentRequest {
	return ApiDexWithdrawsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DexWithdrawDTO
func (a *DexApiService) DexWithdrawsCurrentExecute(r ApiDexWithdrawsCurrentRequest) ([]DexWithdrawDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DexWithdrawDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DexApiService.DexWithdrawsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/dex/withdraws/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
