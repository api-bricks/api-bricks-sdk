/*
OnChain API

 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

API version: v1
Contact: support@coinapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// UniswapV3ApiService UniswapV3Api service
type UniswapV3ApiService service

type ApiChainsChainIdDappsUniswapv3BundleCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
}

func (r ApiChainsChainIdDappsUniswapv3BundleCurrentGetRequest) Execute() ([]BundleV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3BundleCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3BundleCurrentGet GetBundles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3BundleCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3BundleCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3BundleCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3BundleCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []BundleV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3BundleCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3BundleCurrentGetRequest) ([]BundleV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BundleV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3BundleCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/bundle/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3BurnsCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterPoolId *string
}

// Filter pool id
func (r ApiChainsChainIdDappsUniswapv3BurnsCurrentGetRequest) FilterPoolId(filterPoolId string) ApiChainsChainIdDappsUniswapv3BurnsCurrentGetRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3BurnsCurrentGetRequest) Execute() ([]BurnV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3BurnsCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3BurnsCurrentGet GetBurns

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3BurnsCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3BurnsCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3BurnsCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3BurnsCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []BurnV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3BurnsCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3BurnsCurrentGetRequest) ([]BurnV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BurnV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3BurnsCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/burns/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3FactoryCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
}

func (r ApiChainsChainIdDappsUniswapv3FactoryCurrentGetRequest) Execute() ([]FactoryV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3FactoryCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3FactoryCurrentGet GetFactory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3FactoryCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3FactoryCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3FactoryCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3FactoryCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []FactoryV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3FactoryCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3FactoryCurrentGetRequest) ([]FactoryV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FactoryV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3FactoryCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/factory/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3MintsCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterPoolId *string
}

// Filter pool id
func (r ApiChainsChainIdDappsUniswapv3MintsCurrentGetRequest) FilterPoolId(filterPoolId string) ApiChainsChainIdDappsUniswapv3MintsCurrentGetRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3MintsCurrentGetRequest) Execute() ([]MintV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3MintsCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3MintsCurrentGet GetMints

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3MintsCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3MintsCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3MintsCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3MintsCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []MintV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3MintsCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3MintsCurrentGetRequest) ([]MintV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MintV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3MintsCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/mints/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3PoolsCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterPoolId *string
}

// Filter pool id
func (r ApiChainsChainIdDappsUniswapv3PoolsCurrentGetRequest) FilterPoolId(filterPoolId string) ApiChainsChainIdDappsUniswapv3PoolsCurrentGetRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3PoolsCurrentGetRequest) Execute() ([]PoolV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3PoolsCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3PoolsCurrentGet GetPools

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3PoolsCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3PoolsCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3PoolsCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3PoolsCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []PoolV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3PoolsCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3PoolsCurrentGetRequest) ([]PoolV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PoolV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3PoolsCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/pools/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3PoolsDayDataCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterPoolId *string
}

// Filter pool id
func (r ApiChainsChainIdDappsUniswapv3PoolsDayDataCurrentGetRequest) FilterPoolId(filterPoolId string) ApiChainsChainIdDappsUniswapv3PoolsDayDataCurrentGetRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3PoolsDayDataCurrentGetRequest) Execute() ([]PoolDayDataV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3PoolsDayDataCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3PoolsDayDataCurrentGet GetPoolsDayData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3PoolsDayDataCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3PoolsDayDataCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3PoolsDayDataCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3PoolsDayDataCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []PoolDayDataV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3PoolsDayDataCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3PoolsDayDataCurrentGetRequest) ([]PoolDayDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PoolDayDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3PoolsDayDataCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/poolsDayData/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3PoolsHourDataCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterPoolId *string
}

// Filter pool id
func (r ApiChainsChainIdDappsUniswapv3PoolsHourDataCurrentGetRequest) FilterPoolId(filterPoolId string) ApiChainsChainIdDappsUniswapv3PoolsHourDataCurrentGetRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3PoolsHourDataCurrentGetRequest) Execute() ([]PoolHourDataV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3PoolsHourDataCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3PoolsHourDataCurrentGet GetPoolsHourData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3PoolsHourDataCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3PoolsHourDataCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3PoolsHourDataCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3PoolsHourDataCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []PoolHourDataV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3PoolsHourDataCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3PoolsHourDataCurrentGetRequest) ([]PoolHourDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PoolHourDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3PoolsHourDataCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/poolsHourData/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterPoolId *string
}

// Filter pool id
func (r ApiChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetRequest) FilterPoolId(filterPoolId string) ApiChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetRequest) Execute() ([]PositionSnapshotV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGet GetPositionSnapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []PositionSnapshotV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGetRequest) ([]PositionSnapshotV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PositionSnapshotV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3PositionSnapshotsCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/positionSnapshots/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3PositionsCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterPoolId *string
}

// Filter pool id
func (r ApiChainsChainIdDappsUniswapv3PositionsCurrentGetRequest) FilterPoolId(filterPoolId string) ApiChainsChainIdDappsUniswapv3PositionsCurrentGetRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3PositionsCurrentGetRequest) Execute() ([]PositionV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3PositionsCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3PositionsCurrentGet GetPositions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3PositionsCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3PositionsCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3PositionsCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3PositionsCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []PositionV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3PositionsCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3PositionsCurrentGetRequest) ([]PositionV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PositionV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3PositionsCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/positions/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3SwapsCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterPoolId *string
}

// Filter pool id
func (r ApiChainsChainIdDappsUniswapv3SwapsCurrentGetRequest) FilterPoolId(filterPoolId string) ApiChainsChainIdDappsUniswapv3SwapsCurrentGetRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3SwapsCurrentGetRequest) Execute() ([]SwapV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3SwapsCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3SwapsCurrentGet GetSwaps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3SwapsCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3SwapsCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3SwapsCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3SwapsCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []SwapV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3SwapsCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3SwapsCurrentGetRequest) ([]SwapV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SwapV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3SwapsCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/swaps/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3TicksCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterPoolId *string
}

// Filter pool id
func (r ApiChainsChainIdDappsUniswapv3TicksCurrentGetRequest) FilterPoolId(filterPoolId string) ApiChainsChainIdDappsUniswapv3TicksCurrentGetRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3TicksCurrentGetRequest) Execute() ([]TickV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3TicksCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3TicksCurrentGet GetTicks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3TicksCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3TicksCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3TicksCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3TicksCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []TickV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3TicksCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3TicksCurrentGetRequest) ([]TickV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TickV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3TicksCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/ticks/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3TicksDayDataCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterPoolId *string
}

// Filter pool id
func (r ApiChainsChainIdDappsUniswapv3TicksDayDataCurrentGetRequest) FilterPoolId(filterPoolId string) ApiChainsChainIdDappsUniswapv3TicksDayDataCurrentGetRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3TicksDayDataCurrentGetRequest) Execute() ([]TickDayDataV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3TicksDayDataCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3TicksDayDataCurrentGet GetTicksDayData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3TicksDayDataCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3TicksDayDataCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3TicksDayDataCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3TicksDayDataCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []TickDayDataV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3TicksDayDataCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3TicksDayDataCurrentGetRequest) ([]TickDayDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TickDayDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3TicksDayDataCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/ticksDayData/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3TokensCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterTokenId *string
}

func (r ApiChainsChainIdDappsUniswapv3TokensCurrentGetRequest) FilterTokenId(filterTokenId string) ApiChainsChainIdDappsUniswapv3TokensCurrentGetRequest {
	r.filterTokenId = &filterTokenId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3TokensCurrentGetRequest) Execute() ([]TokenV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3TokensCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3TokensCurrentGet GetTokens

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3TokensCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3TokensCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3TokensCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3TokensCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []TokenV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3TokensCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3TokensCurrentGetRequest) ([]TokenV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TokenV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3TokensCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/tokens/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTokenId != nil {
		localVarQueryParams.Add("filter_token_id", parameterToString(*r.filterTokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3TokensDayDataCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterTokenId *string
}

func (r ApiChainsChainIdDappsUniswapv3TokensDayDataCurrentGetRequest) FilterTokenId(filterTokenId string) ApiChainsChainIdDappsUniswapv3TokensDayDataCurrentGetRequest {
	r.filterTokenId = &filterTokenId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3TokensDayDataCurrentGetRequest) Execute() ([]TokenV3DayDataDTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3TokensDayDataCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3TokensDayDataCurrentGet GetTokensDayData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3TokensDayDataCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3TokensDayDataCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3TokensDayDataCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3TokensDayDataCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []TokenV3DayDataDTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3TokensDayDataCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3TokensDayDataCurrentGetRequest) ([]TokenV3DayDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TokenV3DayDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3TokensDayDataCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/tokensDayData/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTokenId != nil {
		localVarQueryParams.Add("filter_token_id", parameterToString(*r.filterTokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3TokensHourDataCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
	filterTokenId *string
}

func (r ApiChainsChainIdDappsUniswapv3TokensHourDataCurrentGetRequest) FilterTokenId(filterTokenId string) ApiChainsChainIdDappsUniswapv3TokensHourDataCurrentGetRequest {
	r.filterTokenId = &filterTokenId
	return r
}

func (r ApiChainsChainIdDappsUniswapv3TokensHourDataCurrentGetRequest) Execute() ([]TokenHourDataV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3TokensHourDataCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3TokensHourDataCurrentGet GetTokensHourData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3TokensHourDataCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3TokensHourDataCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3TokensHourDataCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3TokensHourDataCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []TokenHourDataV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3TokensHourDataCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3TokensHourDataCurrentGetRequest) ([]TokenHourDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TokenHourDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3TokensHourDataCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/tokensHourData/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTokenId != nil {
		localVarQueryParams.Add("filter_token_id", parameterToString(*r.filterTokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChainsChainIdDappsUniswapv3UniswapDayDataCurrentGetRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	chainId string
}

func (r ApiChainsChainIdDappsUniswapv3UniswapDayDataCurrentGetRequest) Execute() ([]UniswapDayDataV3DTO, *http.Response, error) {
	return r.ApiService.ChainsChainIdDappsUniswapv3UniswapDayDataCurrentGetExecute(r)
}

/*
ChainsChainIdDappsUniswapv3UniswapDayDataCurrentGet GetUniswapDayData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainId Chain id
 @return ApiChainsChainIdDappsUniswapv3UniswapDayDataCurrentGetRequest
*/
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3UniswapDayDataCurrentGet(ctx context.Context, chainId string) ApiChainsChainIdDappsUniswapv3UniswapDayDataCurrentGetRequest {
	return ApiChainsChainIdDappsUniswapv3UniswapDayDataCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		chainId: chainId,
	}
}

// Execute executes the request
//  @return []UniswapDayDataV3DTO
func (a *UniswapV3ApiService) ChainsChainIdDappsUniswapv3UniswapDayDataCurrentGetExecute(r ApiChainsChainIdDappsUniswapv3UniswapDayDataCurrentGetRequest) ([]UniswapDayDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapDayDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.ChainsChainIdDappsUniswapv3UniswapDayDataCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain_id}/dapps/uniswapv3/uniswapDayData/current"
	localVarPath = strings.Replace(localVarPath, "{"+"chain_id"+"}", url.PathEscape(parameterToString(r.chainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
