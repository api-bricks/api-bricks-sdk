/*
On Chain Dapps - REST API

 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

API version: v1
Contact: support@coinapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
)


// SushiswapApiService SushiswapApi service
type SushiswapApiService service

type ApiSushiswapBundlesCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapBundlesCurrentRequest) Execute() ([]SushiswapBundleDTO, *http.Response, error) {
	return r.ApiService.SushiswapBundlesCurrentExecute(r)
}

/*
SushiswapBundlesCurrent Bundles (current)

Gets bundles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapBundlesCurrentRequest
*/
func (a *SushiswapApiService) SushiswapBundlesCurrent(ctx context.Context) ApiSushiswapBundlesCurrentRequest {
	return ApiSushiswapBundlesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapBundleDTO
func (a *SushiswapApiService) SushiswapBundlesCurrentExecute(r ApiSushiswapBundlesCurrentRequest) ([]SushiswapBundleDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapBundleDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapBundlesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/bundles/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapBurnsCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapBurnsCurrentRequest) Execute() ([]SushiswapBurnDTO, *http.Response, error) {
	return r.ApiService.SushiswapBurnsCurrentExecute(r)
}

/*
SushiswapBurnsCurrent Burns (current)

Gets burns.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapBurnsCurrentRequest
*/
func (a *SushiswapApiService) SushiswapBurnsCurrent(ctx context.Context) ApiSushiswapBurnsCurrentRequest {
	return ApiSushiswapBurnsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapBurnDTO
func (a *SushiswapApiService) SushiswapBurnsCurrentExecute(r ApiSushiswapBurnsCurrentRequest) ([]SushiswapBurnDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapBurnDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapBurnsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/burns/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapDayDataCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapDayDataCurrentRequest) Execute() ([]SushiswapDayDataDTO, *http.Response, error) {
	return r.ApiService.SushiswapDayDataCurrentExecute(r)
}

/*
SushiswapDayDataCurrent DayData (current)

Gets dayData.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapDayDataCurrentRequest
*/
func (a *SushiswapApiService) SushiswapDayDataCurrent(ctx context.Context) ApiSushiswapDayDataCurrentRequest {
	return ApiSushiswapDayDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapDayDataDTO
func (a *SushiswapApiService) SushiswapDayDataCurrentExecute(r ApiSushiswapDayDataCurrentRequest) ([]SushiswapDayDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapDayDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapDayDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/dayData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapFactoriesCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapFactoriesCurrentRequest) Execute() ([]SushiswapFactoryDTO, *http.Response, error) {
	return r.ApiService.SushiswapFactoriesCurrentExecute(r)
}

/*
SushiswapFactoriesCurrent Factories (current)

Gets factories.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapFactoriesCurrentRequest
*/
func (a *SushiswapApiService) SushiswapFactoriesCurrent(ctx context.Context) ApiSushiswapFactoriesCurrentRequest {
	return ApiSushiswapFactoriesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapFactoryDTO
func (a *SushiswapApiService) SushiswapFactoriesCurrentExecute(r ApiSushiswapFactoriesCurrentRequest) ([]SushiswapFactoryDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapFactoryDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapFactoriesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/factories/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetBundlesHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetBundlesHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetBundlesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetBundlesHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetBundlesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetBundlesHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetBundlesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetBundlesHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetBundlesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Hardcoded to &#39;1&#39;.
func (r ApiSushiswapGetBundlesHistoricalRequest) Id(id string) ApiSushiswapGetBundlesHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiSushiswapGetBundlesHistoricalRequest) Execute() ([]SushiswapBundleDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetBundlesHistoricalExecute(r)
}

/*
SushiswapGetBundlesHistorical Bundles (historical)

Gets bundles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetBundlesHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetBundlesHistorical(ctx context.Context) ApiSushiswapGetBundlesHistoricalRequest {
	return ApiSushiswapGetBundlesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapBundleDTO
func (a *SushiswapApiService) SushiswapGetBundlesHistoricalExecute(r ApiSushiswapGetBundlesHistoricalRequest) ([]SushiswapBundleDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapBundleDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetBundlesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/bundles/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetBurnsHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pair *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetBurnsHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetBurnsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetBurnsHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetBurnsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetBurnsHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetBurnsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetBurnsHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetBurnsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Identifier, format: (transaction id):(transaction.burns.length).
func (r ApiSushiswapGetBurnsHistoricalRequest) Id(id string) ApiSushiswapGetBurnsHistoricalRequest {
	r.id = &id
	return r
}

// Reference to pair.
func (r ApiSushiswapGetBurnsHistoricalRequest) Pair(pair string) ApiSushiswapGetBurnsHistoricalRequest {
	r.pair = &pair
	return r
}

func (r ApiSushiswapGetBurnsHistoricalRequest) Execute() ([]SushiswapBurnDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetBurnsHistoricalExecute(r)
}

/*
SushiswapGetBurnsHistorical Burns (historical)

Gets burns.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetBurnsHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetBurnsHistorical(ctx context.Context) ApiSushiswapGetBurnsHistoricalRequest {
	return ApiSushiswapGetBurnsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapBurnDTO
func (a *SushiswapApiService) SushiswapGetBurnsHistoricalExecute(r ApiSushiswapGetBurnsHistoricalRequest) ([]SushiswapBurnDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapBurnDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetBurnsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/burns/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetDayDataHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetDayDataHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetDayDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetDayDataHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetDayDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetDayDataHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetDayDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetDayDataHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetDayDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Unix timestamp for start of day / 86400 giving a unique day index.
func (r ApiSushiswapGetDayDataHistoricalRequest) Id(id string) ApiSushiswapGetDayDataHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiSushiswapGetDayDataHistoricalRequest) Execute() ([]SushiswapDayDataDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetDayDataHistoricalExecute(r)
}

/*
SushiswapGetDayDataHistorical DayData (historical)

Gets dayData.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetDayDataHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetDayDataHistorical(ctx context.Context) ApiSushiswapGetDayDataHistoricalRequest {
	return ApiSushiswapGetDayDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapDayDataDTO
func (a *SushiswapApiService) SushiswapGetDayDataHistoricalExecute(r ApiSushiswapGetDayDataHistoricalRequest) ([]SushiswapDayDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapDayDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetDayDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/dayData/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetFactoriesHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetFactoriesHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetFactoriesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetFactoriesHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetFactoriesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetFactoriesHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetFactoriesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetFactoriesHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetFactoriesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Factory address.
func (r ApiSushiswapGetFactoriesHistoricalRequest) Id(id string) ApiSushiswapGetFactoriesHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiSushiswapGetFactoriesHistoricalRequest) Execute() ([]SushiswapFactoryDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetFactoriesHistoricalExecute(r)
}

/*
SushiswapGetFactoriesHistorical Factories (historical)

Gets factories.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetFactoriesHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetFactoriesHistorical(ctx context.Context) ApiSushiswapGetFactoriesHistoricalRequest {
	return ApiSushiswapGetFactoriesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapFactoryDTO
func (a *SushiswapApiService) SushiswapGetFactoriesHistoricalExecute(r ApiSushiswapGetFactoriesHistoricalRequest) ([]SushiswapFactoryDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapFactoryDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetFactoriesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/factories/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetHourDataHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetHourDataHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetHourDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetHourDataHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetHourDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetHourDataHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetHourDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetHourDataHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetHourDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Start of hour timestamp.
func (r ApiSushiswapGetHourDataHistoricalRequest) Id(id string) ApiSushiswapGetHourDataHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiSushiswapGetHourDataHistoricalRequest) Execute() ([]SushiswapHourDataDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetHourDataHistoricalExecute(r)
}

/*
SushiswapGetHourDataHistorical HourData (historical)

Gets hourData.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetHourDataHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetHourDataHistorical(ctx context.Context) ApiSushiswapGetHourDataHistoricalRequest {
	return ApiSushiswapGetHourDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapHourDataDTO
func (a *SushiswapApiService) SushiswapGetHourDataHistoricalExecute(r ApiSushiswapGetHourDataHistoricalRequest) ([]SushiswapHourDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapHourDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetHourDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/hourData/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
	pair *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Identifier, format: (pair address)-(user address)-(timestamp)
func (r ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest) Id(id string) ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest {
	r.id = &id
	return r
}

// Reference to user.
func (r ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest) User(user string) ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest {
	r.user = &user
	return r
}

// Reference to the pair liquidity is being provided on.
func (r ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest) Pair(pair string) ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest {
	r.pair = &pair
	return r
}

func (r ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest) Execute() ([]SushiswapLiquidityPositionSnapshotDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetLiquidityPositionSnapshotsHistoricalExecute(r)
}

/*
SushiswapGetLiquidityPositionSnapshotsHistorical LiquidityPositionSnapshots (historical)

Gets liquidityPositionSnapshots.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetLiquidityPositionSnapshotsHistorical(ctx context.Context) ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest {
	return ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapLiquidityPositionSnapshotDTO
func (a *SushiswapApiService) SushiswapGetLiquidityPositionSnapshotsHistoricalExecute(r ApiSushiswapGetLiquidityPositionSnapshotsHistoricalRequest) ([]SushiswapLiquidityPositionSnapshotDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapLiquidityPositionSnapshotDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetLiquidityPositionSnapshotsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/liquidityPositionSnapshots/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetLiquidityPositionsHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
	pair *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetLiquidityPositionsHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetLiquidityPositionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetLiquidityPositionsHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetLiquidityPositionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetLiquidityPositionsHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetLiquidityPositionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetLiquidityPositionsHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetLiquidityPositionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Identifier, format: (pair address)-(user address)
func (r ApiSushiswapGetLiquidityPositionsHistoricalRequest) Id(id string) ApiSushiswapGetLiquidityPositionsHistoricalRequest {
	r.id = &id
	return r
}

// User address.
func (r ApiSushiswapGetLiquidityPositionsHistoricalRequest) User(user string) ApiSushiswapGetLiquidityPositionsHistoricalRequest {
	r.user = &user
	return r
}

// Pair address.
func (r ApiSushiswapGetLiquidityPositionsHistoricalRequest) Pair(pair string) ApiSushiswapGetLiquidityPositionsHistoricalRequest {
	r.pair = &pair
	return r
}

func (r ApiSushiswapGetLiquidityPositionsHistoricalRequest) Execute() ([]SushiswapLiquidityPositionDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetLiquidityPositionsHistoricalExecute(r)
}

/*
SushiswapGetLiquidityPositionsHistorical LiquidityPositions (historical)

Gets liquidityPositions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetLiquidityPositionsHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetLiquidityPositionsHistorical(ctx context.Context) ApiSushiswapGetLiquidityPositionsHistoricalRequest {
	return ApiSushiswapGetLiquidityPositionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapLiquidityPositionDTO
func (a *SushiswapApiService) SushiswapGetLiquidityPositionsHistoricalExecute(r ApiSushiswapGetLiquidityPositionsHistoricalRequest) ([]SushiswapLiquidityPositionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapLiquidityPositionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetLiquidityPositionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/liquidityPositions/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetMintsHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pair *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetMintsHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetMintsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetMintsHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetMintsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetMintsHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetMintsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetMintsHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetMintsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Identifier, format: (transaction hash)-(index in the transaction mint array).
func (r ApiSushiswapGetMintsHistoricalRequest) Id(id string) ApiSushiswapGetMintsHistoricalRequest {
	r.id = &id
	return r
}

// Reference to pair.
func (r ApiSushiswapGetMintsHistoricalRequest) Pair(pair string) ApiSushiswapGetMintsHistoricalRequest {
	r.pair = &pair
	return r
}

func (r ApiSushiswapGetMintsHistoricalRequest) Execute() ([]SushiswapMintDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetMintsHistoricalExecute(r)
}

/*
SushiswapGetMintsHistorical Mints (historical)

Gets mints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetMintsHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetMintsHistorical(ctx context.Context) ApiSushiswapGetMintsHistoricalRequest {
	return ApiSushiswapGetMintsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapMintDTO
func (a *SushiswapApiService) SushiswapGetMintsHistoricalExecute(r ApiSushiswapGetMintsHistoricalRequest) ([]SushiswapMintDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapMintDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetMintsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/mints/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetPairDayDataHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pair *string
	token0 *string
	token1 *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetPairDayDataHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetPairDayDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetPairDayDataHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetPairDayDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetPairDayDataHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetPairDayDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetPairDayDataHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetPairDayDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Identifier, format: (pair id)-(day start timestamp).
func (r ApiSushiswapGetPairDayDataHistoricalRequest) Id(id string) ApiSushiswapGetPairDayDataHistoricalRequest {
	r.id = &id
	return r
}

// Reference to pair.
func (r ApiSushiswapGetPairDayDataHistoricalRequest) Pair(pair string) ApiSushiswapGetPairDayDataHistoricalRequest {
	r.pair = &pair
	return r
}

// Reference to token0.
func (r ApiSushiswapGetPairDayDataHistoricalRequest) Token0(token0 string) ApiSushiswapGetPairDayDataHistoricalRequest {
	r.token0 = &token0
	return r
}

// Reference to token1.
func (r ApiSushiswapGetPairDayDataHistoricalRequest) Token1(token1 string) ApiSushiswapGetPairDayDataHistoricalRequest {
	r.token1 = &token1
	return r
}

func (r ApiSushiswapGetPairDayDataHistoricalRequest) Execute() ([]SushiswapPairDayDataDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetPairDayDataHistoricalExecute(r)
}

/*
SushiswapGetPairDayDataHistorical PairDayData (historical)

Gets pairDayData.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetPairDayDataHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetPairDayDataHistorical(ctx context.Context) ApiSushiswapGetPairDayDataHistoricalRequest {
	return ApiSushiswapGetPairDayDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapPairDayDataDTO
func (a *SushiswapApiService) SushiswapGetPairDayDataHistoricalExecute(r ApiSushiswapGetPairDayDataHistoricalRequest) ([]SushiswapPairDayDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapPairDayDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetPairDayDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/pairDayData/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "")
	}
	if r.token0 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_0", r.token0, "")
	}
	if r.token1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_1", r.token1, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetPairHourDataHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pair *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetPairHourDataHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetPairHourDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetPairHourDataHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetPairHourDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetPairHourDataHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetPairHourDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetPairHourDataHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetPairHourDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Identifier, format: (pair id)-(hour start timestamp).
func (r ApiSushiswapGetPairHourDataHistoricalRequest) Id(id string) ApiSushiswapGetPairHourDataHistoricalRequest {
	r.id = &id
	return r
}

// Reference to pair.
func (r ApiSushiswapGetPairHourDataHistoricalRequest) Pair(pair string) ApiSushiswapGetPairHourDataHistoricalRequest {
	r.pair = &pair
	return r
}

func (r ApiSushiswapGetPairHourDataHistoricalRequest) Execute() ([]SushiswapPairHourDataDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetPairHourDataHistoricalExecute(r)
}

/*
SushiswapGetPairHourDataHistorical PairHourData (historical)

Gets pairHourData.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetPairHourDataHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetPairHourDataHistorical(ctx context.Context) ApiSushiswapGetPairHourDataHistoricalRequest {
	return ApiSushiswapGetPairHourDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapPairHourDataDTO
func (a *SushiswapApiService) SushiswapGetPairHourDataHistoricalExecute(r ApiSushiswapGetPairHourDataHistoricalRequest) ([]SushiswapPairHourDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapPairHourDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetPairHourDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/pairHourData/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetPairsHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	name *string
	token0 *string
	token1 *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetPairsHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetPairsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetPairsHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetPairsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetPairsHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetPairsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetPairsHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetPairsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Pair contract address.
func (r ApiSushiswapGetPairsHistoricalRequest) Id(id string) ApiSushiswapGetPairsHistoricalRequest {
	r.id = &id
	return r
}

// Friendly name, format: (token0 name)-(token1 name)
func (r ApiSushiswapGetPairsHistoricalRequest) Name(name string) ApiSushiswapGetPairsHistoricalRequest {
	r.name = &name
	return r
}

// Reference to token0 as stored in pair contract.
func (r ApiSushiswapGetPairsHistoricalRequest) Token0(token0 string) ApiSushiswapGetPairsHistoricalRequest {
	r.token0 = &token0
	return r
}

// Reference to token0 as stored in pair contract.
func (r ApiSushiswapGetPairsHistoricalRequest) Token1(token1 string) ApiSushiswapGetPairsHistoricalRequest {
	r.token1 = &token1
	return r
}

func (r ApiSushiswapGetPairsHistoricalRequest) Execute() ([]SushiswapPairDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetPairsHistoricalExecute(r)
}

/*
SushiswapGetPairsHistorical Pairs (historical)

Gets pairs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetPairsHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetPairsHistorical(ctx context.Context) ApiSushiswapGetPairsHistoricalRequest {
	return ApiSushiswapGetPairsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapPairDTO
func (a *SushiswapApiService) SushiswapGetPairsHistoricalExecute(r ApiSushiswapGetPairsHistoricalRequest) ([]SushiswapPairDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapPairDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetPairsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/pairs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.token0 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_0", r.token0, "")
	}
	if r.token1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_1", r.token1, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetSwapsHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pair *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetSwapsHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetSwapsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetSwapsHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetSwapsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetSwapsHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetSwapsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetSwapsHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetSwapsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Transaction hash plus index in Transaction swap array.
func (r ApiSushiswapGetSwapsHistoricalRequest) Id(id string) ApiSushiswapGetSwapsHistoricalRequest {
	r.id = &id
	return r
}

// Reference to pair.
func (r ApiSushiswapGetSwapsHistoricalRequest) Pair(pair string) ApiSushiswapGetSwapsHistoricalRequest {
	r.pair = &pair
	return r
}

func (r ApiSushiswapGetSwapsHistoricalRequest) Execute() ([]SushiswapSwapDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetSwapsHistoricalExecute(r)
}

/*
SushiswapGetSwapsHistorical Swaps (historical)

Gets swaps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetSwapsHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetSwapsHistorical(ctx context.Context) ApiSushiswapGetSwapsHistoricalRequest {
	return ApiSushiswapGetSwapsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapSwapDTO
func (a *SushiswapApiService) SushiswapGetSwapsHistoricalExecute(r ApiSushiswapGetSwapsHistoricalRequest) ([]SushiswapSwapDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapSwapDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetSwapsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/swaps/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetTokenDayDataHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetTokenDayDataHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetTokenDayDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetTokenDayDataHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetTokenDayDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetTokenDayDataHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetTokenDayDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetTokenDayDataHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetTokenDayDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Identifier, day start timestamp in unix / 86400.
func (r ApiSushiswapGetTokenDayDataHistoricalRequest) Id(id string) ApiSushiswapGetTokenDayDataHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiSushiswapGetTokenDayDataHistoricalRequest) Execute() ([]SushiswapTokenDayDataDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetTokenDayDataHistoricalExecute(r)
}

/*
SushiswapGetTokenDayDataHistorical TokenDayData (historical)

Gets tokenDayData.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetTokenDayDataHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetTokenDayDataHistorical(ctx context.Context) ApiSushiswapGetTokenDayDataHistoricalRequest {
	return ApiSushiswapGetTokenDayDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapTokenDayDataDTO
func (a *SushiswapApiService) SushiswapGetTokenDayDataHistoricalExecute(r ApiSushiswapGetTokenDayDataHistoricalRequest) ([]SushiswapTokenDayDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapTokenDayDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetTokenDayDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/tokenDayData/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	symbol *string
	name *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetTokensHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetTokensHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetTokensHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetTokensHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Token address.
func (r ApiSushiswapGetTokensHistoricalRequest) Id(id string) ApiSushiswapGetTokensHistoricalRequest {
	r.id = &id
	return r
}

// Token symbol.
func (r ApiSushiswapGetTokensHistoricalRequest) Symbol(symbol string) ApiSushiswapGetTokensHistoricalRequest {
	r.symbol = &symbol
	return r
}

// Token name.
func (r ApiSushiswapGetTokensHistoricalRequest) Name(name string) ApiSushiswapGetTokensHistoricalRequest {
	r.name = &name
	return r
}

func (r ApiSushiswapGetTokensHistoricalRequest) Execute() ([]SushiswapTokenDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetTokensHistoricalExecute(r)
}

/*
SushiswapGetTokensHistorical Tokens (historical)

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetTokensHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetTokensHistorical(ctx context.Context) ApiSushiswapGetTokensHistoricalRequest {
	return ApiSushiswapGetTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapTokenDTO
func (a *SushiswapApiService) SushiswapGetTokensHistoricalExecute(r ApiSushiswapGetTokensHistoricalRequest) ([]SushiswapTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/tokens/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetTransactionsHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetTransactionsHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetTransactionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetTransactionsHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetTransactionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetTransactionsHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetTransactionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetTransactionsHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetTransactionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Ethereum transaction hash.
func (r ApiSushiswapGetTransactionsHistoricalRequest) Id(id string) ApiSushiswapGetTransactionsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiSushiswapGetTransactionsHistoricalRequest) Execute() ([]SushiswapTransactionDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetTransactionsHistoricalExecute(r)
}

/*
SushiswapGetTransactionsHistorical Transactions (historical)

Gets transactions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetTransactionsHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetTransactionsHistorical(ctx context.Context) ApiSushiswapGetTransactionsHistoricalRequest {
	return ApiSushiswapGetTransactionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapTransactionDTO
func (a *SushiswapApiService) SushiswapGetTransactionsHistoricalExecute(r ApiSushiswapGetTransactionsHistoricalRequest) ([]SushiswapTransactionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapTransactionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetTransactionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/transactions/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapGetUsersHistoricalRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiSushiswapGetUsersHistoricalRequest) StartBlock(startBlock int64) ApiSushiswapGetUsersHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiSushiswapGetUsersHistoricalRequest) EndBlock(endBlock int64) ApiSushiswapGetUsersHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiSushiswapGetUsersHistoricalRequest) StartDate(startDate time.Time) ApiSushiswapGetUsersHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiSushiswapGetUsersHistoricalRequest) EndDate(endDate time.Time) ApiSushiswapGetUsersHistoricalRequest {
	r.endDate = &endDate
	return r
}

// User address.
func (r ApiSushiswapGetUsersHistoricalRequest) Id(id string) ApiSushiswapGetUsersHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiSushiswapGetUsersHistoricalRequest) Execute() ([]SushiswapUserDTO, *http.Response, error) {
	return r.ApiService.SushiswapGetUsersHistoricalExecute(r)
}

/*
SushiswapGetUsersHistorical Users (historical)

Gets users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapGetUsersHistoricalRequest
*/
func (a *SushiswapApiService) SushiswapGetUsersHistorical(ctx context.Context) ApiSushiswapGetUsersHistoricalRequest {
	return ApiSushiswapGetUsersHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapUserDTO
func (a *SushiswapApiService) SushiswapGetUsersHistoricalExecute(r ApiSushiswapGetUsersHistoricalRequest) ([]SushiswapUserDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapUserDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapGetUsersHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/users/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startBlock", r.startBlock, "")
	}
	if r.endBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endBlock", r.endBlock, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapHourDataCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapHourDataCurrentRequest) Execute() ([]SushiswapHourDataDTO, *http.Response, error) {
	return r.ApiService.SushiswapHourDataCurrentExecute(r)
}

/*
SushiswapHourDataCurrent HourData (current)

Gets hourData.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapHourDataCurrentRequest
*/
func (a *SushiswapApiService) SushiswapHourDataCurrent(ctx context.Context) ApiSushiswapHourDataCurrentRequest {
	return ApiSushiswapHourDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapHourDataDTO
func (a *SushiswapApiService) SushiswapHourDataCurrentExecute(r ApiSushiswapHourDataCurrentRequest) ([]SushiswapHourDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapHourDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapHourDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/hourData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapLiquidityPositionSnapshotsCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapLiquidityPositionSnapshotsCurrentRequest) Execute() ([]SushiswapLiquidityPositionSnapshotDTO, *http.Response, error) {
	return r.ApiService.SushiswapLiquidityPositionSnapshotsCurrentExecute(r)
}

/*
SushiswapLiquidityPositionSnapshotsCurrent LiquidityPositionSnapshots (current)

Gets liquidityPositionSnapshots.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapLiquidityPositionSnapshotsCurrentRequest
*/
func (a *SushiswapApiService) SushiswapLiquidityPositionSnapshotsCurrent(ctx context.Context) ApiSushiswapLiquidityPositionSnapshotsCurrentRequest {
	return ApiSushiswapLiquidityPositionSnapshotsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapLiquidityPositionSnapshotDTO
func (a *SushiswapApiService) SushiswapLiquidityPositionSnapshotsCurrentExecute(r ApiSushiswapLiquidityPositionSnapshotsCurrentRequest) ([]SushiswapLiquidityPositionSnapshotDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapLiquidityPositionSnapshotDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapLiquidityPositionSnapshotsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/liquidityPositionSnapshots/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapLiquidityPositionsCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapLiquidityPositionsCurrentRequest) Execute() ([]SushiswapLiquidityPositionDTO, *http.Response, error) {
	return r.ApiService.SushiswapLiquidityPositionsCurrentExecute(r)
}

/*
SushiswapLiquidityPositionsCurrent LiquidityPositions (current)

Gets liquidityPositions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapLiquidityPositionsCurrentRequest
*/
func (a *SushiswapApiService) SushiswapLiquidityPositionsCurrent(ctx context.Context) ApiSushiswapLiquidityPositionsCurrentRequest {
	return ApiSushiswapLiquidityPositionsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapLiquidityPositionDTO
func (a *SushiswapApiService) SushiswapLiquidityPositionsCurrentExecute(r ApiSushiswapLiquidityPositionsCurrentRequest) ([]SushiswapLiquidityPositionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapLiquidityPositionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapLiquidityPositionsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/liquidityPositions/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapMintsCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapMintsCurrentRequest) Execute() ([]SushiswapMintDTO, *http.Response, error) {
	return r.ApiService.SushiswapMintsCurrentExecute(r)
}

/*
SushiswapMintsCurrent Mints (current)

Gets mints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapMintsCurrentRequest
*/
func (a *SushiswapApiService) SushiswapMintsCurrent(ctx context.Context) ApiSushiswapMintsCurrentRequest {
	return ApiSushiswapMintsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapMintDTO
func (a *SushiswapApiService) SushiswapMintsCurrentExecute(r ApiSushiswapMintsCurrentRequest) ([]SushiswapMintDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapMintDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapMintsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/mints/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapPairDayDataCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapPairDayDataCurrentRequest) Execute() ([]SushiswapPairDayDataDTO, *http.Response, error) {
	return r.ApiService.SushiswapPairDayDataCurrentExecute(r)
}

/*
SushiswapPairDayDataCurrent PairDayData (current)

Gets pairDayData.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapPairDayDataCurrentRequest
*/
func (a *SushiswapApiService) SushiswapPairDayDataCurrent(ctx context.Context) ApiSushiswapPairDayDataCurrentRequest {
	return ApiSushiswapPairDayDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapPairDayDataDTO
func (a *SushiswapApiService) SushiswapPairDayDataCurrentExecute(r ApiSushiswapPairDayDataCurrentRequest) ([]SushiswapPairDayDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapPairDayDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapPairDayDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/pairDayData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapPairHourDataCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapPairHourDataCurrentRequest) Execute() ([]SushiswapPairHourDataDTO, *http.Response, error) {
	return r.ApiService.SushiswapPairHourDataCurrentExecute(r)
}

/*
SushiswapPairHourDataCurrent PairHourData (current)

Gets pairHourData.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapPairHourDataCurrentRequest
*/
func (a *SushiswapApiService) SushiswapPairHourDataCurrent(ctx context.Context) ApiSushiswapPairHourDataCurrentRequest {
	return ApiSushiswapPairHourDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapPairHourDataDTO
func (a *SushiswapApiService) SushiswapPairHourDataCurrentExecute(r ApiSushiswapPairHourDataCurrentRequest) ([]SushiswapPairHourDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapPairHourDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapPairHourDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/pairHourData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapPairsCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	id *string
}

// Pair contract address.
func (r ApiSushiswapPairsCurrentRequest) Id(id string) ApiSushiswapPairsCurrentRequest {
	r.id = &id
	return r
}

func (r ApiSushiswapPairsCurrentRequest) Execute() ([]SushiswapPairDTO, *http.Response, error) {
	return r.ApiService.SushiswapPairsCurrentExecute(r)
}

/*
SushiswapPairsCurrent Pairs (current)

Gets pairs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapPairsCurrentRequest
*/
func (a *SushiswapApiService) SushiswapPairsCurrent(ctx context.Context) ApiSushiswapPairsCurrentRequest {
	return ApiSushiswapPairsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapPairDTO
func (a *SushiswapApiService) SushiswapPairsCurrentExecute(r ApiSushiswapPairsCurrentRequest) ([]SushiswapPairDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapPairDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapPairsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/pairs/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapSwapsCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
	pair *string
}

// Reference to pair.
func (r ApiSushiswapSwapsCurrentRequest) Pair(pair string) ApiSushiswapSwapsCurrentRequest {
	r.pair = &pair
	return r
}

func (r ApiSushiswapSwapsCurrentRequest) Execute() ([]SushiswapSwapDTO, *http.Response, error) {
	return r.ApiService.SushiswapSwapsCurrentExecute(r)
}

/*
SushiswapSwapsCurrent Swaps (current)

Gets swaps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapSwapsCurrentRequest
*/
func (a *SushiswapApiService) SushiswapSwapsCurrent(ctx context.Context) ApiSushiswapSwapsCurrentRequest {
	return ApiSushiswapSwapsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapSwapDTO
func (a *SushiswapApiService) SushiswapSwapsCurrentExecute(r ApiSushiswapSwapsCurrentRequest) ([]SushiswapSwapDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapSwapDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapSwapsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/swaps/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapTokenDayDataCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapTokenDayDataCurrentRequest) Execute() ([]SushiswapTokenDayDataDTO, *http.Response, error) {
	return r.ApiService.SushiswapTokenDayDataCurrentExecute(r)
}

/*
SushiswapTokenDayDataCurrent TokenDayData (current)

Gets tokenDayData.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapTokenDayDataCurrentRequest
*/
func (a *SushiswapApiService) SushiswapTokenDayDataCurrent(ctx context.Context) ApiSushiswapTokenDayDataCurrentRequest {
	return ApiSushiswapTokenDayDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapTokenDayDataDTO
func (a *SushiswapApiService) SushiswapTokenDayDataCurrentExecute(r ApiSushiswapTokenDayDataCurrentRequest) ([]SushiswapTokenDayDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapTokenDayDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapTokenDayDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/tokenDayData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapTokensCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapTokensCurrentRequest) Execute() ([]SushiswapTokenDTO, *http.Response, error) {
	return r.ApiService.SushiswapTokensCurrentExecute(r)
}

/*
SushiswapTokensCurrent Tokens (current)

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapTokensCurrentRequest
*/
func (a *SushiswapApiService) SushiswapTokensCurrent(ctx context.Context) ApiSushiswapTokensCurrentRequest {
	return ApiSushiswapTokensCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapTokenDTO
func (a *SushiswapApiService) SushiswapTokensCurrentExecute(r ApiSushiswapTokensCurrentRequest) ([]SushiswapTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapTokensCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/tokens/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapTransactionsCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapTransactionsCurrentRequest) Execute() ([]SushiswapTransactionDTO, *http.Response, error) {
	return r.ApiService.SushiswapTransactionsCurrentExecute(r)
}

/*
SushiswapTransactionsCurrent Transactions (current)

Gets transactions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapTransactionsCurrentRequest
*/
func (a *SushiswapApiService) SushiswapTransactionsCurrent(ctx context.Context) ApiSushiswapTransactionsCurrentRequest {
	return ApiSushiswapTransactionsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapTransactionDTO
func (a *SushiswapApiService) SushiswapTransactionsCurrentExecute(r ApiSushiswapTransactionsCurrentRequest) ([]SushiswapTransactionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapTransactionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapTransactionsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/transactions/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSushiswapUsersCurrentRequest struct {
	ctx context.Context
	ApiService *SushiswapApiService
}

func (r ApiSushiswapUsersCurrentRequest) Execute() ([]SushiswapUserDTO, *http.Response, error) {
	return r.ApiService.SushiswapUsersCurrentExecute(r)
}

/*
SushiswapUsersCurrent Users (current)

Gets users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSushiswapUsersCurrentRequest
*/
func (a *SushiswapApiService) SushiswapUsersCurrent(ctx context.Context) ApiSushiswapUsersCurrentRequest {
	return ApiSushiswapUsersCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SushiswapUserDTO
func (a *SushiswapApiService) SushiswapUsersCurrentExecute(r ApiSushiswapUsersCurrentRequest) ([]SushiswapUserDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SushiswapUserDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SushiswapApiService.SushiswapUsersCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/sushiswap/users/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
