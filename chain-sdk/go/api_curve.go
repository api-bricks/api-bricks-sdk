/*
OnChain API

 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

API version: v1
Contact: support@coinapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"
)


// CurveApiService CurveApi service
type CurveApiService service

type ApiCurveGetAccountsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetAccountsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAccountsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetAccountsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAccountsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetAccountsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAccountsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetAccountsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAccountsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) Id(id string) ApiCurveGetAccountsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) Address(address string) ApiCurveGetAccountsHistoricalRequest {
	r.address = &address
	return r
}

func (r ApiCurveGetAccountsHistoricalRequest) Execute() ([]CurveAccountDTO, *http.Response, error) {
	return r.ApiService.CurveGetAccountsHistoricalExecute(r)
}

/*
CurveGetAccountsHistorical Accounts (historical) ðŸ”¥

Gets accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAccountsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAccountsHistorical(ctx context.Context) ApiCurveGetAccountsHistoricalRequest {
	return ApiCurveGetAccountsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAccountDTO
func (a *CurveApiService) CurveGetAccountsHistoricalExecute(r ApiCurveGetAccountsHistoricalRequest) ([]CurveAccountDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAccountDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAccountsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/accounts/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAddLiquidityEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) Id(id string) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) Pool(pool string) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) Execute() ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetAddLiquidityEventsHistoricalExecute(r)
}

/*
CurveGetAddLiquidityEventsHistorical AddLiquidityEvents (historical) ðŸ”¥

Gets addliquidityevents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAddLiquidityEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAddLiquidityEventsHistorical(ctx context.Context) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	return ApiCurveGetAddLiquidityEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAddLiquidityEventDTO
func (a *CurveApiService) CurveGetAddLiquidityEventsHistoricalExecute(r ApiCurveGetAddLiquidityEventsHistoricalRequest) ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAddLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAddLiquidityEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/addliquidityevents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAdminFeeChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) Id(id string) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) Pool(pool string) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) Execute() ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetAdminFeeChangeLogsHistoricalExecute(r)
}

/*
CurveGetAdminFeeChangeLogsHistorical AdminFeeChangeLogs (historical) ðŸ”¥

Gets adminfeechangelogs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAdminFeeChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAdminFeeChangeLogsHistorical(ctx context.Context) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	return ApiCurveGetAdminFeeChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAdminFeeChangeLogDTO
func (a *CurveApiService) CurveGetAdminFeeChangeLogsHistoricalExecute(r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAdminFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAdminFeeChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/adminfeechangelogs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) Id(id string) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) Pool(pool string) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) Execute() ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetAmplificationCoeffChangeLogsHistoricalExecute(r)
}

/*
CurveGetAmplificationCoeffChangeLogsHistorical AmplificationCoeffChangeLogs (historical) ðŸ”¥

Gets amplificationcoeffchangelogs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAmplificationCoeffChangeLogsHistorical(ctx context.Context) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	return ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAmplificationCoeffChangeLogDTO
func (a *CurveApiService) CurveGetAmplificationCoeffChangeLogsHistoricalExecute(r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAmplificationCoeffChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAmplificationCoeffChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/amplificationcoeffchangelogs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetCoinsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

func (r ApiCurveGetCoinsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetCoinsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetCoinsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetCoinsHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetCoinsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) Id(id string) ApiCurveGetCoinsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) Pool(pool string) ApiCurveGetCoinsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) Execute() ([]CurveCoinDTO, *http.Response, error) {
	return r.ApiService.CurveGetCoinsHistoricalExecute(r)
}

/*
CurveGetCoinsHistorical Coins (historical) ðŸ”¥

Gets coins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetCoinsHistoricalRequest
*/
func (a *CurveApiService) CurveGetCoinsHistorical(ctx context.Context) ApiCurveGetCoinsHistoricalRequest {
	return ApiCurveGetCoinsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveCoinDTO
func (a *CurveApiService) CurveGetCoinsHistoricalExecute(r ApiCurveGetCoinsHistoricalRequest) ([]CurveCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetCoinsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/coins/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetContractVersionsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetContractVersionsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetContractVersionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetContractVersionsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetContractVersionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetContractVersionsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetContractVersionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetContractVersionsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetContractVersionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetContractVersionsHistoricalRequest) Id(id string) ApiCurveGetContractVersionsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetContractVersionsHistoricalRequest) Address(address string) ApiCurveGetContractVersionsHistoricalRequest {
	r.address = &address
	return r
}

func (r ApiCurveGetContractVersionsHistoricalRequest) Execute() ([]CurveContractVersionDTO, *http.Response, error) {
	return r.ApiService.CurveGetContractVersionsHistoricalExecute(r)
}

/*
CurveGetContractVersionsHistorical ContractVersions (historical) ðŸ”¥

Gets contractversions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetContractVersionsHistoricalRequest
*/
func (a *CurveApiService) CurveGetContractVersionsHistorical(ctx context.Context) ApiCurveGetContractVersionsHistoricalRequest {
	return ApiCurveGetContractVersionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractVersionDTO
func (a *CurveApiService) CurveGetContractVersionsHistoricalExecute(r ApiCurveGetContractVersionsHistoricalRequest) ([]CurveContractVersionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractVersionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetContractVersionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/contractversions/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetContractsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetContractsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetContractsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetContractsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetContractsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetContractsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetContractsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetContractsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetContractsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetContractsHistoricalRequest) Id(id string) ApiCurveGetContractsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetContractsHistoricalRequest) Execute() ([]CurveContractDTO, *http.Response, error) {
	return r.ApiService.CurveGetContractsHistoricalExecute(r)
}

/*
CurveGetContractsHistorical Contracts (historical) ðŸ”¥

Gets contracts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetContractsHistoricalRequest
*/
func (a *CurveApiService) CurveGetContractsHistorical(ctx context.Context) ApiCurveGetContractsHistoricalRequest {
	return ApiCurveGetContractsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractDTO
func (a *CurveApiService) CurveGetContractsHistoricalExecute(r ApiCurveGetContractsHistoricalRequest) ([]CurveContractDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetContractsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/contracts/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetDailyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetDailyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetDailyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetDailyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetDailyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetDailyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetDailyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetDailyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetDailyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) Id(id string) ApiCurveGetDailyVolumesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) Pool(pool string) ApiCurveGetDailyVolumesHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetDailyVolumesHistoricalRequest) Execute() ([]CurveDailyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetDailyVolumesHistoricalExecute(r)
}

/*
CurveGetDailyVolumesHistorical DailyVolumes (historical) ðŸ”¥

Gets dailyvolumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetDailyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetDailyVolumesHistorical(ctx context.Context) ApiCurveGetDailyVolumesHistoricalRequest {
	return ApiCurveGetDailyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveDailyVolumeDTO
func (a *CurveApiService) CurveGetDailyVolumesHistoricalExecute(r ApiCurveGetDailyVolumesHistoricalRequest) ([]CurveDailyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveDailyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetDailyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/dailyvolumes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetExchangesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetExchangesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetExchangesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetExchangesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetExchangesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetExchangesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetExchangesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetExchangesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetExchangesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) Id(id string) ApiCurveGetExchangesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) Pool(pool string) ApiCurveGetExchangesHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetExchangesHistoricalRequest) Execute() ([]CurveExchangeDTO, *http.Response, error) {
	return r.ApiService.CurveGetExchangesHistoricalExecute(r)
}

/*
CurveGetExchangesHistorical Exchanges (historical) ðŸ”¥

Gets exchanges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetExchangesHistoricalRequest
*/
func (a *CurveApiService) CurveGetExchangesHistorical(ctx context.Context) ApiCurveGetExchangesHistoricalRequest {
	return ApiCurveGetExchangesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveExchangeDTO
func (a *CurveApiService) CurveGetExchangesHistoricalExecute(r ApiCurveGetExchangesHistoricalRequest) ([]CurveExchangeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveExchangeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetExchangesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/exchanges/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetFeeChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) Id(id string) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) Pool(pool string) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetFeeChangeLogsHistoricalRequest) Execute() ([]CurveFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetFeeChangeLogsHistoricalExecute(r)
}

/*
CurveGetFeeChangeLogsHistorical FeeChangeLogs (historical) ðŸ”¥

Gets feechangelogs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetFeeChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetFeeChangeLogsHistorical(ctx context.Context) ApiCurveGetFeeChangeLogsHistoricalRequest {
	return ApiCurveGetFeeChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveFeeChangeLogDTO
func (a *CurveApiService) CurveGetFeeChangeLogsHistoricalExecute(r ApiCurveGetFeeChangeLogsHistoricalRequest) ([]CurveFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetFeeChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/feechangelogs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeDepositsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeDepositsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeDepositsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeDepositsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeDepositsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeDepositsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeDepositsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeDepositsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeDepositsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeDepositsHistoricalRequest) Id(id string) ApiCurveGetGaugeDepositsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetGaugeDepositsHistoricalRequest) Execute() ([]CurveGaugeDepositDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeDepositsHistoricalExecute(r)
}

/*
CurveGetGaugeDepositsHistorical GaugeDeposits (historical) ðŸ”¥

Gets gaugedeposits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeDepositsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeDepositsHistorical(ctx context.Context) ApiCurveGetGaugeDepositsHistoricalRequest {
	return ApiCurveGetGaugeDepositsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDepositDTO
func (a *CurveApiService) CurveGetGaugeDepositsHistoricalExecute(r ApiCurveGetGaugeDepositsHistoricalRequest) ([]CurveGaugeDepositDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDepositDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeDepositsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugedeposits/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeLiquiditysHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeLiquiditysHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeLiquiditysHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeLiquiditysHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeLiquiditysHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeLiquiditysHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeLiquiditysHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeLiquiditysHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeLiquiditysHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeLiquiditysHistoricalRequest) Id(id string) ApiCurveGetGaugeLiquiditysHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetGaugeLiquiditysHistoricalRequest) User(user string) ApiCurveGetGaugeLiquiditysHistoricalRequest {
	r.user = &user
	return r
}

func (r ApiCurveGetGaugeLiquiditysHistoricalRequest) Execute() ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeLiquiditysHistoricalExecute(r)
}

/*
CurveGetGaugeLiquiditysHistorical GaugeLiquiditys (historical) ðŸ”¥

Gets gaugeliquiditys.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeLiquiditysHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeLiquiditysHistorical(ctx context.Context) ApiCurveGetGaugeLiquiditysHistoricalRequest {
	return ApiCurveGetGaugeLiquiditysHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeLiquidityDTO
func (a *CurveApiService) CurveGetGaugeLiquiditysHistoricalExecute(r ApiCurveGetGaugeLiquiditysHistoricalRequest) ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeLiquidityDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeLiquiditysHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeliquiditys/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeTotalWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) Id(id string) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) Execute() ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeTotalWeightsHistoricalExecute(r)
}

/*
CurveGetGaugeTotalWeightsHistorical GaugeTotalWeights (historical) ðŸ”¥

Gets gaugetotalweights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeTotalWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeTotalWeightsHistorical(ctx context.Context) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	return ApiCurveGetGaugeTotalWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTotalWeightDTO
func (a *CurveApiService) CurveGetGaugeTotalWeightsHistoricalExecute(r ApiCurveGetGaugeTotalWeightsHistoricalRequest) ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTotalWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeTotalWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugetotalweights/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeTypeWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) Id(id string) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) Execute() ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeTypeWeightsHistoricalExecute(r)
}

/*
CurveGetGaugeTypeWeightsHistorical GaugeTypeWeights (historical) ðŸ”¥

Gets gaugetypeweights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeTypeWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeTypeWeightsHistorical(ctx context.Context) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	return ApiCurveGetGaugeTypeWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeWeightDTO
func (a *CurveApiService) CurveGetGaugeTypeWeightsHistoricalExecute(r ApiCurveGetGaugeTypeWeightsHistoricalRequest) ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeTypeWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugetypeweights/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeTypesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	name *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeTypesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeTypesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeTypesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeTypesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeTypesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeTypesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeTypesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeTypesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeTypesHistoricalRequest) Id(id string) ApiCurveGetGaugeTypesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetGaugeTypesHistoricalRequest) Name(name string) ApiCurveGetGaugeTypesHistoricalRequest {
	r.name = &name
	return r
}

func (r ApiCurveGetGaugeTypesHistoricalRequest) Execute() ([]CurveGaugeTypeDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeTypesHistoricalExecute(r)
}

/*
CurveGetGaugeTypesHistorical GaugeTypes (historical) ðŸ”¥

Gets gaugetypes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeTypesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeTypesHistorical(ctx context.Context) ApiCurveGetGaugeTypesHistoricalRequest {
	return ApiCurveGetGaugeTypesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeDTO
func (a *CurveApiService) CurveGetGaugeTypesHistoricalExecute(r ApiCurveGetGaugeTypesHistoricalRequest) ([]CurveGaugeTypeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeTypesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugetypes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeWeightVotesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) Id(id string) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) User(user string) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.user = &user
	return r
}

func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) Execute() ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeWeightVotesHistoricalExecute(r)
}

/*
CurveGetGaugeWeightVotesHistorical GaugeWeightVotes (historical) ðŸ”¥

Gets gaugeweightvotes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeWeightVotesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeWeightVotesHistorical(ctx context.Context) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	return ApiCurveGetGaugeWeightVotesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightVoteDTO
func (a *CurveApiService) CurveGetGaugeWeightVotesHistoricalExecute(r ApiCurveGetGaugeWeightVotesHistoricalRequest) ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeWeightVotesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeweightvotes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeWeightsHistoricalRequest) Id(id string) ApiCurveGetGaugeWeightsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetGaugeWeightsHistoricalRequest) Execute() ([]CurveGaugeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeWeightsHistoricalExecute(r)
}

/*
CurveGetGaugeWeightsHistorical GaugeWeights (historical) ðŸ”¥

Gets gaugeweights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeWeightsHistorical(ctx context.Context) ApiCurveGetGaugeWeightsHistoricalRequest {
	return ApiCurveGetGaugeWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightDTO
func (a *CurveApiService) CurveGetGaugeWeightsHistoricalExecute(r ApiCurveGetGaugeWeightsHistoricalRequest) ([]CurveGaugeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeweights/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeWithdrawsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) Id(id string) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) Execute() ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeWithdrawsHistoricalExecute(r)
}

/*
CurveGetGaugeWithdrawsHistorical GaugeWithdraws (historical) ðŸ”¥

Gets gaugewithdraws.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeWithdrawsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeWithdrawsHistorical(ctx context.Context) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	return ApiCurveGetGaugeWithdrawsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWithdrawDTO
func (a *CurveApiService) CurveGetGaugeWithdrawsHistoricalExecute(r ApiCurveGetGaugeWithdrawsHistoricalRequest) ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWithdrawDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeWithdrawsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugewithdraws/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) Id(id string) ApiCurveGetGaugesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) Address(address string) ApiCurveGetGaugesHistoricalRequest {
	r.address = &address
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) Pool(pool string) ApiCurveGetGaugesHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetGaugesHistoricalRequest) Execute() ([]CurveGaugeDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesHistoricalExecute(r)
}

/*
CurveGetGaugesHistorical Gauges (historical) ðŸ”¥

Gets gauges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesHistorical(ctx context.Context) ApiCurveGetGaugesHistoricalRequest {
	return ApiCurveGetGaugesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDTO
func (a *CurveApiService) CurveGetGaugesHistoricalExecute(r ApiCurveGetGaugesHistoricalRequest) ([]CurveGaugeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gauges/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetHourlyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetHourlyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetHourlyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetHourlyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetHourlyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) Id(id string) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) Pool(pool string) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetHourlyVolumesHistoricalRequest) Execute() ([]CurveHourlyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetHourlyVolumesHistoricalExecute(r)
}

/*
CurveGetHourlyVolumesHistorical HourlyVolumes (historical) ðŸ”¥

Gets hourlyvolumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetHourlyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetHourlyVolumesHistorical(ctx context.Context) ApiCurveGetHourlyVolumesHistoricalRequest {
	return ApiCurveGetHourlyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveHourlyVolumeDTO
func (a *CurveApiService) CurveGetHourlyVolumesHistoricalExecute(r ApiCurveGetHourlyVolumesHistoricalRequest) ([]CurveHourlyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveHourlyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetHourlyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/hourlyvolumes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetLpTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
	name *string
	symbol *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetLpTokensHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetLpTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetLpTokensHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetLpTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetLpTokensHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetLpTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetLpTokensHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetLpTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) Id(id string) ApiCurveGetLpTokensHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) Address(address string) ApiCurveGetLpTokensHistoricalRequest {
	r.address = &address
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) Name(name string) ApiCurveGetLpTokensHistoricalRequest {
	r.name = &name
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) Symbol(symbol string) ApiCurveGetLpTokensHistoricalRequest {
	r.symbol = &symbol
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) Pool(pool string) ApiCurveGetLpTokensHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetLpTokensHistoricalRequest) Execute() ([]CurveLpTokenDTO, *http.Response, error) {
	return r.ApiService.CurveGetLpTokensHistoricalExecute(r)
}

/*
CurveGetLpTokensHistorical LpTokens (historical) ðŸ”¥

Gets lptokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetLpTokensHistoricalRequest
*/
func (a *CurveApiService) CurveGetLpTokensHistorical(ctx context.Context) ApiCurveGetLpTokensHistoricalRequest {
	return ApiCurveGetLpTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveLpTokenDTO
func (a *CurveApiService) CurveGetLpTokensHistoricalExecute(r ApiCurveGetLpTokensHistoricalRequest) ([]CurveLpTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveLpTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetLpTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/lptokens/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetPoolsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	name *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetPoolsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetPoolsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetPoolsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetPoolsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetPoolsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetPoolsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetPoolsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetPoolsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Pool address.
func (r ApiCurveGetPoolsHistoricalRequest) Id(id string) ApiCurveGetPoolsHistoricalRequest {
	r.id = &id
	return r
}

// Pool&#39;s human-readable name.
func (r ApiCurveGetPoolsHistoricalRequest) Name(name string) ApiCurveGetPoolsHistoricalRequest {
	r.name = &name
	return r
}

func (r ApiCurveGetPoolsHistoricalRequest) Execute() ([]CurvePoolDTO, *http.Response, error) {
	return r.ApiService.CurveGetPoolsHistoricalExecute(r)
}

/*
CurveGetPoolsHistorical Pools (historical) ðŸ”¥

Gets pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetPoolsHistoricalRequest
*/
func (a *CurveApiService) CurveGetPoolsHistorical(ctx context.Context) ApiCurveGetPoolsHistoricalRequest {
	return ApiCurveGetPoolsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurvePoolDTO
func (a *CurveApiService) CurveGetPoolsHistoricalExecute(r ApiCurveGetPoolsHistoricalRequest) ([]CurvePoolDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurvePoolDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetPoolsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/pools/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetProposalVotesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetProposalVotesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetProposalVotesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetProposalVotesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetProposalVotesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetProposalVotesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetProposalVotesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetProposalVotesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetProposalVotesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetProposalVotesHistoricalRequest) Id(id string) ApiCurveGetProposalVotesHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetProposalVotesHistoricalRequest) Execute() ([]CurveProposalVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGetProposalVotesHistoricalExecute(r)
}

/*
CurveGetProposalVotesHistorical ProposalVotes (historical) ðŸ”¥

Gets proposalvotes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetProposalVotesHistoricalRequest
*/
func (a *CurveApiService) CurveGetProposalVotesHistorical(ctx context.Context) ApiCurveGetProposalVotesHistoricalRequest {
	return ApiCurveGetProposalVotesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalVoteDTO
func (a *CurveApiService) CurveGetProposalVotesHistoricalExecute(r ApiCurveGetProposalVotesHistoricalRequest) ([]CurveProposalVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetProposalVotesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/proposalvotes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetProposalsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetProposalsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetProposalsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetProposalsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetProposalsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetProposalsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetProposalsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetProposalsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetProposalsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetProposalsHistoricalRequest) Id(id string) ApiCurveGetProposalsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetProposalsHistoricalRequest) Execute() ([]CurveProposalDTO, *http.Response, error) {
	return r.ApiService.CurveGetProposalsHistoricalExecute(r)
}

/*
CurveGetProposalsHistorical Proposals (historical) ðŸ”¥

Gets proposals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetProposalsHistoricalRequest
*/
func (a *CurveApiService) CurveGetProposalsHistorical(ctx context.Context) ApiCurveGetProposalsHistoricalRequest {
	return ApiCurveGetProposalsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalDTO
func (a *CurveApiService) CurveGetProposalsHistoricalExecute(r ApiCurveGetProposalsHistoricalRequest) ([]CurveProposalDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetProposalsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/proposals/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetRemoveLiquidityEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) Id(id string) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) Pool(pool string) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) Execute() ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetRemoveLiquidityEventsHistoricalExecute(r)
}

/*
CurveGetRemoveLiquidityEventsHistorical RemoveLiquidityEvents (historical) ðŸ”¥

Gets removeliquidityevents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetRemoveLiquidityEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetRemoveLiquidityEventsHistorical(ctx context.Context) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	return ApiCurveGetRemoveLiquidityEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityEventDTO
func (a *CurveApiService) CurveGetRemoveLiquidityEventsHistoricalExecute(r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetRemoveLiquidityEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/removeliquidityevents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) Id(id string) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) Pool(pool string) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) Execute() ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetRemoveLiquidityOneEventsHistoricalExecute(r)
}

/*
CurveGetRemoveLiquidityOneEventsHistorical RemoveLiquidityOneEvents (historical) ðŸ”¥

Gets removeliquidityoneevents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetRemoveLiquidityOneEventsHistorical(ctx context.Context) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	return ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityOneEventDTO
func (a *CurveApiService) CurveGetRemoveLiquidityOneEventsHistoricalExecute(r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityOneEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetRemoveLiquidityOneEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/removeliquidityoneevents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetSystemStatesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetSystemStatesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetSystemStatesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetSystemStatesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetSystemStatesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetSystemStatesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetSystemStatesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetSystemStatesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetSystemStatesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Singleton ID, equals to &#39;current&#39;.
func (r ApiCurveGetSystemStatesHistoricalRequest) Id(id string) ApiCurveGetSystemStatesHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetSystemStatesHistoricalRequest) Execute() ([]CurveSystemStateDTO, *http.Response, error) {
	return r.ApiService.CurveGetSystemStatesHistoricalExecute(r)
}

/*
CurveGetSystemStatesHistorical SystemStates (historical) ðŸ”¥

Gets systemstates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetSystemStatesHistoricalRequest
*/
func (a *CurveApiService) CurveGetSystemStatesHistorical(ctx context.Context) ApiCurveGetSystemStatesHistoricalRequest {
	return ApiCurveGetSystemStatesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveSystemStateDTO
func (a *CurveApiService) CurveGetSystemStatesHistoricalExecute(r ApiCurveGetSystemStatesHistoricalRequest) ([]CurveSystemStateDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveSystemStateDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetSystemStatesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/systemstates/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
	name *string
	symbol *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetTokensHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetTokensHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetTokensHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetTokensHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) Id(id string) ApiCurveGetTokensHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) Address(address string) ApiCurveGetTokensHistoricalRequest {
	r.address = &address
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) Name(name string) ApiCurveGetTokensHistoricalRequest {
	r.name = &name
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) Symbol(symbol string) ApiCurveGetTokensHistoricalRequest {
	r.symbol = &symbol
	return r
}

func (r ApiCurveGetTokensHistoricalRequest) Execute() ([]CurveTokenDTO, *http.Response, error) {
	return r.ApiService.CurveGetTokensHistoricalExecute(r)
}

/*
CurveGetTokensHistorical Tokens (historical) ðŸ”¥

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetTokensHistoricalRequest
*/
func (a *CurveApiService) CurveGetTokensHistorical(ctx context.Context) ApiCurveGetTokensHistoricalRequest {
	return ApiCurveGetTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTokenDTO
func (a *CurveApiService) CurveGetTokensHistoricalExecute(r ApiCurveGetTokensHistoricalRequest) ([]CurveTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/tokens/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetTransferOwnershipEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) Id(id string) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) Pool(pool string) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) Execute() ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetTransferOwnershipEventsHistoricalExecute(r)
}

/*
CurveGetTransferOwnershipEventsHistorical TransferOwnershipEvents (historical) ðŸ”¥

Gets transferownershipevents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetTransferOwnershipEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetTransferOwnershipEventsHistorical(ctx context.Context) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	return ApiCurveGetTransferOwnershipEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTransferOwnershipEventDTO
func (a *CurveApiService) CurveGetTransferOwnershipEventsHistoricalExecute(r ApiCurveGetTransferOwnershipEventsHistoricalRequest) ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTransferOwnershipEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetTransferOwnershipEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/transferownershipevents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetUnderlyingCoinsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) Id(id string) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) Pool(pool string) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) Execute() ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	return r.ApiService.CurveGetUnderlyingCoinsHistoricalExecute(r)
}

/*
CurveGetUnderlyingCoinsHistorical UnderlyingCoins (historical) ðŸ”¥

Gets underlyingcoins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetUnderlyingCoinsHistoricalRequest
*/
func (a *CurveApiService) CurveGetUnderlyingCoinsHistorical(ctx context.Context) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	return ApiCurveGetUnderlyingCoinsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveUnderlyingCoinDTO
func (a *CurveApiService) CurveGetUnderlyingCoinsHistoricalExecute(r ApiCurveGetUnderlyingCoinsHistoricalRequest) ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveUnderlyingCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetUnderlyingCoinsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/underlyingcoins/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetVotingAppsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetVotingAppsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetVotingAppsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetVotingAppsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetVotingAppsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetVotingAppsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetVotingAppsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetVotingAppsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetVotingAppsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// App address.
func (r ApiCurveGetVotingAppsHistoricalRequest) Id(id string) ApiCurveGetVotingAppsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetVotingAppsHistoricalRequest) Address(address string) ApiCurveGetVotingAppsHistoricalRequest {
	r.address = &address
	return r
}

func (r ApiCurveGetVotingAppsHistoricalRequest) Execute() ([]CurveVotingAppDTO, *http.Response, error) {
	return r.ApiService.CurveGetVotingAppsHistoricalExecute(r)
}

/*
CurveGetVotingAppsHistorical VotingApps (historical) ðŸ”¥

Gets votingapps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetVotingAppsHistoricalRequest
*/
func (a *CurveApiService) CurveGetVotingAppsHistorical(ctx context.Context) ApiCurveGetVotingAppsHistoricalRequest {
	return ApiCurveGetVotingAppsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveVotingAppDTO
func (a *CurveApiService) CurveGetVotingAppsHistoricalExecute(r ApiCurveGetVotingAppsHistoricalRequest) ([]CurveVotingAppDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveVotingAppDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetVotingAppsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/votingapps/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetWeeklyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) Id(id string) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) Pool(pool string) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetWeeklyVolumesHistoricalRequest) Execute() ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetWeeklyVolumesHistoricalExecute(r)
}

/*
CurveGetWeeklyVolumesHistorical WeeklyVolumes (historical) ðŸ”¥

Gets weeklyvolumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetWeeklyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetWeeklyVolumesHistorical(ctx context.Context) ApiCurveGetWeeklyVolumesHistoricalRequest {
	return ApiCurveGetWeeklyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveWeeklyVolumeDTO
func (a *CurveApiService) CurveGetWeeklyVolumesHistoricalExecute(r ApiCurveGetWeeklyVolumesHistoricalRequest) ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveWeeklyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetWeeklyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/weeklyvolumes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
