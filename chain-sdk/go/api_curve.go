/*
OnChain API

 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

API version: v1
Contact: support@coinapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"
)


// CurveApiService CurveApi service
type CurveApiService service

type ApiCurveGetAccountsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAccountsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAccountsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAccountsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAccountsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetAccountsHistoricalRequest) Execute() ([]CurveAccountDTO, *http.Response, error) {
	return r.ApiService.CurveGetAccountsHistoricalExecute(r)
}

/*
CurveGetAccountsHistorical Accounts (historical)

Gets accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAccountsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAccountsHistorical(ctx context.Context) ApiCurveGetAccountsHistoricalRequest {
	return ApiCurveGetAccountsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAccountDTO
func (a *CurveApiService) CurveGetAccountsHistoricalExecute(r ApiCurveGetAccountsHistoricalRequest) ([]CurveAccountDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAccountDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAccountsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/accounts/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAddLiquidityEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) PoolId(poolId string) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) Execute() ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetAddLiquidityEventsHistoricalExecute(r)
}

/*
CurveGetAddLiquidityEventsHistorical AddLiquidityEvents (historical)

Gets add liquidity events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAddLiquidityEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAddLiquidityEventsHistorical(ctx context.Context) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	return ApiCurveGetAddLiquidityEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAddLiquidityEventDTO
func (a *CurveApiService) CurveGetAddLiquidityEventsHistoricalExecute(r ApiCurveGetAddLiquidityEventsHistoricalRequest) ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAddLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAddLiquidityEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/addLiquidityEvents/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAdminFeeChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) PoolId(poolId string) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) Execute() ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetAdminFeeChangeLogsHistoricalExecute(r)
}

/*
CurveGetAdminFeeChangeLogsHistorical AdminFeeChangeLogs (historical)

Gets admin fee change logs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAdminFeeChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAdminFeeChangeLogsHistorical(ctx context.Context) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	return ApiCurveGetAdminFeeChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAdminFeeChangeLogDTO
func (a *CurveApiService) CurveGetAdminFeeChangeLogsHistoricalExecute(r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAdminFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAdminFeeChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/adminFeeChangeLogs/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) PoolId(poolId string) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) Execute() ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetAmplificationCoeffChangeLogsHistoricalExecute(r)
}

/*
CurveGetAmplificationCoeffChangeLogsHistorical AmplificationCoeffChangeLogs (historical)

Gets amplification coeff change logs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAmplificationCoeffChangeLogsHistorical(ctx context.Context) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	return ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAmplificationCoeffChangeLogDTO
func (a *CurveApiService) CurveGetAmplificationCoeffChangeLogsHistoricalExecute(r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAmplificationCoeffChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAmplificationCoeffChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/amplificationCoeffChangeLogs/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetCoinsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetCoinsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetCoinsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetCoinsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetCoinsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetCoinsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetCoinsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetCoinsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetCoinsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetCoinsHistoricalRequest) PoolId(poolId string) ApiCurveGetCoinsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) Execute() ([]CurveCoinDTO, *http.Response, error) {
	return r.ApiService.CurveGetCoinsHistoricalExecute(r)
}

/*
CurveGetCoinsHistorical Coins (historical)

Gets coins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetCoinsHistoricalRequest
*/
func (a *CurveApiService) CurveGetCoinsHistorical(ctx context.Context) ApiCurveGetCoinsHistoricalRequest {
	return ApiCurveGetCoinsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveCoinDTO
func (a *CurveApiService) CurveGetCoinsHistoricalExecute(r ApiCurveGetCoinsHistoricalRequest) ([]CurveCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetCoinsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/coins/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetContractsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetContractsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetContractsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetContractsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetContractsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetContractsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetContractsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetContractsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetContractsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetContractsHistoricalRequest) PoolId(poolId string) ApiCurveGetContractsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetContractsHistoricalRequest) Execute() ([]CurveContractDTO, *http.Response, error) {
	return r.ApiService.CurveGetContractsHistoricalExecute(r)
}

/*
CurveGetContractsHistorical Contracts (historical)

Gets contracts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetContractsHistoricalRequest
*/
func (a *CurveApiService) CurveGetContractsHistorical(ctx context.Context) ApiCurveGetContractsHistoricalRequest {
	return ApiCurveGetContractsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractDTO
func (a *CurveApiService) CurveGetContractsHistoricalExecute(r ApiCurveGetContractsHistoricalRequest) ([]CurveContractDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetContractsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/contracts/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetContractsVersionsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetContractsVersionsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetContractsVersionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetContractsVersionsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetContractsVersionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetContractsVersionsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetContractsVersionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetContractsVersionsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetContractsVersionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetContractsVersionsHistoricalRequest) PoolId(poolId string) ApiCurveGetContractsVersionsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetContractsVersionsHistoricalRequest) Execute() ([]CurveContractVersionDTO, *http.Response, error) {
	return r.ApiService.CurveGetContractsVersionsHistoricalExecute(r)
}

/*
CurveGetContractsVersionsHistorical ContractsVersions (historical)

Gets contracts versions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetContractsVersionsHistoricalRequest
*/
func (a *CurveApiService) CurveGetContractsVersionsHistorical(ctx context.Context) ApiCurveGetContractsVersionsHistoricalRequest {
	return ApiCurveGetContractsVersionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractVersionDTO
func (a *CurveApiService) CurveGetContractsVersionsHistoricalExecute(r ApiCurveGetContractsVersionsHistoricalRequest) ([]CurveContractVersionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractVersionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetContractsVersionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/contractsVersions/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetDailyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetDailyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetDailyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetDailyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetDailyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) PoolId(poolId string) ApiCurveGetDailyVolumesHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetDailyVolumesHistoricalRequest) Execute() ([]CurveDailyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetDailyVolumesHistoricalExecute(r)
}

/*
CurveGetDailyVolumesHistorical DailyVolumes (historical)

Gets daily volumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetDailyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetDailyVolumesHistorical(ctx context.Context) ApiCurveGetDailyVolumesHistoricalRequest {
	return ApiCurveGetDailyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveDailyVolumeDTO
func (a *CurveApiService) CurveGetDailyVolumesHistoricalExecute(r ApiCurveGetDailyVolumesHistoricalRequest) ([]CurveDailyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveDailyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetDailyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/dailyVolumes/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetExchangesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetExchangesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetExchangesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetExchangesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetExchangesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) PoolId(poolId string) ApiCurveGetExchangesHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetExchangesHistoricalRequest) Execute() ([]CurveExchangeDTO, *http.Response, error) {
	return r.ApiService.CurveGetExchangesHistoricalExecute(r)
}

/*
CurveGetExchangesHistorical Exchanges (historical) 🔥

Gets exchanges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetExchangesHistoricalRequest
*/
func (a *CurveApiService) CurveGetExchangesHistorical(ctx context.Context) ApiCurveGetExchangesHistoricalRequest {
	return ApiCurveGetExchangesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveExchangeDTO
func (a *CurveApiService) CurveGetExchangesHistoricalExecute(r ApiCurveGetExchangesHistoricalRequest) ([]CurveExchangeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveExchangeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetExchangesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/exchanges/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetFeeChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) PoolId(poolId string) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetFeeChangeLogsHistoricalRequest) Execute() ([]CurveFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetFeeChangeLogsHistoricalExecute(r)
}

/*
CurveGetFeeChangeLogsHistorical FeeChangeLogs (historical)

Gets fee change logs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetFeeChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetFeeChangeLogsHistorical(ctx context.Context) ApiCurveGetFeeChangeLogsHistoricalRequest {
	return ApiCurveGetFeeChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveFeeChangeLogDTO
func (a *CurveApiService) CurveGetFeeChangeLogsHistoricalExecute(r ApiCurveGetFeeChangeLogsHistoricalRequest) ([]CurveFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetFeeChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/feeChangeLogs/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesDepositsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesDepositsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesDepositsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesDepositsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesDepositsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesDepositsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesDepositsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesDepositsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesDepositsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesDepositsHistoricalRequest) Execute() ([]CurveGaugeDepositDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesDepositsHistoricalExecute(r)
}

/*
CurveGetGaugesDepositsHistorical GaugesDeposits (historical)

Gets gauges deposits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesDepositsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesDepositsHistorical(ctx context.Context) ApiCurveGetGaugesDepositsHistoricalRequest {
	return ApiCurveGetGaugesDepositsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDepositDTO
func (a *CurveApiService) CurveGetGaugesDepositsHistoricalExecute(r ApiCurveGetGaugesDepositsHistoricalRequest) ([]CurveGaugeDepositDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDepositDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesDepositsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesDeposits/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugesHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugesHistoricalRequest) Execute() ([]CurveGaugeDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesHistoricalExecute(r)
}

/*
CurveGetGaugesHistorical Gauges (historical)

Gets gauges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesHistorical(ctx context.Context) ApiCurveGetGaugesHistoricalRequest {
	return ApiCurveGetGaugesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDTO
func (a *CurveApiService) CurveGetGaugesHistoricalExecute(r ApiCurveGetGaugesHistoricalRequest) ([]CurveGaugeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gauges/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesLiquidityHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesLiquidityHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesLiquidityHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesLiquidityHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesLiquidityHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesLiquidityHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesLiquidityHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesLiquidityHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesLiquidityHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesLiquidityHistoricalRequest) Execute() ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesLiquidityHistoricalExecute(r)
}

/*
CurveGetGaugesLiquidityHistorical GaugesLiquidity (historical)

Gets gauges liquidity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesLiquidityHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesLiquidityHistorical(ctx context.Context) ApiCurveGetGaugesLiquidityHistoricalRequest {
	return ApiCurveGetGaugesLiquidityHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeLiquidityDTO
func (a *CurveApiService) CurveGetGaugesLiquidityHistoricalExecute(r ApiCurveGetGaugesLiquidityHistoricalRequest) ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeLiquidityDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesLiquidityHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesLiquidity/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesTotalWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesTotalWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesTotalWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesTotalWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesTotalWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesTotalWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesTotalWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesTotalWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesTotalWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesTotalWeightsHistoricalRequest) Execute() ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesTotalWeightsHistoricalExecute(r)
}

/*
CurveGetGaugesTotalWeightsHistorical GaugesTotalWeights (historical)

Gets gauges total weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesTotalWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesTotalWeightsHistorical(ctx context.Context) ApiCurveGetGaugesTotalWeightsHistoricalRequest {
	return ApiCurveGetGaugesTotalWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTotalWeightDTO
func (a *CurveApiService) CurveGetGaugesTotalWeightsHistoricalExecute(r ApiCurveGetGaugesTotalWeightsHistoricalRequest) ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTotalWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesTotalWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesTotalWeights/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesTypesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesTypesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesTypesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesTypesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesTypesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesTypesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesTypesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesTypesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesTypesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesTypesHistoricalRequest) Execute() ([]CurveGaugeTypeDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesTypesHistoricalExecute(r)
}

/*
CurveGetGaugesTypesHistorical GaugesTypes (historical)

Gets gauges types.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesTypesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesTypesHistorical(ctx context.Context) ApiCurveGetGaugesTypesHistoricalRequest {
	return ApiCurveGetGaugesTypesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeDTO
func (a *CurveApiService) CurveGetGaugesTypesHistoricalExecute(r ApiCurveGetGaugesTypesHistoricalRequest) ([]CurveGaugeTypeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesTypesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesTypes/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesTypesWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesTypesWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesTypesWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesTypesWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesTypesWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesTypesWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesTypesWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesTypesWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesTypesWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesTypesWeightsHistoricalRequest) Execute() ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesTypesWeightsHistoricalExecute(r)
}

/*
CurveGetGaugesTypesWeightsHistorical GaugesTypesWeights (historical)

Gets gauges types weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesTypesWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesTypesWeightsHistorical(ctx context.Context) ApiCurveGetGaugesTypesWeightsHistoricalRequest {
	return ApiCurveGetGaugesTypesWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeWeightDTO
func (a *CurveApiService) CurveGetGaugesTypesWeightsHistoricalExecute(r ApiCurveGetGaugesTypesWeightsHistoricalRequest) ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesTypesWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesTypesWeights/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesWeightsHistoricalRequest) Execute() ([]CurveGaugeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesWeightsHistoricalExecute(r)
}

/*
CurveGetGaugesWeightsHistorical GaugesWeights (historical)

Gets gauges weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesWeightsHistorical(ctx context.Context) ApiCurveGetGaugesWeightsHistoricalRequest {
	return ApiCurveGetGaugesWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightDTO
func (a *CurveApiService) CurveGetGaugesWeightsHistoricalExecute(r ApiCurveGetGaugesWeightsHistoricalRequest) ([]CurveGaugeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesWeights/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesWeightsVotesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesWeightsVotesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesWeightsVotesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesWeightsVotesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesWeightsVotesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesWeightsVotesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesWeightsVotesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesWeightsVotesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesWeightsVotesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesWeightsVotesHistoricalRequest) Execute() ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesWeightsVotesHistoricalExecute(r)
}

/*
CurveGetGaugesWeightsVotesHistorical GaugesWeightsVotes (historical)

Gets gauges weights votes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesWeightsVotesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesWeightsVotesHistorical(ctx context.Context) ApiCurveGetGaugesWeightsVotesHistoricalRequest {
	return ApiCurveGetGaugesWeightsVotesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightVoteDTO
func (a *CurveApiService) CurveGetGaugesWeightsVotesHistoricalExecute(r ApiCurveGetGaugesWeightsVotesHistoricalRequest) ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesWeightsVotesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesWeightsVotes/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesWithdrawHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesWithdrawHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesWithdrawHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesWithdrawHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesWithdrawHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesWithdrawHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesWithdrawHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesWithdrawHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesWithdrawHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesWithdrawHistoricalRequest) Execute() ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesWithdrawHistoricalExecute(r)
}

/*
CurveGetGaugesWithdrawHistorical GaugesWithdraw (historical)

Gets gauges withdraws.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesWithdrawHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesWithdrawHistorical(ctx context.Context) ApiCurveGetGaugesWithdrawHistoricalRequest {
	return ApiCurveGetGaugesWithdrawHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWithdrawDTO
func (a *CurveApiService) CurveGetGaugesWithdrawHistoricalExecute(r ApiCurveGetGaugesWithdrawHistoricalRequest) ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWithdrawDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesWithdrawHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesWithdraws/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetHourlyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) PoolId(poolId string) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetHourlyVolumesHistoricalRequest) Execute() ([]CurveHourlyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetHourlyVolumesHistoricalExecute(r)
}

/*
CurveGetHourlyVolumesHistorical HourlyVolumes (historical)

Gets hourly volumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetHourlyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetHourlyVolumesHistorical(ctx context.Context) ApiCurveGetHourlyVolumesHistoricalRequest {
	return ApiCurveGetHourlyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveHourlyVolumeDTO
func (a *CurveApiService) CurveGetHourlyVolumesHistoricalExecute(r ApiCurveGetHourlyVolumesHistoricalRequest) ([]CurveHourlyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveHourlyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetHourlyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/hourlyVolumes/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetLpTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetLpTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetLpTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetLpTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetLpTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) PoolId(poolId string) ApiCurveGetLpTokensHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetLpTokensHistoricalRequest) Execute() ([]CurveLpTokenDTO, *http.Response, error) {
	return r.ApiService.CurveGetLpTokensHistoricalExecute(r)
}

/*
CurveGetLpTokensHistorical LpTokens (historical)

Gets lp tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetLpTokensHistoricalRequest
*/
func (a *CurveApiService) CurveGetLpTokensHistorical(ctx context.Context) ApiCurveGetLpTokensHistoricalRequest {
	return ApiCurveGetLpTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveLpTokenDTO
func (a *CurveApiService) CurveGetLpTokensHistoricalExecute(r ApiCurveGetLpTokensHistoricalRequest) ([]CurveLpTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveLpTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetLpTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/lpTokens/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetPoolsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetPoolsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetPoolsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetPoolsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetPoolsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetPoolsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetPoolsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetPoolsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetPoolsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetPoolsHistoricalRequest) PoolId(poolId string) ApiCurveGetPoolsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetPoolsHistoricalRequest) Execute() ([]CurvePoolDTO, *http.Response, error) {
	return r.ApiService.CurveGetPoolsHistoricalExecute(r)
}

/*
CurveGetPoolsHistorical Pools (historical) 🔥

Gets pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetPoolsHistoricalRequest
*/
func (a *CurveApiService) CurveGetPoolsHistorical(ctx context.Context) ApiCurveGetPoolsHistoricalRequest {
	return ApiCurveGetPoolsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurvePoolDTO
func (a *CurveApiService) CurveGetPoolsHistoricalExecute(r ApiCurveGetPoolsHistoricalRequest) ([]CurvePoolDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurvePoolDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetPoolsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/pools/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetProposalsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetProposalsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetProposalsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetProposalsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetProposalsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetProposalsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetProposalsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetProposalsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetProposalsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetProposalsHistoricalRequest) Execute() ([]CurveProposalDTO, *http.Response, error) {
	return r.ApiService.CurveGetProposalsHistoricalExecute(r)
}

/*
CurveGetProposalsHistorical Proposals (historical)

Gets proposals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetProposalsHistoricalRequest
*/
func (a *CurveApiService) CurveGetProposalsHistorical(ctx context.Context) ApiCurveGetProposalsHistoricalRequest {
	return ApiCurveGetProposalsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalDTO
func (a *CurveApiService) CurveGetProposalsHistoricalExecute(r ApiCurveGetProposalsHistoricalRequest) ([]CurveProposalDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetProposalsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/proposals/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetProposalsVotesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetProposalsVotesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetProposalsVotesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetProposalsVotesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetProposalsVotesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetProposalsVotesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetProposalsVotesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetProposalsVotesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetProposalsVotesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetProposalsVotesHistoricalRequest) Execute() ([]CurveProposalVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGetProposalsVotesHistoricalExecute(r)
}

/*
CurveGetProposalsVotesHistorical ProposalsVotes (historical)

Gets proposals votes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetProposalsVotesHistoricalRequest
*/
func (a *CurveApiService) CurveGetProposalsVotesHistorical(ctx context.Context) ApiCurveGetProposalsVotesHistoricalRequest {
	return ApiCurveGetProposalsVotesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalVoteDTO
func (a *CurveApiService) CurveGetProposalsVotesHistoricalExecute(r ApiCurveGetProposalsVotesHistoricalRequest) ([]CurveProposalVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetProposalsVotesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/proposalsVotes/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetRemoveLiquidityEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) PoolId(poolId string) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) Execute() ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetRemoveLiquidityEventsHistoricalExecute(r)
}

/*
CurveGetRemoveLiquidityEventsHistorical RemoveLiquidityEvents (historical)

Gets remove liquidity events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetRemoveLiquidityEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetRemoveLiquidityEventsHistorical(ctx context.Context) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	return ApiCurveGetRemoveLiquidityEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityEventDTO
func (a *CurveApiService) CurveGetRemoveLiquidityEventsHistoricalExecute(r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetRemoveLiquidityEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/removeLiquidityEvents/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) PoolId(poolId string) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) Execute() ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetRemoveLiquidityOneEventsHistoricalExecute(r)
}

/*
CurveGetRemoveLiquidityOneEventsHistorical RemoveLiquidityOneEvents (historical)

Gets remove liquidity one events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetRemoveLiquidityOneEventsHistorical(ctx context.Context) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	return ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityOneEventDTO
func (a *CurveApiService) CurveGetRemoveLiquidityOneEventsHistoricalExecute(r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityOneEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetRemoveLiquidityOneEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/removeLiquidityOneEvents/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetSystemStatesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetSystemStatesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetSystemStatesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetSystemStatesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetSystemStatesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetSystemStatesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetSystemStatesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetSystemStatesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetSystemStatesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetSystemStatesHistoricalRequest) Execute() ([]CurveSystemStateDTO, *http.Response, error) {
	return r.ApiService.CurveGetSystemStatesHistoricalExecute(r)
}

/*
CurveGetSystemStatesHistorical SystemStates (historical)

Gets system states.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetSystemStatesHistoricalRequest
*/
func (a *CurveApiService) CurveGetSystemStatesHistorical(ctx context.Context) ApiCurveGetSystemStatesHistoricalRequest {
	return ApiCurveGetSystemStatesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveSystemStateDTO
func (a *CurveApiService) CurveGetSystemStatesHistoricalExecute(r ApiCurveGetSystemStatesHistoricalRequest) ([]CurveSystemStateDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveSystemStateDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetSystemStatesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/systemStates/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	tokenId *string
}

// 
func (r ApiCurveGetTokensHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) TokenId(tokenId string) ApiCurveGetTokensHistoricalRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiCurveGetTokensHistoricalRequest) Execute() ([]CurveTokenDTO, *http.Response, error) {
	return r.ApiService.CurveGetTokensHistoricalExecute(r)
}

/*
CurveGetTokensHistorical Tokens (historical) 🔥

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetTokensHistoricalRequest
*/
func (a *CurveApiService) CurveGetTokensHistorical(ctx context.Context) ApiCurveGetTokensHistoricalRequest {
	return ApiCurveGetTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTokenDTO
func (a *CurveApiService) CurveGetTokensHistoricalExecute(r ApiCurveGetTokensHistoricalRequest) ([]CurveTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/tokens/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetTransferOwnershipEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) PoolId(poolId string) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) Execute() ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetTransferOwnershipEventsHistoricalExecute(r)
}

/*
CurveGetTransferOwnershipEventsHistorical TransferOwnershipEvents (historical)

Gets transfer ownership events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetTransferOwnershipEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetTransferOwnershipEventsHistorical(ctx context.Context) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	return ApiCurveGetTransferOwnershipEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTransferOwnershipEventDTO
func (a *CurveApiService) CurveGetTransferOwnershipEventsHistoricalExecute(r ApiCurveGetTransferOwnershipEventsHistoricalRequest) ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTransferOwnershipEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetTransferOwnershipEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/transferOwnershipEvents/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetUnderlyingCoinsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) PoolId(poolId string) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) Execute() ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	return r.ApiService.CurveGetUnderlyingCoinsHistoricalExecute(r)
}

/*
CurveGetUnderlyingCoinsHistorical UnderlyingCoins (historical)

Gets underlying coins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetUnderlyingCoinsHistoricalRequest
*/
func (a *CurveApiService) CurveGetUnderlyingCoinsHistorical(ctx context.Context) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	return ApiCurveGetUnderlyingCoinsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveUnderlyingCoinDTO
func (a *CurveApiService) CurveGetUnderlyingCoinsHistoricalExecute(r ApiCurveGetUnderlyingCoinsHistoricalRequest) ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveUnderlyingCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetUnderlyingCoinsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/underlyingCoins/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetVotingAppsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetVotingAppsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetVotingAppsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetVotingAppsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetVotingAppsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetVotingAppsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetVotingAppsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetVotingAppsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetVotingAppsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetVotingAppsHistoricalRequest) Execute() ([]CurveVotingAppDTO, *http.Response, error) {
	return r.ApiService.CurveGetVotingAppsHistoricalExecute(r)
}

/*
CurveGetVotingAppsHistorical VotingApps (historical)

Gets voting apps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetVotingAppsHistoricalRequest
*/
func (a *CurveApiService) CurveGetVotingAppsHistorical(ctx context.Context) ApiCurveGetVotingAppsHistoricalRequest {
	return ApiCurveGetVotingAppsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveVotingAppDTO
func (a *CurveApiService) CurveGetVotingAppsHistoricalExecute(r ApiCurveGetVotingAppsHistoricalRequest) ([]CurveVotingAppDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveVotingAppDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetVotingAppsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/votingApps/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetWeeklyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) PoolId(poolId string) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetWeeklyVolumesHistoricalRequest) Execute() ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetWeeklyVolumesHistoricalExecute(r)
}

/*
CurveGetWeeklyVolumesHistorical WeeklyVolumes (historical)

Gets weekly volumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetWeeklyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetWeeklyVolumesHistorical(ctx context.Context) ApiCurveGetWeeklyVolumesHistoricalRequest {
	return ApiCurveGetWeeklyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveWeeklyVolumeDTO
func (a *CurveApiService) CurveGetWeeklyVolumesHistoricalExecute(r ApiCurveGetWeeklyVolumesHistoricalRequest) ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveWeeklyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetWeeklyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/weeklyVolumes/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
