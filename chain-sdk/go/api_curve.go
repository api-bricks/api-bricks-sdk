/*
OnChain API

 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

API version: v1
Contact: support@coinapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"
)


// CurveApiService CurveApi service
type CurveApiService service

type ApiCurveGetAccountDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetAccountDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAccountDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAccountDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAccountDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAccountDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAccountDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAccountDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAccountDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAccountDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetAccountDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetAccountDTOsHistoricalRequest) Execute() ([]CurveAccountDTO, *http.Response, error) {
	return r.ApiService.CurveGetAccountDTOsHistoricalExecute(r)
}

/*
CurveGetAccountDTOsHistorical AccountDTOs (historical) ðŸ”¥

Gets AccountDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAccountDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAccountDTOsHistorical(ctx context.Context) ApiCurveGetAccountDTOsHistoricalRequest {
	return ApiCurveGetAccountDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAccountDTO
func (a *CurveApiService) CurveGetAccountDTOsHistoricalExecute(r ApiCurveGetAccountDTOsHistoricalRequest) ([]CurveAccountDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAccountDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAccountDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/AccountDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAccountsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAccountsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAccountsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAccountsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAccountsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetAccountsHistoricalRequest) Execute() ([]CurveAccountDTO, *http.Response, error) {
	return r.ApiService.CurveGetAccountsHistoricalExecute(r)
}

/*
CurveGetAccountsHistorical Accounts (historical)

Gets accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAccountsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAccountsHistorical(ctx context.Context) ApiCurveGetAccountsHistoricalRequest {
	return ApiCurveGetAccountsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAccountDTO
func (a *CurveApiService) CurveGetAccountsHistoricalExecute(r ApiCurveGetAccountsHistoricalRequest) ([]CurveAccountDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAccountDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAccountsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/accounts/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAddLiquidityEventDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetAddLiquidityEventDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAddLiquidityEventDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAddLiquidityEventDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAddLiquidityEventDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAddLiquidityEventDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetAddLiquidityEventDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetAddLiquidityEventDTOsHistoricalRequest) Execute() ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetAddLiquidityEventDTOsHistoricalExecute(r)
}

/*
CurveGetAddLiquidityEventDTOsHistorical AddLiquidityEventDTOs (historical) ðŸ”¥

Gets AddLiquidityEventDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAddLiquidityEventDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAddLiquidityEventDTOsHistorical(ctx context.Context) ApiCurveGetAddLiquidityEventDTOsHistoricalRequest {
	return ApiCurveGetAddLiquidityEventDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAddLiquidityEventDTO
func (a *CurveApiService) CurveGetAddLiquidityEventDTOsHistoricalExecute(r ApiCurveGetAddLiquidityEventDTOsHistoricalRequest) ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAddLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAddLiquidityEventDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/AddLiquidityEventDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAddLiquidityEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) PoolId(poolId string) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) Execute() ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetAddLiquidityEventsHistoricalExecute(r)
}

/*
CurveGetAddLiquidityEventsHistorical AddLiquidityEvents (historical)

Gets add liquidity events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAddLiquidityEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAddLiquidityEventsHistorical(ctx context.Context) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	return ApiCurveGetAddLiquidityEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAddLiquidityEventDTO
func (a *CurveApiService) CurveGetAddLiquidityEventsHistoricalExecute(r ApiCurveGetAddLiquidityEventsHistoricalRequest) ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAddLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAddLiquidityEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/addLiquidityEvents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest) Execute() ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetAdminFeeChangeLogDTOsHistoricalExecute(r)
}

/*
CurveGetAdminFeeChangeLogDTOsHistorical AdminFeeChangeLogDTOs (historical) ðŸ”¥

Gets AdminFeeChangeLogDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAdminFeeChangeLogDTOsHistorical(ctx context.Context) ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest {
	return ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAdminFeeChangeLogDTO
func (a *CurveApiService) CurveGetAdminFeeChangeLogDTOsHistoricalExecute(r ApiCurveGetAdminFeeChangeLogDTOsHistoricalRequest) ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAdminFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAdminFeeChangeLogDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/AdminFeeChangeLogDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAdminFeeChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) PoolId(poolId string) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) Execute() ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetAdminFeeChangeLogsHistoricalExecute(r)
}

/*
CurveGetAdminFeeChangeLogsHistorical AdminFeeChangeLogs (historical)

Gets admin fee change logs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAdminFeeChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAdminFeeChangeLogsHistorical(ctx context.Context) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	return ApiCurveGetAdminFeeChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAdminFeeChangeLogDTO
func (a *CurveApiService) CurveGetAdminFeeChangeLogsHistoricalExecute(r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAdminFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAdminFeeChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/adminFeeChangeLogs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest) Execute() ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetAmplificationCoeffChangeLogDTOsHistoricalExecute(r)
}

/*
CurveGetAmplificationCoeffChangeLogDTOsHistorical AmplificationCoeffChangeLogDTOs (historical) ðŸ”¥

Gets AmplificationCoeffChangeLogDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAmplificationCoeffChangeLogDTOsHistorical(ctx context.Context) ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest {
	return ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAmplificationCoeffChangeLogDTO
func (a *CurveApiService) CurveGetAmplificationCoeffChangeLogDTOsHistoricalExecute(r ApiCurveGetAmplificationCoeffChangeLogDTOsHistoricalRequest) ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAmplificationCoeffChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAmplificationCoeffChangeLogDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/AmplificationCoeffChangeLogDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) PoolId(poolId string) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) Execute() ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetAmplificationCoeffChangeLogsHistoricalExecute(r)
}

/*
CurveGetAmplificationCoeffChangeLogsHistorical AmplificationCoeffChangeLogs (historical)

Gets amplification coeff change logs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAmplificationCoeffChangeLogsHistorical(ctx context.Context) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	return ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAmplificationCoeffChangeLogDTO
func (a *CurveApiService) CurveGetAmplificationCoeffChangeLogsHistoricalExecute(r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAmplificationCoeffChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAmplificationCoeffChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/amplificationCoeffChangeLogs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetCoinDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetCoinDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetCoinDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetCoinDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetCoinDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetCoinDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetCoinDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetCoinDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetCoinDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetCoinDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetCoinDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetCoinDTOsHistoricalRequest) Execute() ([]CurveCoinDTO, *http.Response, error) {
	return r.ApiService.CurveGetCoinDTOsHistoricalExecute(r)
}

/*
CurveGetCoinDTOsHistorical CoinDTOs (historical) ðŸ”¥

Gets CoinDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetCoinDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetCoinDTOsHistorical(ctx context.Context) ApiCurveGetCoinDTOsHistoricalRequest {
	return ApiCurveGetCoinDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveCoinDTO
func (a *CurveApiService) CurveGetCoinDTOsHistoricalExecute(r ApiCurveGetCoinDTOsHistoricalRequest) ([]CurveCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetCoinDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/CoinDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetCoinsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetCoinsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetCoinsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetCoinsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetCoinsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetCoinsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetCoinsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetCoinsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetCoinsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetCoinsHistoricalRequest) PoolId(poolId string) ApiCurveGetCoinsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) Execute() ([]CurveCoinDTO, *http.Response, error) {
	return r.ApiService.CurveGetCoinsHistoricalExecute(r)
}

/*
CurveGetCoinsHistorical Coins (historical)

Gets coins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetCoinsHistoricalRequest
*/
func (a *CurveApiService) CurveGetCoinsHistorical(ctx context.Context) ApiCurveGetCoinsHistoricalRequest {
	return ApiCurveGetCoinsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveCoinDTO
func (a *CurveApiService) CurveGetCoinsHistoricalExecute(r ApiCurveGetCoinsHistoricalRequest) ([]CurveCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetCoinsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/coins/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetContractDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetContractDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetContractDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetContractDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetContractDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetContractDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetContractDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetContractDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetContractDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetContractDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetContractDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetContractDTOsHistoricalRequest) Execute() ([]CurveContractDTO, *http.Response, error) {
	return r.ApiService.CurveGetContractDTOsHistoricalExecute(r)
}

/*
CurveGetContractDTOsHistorical ContractDTOs (historical) ðŸ”¥

Gets ContractDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetContractDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetContractDTOsHistorical(ctx context.Context) ApiCurveGetContractDTOsHistoricalRequest {
	return ApiCurveGetContractDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractDTO
func (a *CurveApiService) CurveGetContractDTOsHistoricalExecute(r ApiCurveGetContractDTOsHistoricalRequest) ([]CurveContractDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetContractDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/ContractDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetContractVersionDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetContractVersionDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetContractVersionDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetContractVersionDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetContractVersionDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetContractVersionDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetContractVersionDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetContractVersionDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetContractVersionDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetContractVersionDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetContractVersionDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetContractVersionDTOsHistoricalRequest) Execute() ([]CurveContractVersionDTO, *http.Response, error) {
	return r.ApiService.CurveGetContractVersionDTOsHistoricalExecute(r)
}

/*
CurveGetContractVersionDTOsHistorical ContractVersionDTOs (historical) ðŸ”¥

Gets ContractVersionDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetContractVersionDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetContractVersionDTOsHistorical(ctx context.Context) ApiCurveGetContractVersionDTOsHistoricalRequest {
	return ApiCurveGetContractVersionDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractVersionDTO
func (a *CurveApiService) CurveGetContractVersionDTOsHistoricalExecute(r ApiCurveGetContractVersionDTOsHistoricalRequest) ([]CurveContractVersionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractVersionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetContractVersionDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/ContractVersionDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetContractsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetContractsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetContractsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetContractsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetContractsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetContractsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetContractsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetContractsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetContractsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetContractsHistoricalRequest) PoolId(poolId string) ApiCurveGetContractsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetContractsHistoricalRequest) Execute() ([]CurveContractDTO, *http.Response, error) {
	return r.ApiService.CurveGetContractsHistoricalExecute(r)
}

/*
CurveGetContractsHistorical Contracts (historical)

Gets contracts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetContractsHistoricalRequest
*/
func (a *CurveApiService) CurveGetContractsHistorical(ctx context.Context) ApiCurveGetContractsHistoricalRequest {
	return ApiCurveGetContractsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractDTO
func (a *CurveApiService) CurveGetContractsHistoricalExecute(r ApiCurveGetContractsHistoricalRequest) ([]CurveContractDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetContractsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/contracts/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetContractsVersionsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetContractsVersionsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetContractsVersionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetContractsVersionsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetContractsVersionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetContractsVersionsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetContractsVersionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetContractsVersionsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetContractsVersionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetContractsVersionsHistoricalRequest) PoolId(poolId string) ApiCurveGetContractsVersionsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetContractsVersionsHistoricalRequest) Execute() ([]CurveContractVersionDTO, *http.Response, error) {
	return r.ApiService.CurveGetContractsVersionsHistoricalExecute(r)
}

/*
CurveGetContractsVersionsHistorical ContractsVersions (historical)

Gets contracts versions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetContractsVersionsHistoricalRequest
*/
func (a *CurveApiService) CurveGetContractsVersionsHistorical(ctx context.Context) ApiCurveGetContractsVersionsHistoricalRequest {
	return ApiCurveGetContractsVersionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractVersionDTO
func (a *CurveApiService) CurveGetContractsVersionsHistoricalExecute(r ApiCurveGetContractsVersionsHistoricalRequest) ([]CurveContractVersionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractVersionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetContractsVersionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/contractsVersions/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetDailyVolumeDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetDailyVolumeDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetDailyVolumeDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetDailyVolumeDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetDailyVolumeDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetDailyVolumeDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetDailyVolumeDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetDailyVolumeDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetDailyVolumeDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetDailyVolumeDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetDailyVolumeDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetDailyVolumeDTOsHistoricalRequest) Execute() ([]CurveDailyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetDailyVolumeDTOsHistoricalExecute(r)
}

/*
CurveGetDailyVolumeDTOsHistorical DailyVolumeDTOs (historical) ðŸ”¥

Gets DailyVolumeDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetDailyVolumeDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetDailyVolumeDTOsHistorical(ctx context.Context) ApiCurveGetDailyVolumeDTOsHistoricalRequest {
	return ApiCurveGetDailyVolumeDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveDailyVolumeDTO
func (a *CurveApiService) CurveGetDailyVolumeDTOsHistoricalExecute(r ApiCurveGetDailyVolumeDTOsHistoricalRequest) ([]CurveDailyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveDailyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetDailyVolumeDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/DailyVolumeDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetDailyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetDailyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetDailyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetDailyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetDailyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) PoolId(poolId string) ApiCurveGetDailyVolumesHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetDailyVolumesHistoricalRequest) Execute() ([]CurveDailyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetDailyVolumesHistoricalExecute(r)
}

/*
CurveGetDailyVolumesHistorical DailyVolumes (historical)

Gets daily volumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetDailyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetDailyVolumesHistorical(ctx context.Context) ApiCurveGetDailyVolumesHistoricalRequest {
	return ApiCurveGetDailyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveDailyVolumeDTO
func (a *CurveApiService) CurveGetDailyVolumesHistoricalExecute(r ApiCurveGetDailyVolumesHistoricalRequest) ([]CurveDailyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveDailyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetDailyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/dailyVolumes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetExchangeDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetExchangeDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetExchangeDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetExchangeDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetExchangeDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetExchangeDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetExchangeDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetExchangeDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetExchangeDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetExchangeDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetExchangeDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetExchangeDTOsHistoricalRequest) Execute() ([]CurveExchangeDTO, *http.Response, error) {
	return r.ApiService.CurveGetExchangeDTOsHistoricalExecute(r)
}

/*
CurveGetExchangeDTOsHistorical ExchangeDTOs (historical) ðŸ”¥

Gets ExchangeDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetExchangeDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetExchangeDTOsHistorical(ctx context.Context) ApiCurveGetExchangeDTOsHistoricalRequest {
	return ApiCurveGetExchangeDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveExchangeDTO
func (a *CurveApiService) CurveGetExchangeDTOsHistoricalExecute(r ApiCurveGetExchangeDTOsHistoricalRequest) ([]CurveExchangeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveExchangeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetExchangeDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/ExchangeDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetExchangesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetExchangesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetExchangesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetExchangesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetExchangesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) PoolId(poolId string) ApiCurveGetExchangesHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetExchangesHistoricalRequest) Execute() ([]CurveExchangeDTO, *http.Response, error) {
	return r.ApiService.CurveGetExchangesHistoricalExecute(r)
}

/*
CurveGetExchangesHistorical Exchanges (historical) ðŸ”¥

Gets exchanges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetExchangesHistoricalRequest
*/
func (a *CurveApiService) CurveGetExchangesHistorical(ctx context.Context) ApiCurveGetExchangesHistoricalRequest {
	return ApiCurveGetExchangesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveExchangeDTO
func (a *CurveApiService) CurveGetExchangesHistoricalExecute(r ApiCurveGetExchangesHistoricalRequest) ([]CurveExchangeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveExchangeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetExchangesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/exchanges/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetFeeChangeLogDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetFeeChangeLogDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetFeeChangeLogDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetFeeChangeLogDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetFeeChangeLogDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetFeeChangeLogDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetFeeChangeLogDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetFeeChangeLogDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetFeeChangeLogDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetFeeChangeLogDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetFeeChangeLogDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetFeeChangeLogDTOsHistoricalRequest) Execute() ([]CurveFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetFeeChangeLogDTOsHistoricalExecute(r)
}

/*
CurveGetFeeChangeLogDTOsHistorical FeeChangeLogDTOs (historical) ðŸ”¥

Gets FeeChangeLogDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetFeeChangeLogDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetFeeChangeLogDTOsHistorical(ctx context.Context) ApiCurveGetFeeChangeLogDTOsHistoricalRequest {
	return ApiCurveGetFeeChangeLogDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveFeeChangeLogDTO
func (a *CurveApiService) CurveGetFeeChangeLogDTOsHistoricalExecute(r ApiCurveGetFeeChangeLogDTOsHistoricalRequest) ([]CurveFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetFeeChangeLogDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/FeeChangeLogDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetFeeChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) PoolId(poolId string) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetFeeChangeLogsHistoricalRequest) Execute() ([]CurveFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetFeeChangeLogsHistoricalExecute(r)
}

/*
CurveGetFeeChangeLogsHistorical FeeChangeLogs (historical)

Gets fee change logs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetFeeChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetFeeChangeLogsHistorical(ctx context.Context) ApiCurveGetFeeChangeLogsHistoricalRequest {
	return ApiCurveGetFeeChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveFeeChangeLogDTO
func (a *CurveApiService) CurveGetFeeChangeLogsHistoricalExecute(r ApiCurveGetFeeChangeLogsHistoricalRequest) ([]CurveFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetFeeChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/feeChangeLogs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugeDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugeDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugeDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugeDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugeDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugeDTOsHistoricalRequest) Execute() ([]CurveGaugeDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeDTOsHistoricalExecute(r)
}

/*
CurveGetGaugeDTOsHistorical GaugeDTOs (historical) ðŸ”¥

Gets GaugeDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeDTOsHistorical(ctx context.Context) ApiCurveGetGaugeDTOsHistoricalRequest {
	return ApiCurveGetGaugeDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDTO
func (a *CurveApiService) CurveGetGaugeDTOsHistoricalExecute(r ApiCurveGetGaugeDTOsHistoricalRequest) ([]CurveGaugeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/GaugeDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeDepositDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugeDepositDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeDepositDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugeDepositDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeDepositDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugeDepositDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeDepositDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugeDepositDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeDepositDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeDepositDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugeDepositDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugeDepositDTOsHistoricalRequest) Execute() ([]CurveGaugeDepositDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeDepositDTOsHistoricalExecute(r)
}

/*
CurveGetGaugeDepositDTOsHistorical GaugeDepositDTOs (historical) ðŸ”¥

Gets GaugeDepositDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeDepositDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeDepositDTOsHistorical(ctx context.Context) ApiCurveGetGaugeDepositDTOsHistoricalRequest {
	return ApiCurveGetGaugeDepositDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDepositDTO
func (a *CurveApiService) CurveGetGaugeDepositDTOsHistoricalExecute(r ApiCurveGetGaugeDepositDTOsHistoricalRequest) ([]CurveGaugeDepositDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDepositDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeDepositDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/GaugeDepositDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeLiquidityDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugeLiquidityDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeLiquidityDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugeLiquidityDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeLiquidityDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugeLiquidityDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeLiquidityDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugeLiquidityDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeLiquidityDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeLiquidityDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugeLiquidityDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugeLiquidityDTOsHistoricalRequest) Execute() ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeLiquidityDTOsHistoricalExecute(r)
}

/*
CurveGetGaugeLiquidityDTOsHistorical GaugeLiquidityDTOs (historical) ðŸ”¥

Gets GaugeLiquidityDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeLiquidityDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeLiquidityDTOsHistorical(ctx context.Context) ApiCurveGetGaugeLiquidityDTOsHistoricalRequest {
	return ApiCurveGetGaugeLiquidityDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeLiquidityDTO
func (a *CurveApiService) CurveGetGaugeLiquidityDTOsHistoricalExecute(r ApiCurveGetGaugeLiquidityDTOsHistoricalRequest) ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeLiquidityDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeLiquidityDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/GaugeLiquidityDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest) Execute() ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeTotalWeightDTOsHistoricalExecute(r)
}

/*
CurveGetGaugeTotalWeightDTOsHistorical GaugeTotalWeightDTOs (historical) ðŸ”¥

Gets GaugeTotalWeightDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeTotalWeightDTOsHistorical(ctx context.Context) ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest {
	return ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTotalWeightDTO
func (a *CurveApiService) CurveGetGaugeTotalWeightDTOsHistoricalExecute(r ApiCurveGetGaugeTotalWeightDTOsHistoricalRequest) ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTotalWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeTotalWeightDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/GaugeTotalWeightDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeTypeDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugeTypeDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeTypeDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugeTypeDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeTypeDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugeTypeDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeTypeDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugeTypeDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeTypeDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeTypeDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugeTypeDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugeTypeDTOsHistoricalRequest) Execute() ([]CurveGaugeTypeDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeTypeDTOsHistoricalExecute(r)
}

/*
CurveGetGaugeTypeDTOsHistorical GaugeTypeDTOs (historical) ðŸ”¥

Gets GaugeTypeDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeTypeDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeTypeDTOsHistorical(ctx context.Context) ApiCurveGetGaugeTypeDTOsHistoricalRequest {
	return ApiCurveGetGaugeTypeDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeDTO
func (a *CurveApiService) CurveGetGaugeTypeDTOsHistoricalExecute(r ApiCurveGetGaugeTypeDTOsHistoricalRequest) ([]CurveGaugeTypeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeTypeDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/GaugeTypeDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest) Execute() ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeTypeWeightDTOsHistoricalExecute(r)
}

/*
CurveGetGaugeTypeWeightDTOsHistorical GaugeTypeWeightDTOs (historical) ðŸ”¥

Gets GaugeTypeWeightDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeTypeWeightDTOsHistorical(ctx context.Context) ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest {
	return ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeWeightDTO
func (a *CurveApiService) CurveGetGaugeTypeWeightDTOsHistoricalExecute(r ApiCurveGetGaugeTypeWeightDTOsHistoricalRequest) ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeTypeWeightDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/GaugeTypeWeightDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeWeightDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugeWeightDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeWeightDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugeWeightDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeWeightDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugeWeightDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeWeightDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugeWeightDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeWeightDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeWeightDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugeWeightDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugeWeightDTOsHistoricalRequest) Execute() ([]CurveGaugeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeWeightDTOsHistoricalExecute(r)
}

/*
CurveGetGaugeWeightDTOsHistorical GaugeWeightDTOs (historical) ðŸ”¥

Gets GaugeWeightDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeWeightDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeWeightDTOsHistorical(ctx context.Context) ApiCurveGetGaugeWeightDTOsHistoricalRequest {
	return ApiCurveGetGaugeWeightDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightDTO
func (a *CurveApiService) CurveGetGaugeWeightDTOsHistoricalExecute(r ApiCurveGetGaugeWeightDTOsHistoricalRequest) ([]CurveGaugeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeWeightDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/GaugeWeightDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest) Execute() ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeWeightVoteDTOsHistoricalExecute(r)
}

/*
CurveGetGaugeWeightVoteDTOsHistorical GaugeWeightVoteDTOs (historical) ðŸ”¥

Gets GaugeWeightVoteDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeWeightVoteDTOsHistorical(ctx context.Context) ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest {
	return ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightVoteDTO
func (a *CurveApiService) CurveGetGaugeWeightVoteDTOsHistoricalExecute(r ApiCurveGetGaugeWeightVoteDTOsHistoricalRequest) ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeWeightVoteDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/GaugeWeightVoteDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeWithdrawDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugeWithdrawDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeWithdrawDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugeWithdrawDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeWithdrawDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugeWithdrawDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeWithdrawDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugeWithdrawDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeWithdrawDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeWithdrawDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugeWithdrawDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugeWithdrawDTOsHistoricalRequest) Execute() ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeWithdrawDTOsHistoricalExecute(r)
}

/*
CurveGetGaugeWithdrawDTOsHistorical GaugeWithdrawDTOs (historical) ðŸ”¥

Gets GaugeWithdrawDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeWithdrawDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeWithdrawDTOsHistorical(ctx context.Context) ApiCurveGetGaugeWithdrawDTOsHistoricalRequest {
	return ApiCurveGetGaugeWithdrawDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWithdrawDTO
func (a *CurveApiService) CurveGetGaugeWithdrawDTOsHistoricalExecute(r ApiCurveGetGaugeWithdrawDTOsHistoricalRequest) ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWithdrawDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeWithdrawDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/GaugeWithdrawDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesDepositsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesDepositsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesDepositsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesDepositsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesDepositsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesDepositsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesDepositsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesDepositsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesDepositsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesDepositsHistoricalRequest) Execute() ([]CurveGaugeDepositDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesDepositsHistoricalExecute(r)
}

/*
CurveGetGaugesDepositsHistorical GaugesDeposits (historical)

Gets gauges deposits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesDepositsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesDepositsHistorical(ctx context.Context) ApiCurveGetGaugesDepositsHistoricalRequest {
	return ApiCurveGetGaugesDepositsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDepositDTO
func (a *CurveApiService) CurveGetGaugesDepositsHistoricalExecute(r ApiCurveGetGaugesDepositsHistoricalRequest) ([]CurveGaugeDepositDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDepositDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesDepositsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesDeposits/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) PoolId(poolId string) ApiCurveGetGaugesHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetGaugesHistoricalRequest) Execute() ([]CurveGaugeDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesHistoricalExecute(r)
}

/*
CurveGetGaugesHistorical Gauges (historical)

Gets gauges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesHistorical(ctx context.Context) ApiCurveGetGaugesHistoricalRequest {
	return ApiCurveGetGaugesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDTO
func (a *CurveApiService) CurveGetGaugesHistoricalExecute(r ApiCurveGetGaugesHistoricalRequest) ([]CurveGaugeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gauges/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesLiquidityHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesLiquidityHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesLiquidityHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesLiquidityHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesLiquidityHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesLiquidityHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesLiquidityHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesLiquidityHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesLiquidityHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesLiquidityHistoricalRequest) Execute() ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesLiquidityHistoricalExecute(r)
}

/*
CurveGetGaugesLiquidityHistorical GaugesLiquidity (historical)

Gets gauges liquidity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesLiquidityHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesLiquidityHistorical(ctx context.Context) ApiCurveGetGaugesLiquidityHistoricalRequest {
	return ApiCurveGetGaugesLiquidityHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeLiquidityDTO
func (a *CurveApiService) CurveGetGaugesLiquidityHistoricalExecute(r ApiCurveGetGaugesLiquidityHistoricalRequest) ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeLiquidityDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesLiquidityHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesLiquidity/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesTotalWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesTotalWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesTotalWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesTotalWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesTotalWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesTotalWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesTotalWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesTotalWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesTotalWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesTotalWeightsHistoricalRequest) Execute() ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesTotalWeightsHistoricalExecute(r)
}

/*
CurveGetGaugesTotalWeightsHistorical GaugesTotalWeights (historical)

Gets gauges total weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesTotalWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesTotalWeightsHistorical(ctx context.Context) ApiCurveGetGaugesTotalWeightsHistoricalRequest {
	return ApiCurveGetGaugesTotalWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTotalWeightDTO
func (a *CurveApiService) CurveGetGaugesTotalWeightsHistoricalExecute(r ApiCurveGetGaugesTotalWeightsHistoricalRequest) ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTotalWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesTotalWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesTotalWeights/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesTypesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesTypesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesTypesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesTypesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesTypesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesTypesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesTypesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesTypesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesTypesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesTypesHistoricalRequest) Execute() ([]CurveGaugeTypeDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesTypesHistoricalExecute(r)
}

/*
CurveGetGaugesTypesHistorical GaugesTypes (historical)

Gets gauges types.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesTypesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesTypesHistorical(ctx context.Context) ApiCurveGetGaugesTypesHistoricalRequest {
	return ApiCurveGetGaugesTypesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeDTO
func (a *CurveApiService) CurveGetGaugesTypesHistoricalExecute(r ApiCurveGetGaugesTypesHistoricalRequest) ([]CurveGaugeTypeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesTypesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesTypes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesTypesWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesTypesWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesTypesWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesTypesWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesTypesWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesTypesWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesTypesWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesTypesWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesTypesWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesTypesWeightsHistoricalRequest) Execute() ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesTypesWeightsHistoricalExecute(r)
}

/*
CurveGetGaugesTypesWeightsHistorical GaugesTypesWeights (historical)

Gets gauges types weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesTypesWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesTypesWeightsHistorical(ctx context.Context) ApiCurveGetGaugesTypesWeightsHistoricalRequest {
	return ApiCurveGetGaugesTypesWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeWeightDTO
func (a *CurveApiService) CurveGetGaugesTypesWeightsHistoricalExecute(r ApiCurveGetGaugesTypesWeightsHistoricalRequest) ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesTypesWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesTypesWeights/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesWeightsHistoricalRequest) Execute() ([]CurveGaugeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesWeightsHistoricalExecute(r)
}

/*
CurveGetGaugesWeightsHistorical GaugesWeights (historical)

Gets gauges weights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesWeightsHistorical(ctx context.Context) ApiCurveGetGaugesWeightsHistoricalRequest {
	return ApiCurveGetGaugesWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightDTO
func (a *CurveApiService) CurveGetGaugesWeightsHistoricalExecute(r ApiCurveGetGaugesWeightsHistoricalRequest) ([]CurveGaugeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesWeights/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesWeightsVotesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesWeightsVotesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesWeightsVotesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesWeightsVotesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesWeightsVotesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesWeightsVotesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesWeightsVotesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesWeightsVotesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesWeightsVotesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesWeightsVotesHistoricalRequest) Execute() ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesWeightsVotesHistoricalExecute(r)
}

/*
CurveGetGaugesWeightsVotesHistorical GaugesWeightsVotes (historical)

Gets gauges weights votes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesWeightsVotesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesWeightsVotesHistorical(ctx context.Context) ApiCurveGetGaugesWeightsVotesHistoricalRequest {
	return ApiCurveGetGaugesWeightsVotesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightVoteDTO
func (a *CurveApiService) CurveGetGaugesWeightsVotesHistoricalExecute(r ApiCurveGetGaugesWeightsVotesHistoricalRequest) ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesWeightsVotesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesWeightsVotes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesWithdrawHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetGaugesWithdrawHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesWithdrawHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetGaugesWithdrawHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesWithdrawHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetGaugesWithdrawHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesWithdrawHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetGaugesWithdrawHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesWithdrawHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetGaugesWithdrawHistoricalRequest) Execute() ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesWithdrawHistoricalExecute(r)
}

/*
CurveGetGaugesWithdrawHistorical GaugesWithdraw (historical)

Gets gauges withdraws.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesWithdrawHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesWithdrawHistorical(ctx context.Context) ApiCurveGetGaugesWithdrawHistoricalRequest {
	return ApiCurveGetGaugesWithdrawHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWithdrawDTO
func (a *CurveApiService) CurveGetGaugesWithdrawHistoricalExecute(r ApiCurveGetGaugesWithdrawHistoricalRequest) ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWithdrawDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesWithdrawHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugesWithdraws/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetHourlyVolumeDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetHourlyVolumeDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetHourlyVolumeDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetHourlyVolumeDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetHourlyVolumeDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetHourlyVolumeDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetHourlyVolumeDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetHourlyVolumeDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetHourlyVolumeDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetHourlyVolumeDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetHourlyVolumeDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetHourlyVolumeDTOsHistoricalRequest) Execute() ([]CurveHourlyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetHourlyVolumeDTOsHistoricalExecute(r)
}

/*
CurveGetHourlyVolumeDTOsHistorical HourlyVolumeDTOs (historical) ðŸ”¥

Gets HourlyVolumeDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetHourlyVolumeDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetHourlyVolumeDTOsHistorical(ctx context.Context) ApiCurveGetHourlyVolumeDTOsHistoricalRequest {
	return ApiCurveGetHourlyVolumeDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveHourlyVolumeDTO
func (a *CurveApiService) CurveGetHourlyVolumeDTOsHistoricalExecute(r ApiCurveGetHourlyVolumeDTOsHistoricalRequest) ([]CurveHourlyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveHourlyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetHourlyVolumeDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/HourlyVolumeDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetHourlyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) PoolId(poolId string) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetHourlyVolumesHistoricalRequest) Execute() ([]CurveHourlyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetHourlyVolumesHistoricalExecute(r)
}

/*
CurveGetHourlyVolumesHistorical HourlyVolumes (historical)

Gets hourly volumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetHourlyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetHourlyVolumesHistorical(ctx context.Context) ApiCurveGetHourlyVolumesHistoricalRequest {
	return ApiCurveGetHourlyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveHourlyVolumeDTO
func (a *CurveApiService) CurveGetHourlyVolumesHistoricalExecute(r ApiCurveGetHourlyVolumesHistoricalRequest) ([]CurveHourlyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveHourlyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetHourlyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/hourlyVolumes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetLpTokenDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetLpTokenDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetLpTokenDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetLpTokenDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetLpTokenDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetLpTokenDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetLpTokenDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetLpTokenDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetLpTokenDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetLpTokenDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetLpTokenDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetLpTokenDTOsHistoricalRequest) Execute() ([]CurveLpTokenDTO, *http.Response, error) {
	return r.ApiService.CurveGetLpTokenDTOsHistoricalExecute(r)
}

/*
CurveGetLpTokenDTOsHistorical LpTokenDTOs (historical) ðŸ”¥

Gets LpTokenDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetLpTokenDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetLpTokenDTOsHistorical(ctx context.Context) ApiCurveGetLpTokenDTOsHistoricalRequest {
	return ApiCurveGetLpTokenDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveLpTokenDTO
func (a *CurveApiService) CurveGetLpTokenDTOsHistoricalExecute(r ApiCurveGetLpTokenDTOsHistoricalRequest) ([]CurveLpTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveLpTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetLpTokenDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/LpTokenDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetLpTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetLpTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetLpTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetLpTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetLpTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) PoolId(poolId string) ApiCurveGetLpTokensHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetLpTokensHistoricalRequest) Execute() ([]CurveLpTokenDTO, *http.Response, error) {
	return r.ApiService.CurveGetLpTokensHistoricalExecute(r)
}

/*
CurveGetLpTokensHistorical LpTokens (historical)

Gets lp tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetLpTokensHistoricalRequest
*/
func (a *CurveApiService) CurveGetLpTokensHistorical(ctx context.Context) ApiCurveGetLpTokensHistoricalRequest {
	return ApiCurveGetLpTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveLpTokenDTO
func (a *CurveApiService) CurveGetLpTokensHistoricalExecute(r ApiCurveGetLpTokensHistoricalRequest) ([]CurveLpTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveLpTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetLpTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/lpTokens/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetPoolDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetPoolDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetPoolDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetPoolDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetPoolDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetPoolDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetPoolDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetPoolDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetPoolDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetPoolDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetPoolDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetPoolDTOsHistoricalRequest) Execute() ([]CurvePoolDTO, *http.Response, error) {
	return r.ApiService.CurveGetPoolDTOsHistoricalExecute(r)
}

/*
CurveGetPoolDTOsHistorical PoolDTOs (historical) ðŸ”¥

Gets PoolDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetPoolDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetPoolDTOsHistorical(ctx context.Context) ApiCurveGetPoolDTOsHistoricalRequest {
	return ApiCurveGetPoolDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurvePoolDTO
func (a *CurveApiService) CurveGetPoolDTOsHistoricalExecute(r ApiCurveGetPoolDTOsHistoricalRequest) ([]CurvePoolDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurvePoolDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetPoolDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/PoolDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetPoolsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetPoolsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetPoolsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetPoolsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetPoolsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetPoolsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetPoolsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetPoolsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetPoolsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetPoolsHistoricalRequest) PoolId(poolId string) ApiCurveGetPoolsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetPoolsHistoricalRequest) Execute() ([]CurvePoolDTO, *http.Response, error) {
	return r.ApiService.CurveGetPoolsHistoricalExecute(r)
}

/*
CurveGetPoolsHistorical Pools (historical) ðŸ”¥

Gets pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetPoolsHistoricalRequest
*/
func (a *CurveApiService) CurveGetPoolsHistorical(ctx context.Context) ApiCurveGetPoolsHistoricalRequest {
	return ApiCurveGetPoolsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurvePoolDTO
func (a *CurveApiService) CurveGetPoolsHistoricalExecute(r ApiCurveGetPoolsHistoricalRequest) ([]CurvePoolDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurvePoolDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetPoolsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/pools/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetProposalDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetProposalDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetProposalDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetProposalDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetProposalDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetProposalDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetProposalDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetProposalDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetProposalDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetProposalDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetProposalDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetProposalDTOsHistoricalRequest) Execute() ([]CurveProposalDTO, *http.Response, error) {
	return r.ApiService.CurveGetProposalDTOsHistoricalExecute(r)
}

/*
CurveGetProposalDTOsHistorical ProposalDTOs (historical) ðŸ”¥

Gets ProposalDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetProposalDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetProposalDTOsHistorical(ctx context.Context) ApiCurveGetProposalDTOsHistoricalRequest {
	return ApiCurveGetProposalDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalDTO
func (a *CurveApiService) CurveGetProposalDTOsHistoricalExecute(r ApiCurveGetProposalDTOsHistoricalRequest) ([]CurveProposalDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetProposalDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/ProposalDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetProposalVoteDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetProposalVoteDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetProposalVoteDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetProposalVoteDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetProposalVoteDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetProposalVoteDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetProposalVoteDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetProposalVoteDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetProposalVoteDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetProposalVoteDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetProposalVoteDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetProposalVoteDTOsHistoricalRequest) Execute() ([]CurveProposalVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGetProposalVoteDTOsHistoricalExecute(r)
}

/*
CurveGetProposalVoteDTOsHistorical ProposalVoteDTOs (historical) ðŸ”¥

Gets ProposalVoteDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetProposalVoteDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetProposalVoteDTOsHistorical(ctx context.Context) ApiCurveGetProposalVoteDTOsHistoricalRequest {
	return ApiCurveGetProposalVoteDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalVoteDTO
func (a *CurveApiService) CurveGetProposalVoteDTOsHistoricalExecute(r ApiCurveGetProposalVoteDTOsHistoricalRequest) ([]CurveProposalVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetProposalVoteDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/ProposalVoteDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetProposalsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetProposalsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetProposalsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetProposalsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetProposalsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetProposalsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetProposalsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetProposalsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetProposalsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetProposalsHistoricalRequest) Execute() ([]CurveProposalDTO, *http.Response, error) {
	return r.ApiService.CurveGetProposalsHistoricalExecute(r)
}

/*
CurveGetProposalsHistorical Proposals (historical)

Gets proposals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetProposalsHistoricalRequest
*/
func (a *CurveApiService) CurveGetProposalsHistorical(ctx context.Context) ApiCurveGetProposalsHistoricalRequest {
	return ApiCurveGetProposalsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalDTO
func (a *CurveApiService) CurveGetProposalsHistoricalExecute(r ApiCurveGetProposalsHistoricalRequest) ([]CurveProposalDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetProposalsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/proposals/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetProposalsVotesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetProposalsVotesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetProposalsVotesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetProposalsVotesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetProposalsVotesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetProposalsVotesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetProposalsVotesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetProposalsVotesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetProposalsVotesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetProposalsVotesHistoricalRequest) Execute() ([]CurveProposalVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGetProposalsVotesHistoricalExecute(r)
}

/*
CurveGetProposalsVotesHistorical ProposalsVotes (historical)

Gets proposals votes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetProposalsVotesHistoricalRequest
*/
func (a *CurveApiService) CurveGetProposalsVotesHistorical(ctx context.Context) ApiCurveGetProposalsVotesHistoricalRequest {
	return ApiCurveGetProposalsVotesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalVoteDTO
func (a *CurveApiService) CurveGetProposalsVotesHistoricalExecute(r ApiCurveGetProposalsVotesHistoricalRequest) ([]CurveProposalVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetProposalsVotesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/proposalsVotes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest) Execute() ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetRemoveLiquidityEventDTOsHistoricalExecute(r)
}

/*
CurveGetRemoveLiquidityEventDTOsHistorical RemoveLiquidityEventDTOs (historical) ðŸ”¥

Gets RemoveLiquidityEventDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetRemoveLiquidityEventDTOsHistorical(ctx context.Context) ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest {
	return ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityEventDTO
func (a *CurveApiService) CurveGetRemoveLiquidityEventDTOsHistoricalExecute(r ApiCurveGetRemoveLiquidityEventDTOsHistoricalRequest) ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetRemoveLiquidityEventDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/RemoveLiquidityEventDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetRemoveLiquidityEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) PoolId(poolId string) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) Execute() ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetRemoveLiquidityEventsHistoricalExecute(r)
}

/*
CurveGetRemoveLiquidityEventsHistorical RemoveLiquidityEvents (historical)

Gets remove liquidity events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetRemoveLiquidityEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetRemoveLiquidityEventsHistorical(ctx context.Context) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	return ApiCurveGetRemoveLiquidityEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityEventDTO
func (a *CurveApiService) CurveGetRemoveLiquidityEventsHistoricalExecute(r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetRemoveLiquidityEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/removeLiquidityEvents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest) Execute() ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetRemoveLiquidityOneEventDTOsHistoricalExecute(r)
}

/*
CurveGetRemoveLiquidityOneEventDTOsHistorical RemoveLiquidityOneEventDTOs (historical) ðŸ”¥

Gets RemoveLiquidityOneEventDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetRemoveLiquidityOneEventDTOsHistorical(ctx context.Context) ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest {
	return ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityOneEventDTO
func (a *CurveApiService) CurveGetRemoveLiquidityOneEventDTOsHistoricalExecute(r ApiCurveGetRemoveLiquidityOneEventDTOsHistoricalRequest) ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityOneEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetRemoveLiquidityOneEventDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/RemoveLiquidityOneEventDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) PoolId(poolId string) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) Execute() ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetRemoveLiquidityOneEventsHistoricalExecute(r)
}

/*
CurveGetRemoveLiquidityOneEventsHistorical RemoveLiquidityOneEvents (historical)

Gets remove liquidity one events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetRemoveLiquidityOneEventsHistorical(ctx context.Context) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	return ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityOneEventDTO
func (a *CurveApiService) CurveGetRemoveLiquidityOneEventsHistoricalExecute(r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityOneEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetRemoveLiquidityOneEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/removeLiquidityOneEvents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetSystemStateDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetSystemStateDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetSystemStateDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetSystemStateDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetSystemStateDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetSystemStateDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetSystemStateDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetSystemStateDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetSystemStateDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetSystemStateDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetSystemStateDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetSystemStateDTOsHistoricalRequest) Execute() ([]CurveSystemStateDTO, *http.Response, error) {
	return r.ApiService.CurveGetSystemStateDTOsHistoricalExecute(r)
}

/*
CurveGetSystemStateDTOsHistorical SystemStateDTOs (historical) ðŸ”¥

Gets SystemStateDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetSystemStateDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetSystemStateDTOsHistorical(ctx context.Context) ApiCurveGetSystemStateDTOsHistoricalRequest {
	return ApiCurveGetSystemStateDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveSystemStateDTO
func (a *CurveApiService) CurveGetSystemStateDTOsHistoricalExecute(r ApiCurveGetSystemStateDTOsHistoricalRequest) ([]CurveSystemStateDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveSystemStateDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetSystemStateDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/SystemStateDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetSystemStatesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetSystemStatesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetSystemStatesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetSystemStatesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetSystemStatesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetSystemStatesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetSystemStatesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetSystemStatesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetSystemStatesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetSystemStatesHistoricalRequest) Execute() ([]CurveSystemStateDTO, *http.Response, error) {
	return r.ApiService.CurveGetSystemStatesHistoricalExecute(r)
}

/*
CurveGetSystemStatesHistorical SystemStates (historical)

Gets system states.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetSystemStatesHistoricalRequest
*/
func (a *CurveApiService) CurveGetSystemStatesHistorical(ctx context.Context) ApiCurveGetSystemStatesHistoricalRequest {
	return ApiCurveGetSystemStatesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveSystemStateDTO
func (a *CurveApiService) CurveGetSystemStatesHistoricalExecute(r ApiCurveGetSystemStatesHistoricalRequest) ([]CurveSystemStateDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveSystemStateDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetSystemStatesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/systemStates/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetTokenDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetTokenDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetTokenDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetTokenDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetTokenDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetTokenDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetTokenDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetTokenDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetTokenDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetTokenDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetTokenDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetTokenDTOsHistoricalRequest) Execute() ([]CurveTokenDTO, *http.Response, error) {
	return r.ApiService.CurveGetTokenDTOsHistoricalExecute(r)
}

/*
CurveGetTokenDTOsHistorical TokenDTOs (historical) ðŸ”¥

Gets TokenDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetTokenDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetTokenDTOsHistorical(ctx context.Context) ApiCurveGetTokenDTOsHistoricalRequest {
	return ApiCurveGetTokenDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTokenDTO
func (a *CurveApiService) CurveGetTokenDTOsHistoricalExecute(r ApiCurveGetTokenDTOsHistoricalRequest) ([]CurveTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetTokenDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/TokenDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	tokenId *string
}

// 
func (r ApiCurveGetTokensHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) TokenId(tokenId string) ApiCurveGetTokensHistoricalRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiCurveGetTokensHistoricalRequest) Execute() ([]CurveTokenDTO, *http.Response, error) {
	return r.ApiService.CurveGetTokensHistoricalExecute(r)
}

/*
CurveGetTokensHistorical Tokens (historical) ðŸ”¥

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetTokensHistoricalRequest
*/
func (a *CurveApiService) CurveGetTokensHistorical(ctx context.Context) ApiCurveGetTokensHistoricalRequest {
	return ApiCurveGetTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTokenDTO
func (a *CurveApiService) CurveGetTokensHistoricalExecute(r ApiCurveGetTokensHistoricalRequest) ([]CurveTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/tokens/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest) Execute() ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetTransferOwnershipEventDTOsHistoricalExecute(r)
}

/*
CurveGetTransferOwnershipEventDTOsHistorical TransferOwnershipEventDTOs (historical) ðŸ”¥

Gets TransferOwnershipEventDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetTransferOwnershipEventDTOsHistorical(ctx context.Context) ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest {
	return ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTransferOwnershipEventDTO
func (a *CurveApiService) CurveGetTransferOwnershipEventDTOsHistoricalExecute(r ApiCurveGetTransferOwnershipEventDTOsHistoricalRequest) ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTransferOwnershipEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetTransferOwnershipEventDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/TransferOwnershipEventDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetTransferOwnershipEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) PoolId(poolId string) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) Execute() ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetTransferOwnershipEventsHistoricalExecute(r)
}

/*
CurveGetTransferOwnershipEventsHistorical TransferOwnershipEvents (historical)

Gets transfer ownership events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetTransferOwnershipEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetTransferOwnershipEventsHistorical(ctx context.Context) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	return ApiCurveGetTransferOwnershipEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTransferOwnershipEventDTO
func (a *CurveApiService) CurveGetTransferOwnershipEventsHistoricalExecute(r ApiCurveGetTransferOwnershipEventsHistoricalRequest) ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTransferOwnershipEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetTransferOwnershipEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/transferOwnershipEvents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetUnderlyingCoinDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetUnderlyingCoinDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetUnderlyingCoinDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetUnderlyingCoinDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetUnderlyingCoinDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetUnderlyingCoinDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetUnderlyingCoinDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetUnderlyingCoinDTOsHistoricalRequest) Execute() ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	return r.ApiService.CurveGetUnderlyingCoinDTOsHistoricalExecute(r)
}

/*
CurveGetUnderlyingCoinDTOsHistorical UnderlyingCoinDTOs (historical) ðŸ”¥

Gets UnderlyingCoinDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetUnderlyingCoinDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetUnderlyingCoinDTOsHistorical(ctx context.Context) ApiCurveGetUnderlyingCoinDTOsHistoricalRequest {
	return ApiCurveGetUnderlyingCoinDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveUnderlyingCoinDTO
func (a *CurveApiService) CurveGetUnderlyingCoinDTOsHistoricalExecute(r ApiCurveGetUnderlyingCoinDTOsHistoricalRequest) ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveUnderlyingCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetUnderlyingCoinDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/UnderlyingCoinDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetUnderlyingCoinsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) PoolId(poolId string) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) Execute() ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	return r.ApiService.CurveGetUnderlyingCoinsHistoricalExecute(r)
}

/*
CurveGetUnderlyingCoinsHistorical UnderlyingCoins (historical)

Gets underlying coins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetUnderlyingCoinsHistoricalRequest
*/
func (a *CurveApiService) CurveGetUnderlyingCoinsHistorical(ctx context.Context) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	return ApiCurveGetUnderlyingCoinsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveUnderlyingCoinDTO
func (a *CurveApiService) CurveGetUnderlyingCoinsHistoricalExecute(r ApiCurveGetUnderlyingCoinsHistoricalRequest) ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveUnderlyingCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetUnderlyingCoinsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/underlyingCoins/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetVotingAppDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetVotingAppDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetVotingAppDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetVotingAppDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetVotingAppDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetVotingAppDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetVotingAppDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetVotingAppDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetVotingAppDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetVotingAppDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetVotingAppDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetVotingAppDTOsHistoricalRequest) Execute() ([]CurveVotingAppDTO, *http.Response, error) {
	return r.ApiService.CurveGetVotingAppDTOsHistoricalExecute(r)
}

/*
CurveGetVotingAppDTOsHistorical VotingAppDTOs (historical) ðŸ”¥

Gets VotingAppDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetVotingAppDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetVotingAppDTOsHistorical(ctx context.Context) ApiCurveGetVotingAppDTOsHistoricalRequest {
	return ApiCurveGetVotingAppDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveVotingAppDTO
func (a *CurveApiService) CurveGetVotingAppDTOsHistoricalExecute(r ApiCurveGetVotingAppDTOsHistoricalRequest) ([]CurveVotingAppDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveVotingAppDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetVotingAppDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/VotingAppDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetVotingAppsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiCurveGetVotingAppsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetVotingAppsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetVotingAppsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetVotingAppsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetVotingAppsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetVotingAppsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetVotingAppsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetVotingAppsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetVotingAppsHistoricalRequest) Execute() ([]CurveVotingAppDTO, *http.Response, error) {
	return r.ApiService.CurveGetVotingAppsHistoricalExecute(r)
}

/*
CurveGetVotingAppsHistorical VotingApps (historical)

Gets voting apps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetVotingAppsHistoricalRequest
*/
func (a *CurveApiService) CurveGetVotingAppsHistorical(ctx context.Context) ApiCurveGetVotingAppsHistoricalRequest {
	return ApiCurveGetVotingAppsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveVotingAppDTO
func (a *CurveApiService) CurveGetVotingAppsHistoricalExecute(r ApiCurveGetVotingAppsHistoricalRequest) ([]CurveVotingAppDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveVotingAppDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetVotingAppsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/votingApps/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetWeeklyVolumeDTOsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetWeeklyVolumeDTOsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetWeeklyVolumeDTOsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetWeeklyVolumeDTOsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetWeeklyVolumeDTOsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetWeeklyVolumeDTOsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetWeeklyVolumeDTOsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetWeeklyVolumeDTOsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetWeeklyVolumeDTOsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetWeeklyVolumeDTOsHistoricalRequest) PoolId(poolId string) ApiCurveGetWeeklyVolumeDTOsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetWeeklyVolumeDTOsHistoricalRequest) Execute() ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetWeeklyVolumeDTOsHistoricalExecute(r)
}

/*
CurveGetWeeklyVolumeDTOsHistorical WeeklyVolumeDTOs (historical) ðŸ”¥

Gets WeeklyVolumeDTOs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetWeeklyVolumeDTOsHistoricalRequest
*/
func (a *CurveApiService) CurveGetWeeklyVolumeDTOsHistorical(ctx context.Context) ApiCurveGetWeeklyVolumeDTOsHistoricalRequest {
	return ApiCurveGetWeeklyVolumeDTOsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveWeeklyVolumeDTO
func (a *CurveApiService) CurveGetWeeklyVolumeDTOsHistoricalExecute(r ApiCurveGetWeeklyVolumeDTOsHistoricalRequest) ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveWeeklyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetWeeklyVolumeDTOsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/WeeklyVolumeDTOs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetWeeklyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) PoolId(poolId string) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiCurveGetWeeklyVolumesHistoricalRequest) Execute() ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetWeeklyVolumesHistoricalExecute(r)
}

/*
CurveGetWeeklyVolumesHistorical WeeklyVolumes (historical)

Gets weekly volumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetWeeklyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetWeeklyVolumesHistorical(ctx context.Context) ApiCurveGetWeeklyVolumesHistoricalRequest {
	return ApiCurveGetWeeklyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveWeeklyVolumeDTO
func (a *CurveApiService) CurveGetWeeklyVolumesHistoricalExecute(r ApiCurveGetWeeklyVolumesHistoricalRequest) ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveWeeklyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetWeeklyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/weeklyVolumes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
