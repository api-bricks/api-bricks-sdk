{-
   OnChain API

    This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

   OpenAPI Version: 3.0.1
   OnChain API API version: v1
   Contact: support@coinapi.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OnChain.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OnChain.Model where

import OnChain.Core
import OnChain.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** EndBlock
newtype EndBlock = EndBlock { unEndBlock :: Integer } deriving (P.Eq, P.Show)

-- ** EndDate
newtype EndDate = EndDate { unEndDate :: DateTime } deriving (P.Eq, P.Show)

-- ** FilterPoolId
newtype FilterPoolId = FilterPoolId { unFilterPoolId :: Text } deriving (P.Eq, P.Show)

-- ** FilterTokenId
newtype FilterTokenId = FilterTokenId { unFilterTokenId :: Text } deriving (P.Eq, P.Show)

-- ** PoolId
newtype PoolId = PoolId { unPoolId :: Text } deriving (P.Eq, P.Show)

-- ** StartBlock
newtype StartBlock = StartBlock { unStartBlock :: Integer } deriving (P.Eq, P.Show)

-- ** StartDate
newtype StartDate = StartDate { unStartDate :: DateTime } deriving (P.Eq, P.Show)

-- ** TokenId
newtype TokenId = TokenId { unTokenId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** CowOrderDTO
-- | CowOrderDTO
data CowOrderDTO = CowOrderDTO
  { cowOrderDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cowOrderDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cowOrderDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cowOrderDTOId :: !(Maybe Text) -- ^ "id" - User&#39;s address.
  , cowOrderDTOOwner :: !(Maybe Text) -- ^ "owner" - User&#39;s address.
  , cowOrderDTOTradesTimestamp :: !(Maybe Text) -- ^ "trades_timestamp" - Block&#39;s timestamp on trade event.
  , cowOrderDTOInvalidateTimestamp :: !(Maybe Text) -- ^ "invalidate_timestamp" - Block&#39;s timestamp on invalidate event.
  , cowOrderDTOPresignTimestamp :: !(Maybe Text) -- ^ "presign_timestamp" - Block&#39;s timestamp on presign event.
  , cowOrderDTOIsSigned :: !(Maybe Bool) -- ^ "is_signed" - Determines whether order is signed.
  , cowOrderDTOIsValid :: !(Maybe Bool) -- ^ "is_valid" - Determines whether order is valid.
  , cowOrderDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CowOrderDTO
instance A.FromJSON CowOrderDTO where
  parseJSON = A.withObject "CowOrderDTO" $ \o ->
    CowOrderDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "owner")
      <*> (o .:? "trades_timestamp")
      <*> (o .:? "invalidate_timestamp")
      <*> (o .:? "presign_timestamp")
      <*> (o .:? "is_signed")
      <*> (o .:? "is_valid")
      <*> (o .:? "vid")

-- | ToJSON CowOrderDTO
instance A.ToJSON CowOrderDTO where
  toJSON CowOrderDTO {..} =
   _omitNulls
      [ "entry_time" .= cowOrderDTOEntryTime
      , "recv_time" .= cowOrderDTORecvTime
      , "block_number" .= cowOrderDTOBlockNumber
      , "id" .= cowOrderDTOId
      , "owner" .= cowOrderDTOOwner
      , "trades_timestamp" .= cowOrderDTOTradesTimestamp
      , "invalidate_timestamp" .= cowOrderDTOInvalidateTimestamp
      , "presign_timestamp" .= cowOrderDTOPresignTimestamp
      , "is_signed" .= cowOrderDTOIsSigned
      , "is_valid" .= cowOrderDTOIsValid
      , "vid" .= cowOrderDTOVid
      ]


-- | Construct a value of type 'CowOrderDTO' (by applying it's required fields, if any)
mkCowOrderDTO
  :: CowOrderDTO
mkCowOrderDTO =
  CowOrderDTO
  { cowOrderDTOEntryTime = Nothing
  , cowOrderDTORecvTime = Nothing
  , cowOrderDTOBlockNumber = Nothing
  , cowOrderDTOId = Nothing
  , cowOrderDTOOwner = Nothing
  , cowOrderDTOTradesTimestamp = Nothing
  , cowOrderDTOInvalidateTimestamp = Nothing
  , cowOrderDTOPresignTimestamp = Nothing
  , cowOrderDTOIsSigned = Nothing
  , cowOrderDTOIsValid = Nothing
  , cowOrderDTOVid = Nothing
  }

-- ** CowSettlementDTO
-- | CowSettlementDTO
-- A settlement comprises a list of traded tokens with their corresponding price in the batch.
data CowSettlementDTO = CowSettlementDTO
  { cowSettlementDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cowSettlementDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cowSettlementDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cowSettlementDTOId :: !(Maybe Text) -- ^ "id" - Transaction hash.
  , cowSettlementDTOSolver :: !(Maybe Text) -- ^ "solver" - Solver&#39;s address.
  , cowSettlementDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Transaction hash.
  , cowSettlementDTOFirstTradeTimestamp :: !(Maybe Text) -- ^ "first_trade_timestamp" - First trade timestamp.
  , cowSettlementDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CowSettlementDTO
instance A.FromJSON CowSettlementDTO where
  parseJSON = A.withObject "CowSettlementDTO" $ \o ->
    CowSettlementDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "solver")
      <*> (o .:? "tx_hash")
      <*> (o .:? "first_trade_timestamp")
      <*> (o .:? "vid")

-- | ToJSON CowSettlementDTO
instance A.ToJSON CowSettlementDTO where
  toJSON CowSettlementDTO {..} =
   _omitNulls
      [ "entry_time" .= cowSettlementDTOEntryTime
      , "recv_time" .= cowSettlementDTORecvTime
      , "block_number" .= cowSettlementDTOBlockNumber
      , "id" .= cowSettlementDTOId
      , "solver" .= cowSettlementDTOSolver
      , "tx_hash" .= cowSettlementDTOTxHash
      , "first_trade_timestamp" .= cowSettlementDTOFirstTradeTimestamp
      , "vid" .= cowSettlementDTOVid
      ]


-- | Construct a value of type 'CowSettlementDTO' (by applying it's required fields, if any)
mkCowSettlementDTO
  :: CowSettlementDTO
mkCowSettlementDTO =
  CowSettlementDTO
  { cowSettlementDTOEntryTime = Nothing
  , cowSettlementDTORecvTime = Nothing
  , cowSettlementDTOBlockNumber = Nothing
  , cowSettlementDTOId = Nothing
  , cowSettlementDTOSolver = Nothing
  , cowSettlementDTOTxHash = Nothing
  , cowSettlementDTOFirstTradeTimestamp = Nothing
  , cowSettlementDTOVid = Nothing
  }

-- ** CowTokenDTO
-- | CowTokenDTO
-- Stores information for a specific token across all pairs that token is included in.
data CowTokenDTO = CowTokenDTO
  { cowTokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cowTokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cowTokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cowTokenDTOId :: !(Maybe Text) -- ^ "id" - Token&#39;s address.
  , cowTokenDTOAddress :: !(Maybe Text) -- ^ "address" - Token&#39;s address.
  , cowTokenDTOFirstTradeTimestamp :: !(Maybe Text) -- ^ "first_trade_timestamp" - First token trade block timestamp.
  , cowTokenDTOName :: !(Maybe Text) -- ^ "name" - Token name fetched by ERC20 contract call.
  , cowTokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - Token symbol fetched by contract call.
  , cowTokenDTODecimals :: !(Maybe Int) -- ^ "decimals" - Token decimals fetched by contract call.
  , cowTokenDTOTotalVolume :: !(Maybe Text) -- ^ "total_volume" - Sum of total amount traded for this token.
  , cowTokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cowTokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CowTokenDTO
instance A.FromJSON CowTokenDTO where
  parseJSON = A.withObject "CowTokenDTO" $ \o ->
    CowTokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "first_trade_timestamp")
      <*> (o .:? "name")
      <*> (o .:? "symbol")
      <*> (o .:? "decimals")
      <*> (o .:? "total_volume")
      <*> (o .:? "vid")
      <*> (o .:? "token_symbol")

-- | ToJSON CowTokenDTO
instance A.ToJSON CowTokenDTO where
  toJSON CowTokenDTO {..} =
   _omitNulls
      [ "entry_time" .= cowTokenDTOEntryTime
      , "recv_time" .= cowTokenDTORecvTime
      , "block_number" .= cowTokenDTOBlockNumber
      , "id" .= cowTokenDTOId
      , "address" .= cowTokenDTOAddress
      , "first_trade_timestamp" .= cowTokenDTOFirstTradeTimestamp
      , "name" .= cowTokenDTOName
      , "symbol" .= cowTokenDTOSymbol
      , "decimals" .= cowTokenDTODecimals
      , "total_volume" .= cowTokenDTOTotalVolume
      , "vid" .= cowTokenDTOVid
      , "token_symbol" .= cowTokenDTOTokenSymbol
      ]


-- | Construct a value of type 'CowTokenDTO' (by applying it's required fields, if any)
mkCowTokenDTO
  :: CowTokenDTO
mkCowTokenDTO =
  CowTokenDTO
  { cowTokenDTOEntryTime = Nothing
  , cowTokenDTORecvTime = Nothing
  , cowTokenDTOBlockNumber = Nothing
  , cowTokenDTOId = Nothing
  , cowTokenDTOAddress = Nothing
  , cowTokenDTOFirstTradeTimestamp = Nothing
  , cowTokenDTOName = Nothing
  , cowTokenDTOSymbol = Nothing
  , cowTokenDTODecimals = Nothing
  , cowTokenDTOTotalVolume = Nothing
  , cowTokenDTOVid = Nothing
  , cowTokenDTOTokenSymbol = Nothing
  }

-- ** CowTradeDTO
-- | CowTradeDTO
-- Trade entity.
data CowTradeDTO = CowTradeDTO
  { cowTradeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cowTradeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cowTradeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cowTradeDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;order id&gt;|&lt;transaction hash&gt;|&lt;event index&gt;.
  , cowTradeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Block&#39;s timestamp.
  , cowTradeDTOGasPrice :: !(Maybe Text) -- ^ "gas_price" - Transaction&#39;s gas price.
  , cowTradeDTOGasLimit :: !(Maybe Text) -- ^ "gas_limit" - Transaction&#39;s gas limit.
  , cowTradeDTOFeeAmount :: !(Maybe Text) -- ^ "fee_amount" - Trade&#39;s fee amount.
  , cowTradeDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Trade event transaction hash.
  , cowTradeDTOSettlement :: !(Maybe Text) -- ^ "settlement" - Reference to settlement.
  , cowTradeDTOBuyAmount :: !(Maybe Text) -- ^ "buy_amount" - Buy amount.
  , cowTradeDTOSellAmount :: !(Maybe Text) -- ^ "sell_amount" - Sell amount.
  , cowTradeDTOSellToken :: !(Maybe Text) -- ^ "sell_token" - Address of token that is sold.
  , cowTradeDTOBuyToken :: !(Maybe Text) -- ^ "buy_token" - Address of token that is bought.
  , cowTradeDTOOrder :: !(Maybe Text) -- ^ "order" - Reference to order.
  , cowTradeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cowTradeDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , cowTradeDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  , cowTradeDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , cowTradeDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , cowTradeDTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CowTradeDTO
instance A.FromJSON CowTradeDTO where
  parseJSON = A.withObject "CowTradeDTO" $ \o ->
    CowTradeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "timestamp")
      <*> (o .:? "gas_price")
      <*> (o .:? "gas_limit")
      <*> (o .:? "fee_amount")
      <*> (o .:? "tx_hash")
      <*> (o .:? "settlement")
      <*> (o .:? "buy_amount")
      <*> (o .:? "sell_amount")
      <*> (o .:? "sell_token")
      <*> (o .:? "buy_token")
      <*> (o .:? "order")
      <*> (o .:? "vid")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")

-- | ToJSON CowTradeDTO
instance A.ToJSON CowTradeDTO where
  toJSON CowTradeDTO {..} =
   _omitNulls
      [ "entry_time" .= cowTradeDTOEntryTime
      , "recv_time" .= cowTradeDTORecvTime
      , "block_number" .= cowTradeDTOBlockNumber
      , "id" .= cowTradeDTOId
      , "timestamp" .= cowTradeDTOTimestamp
      , "gas_price" .= cowTradeDTOGasPrice
      , "gas_limit" .= cowTradeDTOGasLimit
      , "fee_amount" .= cowTradeDTOFeeAmount
      , "tx_hash" .= cowTradeDTOTxHash
      , "settlement" .= cowTradeDTOSettlement
      , "buy_amount" .= cowTradeDTOBuyAmount
      , "sell_amount" .= cowTradeDTOSellAmount
      , "sell_token" .= cowTradeDTOSellToken
      , "buy_token" .= cowTradeDTOBuyToken
      , "order" .= cowTradeDTOOrder
      , "vid" .= cowTradeDTOVid
      , "pool_id" .= cowTradeDTOPoolId
      , "transaction_id" .= cowTradeDTOTransactionId
      , "evaluated_price" .= cowTradeDTOEvaluatedPrice
      , "evaluated_amount" .= cowTradeDTOEvaluatedAmount
      , "evaluated_aggressor" .= cowTradeDTOEvaluatedAggressor
      ]


-- | Construct a value of type 'CowTradeDTO' (by applying it's required fields, if any)
mkCowTradeDTO
  :: CowTradeDTO
mkCowTradeDTO =
  CowTradeDTO
  { cowTradeDTOEntryTime = Nothing
  , cowTradeDTORecvTime = Nothing
  , cowTradeDTOBlockNumber = Nothing
  , cowTradeDTOId = Nothing
  , cowTradeDTOTimestamp = Nothing
  , cowTradeDTOGasPrice = Nothing
  , cowTradeDTOGasLimit = Nothing
  , cowTradeDTOFeeAmount = Nothing
  , cowTradeDTOTxHash = Nothing
  , cowTradeDTOSettlement = Nothing
  , cowTradeDTOBuyAmount = Nothing
  , cowTradeDTOSellAmount = Nothing
  , cowTradeDTOSellToken = Nothing
  , cowTradeDTOBuyToken = Nothing
  , cowTradeDTOOrder = Nothing
  , cowTradeDTOVid = Nothing
  , cowTradeDTOPoolId = Nothing
  , cowTradeDTOTransactionId = Nothing
  , cowTradeDTOEvaluatedPrice = Nothing
  , cowTradeDTOEvaluatedAmount = Nothing
  , cowTradeDTOEvaluatedAggressor = Nothing
  }

-- ** CowUserDTO
-- | CowUserDTO
data CowUserDTO = CowUserDTO
  { cowUserDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cowUserDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cowUserDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cowUserDTOId :: !(Maybe Text) -- ^ "id" - User&#39;s address.
  , cowUserDTOAddress :: !(Maybe Text) -- ^ "address" - User&#39;s address.
  , cowUserDTOFirstTradeTimestamp :: !(Maybe Text) -- ^ "first_trade_timestamp" - First trade block timestamp.
  , cowUserDTOIsSolver :: !(Maybe Bool) -- ^ "is_solver" - Determines if user has solved a settlement.
  , cowUserDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CowUserDTO
instance A.FromJSON CowUserDTO where
  parseJSON = A.withObject "CowUserDTO" $ \o ->
    CowUserDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "first_trade_timestamp")
      <*> (o .:? "is_solver")
      <*> (o .:? "vid")

-- | ToJSON CowUserDTO
instance A.ToJSON CowUserDTO where
  toJSON CowUserDTO {..} =
   _omitNulls
      [ "entry_time" .= cowUserDTOEntryTime
      , "recv_time" .= cowUserDTORecvTime
      , "block_number" .= cowUserDTOBlockNumber
      , "id" .= cowUserDTOId
      , "address" .= cowUserDTOAddress
      , "first_trade_timestamp" .= cowUserDTOFirstTradeTimestamp
      , "is_solver" .= cowUserDTOIsSolver
      , "vid" .= cowUserDTOVid
      ]


-- | Construct a value of type 'CowUserDTO' (by applying it's required fields, if any)
mkCowUserDTO
  :: CowUserDTO
mkCowUserDTO =
  CowUserDTO
  { cowUserDTOEntryTime = Nothing
  , cowUserDTORecvTime = Nothing
  , cowUserDTOBlockNumber = Nothing
  , cowUserDTOId = Nothing
  , cowUserDTOAddress = Nothing
  , cowUserDTOFirstTradeTimestamp = Nothing
  , cowUserDTOIsSolver = Nothing
  , cowUserDTOVid = Nothing
  }

-- ** CurveAccountDTO
-- | CurveAccountDTO
data CurveAccountDTO = CurveAccountDTO
  { curveAccountDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveAccountDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveAccountDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveAccountDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveAccountDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveAccountDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveAccountDTO
instance A.FromJSON CurveAccountDTO where
  parseJSON = A.withObject "CurveAccountDTO" $ \o ->
    CurveAccountDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "vid")

-- | ToJSON CurveAccountDTO
instance A.ToJSON CurveAccountDTO where
  toJSON CurveAccountDTO {..} =
   _omitNulls
      [ "entry_time" .= curveAccountDTOEntryTime
      , "recv_time" .= curveAccountDTORecvTime
      , "block_number" .= curveAccountDTOBlockNumber
      , "id" .= curveAccountDTOId
      , "address" .= curveAccountDTOAddress
      , "vid" .= curveAccountDTOVid
      ]


-- | Construct a value of type 'CurveAccountDTO' (by applying it's required fields, if any)
mkCurveAccountDTO
  :: CurveAccountDTO
mkCurveAccountDTO =
  CurveAccountDTO
  { curveAccountDTOEntryTime = Nothing
  , curveAccountDTORecvTime = Nothing
  , curveAccountDTOBlockNumber = Nothing
  , curveAccountDTOId = Nothing
  , curveAccountDTOAddress = Nothing
  , curveAccountDTOVid = Nothing
  }

-- ** CurveAddLiquidityEventDTO
-- | CurveAddLiquidityEventDTO
data CurveAddLiquidityEventDTO = CurveAddLiquidityEventDTO
  { curveAddLiquidityEventDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveAddLiquidityEventDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveAddLiquidityEventDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveAddLiquidityEventDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveAddLiquidityEventDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveAddLiquidityEventDTOProvider :: !(Maybe Text) -- ^ "provider" - 
  , curveAddLiquidityEventDTOTokenAmounts :: !(Maybe [Text]) -- ^ "token_amounts" - 
  , curveAddLiquidityEventDTOFees :: !(Maybe [Text]) -- ^ "fees" - 
  , curveAddLiquidityEventDTOInvariant :: !(Maybe Text) -- ^ "invariant" - 
  , curveAddLiquidityEventDTOTokenSupply :: !(Maybe Text) -- ^ "token_supply" - 
  , curveAddLiquidityEventDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveAddLiquidityEventDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveAddLiquidityEventDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveAddLiquidityEventDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveAddLiquidityEventDTO
instance A.FromJSON CurveAddLiquidityEventDTO where
  parseJSON = A.withObject "CurveAddLiquidityEventDTO" $ \o ->
    CurveAddLiquidityEventDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "provider")
      <*> (o .:? "token_amounts")
      <*> (o .:? "fees")
      <*> (o .:? "invariant")
      <*> (o .:? "token_supply")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveAddLiquidityEventDTO
instance A.ToJSON CurveAddLiquidityEventDTO where
  toJSON CurveAddLiquidityEventDTO {..} =
   _omitNulls
      [ "entry_time" .= curveAddLiquidityEventDTOEntryTime
      , "recv_time" .= curveAddLiquidityEventDTORecvTime
      , "block_number" .= curveAddLiquidityEventDTOBlockNumber
      , "id" .= curveAddLiquidityEventDTOId
      , "pool" .= curveAddLiquidityEventDTOPool
      , "provider" .= curveAddLiquidityEventDTOProvider
      , "token_amounts" .= curveAddLiquidityEventDTOTokenAmounts
      , "fees" .= curveAddLiquidityEventDTOFees
      , "invariant" .= curveAddLiquidityEventDTOInvariant
      , "token_supply" .= curveAddLiquidityEventDTOTokenSupply
      , "block" .= curveAddLiquidityEventDTOBlock
      , "timestamp" .= curveAddLiquidityEventDTOTimestamp
      , "transaction" .= curveAddLiquidityEventDTOTransaction
      , "vid" .= curveAddLiquidityEventDTOVid
      ]


-- | Construct a value of type 'CurveAddLiquidityEventDTO' (by applying it's required fields, if any)
mkCurveAddLiquidityEventDTO
  :: CurveAddLiquidityEventDTO
mkCurveAddLiquidityEventDTO =
  CurveAddLiquidityEventDTO
  { curveAddLiquidityEventDTOEntryTime = Nothing
  , curveAddLiquidityEventDTORecvTime = Nothing
  , curveAddLiquidityEventDTOBlockNumber = Nothing
  , curveAddLiquidityEventDTOId = Nothing
  , curveAddLiquidityEventDTOPool = Nothing
  , curveAddLiquidityEventDTOProvider = Nothing
  , curveAddLiquidityEventDTOTokenAmounts = Nothing
  , curveAddLiquidityEventDTOFees = Nothing
  , curveAddLiquidityEventDTOInvariant = Nothing
  , curveAddLiquidityEventDTOTokenSupply = Nothing
  , curveAddLiquidityEventDTOBlock = Nothing
  , curveAddLiquidityEventDTOTimestamp = Nothing
  , curveAddLiquidityEventDTOTransaction = Nothing
  , curveAddLiquidityEventDTOVid = Nothing
  }

-- ** CurveAdminFeeChangeLogDTO
-- | CurveAdminFeeChangeLogDTO
data CurveAdminFeeChangeLogDTO = CurveAdminFeeChangeLogDTO
  { curveAdminFeeChangeLogDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveAdminFeeChangeLogDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveAdminFeeChangeLogDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveAdminFeeChangeLogDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveAdminFeeChangeLogDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveAdminFeeChangeLogDTOValue :: !(Maybe Text) -- ^ "value" - 
  , curveAdminFeeChangeLogDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveAdminFeeChangeLogDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveAdminFeeChangeLogDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveAdminFeeChangeLogDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveAdminFeeChangeLogDTO
instance A.FromJSON CurveAdminFeeChangeLogDTO where
  parseJSON = A.withObject "CurveAdminFeeChangeLogDTO" $ \o ->
    CurveAdminFeeChangeLogDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "value")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveAdminFeeChangeLogDTO
instance A.ToJSON CurveAdminFeeChangeLogDTO where
  toJSON CurveAdminFeeChangeLogDTO {..} =
   _omitNulls
      [ "entry_time" .= curveAdminFeeChangeLogDTOEntryTime
      , "recv_time" .= curveAdminFeeChangeLogDTORecvTime
      , "block_number" .= curveAdminFeeChangeLogDTOBlockNumber
      , "id" .= curveAdminFeeChangeLogDTOId
      , "pool" .= curveAdminFeeChangeLogDTOPool
      , "value" .= curveAdminFeeChangeLogDTOValue
      , "block" .= curveAdminFeeChangeLogDTOBlock
      , "timestamp" .= curveAdminFeeChangeLogDTOTimestamp
      , "transaction" .= curveAdminFeeChangeLogDTOTransaction
      , "vid" .= curveAdminFeeChangeLogDTOVid
      ]


-- | Construct a value of type 'CurveAdminFeeChangeLogDTO' (by applying it's required fields, if any)
mkCurveAdminFeeChangeLogDTO
  :: CurveAdminFeeChangeLogDTO
mkCurveAdminFeeChangeLogDTO =
  CurveAdminFeeChangeLogDTO
  { curveAdminFeeChangeLogDTOEntryTime = Nothing
  , curveAdminFeeChangeLogDTORecvTime = Nothing
  , curveAdminFeeChangeLogDTOBlockNumber = Nothing
  , curveAdminFeeChangeLogDTOId = Nothing
  , curveAdminFeeChangeLogDTOPool = Nothing
  , curveAdminFeeChangeLogDTOValue = Nothing
  , curveAdminFeeChangeLogDTOBlock = Nothing
  , curveAdminFeeChangeLogDTOTimestamp = Nothing
  , curveAdminFeeChangeLogDTOTransaction = Nothing
  , curveAdminFeeChangeLogDTOVid = Nothing
  }

-- ** CurveAmplificationCoeffChangeLogDTO
-- | CurveAmplificationCoeffChangeLogDTO
data CurveAmplificationCoeffChangeLogDTO = CurveAmplificationCoeffChangeLogDTO
  { curveAmplificationCoeffChangeLogDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveAmplificationCoeffChangeLogDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveAmplificationCoeffChangeLogDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveAmplificationCoeffChangeLogDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveAmplificationCoeffChangeLogDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveAmplificationCoeffChangeLogDTOValue :: !(Maybe Text) -- ^ "value" - 
  , curveAmplificationCoeffChangeLogDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveAmplificationCoeffChangeLogDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveAmplificationCoeffChangeLogDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveAmplificationCoeffChangeLogDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveAmplificationCoeffChangeLogDTO
instance A.FromJSON CurveAmplificationCoeffChangeLogDTO where
  parseJSON = A.withObject "CurveAmplificationCoeffChangeLogDTO" $ \o ->
    CurveAmplificationCoeffChangeLogDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "value")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveAmplificationCoeffChangeLogDTO
instance A.ToJSON CurveAmplificationCoeffChangeLogDTO where
  toJSON CurveAmplificationCoeffChangeLogDTO {..} =
   _omitNulls
      [ "entry_time" .= curveAmplificationCoeffChangeLogDTOEntryTime
      , "recv_time" .= curveAmplificationCoeffChangeLogDTORecvTime
      , "block_number" .= curveAmplificationCoeffChangeLogDTOBlockNumber
      , "id" .= curveAmplificationCoeffChangeLogDTOId
      , "pool" .= curveAmplificationCoeffChangeLogDTOPool
      , "value" .= curveAmplificationCoeffChangeLogDTOValue
      , "block" .= curveAmplificationCoeffChangeLogDTOBlock
      , "timestamp" .= curveAmplificationCoeffChangeLogDTOTimestamp
      , "transaction" .= curveAmplificationCoeffChangeLogDTOTransaction
      , "vid" .= curveAmplificationCoeffChangeLogDTOVid
      ]


-- | Construct a value of type 'CurveAmplificationCoeffChangeLogDTO' (by applying it's required fields, if any)
mkCurveAmplificationCoeffChangeLogDTO
  :: CurveAmplificationCoeffChangeLogDTO
mkCurveAmplificationCoeffChangeLogDTO =
  CurveAmplificationCoeffChangeLogDTO
  { curveAmplificationCoeffChangeLogDTOEntryTime = Nothing
  , curveAmplificationCoeffChangeLogDTORecvTime = Nothing
  , curveAmplificationCoeffChangeLogDTOBlockNumber = Nothing
  , curveAmplificationCoeffChangeLogDTOId = Nothing
  , curveAmplificationCoeffChangeLogDTOPool = Nothing
  , curveAmplificationCoeffChangeLogDTOValue = Nothing
  , curveAmplificationCoeffChangeLogDTOBlock = Nothing
  , curveAmplificationCoeffChangeLogDTOTimestamp = Nothing
  , curveAmplificationCoeffChangeLogDTOTransaction = Nothing
  , curveAmplificationCoeffChangeLogDTOVid = Nothing
  }

-- ** CurveCoinDTO
-- | CurveCoinDTO
data CurveCoinDTO = CurveCoinDTO
  { curveCoinDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveCoinDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveCoinDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveCoinDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;pool_id&gt;-&lt;coin_index&gt;.
  , curveCoinDTOIndex :: !(Maybe Int) -- ^ "index" - Coin index.
  , curveCoinDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveCoinDTOToken :: !(Maybe Text) -- ^ "token" - 
  , curveCoinDTOUnderlying :: !(Maybe Text) -- ^ "underlying" - 
  , curveCoinDTOBalance :: !(Maybe Text) -- ^ "balance" - 
  , curveCoinDTORate :: !(Maybe Text) -- ^ "rate" - Exchange rate between this coin and the associated underlying coin within the pool.
  , curveCoinDTOUpdated :: !(Maybe Text) -- ^ "updated" - 
  , curveCoinDTOUpdatedAtBlock :: !(Maybe Text) -- ^ "updated_at_block" - 
  , curveCoinDTOUpdatedAtTransaction :: !(Maybe Text) -- ^ "updated_at_transaction" - 
  , curveCoinDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curveCoinDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveCoinDTO
instance A.FromJSON CurveCoinDTO where
  parseJSON = A.withObject "CurveCoinDTO" $ \o ->
    CurveCoinDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "index")
      <*> (o .:? "pool")
      <*> (o .:? "token")
      <*> (o .:? "underlying")
      <*> (o .:? "balance")
      <*> (o .:? "rate")
      <*> (o .:? "updated")
      <*> (o .:? "updated_at_block")
      <*> (o .:? "updated_at_transaction")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON CurveCoinDTO
instance A.ToJSON CurveCoinDTO where
  toJSON CurveCoinDTO {..} =
   _omitNulls
      [ "entry_time" .= curveCoinDTOEntryTime
      , "recv_time" .= curveCoinDTORecvTime
      , "block_number" .= curveCoinDTOBlockNumber
      , "id" .= curveCoinDTOId
      , "index" .= curveCoinDTOIndex
      , "pool" .= curveCoinDTOPool
      , "token" .= curveCoinDTOToken
      , "underlying" .= curveCoinDTOUnderlying
      , "balance" .= curveCoinDTOBalance
      , "rate" .= curveCoinDTORate
      , "updated" .= curveCoinDTOUpdated
      , "updated_at_block" .= curveCoinDTOUpdatedAtBlock
      , "updated_at_transaction" .= curveCoinDTOUpdatedAtTransaction
      , "vid" .= curveCoinDTOVid
      , "block_range" .= curveCoinDTOBlockRange
      ]


-- | Construct a value of type 'CurveCoinDTO' (by applying it's required fields, if any)
mkCurveCoinDTO
  :: CurveCoinDTO
mkCurveCoinDTO =
  CurveCoinDTO
  { curveCoinDTOEntryTime = Nothing
  , curveCoinDTORecvTime = Nothing
  , curveCoinDTOBlockNumber = Nothing
  , curveCoinDTOId = Nothing
  , curveCoinDTOIndex = Nothing
  , curveCoinDTOPool = Nothing
  , curveCoinDTOToken = Nothing
  , curveCoinDTOUnderlying = Nothing
  , curveCoinDTOBalance = Nothing
  , curveCoinDTORate = Nothing
  , curveCoinDTOUpdated = Nothing
  , curveCoinDTOUpdatedAtBlock = Nothing
  , curveCoinDTOUpdatedAtTransaction = Nothing
  , curveCoinDTOVid = Nothing
  , curveCoinDTOBlockRange = Nothing
  }

-- ** CurveContractDTO
-- | CurveContractDTO
data CurveContractDTO = CurveContractDTO
  { curveContractDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveContractDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveContractDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveContractDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveContractDTODescription :: !(Maybe Text) -- ^ "description" - Human-readable description.
  , curveContractDTOAdded :: !(Maybe Text) -- ^ "added" - 
  , curveContractDTOAddedAtBlock :: !(Maybe Text) -- ^ "added_at_block" - 
  , curveContractDTOAddedAtTransaction :: !(Maybe Text) -- ^ "added_at_transaction" - 
  , curveContractDTOModified :: !(Maybe Text) -- ^ "modified" - 
  , curveContractDTOModifiedAtBlock :: !(Maybe Text) -- ^ "modified_at_block" - 
  , curveContractDTOModifiedAtTransaction :: !(Maybe Text) -- ^ "modified_at_transaction" - 
  , curveContractDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveContractDTO
instance A.FromJSON CurveContractDTO where
  parseJSON = A.withObject "CurveContractDTO" $ \o ->
    CurveContractDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "description")
      <*> (o .:? "added")
      <*> (o .:? "added_at_block")
      <*> (o .:? "added_at_transaction")
      <*> (o .:? "modified")
      <*> (o .:? "modified_at_block")
      <*> (o .:? "modified_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveContractDTO
instance A.ToJSON CurveContractDTO where
  toJSON CurveContractDTO {..} =
   _omitNulls
      [ "entry_time" .= curveContractDTOEntryTime
      , "recv_time" .= curveContractDTORecvTime
      , "block_number" .= curveContractDTOBlockNumber
      , "id" .= curveContractDTOId
      , "description" .= curveContractDTODescription
      , "added" .= curveContractDTOAdded
      , "added_at_block" .= curveContractDTOAddedAtBlock
      , "added_at_transaction" .= curveContractDTOAddedAtTransaction
      , "modified" .= curveContractDTOModified
      , "modified_at_block" .= curveContractDTOModifiedAtBlock
      , "modified_at_transaction" .= curveContractDTOModifiedAtTransaction
      , "vid" .= curveContractDTOVid
      ]


-- | Construct a value of type 'CurveContractDTO' (by applying it's required fields, if any)
mkCurveContractDTO
  :: CurveContractDTO
mkCurveContractDTO =
  CurveContractDTO
  { curveContractDTOEntryTime = Nothing
  , curveContractDTORecvTime = Nothing
  , curveContractDTOBlockNumber = Nothing
  , curveContractDTOId = Nothing
  , curveContractDTODescription = Nothing
  , curveContractDTOAdded = Nothing
  , curveContractDTOAddedAtBlock = Nothing
  , curveContractDTOAddedAtTransaction = Nothing
  , curveContractDTOModified = Nothing
  , curveContractDTOModifiedAtBlock = Nothing
  , curveContractDTOModifiedAtTransaction = Nothing
  , curveContractDTOVid = Nothing
  }

-- ** CurveContractVersionDTO
-- | CurveContractVersionDTO
data CurveContractVersionDTO = CurveContractVersionDTO
  { curveContractVersionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveContractVersionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveContractVersionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveContractVersionDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveContractVersionDTOContract :: !(Maybe Text) -- ^ "contract" - 
  , curveContractVersionDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveContractVersionDTOVersion :: !(Maybe Text) -- ^ "version" - 
  , curveContractVersionDTOAdded :: !(Maybe Text) -- ^ "added" - 
  , curveContractVersionDTOAddedAtBlock :: !(Maybe Text) -- ^ "added_at_block" - 
  , curveContractVersionDTOAddedAtTransaction :: !(Maybe Text) -- ^ "added_at_transaction" - 
  , curveContractVersionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveContractVersionDTO
instance A.FromJSON CurveContractVersionDTO where
  parseJSON = A.withObject "CurveContractVersionDTO" $ \o ->
    CurveContractVersionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "contract")
      <*> (o .:? "address")
      <*> (o .:? "version")
      <*> (o .:? "added")
      <*> (o .:? "added_at_block")
      <*> (o .:? "added_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveContractVersionDTO
instance A.ToJSON CurveContractVersionDTO where
  toJSON CurveContractVersionDTO {..} =
   _omitNulls
      [ "entry_time" .= curveContractVersionDTOEntryTime
      , "recv_time" .= curveContractVersionDTORecvTime
      , "block_number" .= curveContractVersionDTOBlockNumber
      , "id" .= curveContractVersionDTOId
      , "contract" .= curveContractVersionDTOContract
      , "address" .= curveContractVersionDTOAddress
      , "version" .= curveContractVersionDTOVersion
      , "added" .= curveContractVersionDTOAdded
      , "added_at_block" .= curveContractVersionDTOAddedAtBlock
      , "added_at_transaction" .= curveContractVersionDTOAddedAtTransaction
      , "vid" .= curveContractVersionDTOVid
      ]


-- | Construct a value of type 'CurveContractVersionDTO' (by applying it's required fields, if any)
mkCurveContractVersionDTO
  :: CurveContractVersionDTO
mkCurveContractVersionDTO =
  CurveContractVersionDTO
  { curveContractVersionDTOEntryTime = Nothing
  , curveContractVersionDTORecvTime = Nothing
  , curveContractVersionDTOBlockNumber = Nothing
  , curveContractVersionDTOId = Nothing
  , curveContractVersionDTOContract = Nothing
  , curveContractVersionDTOAddress = Nothing
  , curveContractVersionDTOVersion = Nothing
  , curveContractVersionDTOAdded = Nothing
  , curveContractVersionDTOAddedAtBlock = Nothing
  , curveContractVersionDTOAddedAtTransaction = Nothing
  , curveContractVersionDTOVid = Nothing
  }

-- ** CurveDailyVolumeDTO
-- | CurveDailyVolumeDTO
data CurveDailyVolumeDTO = CurveDailyVolumeDTO
  { curveDailyVolumeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveDailyVolumeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveDailyVolumeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveDailyVolumeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveDailyVolumeDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveDailyVolumeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveDailyVolumeDTOVolume :: !(Maybe Text) -- ^ "volume" - 
  , curveDailyVolumeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curveDailyVolumeDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveDailyVolumeDTO
instance A.FromJSON CurveDailyVolumeDTO where
  parseJSON = A.withObject "CurveDailyVolumeDTO" $ \o ->
    CurveDailyVolumeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "timestamp")
      <*> (o .:? "volume")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON CurveDailyVolumeDTO
instance A.ToJSON CurveDailyVolumeDTO where
  toJSON CurveDailyVolumeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveDailyVolumeDTOEntryTime
      , "recv_time" .= curveDailyVolumeDTORecvTime
      , "block_number" .= curveDailyVolumeDTOBlockNumber
      , "id" .= curveDailyVolumeDTOId
      , "pool" .= curveDailyVolumeDTOPool
      , "timestamp" .= curveDailyVolumeDTOTimestamp
      , "volume" .= curveDailyVolumeDTOVolume
      , "vid" .= curveDailyVolumeDTOVid
      , "block_range" .= curveDailyVolumeDTOBlockRange
      ]


-- | Construct a value of type 'CurveDailyVolumeDTO' (by applying it's required fields, if any)
mkCurveDailyVolumeDTO
  :: CurveDailyVolumeDTO
mkCurveDailyVolumeDTO =
  CurveDailyVolumeDTO
  { curveDailyVolumeDTOEntryTime = Nothing
  , curveDailyVolumeDTORecvTime = Nothing
  , curveDailyVolumeDTOBlockNumber = Nothing
  , curveDailyVolumeDTOId = Nothing
  , curveDailyVolumeDTOPool = Nothing
  , curveDailyVolumeDTOTimestamp = Nothing
  , curveDailyVolumeDTOVolume = Nothing
  , curveDailyVolumeDTOVid = Nothing
  , curveDailyVolumeDTOBlockRange = Nothing
  }

-- ** CurveExchangeDTO
-- | CurveExchangeDTO
data CurveExchangeDTO = CurveExchangeDTO
  { curveExchangeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveExchangeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveExchangeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveExchangeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveExchangeDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveExchangeDTOBuyer :: !(Maybe Text) -- ^ "buyer" - 
  , curveExchangeDTOReceiver :: !(Maybe Text) -- ^ "receiver" - 
  , curveExchangeDTOTokenSold :: !(Maybe Text) -- ^ "token_sold" - 
  , curveExchangeDTOTokenBought :: !(Maybe Text) -- ^ "token_bought" - 
  , curveExchangeDTOAmountSold :: !(Maybe Text) -- ^ "amount_sold" - 
  , curveExchangeDTOAmountBought :: !(Maybe Text) -- ^ "amount_bought" - 
  , curveExchangeDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveExchangeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveExchangeDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveExchangeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curveExchangeDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , curveExchangeDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , curveExchangeDTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  , curveExchangeDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , curveExchangeDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveExchangeDTO
instance A.FromJSON CurveExchangeDTO where
  parseJSON = A.withObject "CurveExchangeDTO" $ \o ->
    CurveExchangeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "buyer")
      <*> (o .:? "receiver")
      <*> (o .:? "token_sold")
      <*> (o .:? "token_bought")
      <*> (o .:? "amount_sold")
      <*> (o .:? "amount_bought")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")

-- | ToJSON CurveExchangeDTO
instance A.ToJSON CurveExchangeDTO where
  toJSON CurveExchangeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveExchangeDTOEntryTime
      , "recv_time" .= curveExchangeDTORecvTime
      , "block_number" .= curveExchangeDTOBlockNumber
      , "id" .= curveExchangeDTOId
      , "pool" .= curveExchangeDTOPool
      , "buyer" .= curveExchangeDTOBuyer
      , "receiver" .= curveExchangeDTOReceiver
      , "token_sold" .= curveExchangeDTOTokenSold
      , "token_bought" .= curveExchangeDTOTokenBought
      , "amount_sold" .= curveExchangeDTOAmountSold
      , "amount_bought" .= curveExchangeDTOAmountBought
      , "block" .= curveExchangeDTOBlock
      , "timestamp" .= curveExchangeDTOTimestamp
      , "transaction" .= curveExchangeDTOTransaction
      , "vid" .= curveExchangeDTOVid
      , "evaluated_price" .= curveExchangeDTOEvaluatedPrice
      , "evaluated_amount" .= curveExchangeDTOEvaluatedAmount
      , "evaluated_aggressor" .= curveExchangeDTOEvaluatedAggressor
      , "pool_id" .= curveExchangeDTOPoolId
      , "transaction_id" .= curveExchangeDTOTransactionId
      ]


-- | Construct a value of type 'CurveExchangeDTO' (by applying it's required fields, if any)
mkCurveExchangeDTO
  :: CurveExchangeDTO
mkCurveExchangeDTO =
  CurveExchangeDTO
  { curveExchangeDTOEntryTime = Nothing
  , curveExchangeDTORecvTime = Nothing
  , curveExchangeDTOBlockNumber = Nothing
  , curveExchangeDTOId = Nothing
  , curveExchangeDTOPool = Nothing
  , curveExchangeDTOBuyer = Nothing
  , curveExchangeDTOReceiver = Nothing
  , curveExchangeDTOTokenSold = Nothing
  , curveExchangeDTOTokenBought = Nothing
  , curveExchangeDTOAmountSold = Nothing
  , curveExchangeDTOAmountBought = Nothing
  , curveExchangeDTOBlock = Nothing
  , curveExchangeDTOTimestamp = Nothing
  , curveExchangeDTOTransaction = Nothing
  , curveExchangeDTOVid = Nothing
  , curveExchangeDTOEvaluatedPrice = Nothing
  , curveExchangeDTOEvaluatedAmount = Nothing
  , curveExchangeDTOEvaluatedAggressor = Nothing
  , curveExchangeDTOPoolId = Nothing
  , curveExchangeDTOTransactionId = Nothing
  }

-- ** CurveFeeChangeLogDTO
-- | CurveFeeChangeLogDTO
data CurveFeeChangeLogDTO = CurveFeeChangeLogDTO
  { curveFeeChangeLogDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveFeeChangeLogDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveFeeChangeLogDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveFeeChangeLogDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveFeeChangeLogDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveFeeChangeLogDTOValue :: !(Maybe Text) -- ^ "value" - 
  , curveFeeChangeLogDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveFeeChangeLogDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveFeeChangeLogDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveFeeChangeLogDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveFeeChangeLogDTO
instance A.FromJSON CurveFeeChangeLogDTO where
  parseJSON = A.withObject "CurveFeeChangeLogDTO" $ \o ->
    CurveFeeChangeLogDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "value")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveFeeChangeLogDTO
instance A.ToJSON CurveFeeChangeLogDTO where
  toJSON CurveFeeChangeLogDTO {..} =
   _omitNulls
      [ "entry_time" .= curveFeeChangeLogDTOEntryTime
      , "recv_time" .= curveFeeChangeLogDTORecvTime
      , "block_number" .= curveFeeChangeLogDTOBlockNumber
      , "id" .= curveFeeChangeLogDTOId
      , "pool" .= curveFeeChangeLogDTOPool
      , "value" .= curveFeeChangeLogDTOValue
      , "block" .= curveFeeChangeLogDTOBlock
      , "timestamp" .= curveFeeChangeLogDTOTimestamp
      , "transaction" .= curveFeeChangeLogDTOTransaction
      , "vid" .= curveFeeChangeLogDTOVid
      ]


-- | Construct a value of type 'CurveFeeChangeLogDTO' (by applying it's required fields, if any)
mkCurveFeeChangeLogDTO
  :: CurveFeeChangeLogDTO
mkCurveFeeChangeLogDTO =
  CurveFeeChangeLogDTO
  { curveFeeChangeLogDTOEntryTime = Nothing
  , curveFeeChangeLogDTORecvTime = Nothing
  , curveFeeChangeLogDTOBlockNumber = Nothing
  , curveFeeChangeLogDTOId = Nothing
  , curveFeeChangeLogDTOPool = Nothing
  , curveFeeChangeLogDTOValue = Nothing
  , curveFeeChangeLogDTOBlock = Nothing
  , curveFeeChangeLogDTOTimestamp = Nothing
  , curveFeeChangeLogDTOTransaction = Nothing
  , curveFeeChangeLogDTOVid = Nothing
  }

-- ** CurveGaugeDTO
-- | CurveGaugeDTO
data CurveGaugeDTO = CurveGaugeDTO
  { curveGaugeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveGaugeDTOType :: !(Maybe Text) -- ^ "type" - 
  , curveGaugeDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveGaugeDTOCreated :: !(Maybe Text) -- ^ "created" - 
  , curveGaugeDTOCreatedAtBlock :: !(Maybe Text) -- ^ "created_at_block" - 
  , curveGaugeDTOCreatedAtTransaction :: !(Maybe Text) -- ^ "created_at_transaction" - 
  , curveGaugeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeDTO
instance A.FromJSON CurveGaugeDTO where
  parseJSON = A.withObject "CurveGaugeDTO" $ \o ->
    CurveGaugeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "type")
      <*> (o .:? "pool")
      <*> (o .:? "created")
      <*> (o .:? "created_at_block")
      <*> (o .:? "created_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeDTO
instance A.ToJSON CurveGaugeDTO where
  toJSON CurveGaugeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeDTOEntryTime
      , "recv_time" .= curveGaugeDTORecvTime
      , "block_number" .= curveGaugeDTOBlockNumber
      , "id" .= curveGaugeDTOId
      , "address" .= curveGaugeDTOAddress
      , "type" .= curveGaugeDTOType
      , "pool" .= curveGaugeDTOPool
      , "created" .= curveGaugeDTOCreated
      , "created_at_block" .= curveGaugeDTOCreatedAtBlock
      , "created_at_transaction" .= curveGaugeDTOCreatedAtTransaction
      , "vid" .= curveGaugeDTOVid
      ]


-- | Construct a value of type 'CurveGaugeDTO' (by applying it's required fields, if any)
mkCurveGaugeDTO
  :: CurveGaugeDTO
mkCurveGaugeDTO =
  CurveGaugeDTO
  { curveGaugeDTOEntryTime = Nothing
  , curveGaugeDTORecvTime = Nothing
  , curveGaugeDTOBlockNumber = Nothing
  , curveGaugeDTOId = Nothing
  , curveGaugeDTOAddress = Nothing
  , curveGaugeDTOType = Nothing
  , curveGaugeDTOPool = Nothing
  , curveGaugeDTOCreated = Nothing
  , curveGaugeDTOCreatedAtBlock = Nothing
  , curveGaugeDTOCreatedAtTransaction = Nothing
  , curveGaugeDTOVid = Nothing
  }

-- ** CurveGaugeDepositDTO
-- | CurveGaugeDepositDTO
data CurveGaugeDepositDTO = CurveGaugeDepositDTO
  { curveGaugeDepositDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeDepositDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeDepositDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeDepositDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeDepositDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveGaugeDepositDTOProvider :: !(Maybe Text) -- ^ "provider" - 
  , curveGaugeDepositDTOValue :: !(Maybe Text) -- ^ "value" - 
  , curveGaugeDepositDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curveGaugeDepositDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeDepositDTO
instance A.FromJSON CurveGaugeDepositDTO where
  parseJSON = A.withObject "CurveGaugeDepositDTO" $ \o ->
    CurveGaugeDepositDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "gauge")
      <*> (o .:? "provider")
      <*> (o .:? "value")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON CurveGaugeDepositDTO
instance A.ToJSON CurveGaugeDepositDTO where
  toJSON CurveGaugeDepositDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeDepositDTOEntryTime
      , "recv_time" .= curveGaugeDepositDTORecvTime
      , "block_number" .= curveGaugeDepositDTOBlockNumber
      , "id" .= curveGaugeDepositDTOId
      , "gauge" .= curveGaugeDepositDTOGauge
      , "provider" .= curveGaugeDepositDTOProvider
      , "value" .= curveGaugeDepositDTOValue
      , "vid" .= curveGaugeDepositDTOVid
      , "block_range" .= curveGaugeDepositDTOBlockRange
      ]


-- | Construct a value of type 'CurveGaugeDepositDTO' (by applying it's required fields, if any)
mkCurveGaugeDepositDTO
  :: CurveGaugeDepositDTO
mkCurveGaugeDepositDTO =
  CurveGaugeDepositDTO
  { curveGaugeDepositDTOEntryTime = Nothing
  , curveGaugeDepositDTORecvTime = Nothing
  , curveGaugeDepositDTOBlockNumber = Nothing
  , curveGaugeDepositDTOId = Nothing
  , curveGaugeDepositDTOGauge = Nothing
  , curveGaugeDepositDTOProvider = Nothing
  , curveGaugeDepositDTOValue = Nothing
  , curveGaugeDepositDTOVid = Nothing
  , curveGaugeDepositDTOBlockRange = Nothing
  }

-- ** CurveGaugeLiquidityDTO
-- | CurveGaugeLiquidityDTO
data CurveGaugeLiquidityDTO = CurveGaugeLiquidityDTO
  { curveGaugeLiquidityDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeLiquidityDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeLiquidityDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeLiquidityDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeLiquidityDTOUser :: !(Maybe Text) -- ^ "user" - 
  , curveGaugeLiquidityDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveGaugeLiquidityDTOOriginalBalance :: !(Maybe Text) -- ^ "original_balance" - 
  , curveGaugeLiquidityDTOOriginalSupply :: !(Maybe Text) -- ^ "original_supply" - 
  , curveGaugeLiquidityDTOWorkingBalance :: !(Maybe Text) -- ^ "working_balance" - 
  , curveGaugeLiquidityDTOWorkingSupply :: !(Maybe Text) -- ^ "working_supply" - 
  , curveGaugeLiquidityDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveGaugeLiquidityDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveGaugeLiquidityDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveGaugeLiquidityDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeLiquidityDTO
instance A.FromJSON CurveGaugeLiquidityDTO where
  parseJSON = A.withObject "CurveGaugeLiquidityDTO" $ \o ->
    CurveGaugeLiquidityDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "gauge")
      <*> (o .:? "original_balance")
      <*> (o .:? "original_supply")
      <*> (o .:? "working_balance")
      <*> (o .:? "working_supply")
      <*> (o .:? "timestamp")
      <*> (o .:? "block")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeLiquidityDTO
instance A.ToJSON CurveGaugeLiquidityDTO where
  toJSON CurveGaugeLiquidityDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeLiquidityDTOEntryTime
      , "recv_time" .= curveGaugeLiquidityDTORecvTime
      , "block_number" .= curveGaugeLiquidityDTOBlockNumber
      , "id" .= curveGaugeLiquidityDTOId
      , "user" .= curveGaugeLiquidityDTOUser
      , "gauge" .= curveGaugeLiquidityDTOGauge
      , "original_balance" .= curveGaugeLiquidityDTOOriginalBalance
      , "original_supply" .= curveGaugeLiquidityDTOOriginalSupply
      , "working_balance" .= curveGaugeLiquidityDTOWorkingBalance
      , "working_supply" .= curveGaugeLiquidityDTOWorkingSupply
      , "timestamp" .= curveGaugeLiquidityDTOTimestamp
      , "block" .= curveGaugeLiquidityDTOBlock
      , "transaction" .= curveGaugeLiquidityDTOTransaction
      , "vid" .= curveGaugeLiquidityDTOVid
      ]


-- | Construct a value of type 'CurveGaugeLiquidityDTO' (by applying it's required fields, if any)
mkCurveGaugeLiquidityDTO
  :: CurveGaugeLiquidityDTO
mkCurveGaugeLiquidityDTO =
  CurveGaugeLiquidityDTO
  { curveGaugeLiquidityDTOEntryTime = Nothing
  , curveGaugeLiquidityDTORecvTime = Nothing
  , curveGaugeLiquidityDTOBlockNumber = Nothing
  , curveGaugeLiquidityDTOId = Nothing
  , curveGaugeLiquidityDTOUser = Nothing
  , curveGaugeLiquidityDTOGauge = Nothing
  , curveGaugeLiquidityDTOOriginalBalance = Nothing
  , curveGaugeLiquidityDTOOriginalSupply = Nothing
  , curveGaugeLiquidityDTOWorkingBalance = Nothing
  , curveGaugeLiquidityDTOWorkingSupply = Nothing
  , curveGaugeLiquidityDTOTimestamp = Nothing
  , curveGaugeLiquidityDTOBlock = Nothing
  , curveGaugeLiquidityDTOTransaction = Nothing
  , curveGaugeLiquidityDTOVid = Nothing
  }

-- ** CurveGaugeTotalWeightDTO
-- | CurveGaugeTotalWeightDTO
data CurveGaugeTotalWeightDTO = CurveGaugeTotalWeightDTO
  { curveGaugeTotalWeightDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeTotalWeightDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeTotalWeightDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeTotalWeightDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeTotalWeightDTOTime :: !(Maybe Text) -- ^ "time" - 
  , curveGaugeTotalWeightDTOWeight :: !(Maybe Text) -- ^ "weight" - 
  , curveGaugeTotalWeightDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeTotalWeightDTO
instance A.FromJSON CurveGaugeTotalWeightDTO where
  parseJSON = A.withObject "CurveGaugeTotalWeightDTO" $ \o ->
    CurveGaugeTotalWeightDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "time")
      <*> (o .:? "weight")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeTotalWeightDTO
instance A.ToJSON CurveGaugeTotalWeightDTO where
  toJSON CurveGaugeTotalWeightDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeTotalWeightDTOEntryTime
      , "recv_time" .= curveGaugeTotalWeightDTORecvTime
      , "block_number" .= curveGaugeTotalWeightDTOBlockNumber
      , "id" .= curveGaugeTotalWeightDTOId
      , "time" .= curveGaugeTotalWeightDTOTime
      , "weight" .= curveGaugeTotalWeightDTOWeight
      , "vid" .= curveGaugeTotalWeightDTOVid
      ]


-- | Construct a value of type 'CurveGaugeTotalWeightDTO' (by applying it's required fields, if any)
mkCurveGaugeTotalWeightDTO
  :: CurveGaugeTotalWeightDTO
mkCurveGaugeTotalWeightDTO =
  CurveGaugeTotalWeightDTO
  { curveGaugeTotalWeightDTOEntryTime = Nothing
  , curveGaugeTotalWeightDTORecvTime = Nothing
  , curveGaugeTotalWeightDTOBlockNumber = Nothing
  , curveGaugeTotalWeightDTOId = Nothing
  , curveGaugeTotalWeightDTOTime = Nothing
  , curveGaugeTotalWeightDTOWeight = Nothing
  , curveGaugeTotalWeightDTOVid = Nothing
  }

-- ** CurveGaugeTypeDTO
-- | CurveGaugeTypeDTO
data CurveGaugeTypeDTO = CurveGaugeTypeDTO
  { curveGaugeTypeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeTypeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeTypeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeTypeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeTypeDTOName :: !(Maybe Text) -- ^ "name" - 
  , curveGaugeTypeDTOGaugeCount :: !(Maybe Text) -- ^ "gauge_count" - 
  , curveGaugeTypeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeTypeDTO
instance A.FromJSON CurveGaugeTypeDTO where
  parseJSON = A.withObject "CurveGaugeTypeDTO" $ \o ->
    CurveGaugeTypeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "gauge_count")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeTypeDTO
instance A.ToJSON CurveGaugeTypeDTO where
  toJSON CurveGaugeTypeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeTypeDTOEntryTime
      , "recv_time" .= curveGaugeTypeDTORecvTime
      , "block_number" .= curveGaugeTypeDTOBlockNumber
      , "id" .= curveGaugeTypeDTOId
      , "name" .= curveGaugeTypeDTOName
      , "gauge_count" .= curveGaugeTypeDTOGaugeCount
      , "vid" .= curveGaugeTypeDTOVid
      ]


-- | Construct a value of type 'CurveGaugeTypeDTO' (by applying it's required fields, if any)
mkCurveGaugeTypeDTO
  :: CurveGaugeTypeDTO
mkCurveGaugeTypeDTO =
  CurveGaugeTypeDTO
  { curveGaugeTypeDTOEntryTime = Nothing
  , curveGaugeTypeDTORecvTime = Nothing
  , curveGaugeTypeDTOBlockNumber = Nothing
  , curveGaugeTypeDTOId = Nothing
  , curveGaugeTypeDTOName = Nothing
  , curveGaugeTypeDTOGaugeCount = Nothing
  , curveGaugeTypeDTOVid = Nothing
  }

-- ** CurveGaugeTypeWeightDTO
-- | CurveGaugeTypeWeightDTO
data CurveGaugeTypeWeightDTO = CurveGaugeTypeWeightDTO
  { curveGaugeTypeWeightDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeTypeWeightDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeTypeWeightDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeTypeWeightDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeTypeWeightDTOType :: !(Maybe Text) -- ^ "type" - 
  , curveGaugeTypeWeightDTOTime :: !(Maybe Text) -- ^ "time" - 
  , curveGaugeTypeWeightDTOWeight :: !(Maybe Text) -- ^ "weight" - 
  , curveGaugeTypeWeightDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeTypeWeightDTO
instance A.FromJSON CurveGaugeTypeWeightDTO where
  parseJSON = A.withObject "CurveGaugeTypeWeightDTO" $ \o ->
    CurveGaugeTypeWeightDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "time")
      <*> (o .:? "weight")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeTypeWeightDTO
instance A.ToJSON CurveGaugeTypeWeightDTO where
  toJSON CurveGaugeTypeWeightDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeTypeWeightDTOEntryTime
      , "recv_time" .= curveGaugeTypeWeightDTORecvTime
      , "block_number" .= curveGaugeTypeWeightDTOBlockNumber
      , "id" .= curveGaugeTypeWeightDTOId
      , "type" .= curveGaugeTypeWeightDTOType
      , "time" .= curveGaugeTypeWeightDTOTime
      , "weight" .= curveGaugeTypeWeightDTOWeight
      , "vid" .= curveGaugeTypeWeightDTOVid
      ]


-- | Construct a value of type 'CurveGaugeTypeWeightDTO' (by applying it's required fields, if any)
mkCurveGaugeTypeWeightDTO
  :: CurveGaugeTypeWeightDTO
mkCurveGaugeTypeWeightDTO =
  CurveGaugeTypeWeightDTO
  { curveGaugeTypeWeightDTOEntryTime = Nothing
  , curveGaugeTypeWeightDTORecvTime = Nothing
  , curveGaugeTypeWeightDTOBlockNumber = Nothing
  , curveGaugeTypeWeightDTOId = Nothing
  , curveGaugeTypeWeightDTOType = Nothing
  , curveGaugeTypeWeightDTOTime = Nothing
  , curveGaugeTypeWeightDTOWeight = Nothing
  , curveGaugeTypeWeightDTOVid = Nothing
  }

-- ** CurveGaugeWeightDTO
-- | CurveGaugeWeightDTO
data CurveGaugeWeightDTO = CurveGaugeWeightDTO
  { curveGaugeWeightDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeWeightDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeWeightDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeWeightDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeWeightDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveGaugeWeightDTOTime :: !(Maybe Text) -- ^ "time" - 
  , curveGaugeWeightDTOWeight :: !(Maybe Text) -- ^ "weight" - 
  , curveGaugeWeightDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeWeightDTO
instance A.FromJSON CurveGaugeWeightDTO where
  parseJSON = A.withObject "CurveGaugeWeightDTO" $ \o ->
    CurveGaugeWeightDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "gauge")
      <*> (o .:? "time")
      <*> (o .:? "weight")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeWeightDTO
instance A.ToJSON CurveGaugeWeightDTO where
  toJSON CurveGaugeWeightDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeWeightDTOEntryTime
      , "recv_time" .= curveGaugeWeightDTORecvTime
      , "block_number" .= curveGaugeWeightDTOBlockNumber
      , "id" .= curveGaugeWeightDTOId
      , "gauge" .= curveGaugeWeightDTOGauge
      , "time" .= curveGaugeWeightDTOTime
      , "weight" .= curveGaugeWeightDTOWeight
      , "vid" .= curveGaugeWeightDTOVid
      ]


-- | Construct a value of type 'CurveGaugeWeightDTO' (by applying it's required fields, if any)
mkCurveGaugeWeightDTO
  :: CurveGaugeWeightDTO
mkCurveGaugeWeightDTO =
  CurveGaugeWeightDTO
  { curveGaugeWeightDTOEntryTime = Nothing
  , curveGaugeWeightDTORecvTime = Nothing
  , curveGaugeWeightDTOBlockNumber = Nothing
  , curveGaugeWeightDTOId = Nothing
  , curveGaugeWeightDTOGauge = Nothing
  , curveGaugeWeightDTOTime = Nothing
  , curveGaugeWeightDTOWeight = Nothing
  , curveGaugeWeightDTOVid = Nothing
  }

-- ** CurveGaugeWeightVoteDTO
-- | CurveGaugeWeightVoteDTO
data CurveGaugeWeightVoteDTO = CurveGaugeWeightVoteDTO
  { curveGaugeWeightVoteDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeWeightVoteDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeWeightVoteDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeWeightVoteDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeWeightVoteDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveGaugeWeightVoteDTOUser :: !(Maybe Text) -- ^ "user" - 
  , curveGaugeWeightVoteDTOTime :: !(Maybe Text) -- ^ "time" - 
  , curveGaugeWeightVoteDTOWeight :: !(Maybe Text) -- ^ "weight" - 
  , curveGaugeWeightVoteDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeWeightVoteDTO
instance A.FromJSON CurveGaugeWeightVoteDTO where
  parseJSON = A.withObject "CurveGaugeWeightVoteDTO" $ \o ->
    CurveGaugeWeightVoteDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "gauge")
      <*> (o .:? "user")
      <*> (o .:? "time")
      <*> (o .:? "weight")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeWeightVoteDTO
instance A.ToJSON CurveGaugeWeightVoteDTO where
  toJSON CurveGaugeWeightVoteDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeWeightVoteDTOEntryTime
      , "recv_time" .= curveGaugeWeightVoteDTORecvTime
      , "block_number" .= curveGaugeWeightVoteDTOBlockNumber
      , "id" .= curveGaugeWeightVoteDTOId
      , "gauge" .= curveGaugeWeightVoteDTOGauge
      , "user" .= curveGaugeWeightVoteDTOUser
      , "time" .= curveGaugeWeightVoteDTOTime
      , "weight" .= curveGaugeWeightVoteDTOWeight
      , "vid" .= curveGaugeWeightVoteDTOVid
      ]


-- | Construct a value of type 'CurveGaugeWeightVoteDTO' (by applying it's required fields, if any)
mkCurveGaugeWeightVoteDTO
  :: CurveGaugeWeightVoteDTO
mkCurveGaugeWeightVoteDTO =
  CurveGaugeWeightVoteDTO
  { curveGaugeWeightVoteDTOEntryTime = Nothing
  , curveGaugeWeightVoteDTORecvTime = Nothing
  , curveGaugeWeightVoteDTOBlockNumber = Nothing
  , curveGaugeWeightVoteDTOId = Nothing
  , curveGaugeWeightVoteDTOGauge = Nothing
  , curveGaugeWeightVoteDTOUser = Nothing
  , curveGaugeWeightVoteDTOTime = Nothing
  , curveGaugeWeightVoteDTOWeight = Nothing
  , curveGaugeWeightVoteDTOVid = Nothing
  }

-- ** CurveGaugeWithdrawDTO
-- | CurveGaugeWithdrawDTO
data CurveGaugeWithdrawDTO = CurveGaugeWithdrawDTO
  { curveGaugeWithdrawDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeWithdrawDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeWithdrawDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeWithdrawDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeWithdrawDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveGaugeWithdrawDTOProvider :: !(Maybe Text) -- ^ "provider" - 
  , curveGaugeWithdrawDTOValue :: !(Maybe Text) -- ^ "value" - 
  , curveGaugeWithdrawDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeWithdrawDTO
instance A.FromJSON CurveGaugeWithdrawDTO where
  parseJSON = A.withObject "CurveGaugeWithdrawDTO" $ \o ->
    CurveGaugeWithdrawDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "gauge")
      <*> (o .:? "provider")
      <*> (o .:? "value")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeWithdrawDTO
instance A.ToJSON CurveGaugeWithdrawDTO where
  toJSON CurveGaugeWithdrawDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeWithdrawDTOEntryTime
      , "recv_time" .= curveGaugeWithdrawDTORecvTime
      , "block_number" .= curveGaugeWithdrawDTOBlockNumber
      , "id" .= curveGaugeWithdrawDTOId
      , "gauge" .= curveGaugeWithdrawDTOGauge
      , "provider" .= curveGaugeWithdrawDTOProvider
      , "value" .= curveGaugeWithdrawDTOValue
      , "vid" .= curveGaugeWithdrawDTOVid
      ]


-- | Construct a value of type 'CurveGaugeWithdrawDTO' (by applying it's required fields, if any)
mkCurveGaugeWithdrawDTO
  :: CurveGaugeWithdrawDTO
mkCurveGaugeWithdrawDTO =
  CurveGaugeWithdrawDTO
  { curveGaugeWithdrawDTOEntryTime = Nothing
  , curveGaugeWithdrawDTORecvTime = Nothing
  , curveGaugeWithdrawDTOBlockNumber = Nothing
  , curveGaugeWithdrawDTOId = Nothing
  , curveGaugeWithdrawDTOGauge = Nothing
  , curveGaugeWithdrawDTOProvider = Nothing
  , curveGaugeWithdrawDTOValue = Nothing
  , curveGaugeWithdrawDTOVid = Nothing
  }

-- ** CurveHourlyVolumeDTO
-- | CurveHourlyVolumeDTO
data CurveHourlyVolumeDTO = CurveHourlyVolumeDTO
  { curveHourlyVolumeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveHourlyVolumeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveHourlyVolumeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveHourlyVolumeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveHourlyVolumeDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveHourlyVolumeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveHourlyVolumeDTOVolume :: !(Maybe Text) -- ^ "volume" - 
  , curveHourlyVolumeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveHourlyVolumeDTO
instance A.FromJSON CurveHourlyVolumeDTO where
  parseJSON = A.withObject "CurveHourlyVolumeDTO" $ \o ->
    CurveHourlyVolumeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "timestamp")
      <*> (o .:? "volume")
      <*> (o .:? "vid")

-- | ToJSON CurveHourlyVolumeDTO
instance A.ToJSON CurveHourlyVolumeDTO where
  toJSON CurveHourlyVolumeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveHourlyVolumeDTOEntryTime
      , "recv_time" .= curveHourlyVolumeDTORecvTime
      , "block_number" .= curveHourlyVolumeDTOBlockNumber
      , "id" .= curveHourlyVolumeDTOId
      , "pool" .= curveHourlyVolumeDTOPool
      , "timestamp" .= curveHourlyVolumeDTOTimestamp
      , "volume" .= curveHourlyVolumeDTOVolume
      , "vid" .= curveHourlyVolumeDTOVid
      ]


-- | Construct a value of type 'CurveHourlyVolumeDTO' (by applying it's required fields, if any)
mkCurveHourlyVolumeDTO
  :: CurveHourlyVolumeDTO
mkCurveHourlyVolumeDTO =
  CurveHourlyVolumeDTO
  { curveHourlyVolumeDTOEntryTime = Nothing
  , curveHourlyVolumeDTORecvTime = Nothing
  , curveHourlyVolumeDTOBlockNumber = Nothing
  , curveHourlyVolumeDTOId = Nothing
  , curveHourlyVolumeDTOPool = Nothing
  , curveHourlyVolumeDTOTimestamp = Nothing
  , curveHourlyVolumeDTOVolume = Nothing
  , curveHourlyVolumeDTOVid = Nothing
  }

-- ** CurveLpTokenDTO
-- | CurveLpTokenDTO
data CurveLpTokenDTO = CurveLpTokenDTO
  { curveLpTokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveLpTokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveLpTokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveLpTokenDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveLpTokenDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveLpTokenDTODecimals :: !(Maybe Text) -- ^ "decimals" - 
  , curveLpTokenDTOName :: !(Maybe Text) -- ^ "name" - 
  , curveLpTokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - 
  , curveLpTokenDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveLpTokenDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveLpTokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveLpTokenDTO
instance A.FromJSON CurveLpTokenDTO where
  parseJSON = A.withObject "CurveLpTokenDTO" $ \o ->
    CurveLpTokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "decimals")
      <*> (o .:? "name")
      <*> (o .:? "symbol")
      <*> (o .:? "gauge")
      <*> (o .:? "pool")
      <*> (o .:? "vid")

-- | ToJSON CurveLpTokenDTO
instance A.ToJSON CurveLpTokenDTO where
  toJSON CurveLpTokenDTO {..} =
   _omitNulls
      [ "entry_time" .= curveLpTokenDTOEntryTime
      , "recv_time" .= curveLpTokenDTORecvTime
      , "block_number" .= curveLpTokenDTOBlockNumber
      , "id" .= curveLpTokenDTOId
      , "address" .= curveLpTokenDTOAddress
      , "decimals" .= curveLpTokenDTODecimals
      , "name" .= curveLpTokenDTOName
      , "symbol" .= curveLpTokenDTOSymbol
      , "gauge" .= curveLpTokenDTOGauge
      , "pool" .= curveLpTokenDTOPool
      , "vid" .= curveLpTokenDTOVid
      ]


-- | Construct a value of type 'CurveLpTokenDTO' (by applying it's required fields, if any)
mkCurveLpTokenDTO
  :: CurveLpTokenDTO
mkCurveLpTokenDTO =
  CurveLpTokenDTO
  { curveLpTokenDTOEntryTime = Nothing
  , curveLpTokenDTORecvTime = Nothing
  , curveLpTokenDTOBlockNumber = Nothing
  , curveLpTokenDTOId = Nothing
  , curveLpTokenDTOAddress = Nothing
  , curveLpTokenDTODecimals = Nothing
  , curveLpTokenDTOName = Nothing
  , curveLpTokenDTOSymbol = Nothing
  , curveLpTokenDTOGauge = Nothing
  , curveLpTokenDTOPool = Nothing
  , curveLpTokenDTOVid = Nothing
  }

-- ** CurvePoolDTO
-- | CurvePoolDTO
data CurvePoolDTO = CurvePoolDTO
  { curvePoolDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curvePoolDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curvePoolDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curvePoolDTOId :: !(Maybe Text) -- ^ "id" - Pool address.
  , curvePoolDTOName :: !(Maybe Text) -- ^ "name" - Pool&#39;s human-readable name.
  , curvePoolDTOIsMeta :: !(Maybe Bool) -- ^ "is_meta" - Identify whether pool is a metapool.
  , curvePoolDTORegistryAddress :: !(Maybe Text) -- ^ "registry_address" - Registry contract address from where this pool was registered.
  , curvePoolDTOSwapAddress :: !(Maybe Text) -- ^ "swap_address" - Swap contract address.
  , curvePoolDTOLpToken :: !(Maybe Text) -- ^ "lp_token" - Address of the token representing LP share.
  , curvePoolDTOCoinCount :: !(Maybe Text) -- ^ "coin_count" - Number of coins composing the pool.
  , curvePoolDTOUnderlyingCount :: !(Maybe Text) -- ^ "underlying_count" - Number of underlying coins composing the pool.
  , curvePoolDTOA :: !(Maybe Text) -- ^ "a" - Amplification coefficient multiplied by n * (n - 1).
  , curvePoolDTOFee :: !(Maybe Text) -- ^ "fee" - Fee to charge for exchanges.
  , curvePoolDTOAdminFee :: !(Maybe Text) -- ^ "admin_fee" - Admin fee is represented as a percentage of the total fee collected on a swap.
  , curvePoolDTOOwner :: !(Maybe Text) -- ^ "owner" - Admin address.
  , curvePoolDTOVirtualPrice :: !(Maybe Text) -- ^ "virtual_price" - Average dollar value of pool token.
  , curvePoolDTOLocked :: !(Maybe Text) -- ^ "locked" - 
  , curvePoolDTOAddedAt :: !(Maybe DateTime) -- ^ "added_at" - 
  , curvePoolDTOAddedAtBlock :: !(Maybe Text) -- ^ "added_at_block" - 
  , curvePoolDTOAddedAtTransaction :: !(Maybe Text) -- ^ "added_at_transaction" - 
  , curvePoolDTORemovedAt :: !(Maybe Text) -- ^ "removed_at" - 
  , curvePoolDTORemovedAtBlock :: !(Maybe Text) -- ^ "removed_at_block" - 
  , curvePoolDTORemovedAtTransaction :: !(Maybe Text) -- ^ "removed_at_transaction" - 
  , curvePoolDTOExchangeCount :: !(Maybe Text) -- ^ "exchange_count" - 
  , curvePoolDTOGaugeCount :: !(Maybe Text) -- ^ "gauge_count" - 
  , curvePoolDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curvePoolDTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurvePoolDTO
instance A.FromJSON CurvePoolDTO where
  parseJSON = A.withObject "CurvePoolDTO" $ \o ->
    CurvePoolDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "is_meta")
      <*> (o .:? "registry_address")
      <*> (o .:? "swap_address")
      <*> (o .:? "lp_token")
      <*> (o .:? "coin_count")
      <*> (o .:? "underlying_count")
      <*> (o .:? "a")
      <*> (o .:? "fee")
      <*> (o .:? "admin_fee")
      <*> (o .:? "owner")
      <*> (o .:? "virtual_price")
      <*> (o .:? "locked")
      <*> (o .:? "added_at")
      <*> (o .:? "added_at_block")
      <*> (o .:? "added_at_transaction")
      <*> (o .:? "removed_at")
      <*> (o .:? "removed_at_block")
      <*> (o .:? "removed_at_transaction")
      <*> (o .:? "exchange_count")
      <*> (o .:? "gauge_count")
      <*> (o .:? "vid")
      <*> (o .:? "evaluated_ask")

-- | ToJSON CurvePoolDTO
instance A.ToJSON CurvePoolDTO where
  toJSON CurvePoolDTO {..} =
   _omitNulls
      [ "entry_time" .= curvePoolDTOEntryTime
      , "recv_time" .= curvePoolDTORecvTime
      , "block_number" .= curvePoolDTOBlockNumber
      , "id" .= curvePoolDTOId
      , "name" .= curvePoolDTOName
      , "is_meta" .= curvePoolDTOIsMeta
      , "registry_address" .= curvePoolDTORegistryAddress
      , "swap_address" .= curvePoolDTOSwapAddress
      , "lp_token" .= curvePoolDTOLpToken
      , "coin_count" .= curvePoolDTOCoinCount
      , "underlying_count" .= curvePoolDTOUnderlyingCount
      , "a" .= curvePoolDTOA
      , "fee" .= curvePoolDTOFee
      , "admin_fee" .= curvePoolDTOAdminFee
      , "owner" .= curvePoolDTOOwner
      , "virtual_price" .= curvePoolDTOVirtualPrice
      , "locked" .= curvePoolDTOLocked
      , "added_at" .= curvePoolDTOAddedAt
      , "added_at_block" .= curvePoolDTOAddedAtBlock
      , "added_at_transaction" .= curvePoolDTOAddedAtTransaction
      , "removed_at" .= curvePoolDTORemovedAt
      , "removed_at_block" .= curvePoolDTORemovedAtBlock
      , "removed_at_transaction" .= curvePoolDTORemovedAtTransaction
      , "exchange_count" .= curvePoolDTOExchangeCount
      , "gauge_count" .= curvePoolDTOGaugeCount
      , "vid" .= curvePoolDTOVid
      , "evaluated_ask" .= curvePoolDTOEvaluatedAsk
      ]


-- | Construct a value of type 'CurvePoolDTO' (by applying it's required fields, if any)
mkCurvePoolDTO
  :: CurvePoolDTO
mkCurvePoolDTO =
  CurvePoolDTO
  { curvePoolDTOEntryTime = Nothing
  , curvePoolDTORecvTime = Nothing
  , curvePoolDTOBlockNumber = Nothing
  , curvePoolDTOId = Nothing
  , curvePoolDTOName = Nothing
  , curvePoolDTOIsMeta = Nothing
  , curvePoolDTORegistryAddress = Nothing
  , curvePoolDTOSwapAddress = Nothing
  , curvePoolDTOLpToken = Nothing
  , curvePoolDTOCoinCount = Nothing
  , curvePoolDTOUnderlyingCount = Nothing
  , curvePoolDTOA = Nothing
  , curvePoolDTOFee = Nothing
  , curvePoolDTOAdminFee = Nothing
  , curvePoolDTOOwner = Nothing
  , curvePoolDTOVirtualPrice = Nothing
  , curvePoolDTOLocked = Nothing
  , curvePoolDTOAddedAt = Nothing
  , curvePoolDTOAddedAtBlock = Nothing
  , curvePoolDTOAddedAtTransaction = Nothing
  , curvePoolDTORemovedAt = Nothing
  , curvePoolDTORemovedAtBlock = Nothing
  , curvePoolDTORemovedAtTransaction = Nothing
  , curvePoolDTOExchangeCount = Nothing
  , curvePoolDTOGaugeCount = Nothing
  , curvePoolDTOVid = Nothing
  , curvePoolDTOEvaluatedAsk = Nothing
  }

-- ** CurveProposalDTO
-- | CurveProposalDTO
data CurveProposalDTO = CurveProposalDTO
  { curveProposalDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveProposalDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveProposalDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveProposalDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveProposalDTONumber :: !(Maybe Text) -- ^ "number" - Sequential number in related to the realted voting app.
  , curveProposalDTOApp :: !(Maybe Text) -- ^ "app" - Voting app instance.
  , curveProposalDTOCreator :: !(Maybe Text) -- ^ "creator" - Proposal creator&#39;s account.
  , curveProposalDTOExecutionScript :: !(Maybe Text) -- ^ "execution_script" - 
  , curveProposalDTOExpireDate :: !(Maybe Text) -- ^ "expire_date" - 
  , curveProposalDTOMinimumQuorum :: !(Maybe Text) -- ^ "minimum_quorum" - Percentage of positive votes in total possible votes for this proposal to be accepted.
  , curveProposalDTORequiredSupport :: !(Maybe Text) -- ^ "required_support" - Percentage of positive votes needed for this proposal to be accepted.
  , curveProposalDTOSnapshotBlock :: !(Maybe Text) -- ^ "snapshot_block" - 
  , curveProposalDTOVotingPower :: !(Maybe Text) -- ^ "voting_power" - 
  , curveProposalDTOMetadata :: !(Maybe Text) -- ^ "metadata" - Link to metadata file.
  , curveProposalDTOText :: !(Maybe Text) -- ^ "text" - Proposal description text.
  , curveProposalDTOVoteCount :: !(Maybe Text) -- ^ "vote_count" - Number of votes received by the proposal.
  , curveProposalDTOPositiveVoteCount :: !(Maybe Text) -- ^ "positive_vote_count" - Number of positive votes (yes) received by the proposal.
  , curveProposalDTONegativeVoteCount :: !(Maybe Text) -- ^ "negative_vote_count" - Number of negative votes (no) received by the proposal.
  , curveProposalDTOCurrentQuorum :: !(Maybe Text) -- ^ "current_quorum" - 
  , curveProposalDTOCurrentSupport :: !(Maybe Text) -- ^ "current_support" - 
  , curveProposalDTOStakedSupport :: !(Maybe Text) -- ^ "staked_support" - 
  , curveProposalDTOTotalStaked :: !(Maybe Text) -- ^ "total_staked" - 
  , curveProposalDTOCreated :: !(Maybe Text) -- ^ "created" - 
  , curveProposalDTOCreatedAtBlock :: !(Maybe Text) -- ^ "created_at_block" - 
  , curveProposalDTOCreatedAtTransaction :: !(Maybe Text) -- ^ "created_at_transaction" - 
  , curveProposalDTOUpdated :: !(Maybe Text) -- ^ "updated" - 
  , curveProposalDTOUpdatedAtBlock :: !(Maybe Text) -- ^ "updated_at_block" - 
  , curveProposalDTOUpdatedAtTransaction :: !(Maybe Text) -- ^ "updated_at_transaction" - 
  , curveProposalDTOExecuted :: !(Maybe Text) -- ^ "executed" - 
  , curveProposalDTOExecutedAtBlock :: !(Maybe Text) -- ^ "executed_at_block" - 
  , curveProposalDTOExecutedAtTransaction :: !(Maybe Text) -- ^ "executed_at_transaction" - 
  , curveProposalDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveProposalDTO
instance A.FromJSON CurveProposalDTO where
  parseJSON = A.withObject "CurveProposalDTO" $ \o ->
    CurveProposalDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "number")
      <*> (o .:? "app")
      <*> (o .:? "creator")
      <*> (o .:? "execution_script")
      <*> (o .:? "expire_date")
      <*> (o .:? "minimum_quorum")
      <*> (o .:? "required_support")
      <*> (o .:? "snapshot_block")
      <*> (o .:? "voting_power")
      <*> (o .:? "metadata")
      <*> (o .:? "text")
      <*> (o .:? "vote_count")
      <*> (o .:? "positive_vote_count")
      <*> (o .:? "negative_vote_count")
      <*> (o .:? "current_quorum")
      <*> (o .:? "current_support")
      <*> (o .:? "staked_support")
      <*> (o .:? "total_staked")
      <*> (o .:? "created")
      <*> (o .:? "created_at_block")
      <*> (o .:? "created_at_transaction")
      <*> (o .:? "updated")
      <*> (o .:? "updated_at_block")
      <*> (o .:? "updated_at_transaction")
      <*> (o .:? "executed")
      <*> (o .:? "executed_at_block")
      <*> (o .:? "executed_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveProposalDTO
instance A.ToJSON CurveProposalDTO where
  toJSON CurveProposalDTO {..} =
   _omitNulls
      [ "entry_time" .= curveProposalDTOEntryTime
      , "recv_time" .= curveProposalDTORecvTime
      , "block_number" .= curveProposalDTOBlockNumber
      , "id" .= curveProposalDTOId
      , "number" .= curveProposalDTONumber
      , "app" .= curveProposalDTOApp
      , "creator" .= curveProposalDTOCreator
      , "execution_script" .= curveProposalDTOExecutionScript
      , "expire_date" .= curveProposalDTOExpireDate
      , "minimum_quorum" .= curveProposalDTOMinimumQuorum
      , "required_support" .= curveProposalDTORequiredSupport
      , "snapshot_block" .= curveProposalDTOSnapshotBlock
      , "voting_power" .= curveProposalDTOVotingPower
      , "metadata" .= curveProposalDTOMetadata
      , "text" .= curveProposalDTOText
      , "vote_count" .= curveProposalDTOVoteCount
      , "positive_vote_count" .= curveProposalDTOPositiveVoteCount
      , "negative_vote_count" .= curveProposalDTONegativeVoteCount
      , "current_quorum" .= curveProposalDTOCurrentQuorum
      , "current_support" .= curveProposalDTOCurrentSupport
      , "staked_support" .= curveProposalDTOStakedSupport
      , "total_staked" .= curveProposalDTOTotalStaked
      , "created" .= curveProposalDTOCreated
      , "created_at_block" .= curveProposalDTOCreatedAtBlock
      , "created_at_transaction" .= curveProposalDTOCreatedAtTransaction
      , "updated" .= curveProposalDTOUpdated
      , "updated_at_block" .= curveProposalDTOUpdatedAtBlock
      , "updated_at_transaction" .= curveProposalDTOUpdatedAtTransaction
      , "executed" .= curveProposalDTOExecuted
      , "executed_at_block" .= curveProposalDTOExecutedAtBlock
      , "executed_at_transaction" .= curveProposalDTOExecutedAtTransaction
      , "vid" .= curveProposalDTOVid
      ]


-- | Construct a value of type 'CurveProposalDTO' (by applying it's required fields, if any)
mkCurveProposalDTO
  :: CurveProposalDTO
mkCurveProposalDTO =
  CurveProposalDTO
  { curveProposalDTOEntryTime = Nothing
  , curveProposalDTORecvTime = Nothing
  , curveProposalDTOBlockNumber = Nothing
  , curveProposalDTOId = Nothing
  , curveProposalDTONumber = Nothing
  , curveProposalDTOApp = Nothing
  , curveProposalDTOCreator = Nothing
  , curveProposalDTOExecutionScript = Nothing
  , curveProposalDTOExpireDate = Nothing
  , curveProposalDTOMinimumQuorum = Nothing
  , curveProposalDTORequiredSupport = Nothing
  , curveProposalDTOSnapshotBlock = Nothing
  , curveProposalDTOVotingPower = Nothing
  , curveProposalDTOMetadata = Nothing
  , curveProposalDTOText = Nothing
  , curveProposalDTOVoteCount = Nothing
  , curveProposalDTOPositiveVoteCount = Nothing
  , curveProposalDTONegativeVoteCount = Nothing
  , curveProposalDTOCurrentQuorum = Nothing
  , curveProposalDTOCurrentSupport = Nothing
  , curveProposalDTOStakedSupport = Nothing
  , curveProposalDTOTotalStaked = Nothing
  , curveProposalDTOCreated = Nothing
  , curveProposalDTOCreatedAtBlock = Nothing
  , curveProposalDTOCreatedAtTransaction = Nothing
  , curveProposalDTOUpdated = Nothing
  , curveProposalDTOUpdatedAtBlock = Nothing
  , curveProposalDTOUpdatedAtTransaction = Nothing
  , curveProposalDTOExecuted = Nothing
  , curveProposalDTOExecutedAtBlock = Nothing
  , curveProposalDTOExecutedAtTransaction = Nothing
  , curveProposalDTOVid = Nothing
  }

-- ** CurveProposalVoteDTO
-- | CurveProposalVoteDTO
data CurveProposalVoteDTO = CurveProposalVoteDTO
  { curveProposalVoteDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveProposalVoteDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveProposalVoteDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveProposalVoteDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveProposalVoteDTOProposal :: !(Maybe Text) -- ^ "proposal" - 
  , curveProposalVoteDTOSupports :: !(Maybe Bool) -- ^ "supports" - 
  , curveProposalVoteDTOStake :: !(Maybe Text) -- ^ "stake" - 
  , curveProposalVoteDTOVoter :: !(Maybe Text) -- ^ "voter" - 
  , curveProposalVoteDTOCreated :: !(Maybe Text) -- ^ "created" - 
  , curveProposalVoteDTOCreatedAtBlock :: !(Maybe Text) -- ^ "created_at_block" - 
  , curveProposalVoteDTOCreatedAtTransaction :: !(Maybe Text) -- ^ "created_at_transaction" - 
  , curveProposalVoteDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveProposalVoteDTO
instance A.FromJSON CurveProposalVoteDTO where
  parseJSON = A.withObject "CurveProposalVoteDTO" $ \o ->
    CurveProposalVoteDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "proposal")
      <*> (o .:? "supports")
      <*> (o .:? "stake")
      <*> (o .:? "voter")
      <*> (o .:? "created")
      <*> (o .:? "created_at_block")
      <*> (o .:? "created_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveProposalVoteDTO
instance A.ToJSON CurveProposalVoteDTO where
  toJSON CurveProposalVoteDTO {..} =
   _omitNulls
      [ "entry_time" .= curveProposalVoteDTOEntryTime
      , "recv_time" .= curveProposalVoteDTORecvTime
      , "block_number" .= curveProposalVoteDTOBlockNumber
      , "id" .= curveProposalVoteDTOId
      , "proposal" .= curveProposalVoteDTOProposal
      , "supports" .= curveProposalVoteDTOSupports
      , "stake" .= curveProposalVoteDTOStake
      , "voter" .= curveProposalVoteDTOVoter
      , "created" .= curveProposalVoteDTOCreated
      , "created_at_block" .= curveProposalVoteDTOCreatedAtBlock
      , "created_at_transaction" .= curveProposalVoteDTOCreatedAtTransaction
      , "vid" .= curveProposalVoteDTOVid
      ]


-- | Construct a value of type 'CurveProposalVoteDTO' (by applying it's required fields, if any)
mkCurveProposalVoteDTO
  :: CurveProposalVoteDTO
mkCurveProposalVoteDTO =
  CurveProposalVoteDTO
  { curveProposalVoteDTOEntryTime = Nothing
  , curveProposalVoteDTORecvTime = Nothing
  , curveProposalVoteDTOBlockNumber = Nothing
  , curveProposalVoteDTOId = Nothing
  , curveProposalVoteDTOProposal = Nothing
  , curveProposalVoteDTOSupports = Nothing
  , curveProposalVoteDTOStake = Nothing
  , curveProposalVoteDTOVoter = Nothing
  , curveProposalVoteDTOCreated = Nothing
  , curveProposalVoteDTOCreatedAtBlock = Nothing
  , curveProposalVoteDTOCreatedAtTransaction = Nothing
  , curveProposalVoteDTOVid = Nothing
  }

-- ** CurveRemoveLiquidityEventDTO
-- | CurveRemoveLiquidityEventDTO
data CurveRemoveLiquidityEventDTO = CurveRemoveLiquidityEventDTO
  { curveRemoveLiquidityEventDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveRemoveLiquidityEventDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveRemoveLiquidityEventDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveRemoveLiquidityEventDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveRemoveLiquidityEventDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveRemoveLiquidityEventDTOProvider :: !(Maybe Text) -- ^ "provider" - 
  , curveRemoveLiquidityEventDTOTokenAmounts :: !(Maybe [Text]) -- ^ "token_amounts" - 
  , curveRemoveLiquidityEventDTOFees :: !(Maybe [Text]) -- ^ "fees" - 
  , curveRemoveLiquidityEventDTOTokenSupply :: !(Maybe Text) -- ^ "token_supply" - 
  , curveRemoveLiquidityEventDTOInvariant :: !(Maybe Text) -- ^ "invariant" - 
  , curveRemoveLiquidityEventDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveRemoveLiquidityEventDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveRemoveLiquidityEventDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveRemoveLiquidityEventDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveRemoveLiquidityEventDTO
instance A.FromJSON CurveRemoveLiquidityEventDTO where
  parseJSON = A.withObject "CurveRemoveLiquidityEventDTO" $ \o ->
    CurveRemoveLiquidityEventDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "provider")
      <*> (o .:? "token_amounts")
      <*> (o .:? "fees")
      <*> (o .:? "token_supply")
      <*> (o .:? "invariant")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveRemoveLiquidityEventDTO
instance A.ToJSON CurveRemoveLiquidityEventDTO where
  toJSON CurveRemoveLiquidityEventDTO {..} =
   _omitNulls
      [ "entry_time" .= curveRemoveLiquidityEventDTOEntryTime
      , "recv_time" .= curveRemoveLiquidityEventDTORecvTime
      , "block_number" .= curveRemoveLiquidityEventDTOBlockNumber
      , "id" .= curveRemoveLiquidityEventDTOId
      , "pool" .= curveRemoveLiquidityEventDTOPool
      , "provider" .= curveRemoveLiquidityEventDTOProvider
      , "token_amounts" .= curveRemoveLiquidityEventDTOTokenAmounts
      , "fees" .= curveRemoveLiquidityEventDTOFees
      , "token_supply" .= curveRemoveLiquidityEventDTOTokenSupply
      , "invariant" .= curveRemoveLiquidityEventDTOInvariant
      , "block" .= curveRemoveLiquidityEventDTOBlock
      , "timestamp" .= curveRemoveLiquidityEventDTOTimestamp
      , "transaction" .= curveRemoveLiquidityEventDTOTransaction
      , "vid" .= curveRemoveLiquidityEventDTOVid
      ]


-- | Construct a value of type 'CurveRemoveLiquidityEventDTO' (by applying it's required fields, if any)
mkCurveRemoveLiquidityEventDTO
  :: CurveRemoveLiquidityEventDTO
mkCurveRemoveLiquidityEventDTO =
  CurveRemoveLiquidityEventDTO
  { curveRemoveLiquidityEventDTOEntryTime = Nothing
  , curveRemoveLiquidityEventDTORecvTime = Nothing
  , curveRemoveLiquidityEventDTOBlockNumber = Nothing
  , curveRemoveLiquidityEventDTOId = Nothing
  , curveRemoveLiquidityEventDTOPool = Nothing
  , curveRemoveLiquidityEventDTOProvider = Nothing
  , curveRemoveLiquidityEventDTOTokenAmounts = Nothing
  , curveRemoveLiquidityEventDTOFees = Nothing
  , curveRemoveLiquidityEventDTOTokenSupply = Nothing
  , curveRemoveLiquidityEventDTOInvariant = Nothing
  , curveRemoveLiquidityEventDTOBlock = Nothing
  , curveRemoveLiquidityEventDTOTimestamp = Nothing
  , curveRemoveLiquidityEventDTOTransaction = Nothing
  , curveRemoveLiquidityEventDTOVid = Nothing
  }

-- ** CurveRemoveLiquidityOneEventDTO
-- | CurveRemoveLiquidityOneEventDTO
data CurveRemoveLiquidityOneEventDTO = CurveRemoveLiquidityOneEventDTO
  { curveRemoveLiquidityOneEventDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveRemoveLiquidityOneEventDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveRemoveLiquidityOneEventDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveRemoveLiquidityOneEventDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveRemoveLiquidityOneEventDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveRemoveLiquidityOneEventDTOProvider :: !(Maybe Text) -- ^ "provider" - 
  , curveRemoveLiquidityOneEventDTOTokenAmount :: !(Maybe Text) -- ^ "token_amount" - 
  , curveRemoveLiquidityOneEventDTOCoinAmount :: !(Maybe Text) -- ^ "coin_amount" - 
  , curveRemoveLiquidityOneEventDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveRemoveLiquidityOneEventDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveRemoveLiquidityOneEventDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveRemoveLiquidityOneEventDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveRemoveLiquidityOneEventDTO
instance A.FromJSON CurveRemoveLiquidityOneEventDTO where
  parseJSON = A.withObject "CurveRemoveLiquidityOneEventDTO" $ \o ->
    CurveRemoveLiquidityOneEventDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "provider")
      <*> (o .:? "token_amount")
      <*> (o .:? "coin_amount")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveRemoveLiquidityOneEventDTO
instance A.ToJSON CurveRemoveLiquidityOneEventDTO where
  toJSON CurveRemoveLiquidityOneEventDTO {..} =
   _omitNulls
      [ "entry_time" .= curveRemoveLiquidityOneEventDTOEntryTime
      , "recv_time" .= curveRemoveLiquidityOneEventDTORecvTime
      , "block_number" .= curveRemoveLiquidityOneEventDTOBlockNumber
      , "id" .= curveRemoveLiquidityOneEventDTOId
      , "pool" .= curveRemoveLiquidityOneEventDTOPool
      , "provider" .= curveRemoveLiquidityOneEventDTOProvider
      , "token_amount" .= curveRemoveLiquidityOneEventDTOTokenAmount
      , "coin_amount" .= curveRemoveLiquidityOneEventDTOCoinAmount
      , "block" .= curveRemoveLiquidityOneEventDTOBlock
      , "timestamp" .= curveRemoveLiquidityOneEventDTOTimestamp
      , "transaction" .= curveRemoveLiquidityOneEventDTOTransaction
      , "vid" .= curveRemoveLiquidityOneEventDTOVid
      ]


-- | Construct a value of type 'CurveRemoveLiquidityOneEventDTO' (by applying it's required fields, if any)
mkCurveRemoveLiquidityOneEventDTO
  :: CurveRemoveLiquidityOneEventDTO
mkCurveRemoveLiquidityOneEventDTO =
  CurveRemoveLiquidityOneEventDTO
  { curveRemoveLiquidityOneEventDTOEntryTime = Nothing
  , curveRemoveLiquidityOneEventDTORecvTime = Nothing
  , curveRemoveLiquidityOneEventDTOBlockNumber = Nothing
  , curveRemoveLiquidityOneEventDTOId = Nothing
  , curveRemoveLiquidityOneEventDTOPool = Nothing
  , curveRemoveLiquidityOneEventDTOProvider = Nothing
  , curveRemoveLiquidityOneEventDTOTokenAmount = Nothing
  , curveRemoveLiquidityOneEventDTOCoinAmount = Nothing
  , curveRemoveLiquidityOneEventDTOBlock = Nothing
  , curveRemoveLiquidityOneEventDTOTimestamp = Nothing
  , curveRemoveLiquidityOneEventDTOTransaction = Nothing
  , curveRemoveLiquidityOneEventDTOVid = Nothing
  }

-- ** CurveSystemStateDTO
-- | CurveSystemStateDTO
data CurveSystemStateDTO = CurveSystemStateDTO
  { curveSystemStateDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveSystemStateDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveSystemStateDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveSystemStateDTOId :: !(Maybe Text) -- ^ "id" - Singleton ID, equals to &#39;current&#39;.
  , curveSystemStateDTORegistryContract :: !(Maybe Text) -- ^ "registry_contract" - Current pool registry address.
  , curveSystemStateDTOContractCount :: !(Maybe Text) -- ^ "contract_count" - Number of contracts in the AddressProvider registry.
  , curveSystemStateDTOGaugeCount :: !(Maybe Text) -- ^ "gauge_count" - Number of gauges registered.
  , curveSystemStateDTOGaugeTypeCount :: !(Maybe Text) -- ^ "gauge_type_count" - Number of gauge types registered.
  , curveSystemStateDTOPoolCount :: !(Maybe Text) -- ^ "pool_count" - Number of active pools.
  , curveSystemStateDTOTokenCount :: !(Maybe Text) -- ^ "token_count" - Number of tokens registered.
  , curveSystemStateDTOTotalPoolCount :: !(Maybe Text) -- ^ "total_pool_count" - Total number of pools (including removed ones).
  , curveSystemStateDTOUpdated :: !(Maybe Text) -- ^ "updated" - 
  , curveSystemStateDTOUpdatedAtBlock :: !(Maybe Text) -- ^ "updated_at_block" - 
  , curveSystemStateDTOUpdatedAtTransaction :: !(Maybe Text) -- ^ "updated_at_transaction" - 
  , curveSystemStateDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveSystemStateDTO
instance A.FromJSON CurveSystemStateDTO where
  parseJSON = A.withObject "CurveSystemStateDTO" $ \o ->
    CurveSystemStateDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "registry_contract")
      <*> (o .:? "contract_count")
      <*> (o .:? "gauge_count")
      <*> (o .:? "gauge_type_count")
      <*> (o .:? "pool_count")
      <*> (o .:? "token_count")
      <*> (o .:? "total_pool_count")
      <*> (o .:? "updated")
      <*> (o .:? "updated_at_block")
      <*> (o .:? "updated_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveSystemStateDTO
instance A.ToJSON CurveSystemStateDTO where
  toJSON CurveSystemStateDTO {..} =
   _omitNulls
      [ "entry_time" .= curveSystemStateDTOEntryTime
      , "recv_time" .= curveSystemStateDTORecvTime
      , "block_number" .= curveSystemStateDTOBlockNumber
      , "id" .= curveSystemStateDTOId
      , "registry_contract" .= curveSystemStateDTORegistryContract
      , "contract_count" .= curveSystemStateDTOContractCount
      , "gauge_count" .= curveSystemStateDTOGaugeCount
      , "gauge_type_count" .= curveSystemStateDTOGaugeTypeCount
      , "pool_count" .= curveSystemStateDTOPoolCount
      , "token_count" .= curveSystemStateDTOTokenCount
      , "total_pool_count" .= curveSystemStateDTOTotalPoolCount
      , "updated" .= curveSystemStateDTOUpdated
      , "updated_at_block" .= curveSystemStateDTOUpdatedAtBlock
      , "updated_at_transaction" .= curveSystemStateDTOUpdatedAtTransaction
      , "vid" .= curveSystemStateDTOVid
      ]


-- | Construct a value of type 'CurveSystemStateDTO' (by applying it's required fields, if any)
mkCurveSystemStateDTO
  :: CurveSystemStateDTO
mkCurveSystemStateDTO =
  CurveSystemStateDTO
  { curveSystemStateDTOEntryTime = Nothing
  , curveSystemStateDTORecvTime = Nothing
  , curveSystemStateDTOBlockNumber = Nothing
  , curveSystemStateDTOId = Nothing
  , curveSystemStateDTORegistryContract = Nothing
  , curveSystemStateDTOContractCount = Nothing
  , curveSystemStateDTOGaugeCount = Nothing
  , curveSystemStateDTOGaugeTypeCount = Nothing
  , curveSystemStateDTOPoolCount = Nothing
  , curveSystemStateDTOTokenCount = Nothing
  , curveSystemStateDTOTotalPoolCount = Nothing
  , curveSystemStateDTOUpdated = Nothing
  , curveSystemStateDTOUpdatedAtBlock = Nothing
  , curveSystemStateDTOUpdatedAtTransaction = Nothing
  , curveSystemStateDTOVid = Nothing
  }

-- ** CurveTokenDTO
-- | CurveTokenDTO
data CurveTokenDTO = CurveTokenDTO
  { curveTokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveTokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveTokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveTokenDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveTokenDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveTokenDTODecimals :: !(Maybe Text) -- ^ "decimals" - 
  , curveTokenDTOName :: !(Maybe Text) -- ^ "name" - 
  , curveTokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - 
  , curveTokenDTOPools :: !(Maybe [Text]) -- ^ "pools" - 
  , curveTokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curveTokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveTokenDTO
instance A.FromJSON CurveTokenDTO where
  parseJSON = A.withObject "CurveTokenDTO" $ \o ->
    CurveTokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "decimals")
      <*> (o .:? "name")
      <*> (o .:? "symbol")
      <*> (o .:? "pools")
      <*> (o .:? "vid")
      <*> (o .:? "token_symbol")

-- | ToJSON CurveTokenDTO
instance A.ToJSON CurveTokenDTO where
  toJSON CurveTokenDTO {..} =
   _omitNulls
      [ "entry_time" .= curveTokenDTOEntryTime
      , "recv_time" .= curveTokenDTORecvTime
      , "block_number" .= curveTokenDTOBlockNumber
      , "id" .= curveTokenDTOId
      , "address" .= curveTokenDTOAddress
      , "decimals" .= curveTokenDTODecimals
      , "name" .= curveTokenDTOName
      , "symbol" .= curveTokenDTOSymbol
      , "pools" .= curveTokenDTOPools
      , "vid" .= curveTokenDTOVid
      , "token_symbol" .= curveTokenDTOTokenSymbol
      ]


-- | Construct a value of type 'CurveTokenDTO' (by applying it's required fields, if any)
mkCurveTokenDTO
  :: CurveTokenDTO
mkCurveTokenDTO =
  CurveTokenDTO
  { curveTokenDTOEntryTime = Nothing
  , curveTokenDTORecvTime = Nothing
  , curveTokenDTOBlockNumber = Nothing
  , curveTokenDTOId = Nothing
  , curveTokenDTOAddress = Nothing
  , curveTokenDTODecimals = Nothing
  , curveTokenDTOName = Nothing
  , curveTokenDTOSymbol = Nothing
  , curveTokenDTOPools = Nothing
  , curveTokenDTOVid = Nothing
  , curveTokenDTOTokenSymbol = Nothing
  }

-- ** CurveTransferOwnershipEventDTO
-- | CurveTransferOwnershipEventDTO
data CurveTransferOwnershipEventDTO = CurveTransferOwnershipEventDTO
  { curveTransferOwnershipEventDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveTransferOwnershipEventDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveTransferOwnershipEventDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveTransferOwnershipEventDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveTransferOwnershipEventDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveTransferOwnershipEventDTONewAdmin :: !(Maybe Text) -- ^ "new_admin" - 
  , curveTransferOwnershipEventDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveTransferOwnershipEventDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveTransferOwnershipEventDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveTransferOwnershipEventDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveTransferOwnershipEventDTO
instance A.FromJSON CurveTransferOwnershipEventDTO where
  parseJSON = A.withObject "CurveTransferOwnershipEventDTO" $ \o ->
    CurveTransferOwnershipEventDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "new_admin")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveTransferOwnershipEventDTO
instance A.ToJSON CurveTransferOwnershipEventDTO where
  toJSON CurveTransferOwnershipEventDTO {..} =
   _omitNulls
      [ "entry_time" .= curveTransferOwnershipEventDTOEntryTime
      , "recv_time" .= curveTransferOwnershipEventDTORecvTime
      , "block_number" .= curveTransferOwnershipEventDTOBlockNumber
      , "id" .= curveTransferOwnershipEventDTOId
      , "pool" .= curveTransferOwnershipEventDTOPool
      , "new_admin" .= curveTransferOwnershipEventDTONewAdmin
      , "block" .= curveTransferOwnershipEventDTOBlock
      , "timestamp" .= curveTransferOwnershipEventDTOTimestamp
      , "transaction" .= curveTransferOwnershipEventDTOTransaction
      , "vid" .= curveTransferOwnershipEventDTOVid
      ]


-- | Construct a value of type 'CurveTransferOwnershipEventDTO' (by applying it's required fields, if any)
mkCurveTransferOwnershipEventDTO
  :: CurveTransferOwnershipEventDTO
mkCurveTransferOwnershipEventDTO =
  CurveTransferOwnershipEventDTO
  { curveTransferOwnershipEventDTOEntryTime = Nothing
  , curveTransferOwnershipEventDTORecvTime = Nothing
  , curveTransferOwnershipEventDTOBlockNumber = Nothing
  , curveTransferOwnershipEventDTOId = Nothing
  , curveTransferOwnershipEventDTOPool = Nothing
  , curveTransferOwnershipEventDTONewAdmin = Nothing
  , curveTransferOwnershipEventDTOBlock = Nothing
  , curveTransferOwnershipEventDTOTimestamp = Nothing
  , curveTransferOwnershipEventDTOTransaction = Nothing
  , curveTransferOwnershipEventDTOVid = Nothing
  }

-- ** CurveUnderlyingCoinDTO
-- | CurveUnderlyingCoinDTO
data CurveUnderlyingCoinDTO = CurveUnderlyingCoinDTO
  { curveUnderlyingCoinDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveUnderlyingCoinDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveUnderlyingCoinDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveUnderlyingCoinDTOId :: !(Maybe Text) -- ^ "id" - Equals to: &lt;pool_id&gt;-&lt;coin_index&gt;.
  , curveUnderlyingCoinDTOIndex :: !(Maybe Int) -- ^ "index" - Coin index.
  , curveUnderlyingCoinDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveUnderlyingCoinDTOToken :: !(Maybe Text) -- ^ "token" - 
  , curveUnderlyingCoinDTOCoin :: !(Maybe Text) -- ^ "coin" - 
  , curveUnderlyingCoinDTOBalance :: !(Maybe Text) -- ^ "balance" - 
  , curveUnderlyingCoinDTOUpdated :: !(Maybe Text) -- ^ "updated" - 
  , curveUnderlyingCoinDTOUpdatedAtBlock :: !(Maybe Text) -- ^ "updated_at_block" - 
  , curveUnderlyingCoinDTOUpdatedAtTransaction :: !(Maybe Text) -- ^ "updated_at_transaction" - 
  , curveUnderlyingCoinDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveUnderlyingCoinDTO
instance A.FromJSON CurveUnderlyingCoinDTO where
  parseJSON = A.withObject "CurveUnderlyingCoinDTO" $ \o ->
    CurveUnderlyingCoinDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "index")
      <*> (o .:? "pool")
      <*> (o .:? "token")
      <*> (o .:? "coin")
      <*> (o .:? "balance")
      <*> (o .:? "updated")
      <*> (o .:? "updated_at_block")
      <*> (o .:? "updated_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveUnderlyingCoinDTO
instance A.ToJSON CurveUnderlyingCoinDTO where
  toJSON CurveUnderlyingCoinDTO {..} =
   _omitNulls
      [ "entry_time" .= curveUnderlyingCoinDTOEntryTime
      , "recv_time" .= curveUnderlyingCoinDTORecvTime
      , "block_number" .= curveUnderlyingCoinDTOBlockNumber
      , "id" .= curveUnderlyingCoinDTOId
      , "index" .= curveUnderlyingCoinDTOIndex
      , "pool" .= curveUnderlyingCoinDTOPool
      , "token" .= curveUnderlyingCoinDTOToken
      , "coin" .= curveUnderlyingCoinDTOCoin
      , "balance" .= curveUnderlyingCoinDTOBalance
      , "updated" .= curveUnderlyingCoinDTOUpdated
      , "updated_at_block" .= curveUnderlyingCoinDTOUpdatedAtBlock
      , "updated_at_transaction" .= curveUnderlyingCoinDTOUpdatedAtTransaction
      , "vid" .= curveUnderlyingCoinDTOVid
      ]


-- | Construct a value of type 'CurveUnderlyingCoinDTO' (by applying it's required fields, if any)
mkCurveUnderlyingCoinDTO
  :: CurveUnderlyingCoinDTO
mkCurveUnderlyingCoinDTO =
  CurveUnderlyingCoinDTO
  { curveUnderlyingCoinDTOEntryTime = Nothing
  , curveUnderlyingCoinDTORecvTime = Nothing
  , curveUnderlyingCoinDTOBlockNumber = Nothing
  , curveUnderlyingCoinDTOId = Nothing
  , curveUnderlyingCoinDTOIndex = Nothing
  , curveUnderlyingCoinDTOPool = Nothing
  , curveUnderlyingCoinDTOToken = Nothing
  , curveUnderlyingCoinDTOCoin = Nothing
  , curveUnderlyingCoinDTOBalance = Nothing
  , curveUnderlyingCoinDTOUpdated = Nothing
  , curveUnderlyingCoinDTOUpdatedAtBlock = Nothing
  , curveUnderlyingCoinDTOUpdatedAtTransaction = Nothing
  , curveUnderlyingCoinDTOVid = Nothing
  }

-- ** CurveVotingAppDTO
-- | CurveVotingAppDTO
data CurveVotingAppDTO = CurveVotingAppDTO
  { curveVotingAppDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveVotingAppDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveVotingAppDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveVotingAppDTOId :: !(Maybe Text) -- ^ "id" - App address.
  , curveVotingAppDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveVotingAppDTOCodename :: !(Maybe Text) -- ^ "codename" - 
  , curveVotingAppDTOMinimumBalance :: !(Maybe Text) -- ^ "minimum_balance" - Minimum balance needed to create a proposal.
  , curveVotingAppDTOMinimumQuorum :: !(Maybe Text) -- ^ "minimum_quorum" - Percentage of positive votes in total possible votes for a proposal to be accepted.
  , curveVotingAppDTOMinimumTime :: !(Maybe Text) -- ^ "minimum_time" - Minimum time needed to pass between user&#39;s previous proposal and a user creating a new proposal.
  , curveVotingAppDTORequiredSupport :: !(Maybe Text) -- ^ "required_support" - Percentage of positive votes needed for a proposal to be accepted.
  , curveVotingAppDTOVoteTime :: !(Maybe Text) -- ^ "vote_time" - Seconds that a proposal will be open for vote (unless enough votes have been cast to make an early decision).
  , curveVotingAppDTOProposalCount :: !(Maybe Text) -- ^ "proposal_count" - Number of proposals created with this app.
  , curveVotingAppDTOVoteCount :: !(Maybe Text) -- ^ "vote_count" - Number of votes received by all the proposals created with this app.
  , curveVotingAppDTOToken :: !(Maybe Text) -- ^ "token" - Address of the token used for voting.
  , curveVotingAppDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveVotingAppDTO
instance A.FromJSON CurveVotingAppDTO where
  parseJSON = A.withObject "CurveVotingAppDTO" $ \o ->
    CurveVotingAppDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "codename")
      <*> (o .:? "minimum_balance")
      <*> (o .:? "minimum_quorum")
      <*> (o .:? "minimum_time")
      <*> (o .:? "required_support")
      <*> (o .:? "vote_time")
      <*> (o .:? "proposal_count")
      <*> (o .:? "vote_count")
      <*> (o .:? "token")
      <*> (o .:? "vid")

-- | ToJSON CurveVotingAppDTO
instance A.ToJSON CurveVotingAppDTO where
  toJSON CurveVotingAppDTO {..} =
   _omitNulls
      [ "entry_time" .= curveVotingAppDTOEntryTime
      , "recv_time" .= curveVotingAppDTORecvTime
      , "block_number" .= curveVotingAppDTOBlockNumber
      , "id" .= curveVotingAppDTOId
      , "address" .= curveVotingAppDTOAddress
      , "codename" .= curveVotingAppDTOCodename
      , "minimum_balance" .= curveVotingAppDTOMinimumBalance
      , "minimum_quorum" .= curveVotingAppDTOMinimumQuorum
      , "minimum_time" .= curveVotingAppDTOMinimumTime
      , "required_support" .= curveVotingAppDTORequiredSupport
      , "vote_time" .= curveVotingAppDTOVoteTime
      , "proposal_count" .= curveVotingAppDTOProposalCount
      , "vote_count" .= curveVotingAppDTOVoteCount
      , "token" .= curveVotingAppDTOToken
      , "vid" .= curveVotingAppDTOVid
      ]


-- | Construct a value of type 'CurveVotingAppDTO' (by applying it's required fields, if any)
mkCurveVotingAppDTO
  :: CurveVotingAppDTO
mkCurveVotingAppDTO =
  CurveVotingAppDTO
  { curveVotingAppDTOEntryTime = Nothing
  , curveVotingAppDTORecvTime = Nothing
  , curveVotingAppDTOBlockNumber = Nothing
  , curveVotingAppDTOId = Nothing
  , curveVotingAppDTOAddress = Nothing
  , curveVotingAppDTOCodename = Nothing
  , curveVotingAppDTOMinimumBalance = Nothing
  , curveVotingAppDTOMinimumQuorum = Nothing
  , curveVotingAppDTOMinimumTime = Nothing
  , curveVotingAppDTORequiredSupport = Nothing
  , curveVotingAppDTOVoteTime = Nothing
  , curveVotingAppDTOProposalCount = Nothing
  , curveVotingAppDTOVoteCount = Nothing
  , curveVotingAppDTOToken = Nothing
  , curveVotingAppDTOVid = Nothing
  }

-- ** CurveWeeklyVolumeDTO
-- | CurveWeeklyVolumeDTO
data CurveWeeklyVolumeDTO = CurveWeeklyVolumeDTO
  { curveWeeklyVolumeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveWeeklyVolumeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveWeeklyVolumeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveWeeklyVolumeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveWeeklyVolumeDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveWeeklyVolumeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveWeeklyVolumeDTOVolume :: !(Maybe Text) -- ^ "volume" - 
  , curveWeeklyVolumeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveWeeklyVolumeDTO
instance A.FromJSON CurveWeeklyVolumeDTO where
  parseJSON = A.withObject "CurveWeeklyVolumeDTO" $ \o ->
    CurveWeeklyVolumeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "timestamp")
      <*> (o .:? "volume")
      <*> (o .:? "vid")

-- | ToJSON CurveWeeklyVolumeDTO
instance A.ToJSON CurveWeeklyVolumeDTO where
  toJSON CurveWeeklyVolumeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveWeeklyVolumeDTOEntryTime
      , "recv_time" .= curveWeeklyVolumeDTORecvTime
      , "block_number" .= curveWeeklyVolumeDTOBlockNumber
      , "id" .= curveWeeklyVolumeDTOId
      , "pool" .= curveWeeklyVolumeDTOPool
      , "timestamp" .= curveWeeklyVolumeDTOTimestamp
      , "volume" .= curveWeeklyVolumeDTOVolume
      , "vid" .= curveWeeklyVolumeDTOVid
      ]


-- | Construct a value of type 'CurveWeeklyVolumeDTO' (by applying it's required fields, if any)
mkCurveWeeklyVolumeDTO
  :: CurveWeeklyVolumeDTO
mkCurveWeeklyVolumeDTO =
  CurveWeeklyVolumeDTO
  { curveWeeklyVolumeDTOEntryTime = Nothing
  , curveWeeklyVolumeDTORecvTime = Nothing
  , curveWeeklyVolumeDTOBlockNumber = Nothing
  , curveWeeklyVolumeDTOId = Nothing
  , curveWeeklyVolumeDTOPool = Nothing
  , curveWeeklyVolumeDTOTimestamp = Nothing
  , curveWeeklyVolumeDTOVolume = Nothing
  , curveWeeklyVolumeDTOVid = Nothing
  }

-- ** DexBatchDTO
-- | DexBatchDTO
-- Batch executed. Every batch will contain at least solution with the a set of trades that are executed in it
data DexBatchDTO = DexBatchDTO
  { dexBatchDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexBatchDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexBatchDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexBatchDTOId :: !(Maybe Text) -- ^ "id" - Identifier.
  , dexBatchDTOStartEpoch :: !(Maybe Text) -- ^ "start_epoch" - Start epoch.
  , dexBatchDTOEndEpoch :: !(Maybe Text) -- ^ "end_epoch" - End epoch.
  , dexBatchDTOSolution :: !(Maybe Text) -- ^ "solution" - Reference to solution.
  , dexBatchDTOFirstSolutionEpoch :: !(Maybe Text) -- ^ "first_solution_epoch" - First solution epoch.
  , dexBatchDTOLastRevertEpoch :: !(Maybe Text) -- ^ "last_revert_epoch" - Last revert epoch.
  , dexBatchDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Transaction hash.
  , dexBatchDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexBatchDTO
instance A.FromJSON DexBatchDTO where
  parseJSON = A.withObject "DexBatchDTO" $ \o ->
    DexBatchDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "start_epoch")
      <*> (o .:? "end_epoch")
      <*> (o .:? "solution")
      <*> (o .:? "first_solution_epoch")
      <*> (o .:? "last_revert_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexBatchDTO
instance A.ToJSON DexBatchDTO where
  toJSON DexBatchDTO {..} =
   _omitNulls
      [ "entry_time" .= dexBatchDTOEntryTime
      , "recv_time" .= dexBatchDTORecvTime
      , "block_number" .= dexBatchDTOBlockNumber
      , "id" .= dexBatchDTOId
      , "start_epoch" .= dexBatchDTOStartEpoch
      , "end_epoch" .= dexBatchDTOEndEpoch
      , "solution" .= dexBatchDTOSolution
      , "first_solution_epoch" .= dexBatchDTOFirstSolutionEpoch
      , "last_revert_epoch" .= dexBatchDTOLastRevertEpoch
      , "tx_hash" .= dexBatchDTOTxHash
      , "vid" .= dexBatchDTOVid
      ]


-- | Construct a value of type 'DexBatchDTO' (by applying it's required fields, if any)
mkDexBatchDTO
  :: DexBatchDTO
mkDexBatchDTO =
  DexBatchDTO
  { dexBatchDTOEntryTime = Nothing
  , dexBatchDTORecvTime = Nothing
  , dexBatchDTOBlockNumber = Nothing
  , dexBatchDTOId = Nothing
  , dexBatchDTOStartEpoch = Nothing
  , dexBatchDTOEndEpoch = Nothing
  , dexBatchDTOSolution = Nothing
  , dexBatchDTOFirstSolutionEpoch = Nothing
  , dexBatchDTOLastRevertEpoch = Nothing
  , dexBatchDTOTxHash = Nothing
  , dexBatchDTOVid = Nothing
  }

-- ** DexDepositDTO
-- | DexDepositDTO
-- Deposit of an user.
data DexDepositDTO = DexDepositDTO
  { dexDepositDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexDepositDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexDepositDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexDepositDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;transaction hash&gt;-&lt;token id&gt;.
  , dexDepositDTOUser :: !(Maybe Text) -- ^ "user" - User address.
  , dexDepositDTOTokenAddress :: !(Maybe Text) -- ^ "token_address" - Token address.
  , dexDepositDTOAmount :: !(Maybe Text) -- ^ "amount" - Amount of deposit.
  , dexDepositDTOBatchId :: !(Maybe Text) -- ^ "batch_id" - Identifier (numerical).
  , dexDepositDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - Create epoch.
  , dexDepositDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Transaction hash.
  , dexDepositDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexDepositDTO
instance A.FromJSON DexDepositDTO where
  parseJSON = A.withObject "DexDepositDTO" $ \o ->
    DexDepositDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "token_address")
      <*> (o .:? "amount")
      <*> (o .:? "batch_id")
      <*> (o .:? "create_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexDepositDTO
instance A.ToJSON DexDepositDTO where
  toJSON DexDepositDTO {..} =
   _omitNulls
      [ "entry_time" .= dexDepositDTOEntryTime
      , "recv_time" .= dexDepositDTORecvTime
      , "block_number" .= dexDepositDTOBlockNumber
      , "id" .= dexDepositDTOId
      , "user" .= dexDepositDTOUser
      , "token_address" .= dexDepositDTOTokenAddress
      , "amount" .= dexDepositDTOAmount
      , "batch_id" .= dexDepositDTOBatchId
      , "create_epoch" .= dexDepositDTOCreateEpoch
      , "tx_hash" .= dexDepositDTOTxHash
      , "vid" .= dexDepositDTOVid
      ]


-- | Construct a value of type 'DexDepositDTO' (by applying it's required fields, if any)
mkDexDepositDTO
  :: DexDepositDTO
mkDexDepositDTO =
  DexDepositDTO
  { dexDepositDTOEntryTime = Nothing
  , dexDepositDTORecvTime = Nothing
  , dexDepositDTOBlockNumber = Nothing
  , dexDepositDTOId = Nothing
  , dexDepositDTOUser = Nothing
  , dexDepositDTOTokenAddress = Nothing
  , dexDepositDTOAmount = Nothing
  , dexDepositDTOBatchId = Nothing
  , dexDepositDTOCreateEpoch = Nothing
  , dexDepositDTOTxHash = Nothing
  , dexDepositDTOVid = Nothing
  }

-- ** DexOrderDTO
-- | DexOrderDTO
-- Order submitted by an user. It has a validity (dates) so they can only be executed from/until some given batches. Partial executions of this trades must respect the limit price.
data DexOrderDTO = DexOrderDTO
  { dexOrderDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexOrderDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexOrderDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexOrderDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;owner address&gt;-&lt;order id&gt;
  , dexOrderDTOOwner :: !(Maybe Text) -- ^ "owner" - Reference to owner.
  , dexOrderDTOOrderId :: !(Maybe Int) -- ^ "order_id" - Order id.
  , dexOrderDTOFromBatchId :: !(Maybe Text) -- ^ "from_batch_id" - Batch id from which order became valid.
  , dexOrderDTOFromEpoch :: !(Maybe Text) -- ^ "from_epoch" - Start of epoch in which order was placed and became valid.
  , dexOrderDTOUntilBatchId :: !(Maybe Text) -- ^ "until_batch_id" - Batch id until which trade was still valid.
  , dexOrderDTOUntilEpoch :: !(Maybe Text) -- ^ "until_epoch" - End of epoch in which order was placed.
  , dexOrderDTOBuyToken :: !(Maybe Text) -- ^ "buy_token" - Identifier of token that was bought.
  , dexOrderDTOSellToken :: !(Maybe Text) -- ^ "sell_token" - Identifier of token that was sold.
  , dexOrderDTOPriceNumerator :: !(Maybe Text) -- ^ "price_numerator" - Price enumerator.
  , dexOrderDTOPriceDenominator :: !(Maybe Text) -- ^ "price_denominator" - Price denominator.
  , dexOrderDTOMaxSellAmount :: !(Maybe Text) -- ^ "max_sell_amount" - Maximum sell amount.
  , dexOrderDTOMinReceiveAmount :: !(Maybe Text) -- ^ "min_receive_amount" - Minimum receive amount.
  , dexOrderDTOSoldVolume :: !(Maybe Text) -- ^ "sold_volume" - Sold volume.
  , dexOrderDTOBoughtVolume :: !(Maybe Text) -- ^ "bought_volume" - Bought volume.
  , dexOrderDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - Epoch in which order was created.
  , dexOrderDTOCancelEpoch :: !(Maybe Text) -- ^ "cancel_epoch" - Epoch in which order was cancelled.
  , dexOrderDTODeleteEpoch :: !(Maybe Text) -- ^ "delete_epoch" - Epoch in which order was deleted.
  , dexOrderDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Transaction hash.
  , dexOrderDTOTxLogIndex :: !(Maybe Text) -- ^ "tx_log_index" - Event index within transaction.
  , dexOrderDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexOrderDTO
instance A.FromJSON DexOrderDTO where
  parseJSON = A.withObject "DexOrderDTO" $ \o ->
    DexOrderDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "owner")
      <*> (o .:? "order_id")
      <*> (o .:? "from_batch_id")
      <*> (o .:? "from_epoch")
      <*> (o .:? "until_batch_id")
      <*> (o .:? "until_epoch")
      <*> (o .:? "buy_token")
      <*> (o .:? "sell_token")
      <*> (o .:? "price_numerator")
      <*> (o .:? "price_denominator")
      <*> (o .:? "max_sell_amount")
      <*> (o .:? "min_receive_amount")
      <*> (o .:? "sold_volume")
      <*> (o .:? "bought_volume")
      <*> (o .:? "create_epoch")
      <*> (o .:? "cancel_epoch")
      <*> (o .:? "delete_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "tx_log_index")
      <*> (o .:? "vid")

-- | ToJSON DexOrderDTO
instance A.ToJSON DexOrderDTO where
  toJSON DexOrderDTO {..} =
   _omitNulls
      [ "entry_time" .= dexOrderDTOEntryTime
      , "recv_time" .= dexOrderDTORecvTime
      , "block_number" .= dexOrderDTOBlockNumber
      , "id" .= dexOrderDTOId
      , "owner" .= dexOrderDTOOwner
      , "order_id" .= dexOrderDTOOrderId
      , "from_batch_id" .= dexOrderDTOFromBatchId
      , "from_epoch" .= dexOrderDTOFromEpoch
      , "until_batch_id" .= dexOrderDTOUntilBatchId
      , "until_epoch" .= dexOrderDTOUntilEpoch
      , "buy_token" .= dexOrderDTOBuyToken
      , "sell_token" .= dexOrderDTOSellToken
      , "price_numerator" .= dexOrderDTOPriceNumerator
      , "price_denominator" .= dexOrderDTOPriceDenominator
      , "max_sell_amount" .= dexOrderDTOMaxSellAmount
      , "min_receive_amount" .= dexOrderDTOMinReceiveAmount
      , "sold_volume" .= dexOrderDTOSoldVolume
      , "bought_volume" .= dexOrderDTOBoughtVolume
      , "create_epoch" .= dexOrderDTOCreateEpoch
      , "cancel_epoch" .= dexOrderDTOCancelEpoch
      , "delete_epoch" .= dexOrderDTODeleteEpoch
      , "tx_hash" .= dexOrderDTOTxHash
      , "tx_log_index" .= dexOrderDTOTxLogIndex
      , "vid" .= dexOrderDTOVid
      ]


-- | Construct a value of type 'DexOrderDTO' (by applying it's required fields, if any)
mkDexOrderDTO
  :: DexOrderDTO
mkDexOrderDTO =
  DexOrderDTO
  { dexOrderDTOEntryTime = Nothing
  , dexOrderDTORecvTime = Nothing
  , dexOrderDTOBlockNumber = Nothing
  , dexOrderDTOId = Nothing
  , dexOrderDTOOwner = Nothing
  , dexOrderDTOOrderId = Nothing
  , dexOrderDTOFromBatchId = Nothing
  , dexOrderDTOFromEpoch = Nothing
  , dexOrderDTOUntilBatchId = Nothing
  , dexOrderDTOUntilEpoch = Nothing
  , dexOrderDTOBuyToken = Nothing
  , dexOrderDTOSellToken = Nothing
  , dexOrderDTOPriceNumerator = Nothing
  , dexOrderDTOPriceDenominator = Nothing
  , dexOrderDTOMaxSellAmount = Nothing
  , dexOrderDTOMinReceiveAmount = Nothing
  , dexOrderDTOSoldVolume = Nothing
  , dexOrderDTOBoughtVolume = Nothing
  , dexOrderDTOCreateEpoch = Nothing
  , dexOrderDTOCancelEpoch = Nothing
  , dexOrderDTODeleteEpoch = Nothing
  , dexOrderDTOTxHash = Nothing
  , dexOrderDTOTxLogIndex = Nothing
  , dexOrderDTOVid = Nothing
  }

-- ** DexPriceDTO
-- | DexPriceDTO
-- Token price in conjuction with batch id.
data DexPriceDTO = DexPriceDTO
  { dexPriceDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexPriceDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexPriceDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexPriceDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;token id&gt;-&lt;batch id&gt;.
  , dexPriceDTOToken :: !(Maybe Text) -- ^ "token" - Token identifier.
  , dexPriceDTOBatchId :: !(Maybe Text) -- ^ "batch_id" - Batch identifier.
  , dexPriceDTOPriceInOwlNumerator :: !(Maybe Text) -- ^ "price_in_owl_numerator" - Price enumerator in OWL (derivative of the GNO token).
  , dexPriceDTOPriceInOwlDenominator :: !(Maybe Text) -- ^ "price_in_owl_denominator" - Price denominator in OWL (derivative of the GNO token).
  , dexPriceDTOVolume :: !(Maybe Text) -- ^ "volume" - Volume.
  , dexPriceDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - Create epoch.
  , dexPriceDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Transaction hash.
  , dexPriceDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexPriceDTO
instance A.FromJSON DexPriceDTO where
  parseJSON = A.withObject "DexPriceDTO" $ \o ->
    DexPriceDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "token")
      <*> (o .:? "batch_id")
      <*> (o .:? "price_in_owl_numerator")
      <*> (o .:? "price_in_owl_denominator")
      <*> (o .:? "volume")
      <*> (o .:? "create_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexPriceDTO
instance A.ToJSON DexPriceDTO where
  toJSON DexPriceDTO {..} =
   _omitNulls
      [ "entry_time" .= dexPriceDTOEntryTime
      , "recv_time" .= dexPriceDTORecvTime
      , "block_number" .= dexPriceDTOBlockNumber
      , "id" .= dexPriceDTOId
      , "token" .= dexPriceDTOToken
      , "batch_id" .= dexPriceDTOBatchId
      , "price_in_owl_numerator" .= dexPriceDTOPriceInOwlNumerator
      , "price_in_owl_denominator" .= dexPriceDTOPriceInOwlDenominator
      , "volume" .= dexPriceDTOVolume
      , "create_epoch" .= dexPriceDTOCreateEpoch
      , "tx_hash" .= dexPriceDTOTxHash
      , "vid" .= dexPriceDTOVid
      ]


-- | Construct a value of type 'DexPriceDTO' (by applying it's required fields, if any)
mkDexPriceDTO
  :: DexPriceDTO
mkDexPriceDTO =
  DexPriceDTO
  { dexPriceDTOEntryTime = Nothing
  , dexPriceDTORecvTime = Nothing
  , dexPriceDTOBlockNumber = Nothing
  , dexPriceDTOId = Nothing
  , dexPriceDTOToken = Nothing
  , dexPriceDTOBatchId = Nothing
  , dexPriceDTOPriceInOwlNumerator = Nothing
  , dexPriceDTOPriceInOwlDenominator = Nothing
  , dexPriceDTOVolume = Nothing
  , dexPriceDTOCreateEpoch = Nothing
  , dexPriceDTOTxHash = Nothing
  , dexPriceDTOVid = Nothing
  }

-- ** DexSolutionDTO
-- | DexSolutionDTO
data DexSolutionDTO = DexSolutionDTO
  { dexSolutionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexSolutionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexSolutionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexSolutionDTOId :: !(Maybe Text) -- ^ "id" - 
  , dexSolutionDTOBatch :: !(Maybe Text) -- ^ "batch" - 
  , dexSolutionDTOSolver :: !(Maybe Text) -- ^ "solver" - 
  , dexSolutionDTOFeeReward :: !(Maybe Text) -- ^ "fee_reward" - 
  , dexSolutionDTOObjectiveValue :: !(Maybe Text) -- ^ "objective_value" - 
  , dexSolutionDTOUtility :: !(Maybe Text) -- ^ "utility" - 
  , dexSolutionDTOTrades :: !(Maybe [Text]) -- ^ "trades" - 
  , dexSolutionDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - 
  , dexSolutionDTORevertEpoch :: !(Maybe Text) -- ^ "revert_epoch" - 
  , dexSolutionDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexSolutionDTOTxLogIndex :: !(Maybe Text) -- ^ "tx_log_index" - 
  , dexSolutionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexSolutionDTO
instance A.FromJSON DexSolutionDTO where
  parseJSON = A.withObject "DexSolutionDTO" $ \o ->
    DexSolutionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "batch")
      <*> (o .:? "solver")
      <*> (o .:? "fee_reward")
      <*> (o .:? "objective_value")
      <*> (o .:? "utility")
      <*> (o .:? "trades")
      <*> (o .:? "create_epoch")
      <*> (o .:? "revert_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "tx_log_index")
      <*> (o .:? "vid")

-- | ToJSON DexSolutionDTO
instance A.ToJSON DexSolutionDTO where
  toJSON DexSolutionDTO {..} =
   _omitNulls
      [ "entry_time" .= dexSolutionDTOEntryTime
      , "recv_time" .= dexSolutionDTORecvTime
      , "block_number" .= dexSolutionDTOBlockNumber
      , "id" .= dexSolutionDTOId
      , "batch" .= dexSolutionDTOBatch
      , "solver" .= dexSolutionDTOSolver
      , "fee_reward" .= dexSolutionDTOFeeReward
      , "objective_value" .= dexSolutionDTOObjectiveValue
      , "utility" .= dexSolutionDTOUtility
      , "trades" .= dexSolutionDTOTrades
      , "create_epoch" .= dexSolutionDTOCreateEpoch
      , "revert_epoch" .= dexSolutionDTORevertEpoch
      , "tx_hash" .= dexSolutionDTOTxHash
      , "tx_log_index" .= dexSolutionDTOTxLogIndex
      , "vid" .= dexSolutionDTOVid
      ]


-- | Construct a value of type 'DexSolutionDTO' (by applying it's required fields, if any)
mkDexSolutionDTO
  :: DexSolutionDTO
mkDexSolutionDTO =
  DexSolutionDTO
  { dexSolutionDTOEntryTime = Nothing
  , dexSolutionDTORecvTime = Nothing
  , dexSolutionDTOBlockNumber = Nothing
  , dexSolutionDTOId = Nothing
  , dexSolutionDTOBatch = Nothing
  , dexSolutionDTOSolver = Nothing
  , dexSolutionDTOFeeReward = Nothing
  , dexSolutionDTOObjectiveValue = Nothing
  , dexSolutionDTOUtility = Nothing
  , dexSolutionDTOTrades = Nothing
  , dexSolutionDTOCreateEpoch = Nothing
  , dexSolutionDTORevertEpoch = Nothing
  , dexSolutionDTOTxHash = Nothing
  , dexSolutionDTOTxLogIndex = Nothing
  , dexSolutionDTOVid = Nothing
  }

-- ** DexStatsDTO
-- | DexStatsDTO
-- A type collecting global stats about this instance of Gnosis Protocol.
data DexStatsDTO = DexStatsDTO
  { dexStatsDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexStatsDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexStatsDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexStatsDTOId :: !(Maybe Text) -- ^ "id" - 
  , dexStatsDTOVolumeInOwl :: !(Maybe Text) -- ^ "volume_in_owl" - The total volume denominated in OWL (all sell amounts combined).
  , dexStatsDTOUtilityInOwl :: !(Maybe Text) -- ^ "utility_in_owl" - The total trader surplus in OWL.
  , dexStatsDTOOwlBurnt :: !(Maybe Text) -- ^ "owl_burnt" - The total amount of OWL burnt (equivalent to fees rewarded to solvers).
  , dexStatsDTOSettledBatchCount :: !(Maybe Int) -- ^ "settled_batch_count" - The total number of settled batches.
  , dexStatsDTOSettledTradeCount :: !(Maybe Int) -- ^ "settled_trade_count" - The total number of settled trades.
  , dexStatsDTOListedTokens :: !(Maybe Int) -- ^ "listed_tokens" - The number of listed tokens.
  , dexStatsDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexStatsDTO
instance A.FromJSON DexStatsDTO where
  parseJSON = A.withObject "DexStatsDTO" $ \o ->
    DexStatsDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "volume_in_owl")
      <*> (o .:? "utility_in_owl")
      <*> (o .:? "owl_burnt")
      <*> (o .:? "settled_batch_count")
      <*> (o .:? "settled_trade_count")
      <*> (o .:? "listed_tokens")
      <*> (o .:? "vid")

-- | ToJSON DexStatsDTO
instance A.ToJSON DexStatsDTO where
  toJSON DexStatsDTO {..} =
   _omitNulls
      [ "entry_time" .= dexStatsDTOEntryTime
      , "recv_time" .= dexStatsDTORecvTime
      , "block_number" .= dexStatsDTOBlockNumber
      , "id" .= dexStatsDTOId
      , "volume_in_owl" .= dexStatsDTOVolumeInOwl
      , "utility_in_owl" .= dexStatsDTOUtilityInOwl
      , "owl_burnt" .= dexStatsDTOOwlBurnt
      , "settled_batch_count" .= dexStatsDTOSettledBatchCount
      , "settled_trade_count" .= dexStatsDTOSettledTradeCount
      , "listed_tokens" .= dexStatsDTOListedTokens
      , "vid" .= dexStatsDTOVid
      ]


-- | Construct a value of type 'DexStatsDTO' (by applying it's required fields, if any)
mkDexStatsDTO
  :: DexStatsDTO
mkDexStatsDTO =
  DexStatsDTO
  { dexStatsDTOEntryTime = Nothing
  , dexStatsDTORecvTime = Nothing
  , dexStatsDTOBlockNumber = Nothing
  , dexStatsDTOId = Nothing
  , dexStatsDTOVolumeInOwl = Nothing
  , dexStatsDTOUtilityInOwl = Nothing
  , dexStatsDTOOwlBurnt = Nothing
  , dexStatsDTOSettledBatchCount = Nothing
  , dexStatsDTOSettledTradeCount = Nothing
  , dexStatsDTOListedTokens = Nothing
  , dexStatsDTOVid = Nothing
  }

-- ** DexTokenDTO
-- | DexTokenDTO
-- Registered token.
data DexTokenDTO = DexTokenDTO
  { dexTokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexTokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexTokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexTokenDTOId :: !(Maybe Text) -- ^ "id" - 
  , dexTokenDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , dexTokenDTOFromBatchId :: !(Maybe Text) -- ^ "from_batch_id" - 
  , dexTokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - 
  , dexTokenDTODecimals :: !(Maybe Text) -- ^ "decimals" - 
  , dexTokenDTOName :: !(Maybe Text) -- ^ "name" - 
  , dexTokenDTOSellVolume :: !(Maybe Text) -- ^ "sell_volume" - Cumulative sell volume.
  , dexTokenDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - 
  , dexTokenDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexTokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , dexTokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexTokenDTO
instance A.FromJSON DexTokenDTO where
  parseJSON = A.withObject "DexTokenDTO" $ \o ->
    DexTokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "from_batch_id")
      <*> (o .:? "symbol")
      <*> (o .:? "decimals")
      <*> (o .:? "name")
      <*> (o .:? "sell_volume")
      <*> (o .:? "create_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")
      <*> (o .:? "token_symbol")

-- | ToJSON DexTokenDTO
instance A.ToJSON DexTokenDTO where
  toJSON DexTokenDTO {..} =
   _omitNulls
      [ "entry_time" .= dexTokenDTOEntryTime
      , "recv_time" .= dexTokenDTORecvTime
      , "block_number" .= dexTokenDTOBlockNumber
      , "id" .= dexTokenDTOId
      , "address" .= dexTokenDTOAddress
      , "from_batch_id" .= dexTokenDTOFromBatchId
      , "symbol" .= dexTokenDTOSymbol
      , "decimals" .= dexTokenDTODecimals
      , "name" .= dexTokenDTOName
      , "sell_volume" .= dexTokenDTOSellVolume
      , "create_epoch" .= dexTokenDTOCreateEpoch
      , "tx_hash" .= dexTokenDTOTxHash
      , "vid" .= dexTokenDTOVid
      , "token_symbol" .= dexTokenDTOTokenSymbol
      ]


-- | Construct a value of type 'DexTokenDTO' (by applying it's required fields, if any)
mkDexTokenDTO
  :: DexTokenDTO
mkDexTokenDTO =
  DexTokenDTO
  { dexTokenDTOEntryTime = Nothing
  , dexTokenDTORecvTime = Nothing
  , dexTokenDTOBlockNumber = Nothing
  , dexTokenDTOId = Nothing
  , dexTokenDTOAddress = Nothing
  , dexTokenDTOFromBatchId = Nothing
  , dexTokenDTOSymbol = Nothing
  , dexTokenDTODecimals = Nothing
  , dexTokenDTOName = Nothing
  , dexTokenDTOSellVolume = Nothing
  , dexTokenDTOCreateEpoch = Nothing
  , dexTokenDTOTxHash = Nothing
  , dexTokenDTOVid = Nothing
  , dexTokenDTOTokenSymbol = Nothing
  }

-- ** DexTradeDTO
-- | DexTradeDTO
-- Trade for a single user, as part of a ring trade. It's part of the solution submitted by a solver for a given batch.
data DexTradeDTO = DexTradeDTO
  { dexTradeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexTradeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexTradeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexTradeDTOId :: !(Maybe Text) -- ^ "id" - 
  , dexTradeDTOOrder :: !(Maybe Text) -- ^ "order" - 
  , dexTradeDTOOwner :: !(Maybe Text) -- ^ "owner" - 
  , dexTradeDTOSellVolume :: !(Maybe Text) -- ^ "sell_volume" - 
  , dexTradeDTOBuyVolume :: !(Maybe Text) -- ^ "buy_volume" - 
  , dexTradeDTOTradeBatchId :: !(Maybe Text) -- ^ "trade_batch_id" - 
  , dexTradeDTOTradeEpoch :: !(Maybe Text) -- ^ "trade_epoch" - The date of the end of the batch.
  , dexTradeDTOBuyToken :: !(Maybe Text) -- ^ "buy_token" - 
  , dexTradeDTOSellToken :: !(Maybe Text) -- ^ "sell_token" - 
  , dexTradeDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - The date where the transaction was mined.
  , dexTradeDTORevertEpoch :: !(Maybe Text) -- ^ "revert_epoch" - 
  , dexTradeDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexTradeDTOTxLogIndex :: !(Maybe Text) -- ^ "tx_log_index" - 
  , dexTradeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , dexTradeDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , dexTradeDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  , dexTradeDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , dexTradeDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , dexTradeDTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexTradeDTO
instance A.FromJSON DexTradeDTO where
  parseJSON = A.withObject "DexTradeDTO" $ \o ->
    DexTradeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "order")
      <*> (o .:? "owner")
      <*> (o .:? "sell_volume")
      <*> (o .:? "buy_volume")
      <*> (o .:? "trade_batch_id")
      <*> (o .:? "trade_epoch")
      <*> (o .:? "buy_token")
      <*> (o .:? "sell_token")
      <*> (o .:? "create_epoch")
      <*> (o .:? "revert_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "tx_log_index")
      <*> (o .:? "vid")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")

-- | ToJSON DexTradeDTO
instance A.ToJSON DexTradeDTO where
  toJSON DexTradeDTO {..} =
   _omitNulls
      [ "entry_time" .= dexTradeDTOEntryTime
      , "recv_time" .= dexTradeDTORecvTime
      , "block_number" .= dexTradeDTOBlockNumber
      , "id" .= dexTradeDTOId
      , "order" .= dexTradeDTOOrder
      , "owner" .= dexTradeDTOOwner
      , "sell_volume" .= dexTradeDTOSellVolume
      , "buy_volume" .= dexTradeDTOBuyVolume
      , "trade_batch_id" .= dexTradeDTOTradeBatchId
      , "trade_epoch" .= dexTradeDTOTradeEpoch
      , "buy_token" .= dexTradeDTOBuyToken
      , "sell_token" .= dexTradeDTOSellToken
      , "create_epoch" .= dexTradeDTOCreateEpoch
      , "revert_epoch" .= dexTradeDTORevertEpoch
      , "tx_hash" .= dexTradeDTOTxHash
      , "tx_log_index" .= dexTradeDTOTxLogIndex
      , "vid" .= dexTradeDTOVid
      , "pool_id" .= dexTradeDTOPoolId
      , "transaction_id" .= dexTradeDTOTransactionId
      , "evaluated_price" .= dexTradeDTOEvaluatedPrice
      , "evaluated_amount" .= dexTradeDTOEvaluatedAmount
      , "evaluated_aggressor" .= dexTradeDTOEvaluatedAggressor
      ]


-- | Construct a value of type 'DexTradeDTO' (by applying it's required fields, if any)
mkDexTradeDTO
  :: DexTradeDTO
mkDexTradeDTO =
  DexTradeDTO
  { dexTradeDTOEntryTime = Nothing
  , dexTradeDTORecvTime = Nothing
  , dexTradeDTOBlockNumber = Nothing
  , dexTradeDTOId = Nothing
  , dexTradeDTOOrder = Nothing
  , dexTradeDTOOwner = Nothing
  , dexTradeDTOSellVolume = Nothing
  , dexTradeDTOBuyVolume = Nothing
  , dexTradeDTOTradeBatchId = Nothing
  , dexTradeDTOTradeEpoch = Nothing
  , dexTradeDTOBuyToken = Nothing
  , dexTradeDTOSellToken = Nothing
  , dexTradeDTOCreateEpoch = Nothing
  , dexTradeDTORevertEpoch = Nothing
  , dexTradeDTOTxHash = Nothing
  , dexTradeDTOTxLogIndex = Nothing
  , dexTradeDTOVid = Nothing
  , dexTradeDTOPoolId = Nothing
  , dexTradeDTOTransactionId = Nothing
  , dexTradeDTOEvaluatedPrice = Nothing
  , dexTradeDTOEvaluatedAmount = Nothing
  , dexTradeDTOEvaluatedAggressor = Nothing
  }

-- ** DexUserDTO
-- | DexUserDTO
-- User of the protocol. Any ethereum account that deposited tokens or traded.
data DexUserDTO = DexUserDTO
  { dexUserDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexUserDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexUserDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexUserDTOId :: !(Maybe Text) -- ^ "id" - 
  , dexUserDTOFromBatchId :: !(Maybe Text) -- ^ "from_batch_id" - 
  , dexUserDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - 
  , dexUserDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexUserDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexUserDTO
instance A.FromJSON DexUserDTO where
  parseJSON = A.withObject "DexUserDTO" $ \o ->
    DexUserDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "from_batch_id")
      <*> (o .:? "create_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexUserDTO
instance A.ToJSON DexUserDTO where
  toJSON DexUserDTO {..} =
   _omitNulls
      [ "entry_time" .= dexUserDTOEntryTime
      , "recv_time" .= dexUserDTORecvTime
      , "block_number" .= dexUserDTOBlockNumber
      , "id" .= dexUserDTOId
      , "from_batch_id" .= dexUserDTOFromBatchId
      , "create_epoch" .= dexUserDTOCreateEpoch
      , "tx_hash" .= dexUserDTOTxHash
      , "vid" .= dexUserDTOVid
      ]


-- | Construct a value of type 'DexUserDTO' (by applying it's required fields, if any)
mkDexUserDTO
  :: DexUserDTO
mkDexUserDTO =
  DexUserDTO
  { dexUserDTOEntryTime = Nothing
  , dexUserDTORecvTime = Nothing
  , dexUserDTOBlockNumber = Nothing
  , dexUserDTOId = Nothing
  , dexUserDTOFromBatchId = Nothing
  , dexUserDTOCreateEpoch = Nothing
  , dexUserDTOTxHash = Nothing
  , dexUserDTOVid = Nothing
  }

-- ** DexWithdrawDTO
-- | DexWithdrawDTO
-- Withdraw of an user.
data DexWithdrawDTO = DexWithdrawDTO
  { dexWithdrawDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexWithdrawDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexWithdrawDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexWithdrawDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;transaction hash&gt;-&lt;id&gt;.
  , dexWithdrawDTOUser :: !(Maybe Text) -- ^ "user" - 
  , dexWithdrawDTOTokenAddress :: !(Maybe Text) -- ^ "token_address" - 
  , dexWithdrawDTOAmount :: !(Maybe Text) -- ^ "amount" - 
  , dexWithdrawDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - 
  , dexWithdrawDTOCreateBatchId :: !(Maybe Text) -- ^ "create_batch_id" - 
  , dexWithdrawDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexWithdrawDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexWithdrawDTO
instance A.FromJSON DexWithdrawDTO where
  parseJSON = A.withObject "DexWithdrawDTO" $ \o ->
    DexWithdrawDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "token_address")
      <*> (o .:? "amount")
      <*> (o .:? "create_epoch")
      <*> (o .:? "create_batch_id")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexWithdrawDTO
instance A.ToJSON DexWithdrawDTO where
  toJSON DexWithdrawDTO {..} =
   _omitNulls
      [ "entry_time" .= dexWithdrawDTOEntryTime
      , "recv_time" .= dexWithdrawDTORecvTime
      , "block_number" .= dexWithdrawDTOBlockNumber
      , "id" .= dexWithdrawDTOId
      , "user" .= dexWithdrawDTOUser
      , "token_address" .= dexWithdrawDTOTokenAddress
      , "amount" .= dexWithdrawDTOAmount
      , "create_epoch" .= dexWithdrawDTOCreateEpoch
      , "create_batch_id" .= dexWithdrawDTOCreateBatchId
      , "tx_hash" .= dexWithdrawDTOTxHash
      , "vid" .= dexWithdrawDTOVid
      ]


-- | Construct a value of type 'DexWithdrawDTO' (by applying it's required fields, if any)
mkDexWithdrawDTO
  :: DexWithdrawDTO
mkDexWithdrawDTO =
  DexWithdrawDTO
  { dexWithdrawDTOEntryTime = Nothing
  , dexWithdrawDTORecvTime = Nothing
  , dexWithdrawDTOBlockNumber = Nothing
  , dexWithdrawDTOId = Nothing
  , dexWithdrawDTOUser = Nothing
  , dexWithdrawDTOTokenAddress = Nothing
  , dexWithdrawDTOAmount = Nothing
  , dexWithdrawDTOCreateEpoch = Nothing
  , dexWithdrawDTOCreateBatchId = Nothing
  , dexWithdrawDTOTxHash = Nothing
  , dexWithdrawDTOVid = Nothing
  }

-- ** DexWithdrawRequestDTO
-- | DexWithdrawRequestDTO
-- Withdraw request of an user
data DexWithdrawRequestDTO = DexWithdrawRequestDTO
  { dexWithdrawRequestDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexWithdrawRequestDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexWithdrawRequestDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexWithdrawRequestDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;transaction hash&gt;-&lt;id&gt;.
  , dexWithdrawRequestDTOUser :: !(Maybe Text) -- ^ "user" - 
  , dexWithdrawRequestDTOTokenAddress :: !(Maybe Text) -- ^ "token_address" - 
  , dexWithdrawRequestDTOAmount :: !(Maybe Text) -- ^ "amount" - 
  , dexWithdrawRequestDTOWithdrawableFromBatchId :: !(Maybe Text) -- ^ "withdrawable_from_batch_id" - 
  , dexWithdrawRequestDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - 
  , dexWithdrawRequestDTOCreateBatchId :: !(Maybe Text) -- ^ "create_batch_id" - 
  , dexWithdrawRequestDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexWithdrawRequestDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexWithdrawRequestDTO
instance A.FromJSON DexWithdrawRequestDTO where
  parseJSON = A.withObject "DexWithdrawRequestDTO" $ \o ->
    DexWithdrawRequestDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "token_address")
      <*> (o .:? "amount")
      <*> (o .:? "withdrawable_from_batch_id")
      <*> (o .:? "create_epoch")
      <*> (o .:? "create_batch_id")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexWithdrawRequestDTO
instance A.ToJSON DexWithdrawRequestDTO where
  toJSON DexWithdrawRequestDTO {..} =
   _omitNulls
      [ "entry_time" .= dexWithdrawRequestDTOEntryTime
      , "recv_time" .= dexWithdrawRequestDTORecvTime
      , "block_number" .= dexWithdrawRequestDTOBlockNumber
      , "id" .= dexWithdrawRequestDTOId
      , "user" .= dexWithdrawRequestDTOUser
      , "token_address" .= dexWithdrawRequestDTOTokenAddress
      , "amount" .= dexWithdrawRequestDTOAmount
      , "withdrawable_from_batch_id" .= dexWithdrawRequestDTOWithdrawableFromBatchId
      , "create_epoch" .= dexWithdrawRequestDTOCreateEpoch
      , "create_batch_id" .= dexWithdrawRequestDTOCreateBatchId
      , "tx_hash" .= dexWithdrawRequestDTOTxHash
      , "vid" .= dexWithdrawRequestDTOVid
      ]


-- | Construct a value of type 'DexWithdrawRequestDTO' (by applying it's required fields, if any)
mkDexWithdrawRequestDTO
  :: DexWithdrawRequestDTO
mkDexWithdrawRequestDTO =
  DexWithdrawRequestDTO
  { dexWithdrawRequestDTOEntryTime = Nothing
  , dexWithdrawRequestDTORecvTime = Nothing
  , dexWithdrawRequestDTOBlockNumber = Nothing
  , dexWithdrawRequestDTOId = Nothing
  , dexWithdrawRequestDTOUser = Nothing
  , dexWithdrawRequestDTOTokenAddress = Nothing
  , dexWithdrawRequestDTOAmount = Nothing
  , dexWithdrawRequestDTOWithdrawableFromBatchId = Nothing
  , dexWithdrawRequestDTOCreateEpoch = Nothing
  , dexWithdrawRequestDTOCreateBatchId = Nothing
  , dexWithdrawRequestDTOTxHash = Nothing
  , dexWithdrawRequestDTOVid = Nothing
  }

-- ** NumericsBigInteger
-- | NumericsBigInteger
data NumericsBigInteger = NumericsBigInteger
  { numericsBigIntegerIsPowerOfTwo :: !(Maybe Bool) -- ^ /ReadOnly/ "is_power_of_two"
  , numericsBigIntegerIsZero :: !(Maybe Bool) -- ^ /ReadOnly/ "is_zero"
  , numericsBigIntegerIsOne :: !(Maybe Bool) -- ^ /ReadOnly/ "is_one"
  , numericsBigIntegerIsEven :: !(Maybe Bool) -- ^ /ReadOnly/ "is_even"
  , numericsBigIntegerSign :: !(Maybe Int) -- ^ /ReadOnly/ "sign"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NumericsBigInteger
instance A.FromJSON NumericsBigInteger where
  parseJSON = A.withObject "NumericsBigInteger" $ \o ->
    NumericsBigInteger
      <$> (o .:? "is_power_of_two")
      <*> (o .:? "is_zero")
      <*> (o .:? "is_one")
      <*> (o .:? "is_even")
      <*> (o .:? "sign")

-- | ToJSON NumericsBigInteger
instance A.ToJSON NumericsBigInteger where
  toJSON NumericsBigInteger {..} =
   _omitNulls
      [ "is_power_of_two" .= numericsBigIntegerIsPowerOfTwo
      , "is_zero" .= numericsBigIntegerIsZero
      , "is_one" .= numericsBigIntegerIsOne
      , "is_even" .= numericsBigIntegerIsEven
      , "sign" .= numericsBigIntegerSign
      ]


-- | Construct a value of type 'NumericsBigInteger' (by applying it's required fields, if any)
mkNumericsBigInteger
  :: NumericsBigInteger
mkNumericsBigInteger =
  NumericsBigInteger
  { numericsBigIntegerIsPowerOfTwo = Nothing
  , numericsBigIntegerIsZero = Nothing
  , numericsBigIntegerIsOne = Nothing
  , numericsBigIntegerIsEven = Nothing
  , numericsBigIntegerSign = Nothing
  }

-- ** SushiswapBundleDTO
-- | SushiswapBundleDTO
-- The Bundle is used as a global store of derived ETH price in USD.
data SushiswapBundleDTO = SushiswapBundleDTO
  { sushiswapBundleDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapBundleDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapBundleDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapBundleDTOId :: !(Maybe Text) -- ^ "id" - Hardcoded to &#39;1&#39;.
  , sushiswapBundleDTOEthPrice :: !(Maybe Text) -- ^ "eth_price" - Price of native.
  , sushiswapBundleDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapBundleDTO
instance A.FromJSON SushiswapBundleDTO where
  parseJSON = A.withObject "SushiswapBundleDTO" $ \o ->
    SushiswapBundleDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "eth_price")
      <*> (o .:? "vid")

-- | ToJSON SushiswapBundleDTO
instance A.ToJSON SushiswapBundleDTO where
  toJSON SushiswapBundleDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapBundleDTOEntryTime
      , "recv_time" .= sushiswapBundleDTORecvTime
      , "block_number" .= sushiswapBundleDTOBlockNumber
      , "id" .= sushiswapBundleDTOId
      , "eth_price" .= sushiswapBundleDTOEthPrice
      , "vid" .= sushiswapBundleDTOVid
      ]


-- | Construct a value of type 'SushiswapBundleDTO' (by applying it's required fields, if any)
mkSushiswapBundleDTO
  :: SushiswapBundleDTO
mkSushiswapBundleDTO =
  SushiswapBundleDTO
  { sushiswapBundleDTOEntryTime = Nothing
  , sushiswapBundleDTORecvTime = Nothing
  , sushiswapBundleDTOBlockNumber = Nothing
  , sushiswapBundleDTOId = Nothing
  , sushiswapBundleDTOEthPrice = Nothing
  , sushiswapBundleDTOVid = Nothing
  }

-- ** SushiswapBurnDTO
-- | SushiswapBurnDTO
-- Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
data SushiswapBurnDTO = SushiswapBurnDTO
  { sushiswapBurnDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapBurnDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapBurnDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapBurnDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;transaction id&gt;:&lt;transaction.burns.length&gt;.
  , sushiswapBurnDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to the transaction Burn was included in.
  , sushiswapBurnDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of Burn, used to sort recent liquidity removals.
  , sushiswapBurnDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , sushiswapBurnDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Amount of liquidity tokens burned.
  , sushiswapBurnDTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the liquidity removal.
  , sushiswapBurnDTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token0 removed.
  , sushiswapBurnDTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token1 removed.
  , sushiswapBurnDTOTo :: !(Maybe Text) -- ^ "to" - Recipient of tokens.
  , sushiswapBurnDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Index in the transaction event was emitted.
  , sushiswapBurnDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount based on available prices of tokens.
  , sushiswapBurnDTOComplete :: !(Maybe Bool) -- ^ "complete" - 
  , sushiswapBurnDTOFeeTo :: !(Maybe Text) -- ^ "fee_to" - Address of fee recipient (if fee is on).
  , sushiswapBurnDTOFeeLiquidity :: !(Maybe Text) -- ^ "fee_liquidity" - Amount of tokens sent to fee recipient (if fee is on).
  , sushiswapBurnDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapBurnDTO
instance A.FromJSON SushiswapBurnDTO where
  parseJSON = A.withObject "SushiswapBurnDTO" $ \o ->
    SushiswapBurnDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "liquidity")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "to")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "complete")
      <*> (o .:? "fee_to")
      <*> (o .:? "fee_liquidity")
      <*> (o .:? "vid")

-- | ToJSON SushiswapBurnDTO
instance A.ToJSON SushiswapBurnDTO where
  toJSON SushiswapBurnDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapBurnDTOEntryTime
      , "recv_time" .= sushiswapBurnDTORecvTime
      , "block_number" .= sushiswapBurnDTOBlockNumber
      , "id" .= sushiswapBurnDTOId
      , "transaction" .= sushiswapBurnDTOTransaction
      , "timestamp" .= sushiswapBurnDTOTimestamp
      , "pair" .= sushiswapBurnDTOPair
      , "liquidity" .= sushiswapBurnDTOLiquidity
      , "sender" .= sushiswapBurnDTOSender
      , "amount_0" .= sushiswapBurnDTOAmount0
      , "amount_1" .= sushiswapBurnDTOAmount1
      , "to" .= sushiswapBurnDTOTo
      , "log_index" .= sushiswapBurnDTOLogIndex
      , "amount_usd" .= sushiswapBurnDTOAmountUsd
      , "complete" .= sushiswapBurnDTOComplete
      , "fee_to" .= sushiswapBurnDTOFeeTo
      , "fee_liquidity" .= sushiswapBurnDTOFeeLiquidity
      , "vid" .= sushiswapBurnDTOVid
      ]


-- | Construct a value of type 'SushiswapBurnDTO' (by applying it's required fields, if any)
mkSushiswapBurnDTO
  :: SushiswapBurnDTO
mkSushiswapBurnDTO =
  SushiswapBurnDTO
  { sushiswapBurnDTOEntryTime = Nothing
  , sushiswapBurnDTORecvTime = Nothing
  , sushiswapBurnDTOBlockNumber = Nothing
  , sushiswapBurnDTOId = Nothing
  , sushiswapBurnDTOTransaction = Nothing
  , sushiswapBurnDTOTimestamp = Nothing
  , sushiswapBurnDTOPair = Nothing
  , sushiswapBurnDTOLiquidity = Nothing
  , sushiswapBurnDTOSender = Nothing
  , sushiswapBurnDTOAmount0 = Nothing
  , sushiswapBurnDTOAmount1 = Nothing
  , sushiswapBurnDTOTo = Nothing
  , sushiswapBurnDTOLogIndex = Nothing
  , sushiswapBurnDTOAmountUsd = Nothing
  , sushiswapBurnDTOComplete = Nothing
  , sushiswapBurnDTOFeeTo = Nothing
  , sushiswapBurnDTOFeeLiquidity = Nothing
  , sushiswapBurnDTOVid = Nothing
  }

-- ** SushiswapDayDataDTO
-- | SushiswapDayDataDTO
-- Tracks data across all pairs aggregated into a daily bucket.
data SushiswapDayDataDTO = SushiswapDayDataDTO
  { sushiswapDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapDayDataDTOId :: !(Maybe Text) -- ^ "id" - Unix timestamp for start of day / 86400 giving a unique day index.
  , sushiswapDayDataDTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , sushiswapDayDataDTOFactory :: !(Maybe Text) -- ^ "factory" - Factory address.
  , sushiswapDayDataDTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - Total volume across all pairs on this day, stored as a derived amount of ETH.
  , sushiswapDayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total volume across all pairs on this day, stored as a derived amount of USD.
  , sushiswapDayDataDTOUntrackedVolume :: !(Maybe Text) -- ^ "untracked_volume" - Total volume across all pairs on this day, untracked
  , sushiswapDayDataDTOLiquidityEth :: !(Maybe Text) -- ^ "liquidity_eth" - Total liquidity across all pairs in ETH up to and including this day.
  , sushiswapDayDataDTOLiquidityUsd :: !(Maybe Text) -- ^ "liquidity_usd" - Total liquidity across all pairs in USD up to and including this day.
  , sushiswapDayDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Number of transactions throughout this day.
  , sushiswapDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapDayDataDTO
instance A.FromJSON SushiswapDayDataDTO where
  parseJSON = A.withObject "SushiswapDayDataDTO" $ \o ->
    SushiswapDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "factory")
      <*> (o .:? "volume_eth")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume")
      <*> (o .:? "liquidity_eth")
      <*> (o .:? "liquidity_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON SushiswapDayDataDTO
instance A.ToJSON SushiswapDayDataDTO where
  toJSON SushiswapDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapDayDataDTOEntryTime
      , "recv_time" .= sushiswapDayDataDTORecvTime
      , "block_number" .= sushiswapDayDataDTOBlockNumber
      , "id" .= sushiswapDayDataDTOId
      , "date" .= sushiswapDayDataDTODate
      , "factory" .= sushiswapDayDataDTOFactory
      , "volume_eth" .= sushiswapDayDataDTOVolumeEth
      , "volume_usd" .= sushiswapDayDataDTOVolumeUsd
      , "untracked_volume" .= sushiswapDayDataDTOUntrackedVolume
      , "liquidity_eth" .= sushiswapDayDataDTOLiquidityEth
      , "liquidity_usd" .= sushiswapDayDataDTOLiquidityUsd
      , "tx_count" .= sushiswapDayDataDTOTxCount
      , "vid" .= sushiswapDayDataDTOVid
      ]


-- | Construct a value of type 'SushiswapDayDataDTO' (by applying it's required fields, if any)
mkSushiswapDayDataDTO
  :: SushiswapDayDataDTO
mkSushiswapDayDataDTO =
  SushiswapDayDataDTO
  { sushiswapDayDataDTOEntryTime = Nothing
  , sushiswapDayDataDTORecvTime = Nothing
  , sushiswapDayDataDTOBlockNumber = Nothing
  , sushiswapDayDataDTOId = Nothing
  , sushiswapDayDataDTODate = Nothing
  , sushiswapDayDataDTOFactory = Nothing
  , sushiswapDayDataDTOVolumeEth = Nothing
  , sushiswapDayDataDTOVolumeUsd = Nothing
  , sushiswapDayDataDTOUntrackedVolume = Nothing
  , sushiswapDayDataDTOLiquidityEth = Nothing
  , sushiswapDayDataDTOLiquidityUsd = Nothing
  , sushiswapDayDataDTOTxCount = Nothing
  , sushiswapDayDataDTOVid = Nothing
  }

-- ** SushiswapFactoryDTO
-- | SushiswapFactoryDTO
-- The Sushiswap Factory entity is responsible for storing aggregate information across all Sushiswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
data SushiswapFactoryDTO = SushiswapFactoryDTO
  { sushiswapFactoryDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapFactoryDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapFactoryDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapFactoryDTOId :: !(Maybe Text) -- ^ "id" - Factory address.
  , sushiswapFactoryDTOPairCount :: !(Maybe Text) -- ^ "pair_count" - Amount of pairs created by the Sushiswap factory.
  , sushiswapFactoryDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - All time USD volume across all pairs (USD is derived).
  , sushiswapFactoryDTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - All time volume in ETH across all pairs (ETH is derived).
  , sushiswapFactoryDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Untracked volume USD.
  , sushiswapFactoryDTOLiquidityUsd :: !(Maybe Text) -- ^ "liquidity_usd" - Total liquidity across all pairs stored as a derived USD amount.
  , sushiswapFactoryDTOLiquidityEth :: !(Maybe Text) -- ^ "liquidity_eth" - Total liquidity across all pairs stored as a derived ETH amount.
  , sushiswapFactoryDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - All time amount of transactions across all pairs.
  , sushiswapFactoryDTOTokenCount :: !(Maybe Text) -- ^ "token_count" - Total count of tokens.
  , sushiswapFactoryDTOUserCount :: !(Maybe Text) -- ^ "user_count" - Users count.
  , sushiswapFactoryDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapFactoryDTO
instance A.FromJSON SushiswapFactoryDTO where
  parseJSON = A.withObject "SushiswapFactoryDTO" $ \o ->
    SushiswapFactoryDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pair_count")
      <*> (o .:? "volume_usd")
      <*> (o .:? "volume_eth")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "liquidity_usd")
      <*> (o .:? "liquidity_eth")
      <*> (o .:? "tx_count")
      <*> (o .:? "token_count")
      <*> (o .:? "user_count")
      <*> (o .:? "vid")

-- | ToJSON SushiswapFactoryDTO
instance A.ToJSON SushiswapFactoryDTO where
  toJSON SushiswapFactoryDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapFactoryDTOEntryTime
      , "recv_time" .= sushiswapFactoryDTORecvTime
      , "block_number" .= sushiswapFactoryDTOBlockNumber
      , "id" .= sushiswapFactoryDTOId
      , "pair_count" .= sushiswapFactoryDTOPairCount
      , "volume_usd" .= sushiswapFactoryDTOVolumeUsd
      , "volume_eth" .= sushiswapFactoryDTOVolumeEth
      , "untracked_volume_usd" .= sushiswapFactoryDTOUntrackedVolumeUsd
      , "liquidity_usd" .= sushiswapFactoryDTOLiquidityUsd
      , "liquidity_eth" .= sushiswapFactoryDTOLiquidityEth
      , "tx_count" .= sushiswapFactoryDTOTxCount
      , "token_count" .= sushiswapFactoryDTOTokenCount
      , "user_count" .= sushiswapFactoryDTOUserCount
      , "vid" .= sushiswapFactoryDTOVid
      ]


-- | Construct a value of type 'SushiswapFactoryDTO' (by applying it's required fields, if any)
mkSushiswapFactoryDTO
  :: SushiswapFactoryDTO
mkSushiswapFactoryDTO =
  SushiswapFactoryDTO
  { sushiswapFactoryDTOEntryTime = Nothing
  , sushiswapFactoryDTORecvTime = Nothing
  , sushiswapFactoryDTOBlockNumber = Nothing
  , sushiswapFactoryDTOId = Nothing
  , sushiswapFactoryDTOPairCount = Nothing
  , sushiswapFactoryDTOVolumeUsd = Nothing
  , sushiswapFactoryDTOVolumeEth = Nothing
  , sushiswapFactoryDTOUntrackedVolumeUsd = Nothing
  , sushiswapFactoryDTOLiquidityUsd = Nothing
  , sushiswapFactoryDTOLiquidityEth = Nothing
  , sushiswapFactoryDTOTxCount = Nothing
  , sushiswapFactoryDTOTokenCount = Nothing
  , sushiswapFactoryDTOUserCount = Nothing
  , sushiswapFactoryDTOVid = Nothing
  }

-- ** SushiswapHourDataDTO
-- | SushiswapHourDataDTO
data SushiswapHourDataDTO = SushiswapHourDataDTO
  { sushiswapHourDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapHourDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapHourDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapHourDataDTOId :: !(Maybe Text) -- ^ "id" - Start of hour timestamp.
  , sushiswapHourDataDTODate :: !(Maybe Int) -- ^ "date" - 
  , sushiswapHourDataDTOFactory :: !(Maybe Text) -- ^ "factory" - 
  , sushiswapHourDataDTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - 
  , sushiswapHourDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - 
  , sushiswapHourDataDTOUntrackedVolume :: !(Maybe Text) -- ^ "untracked_volume" - 
  , sushiswapHourDataDTOLiquidityEth :: !(Maybe Text) -- ^ "liquidity_eth" - 
  , sushiswapHourDataDTOLiquidityUsd :: !(Maybe Text) -- ^ "liquidity_usd" - 
  , sushiswapHourDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - 
  , sushiswapHourDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapHourDataDTO
instance A.FromJSON SushiswapHourDataDTO where
  parseJSON = A.withObject "SushiswapHourDataDTO" $ \o ->
    SushiswapHourDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "factory")
      <*> (o .:? "volume_eth")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume")
      <*> (o .:? "liquidity_eth")
      <*> (o .:? "liquidity_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON SushiswapHourDataDTO
instance A.ToJSON SushiswapHourDataDTO where
  toJSON SushiswapHourDataDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapHourDataDTOEntryTime
      , "recv_time" .= sushiswapHourDataDTORecvTime
      , "block_number" .= sushiswapHourDataDTOBlockNumber
      , "id" .= sushiswapHourDataDTOId
      , "date" .= sushiswapHourDataDTODate
      , "factory" .= sushiswapHourDataDTOFactory
      , "volume_eth" .= sushiswapHourDataDTOVolumeEth
      , "volume_usd" .= sushiswapHourDataDTOVolumeUsd
      , "untracked_volume" .= sushiswapHourDataDTOUntrackedVolume
      , "liquidity_eth" .= sushiswapHourDataDTOLiquidityEth
      , "liquidity_usd" .= sushiswapHourDataDTOLiquidityUsd
      , "tx_count" .= sushiswapHourDataDTOTxCount
      , "vid" .= sushiswapHourDataDTOVid
      ]


-- | Construct a value of type 'SushiswapHourDataDTO' (by applying it's required fields, if any)
mkSushiswapHourDataDTO
  :: SushiswapHourDataDTO
mkSushiswapHourDataDTO =
  SushiswapHourDataDTO
  { sushiswapHourDataDTOEntryTime = Nothing
  , sushiswapHourDataDTORecvTime = Nothing
  , sushiswapHourDataDTOBlockNumber = Nothing
  , sushiswapHourDataDTOId = Nothing
  , sushiswapHourDataDTODate = Nothing
  , sushiswapHourDataDTOFactory = Nothing
  , sushiswapHourDataDTOVolumeEth = Nothing
  , sushiswapHourDataDTOVolumeUsd = Nothing
  , sushiswapHourDataDTOUntrackedVolume = Nothing
  , sushiswapHourDataDTOLiquidityEth = Nothing
  , sushiswapHourDataDTOLiquidityUsd = Nothing
  , sushiswapHourDataDTOTxCount = Nothing
  , sushiswapHourDataDTOVid = Nothing
  }

-- ** SushiswapLiquidityPositionDTO
-- | SushiswapLiquidityPositionDTO
data SushiswapLiquidityPositionDTO = SushiswapLiquidityPositionDTO
  { sushiswapLiquidityPositionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapLiquidityPositionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapLiquidityPositionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapLiquidityPositionDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;pair address&gt;-&lt;user address&gt;
  , sushiswapLiquidityPositionDTOUser :: !(Maybe Text) -- ^ "user" - User address.
  , sushiswapLiquidityPositionDTOPair :: !(Maybe Text) -- ^ "pair" - Pair address.
  , sushiswapLiquidityPositionDTOLiquidityTokenBalance :: !(Maybe Text) -- ^ "liquidity_token_balance" - Amount of LP tokens minted for this position.
  , sushiswapLiquidityPositionDTOBlock :: !(Maybe Int) -- ^ "block" - Block number at which position was created.
  , sushiswapLiquidityPositionDTOTimestamp :: !(Maybe Int) -- ^ "timestamp" - Creation time.
  , sushiswapLiquidityPositionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapLiquidityPositionDTO
instance A.FromJSON SushiswapLiquidityPositionDTO where
  parseJSON = A.withObject "SushiswapLiquidityPositionDTO" $ \o ->
    SushiswapLiquidityPositionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "pair")
      <*> (o .:? "liquidity_token_balance")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "vid")

-- | ToJSON SushiswapLiquidityPositionDTO
instance A.ToJSON SushiswapLiquidityPositionDTO where
  toJSON SushiswapLiquidityPositionDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapLiquidityPositionDTOEntryTime
      , "recv_time" .= sushiswapLiquidityPositionDTORecvTime
      , "block_number" .= sushiswapLiquidityPositionDTOBlockNumber
      , "id" .= sushiswapLiquidityPositionDTOId
      , "user" .= sushiswapLiquidityPositionDTOUser
      , "pair" .= sushiswapLiquidityPositionDTOPair
      , "liquidity_token_balance" .= sushiswapLiquidityPositionDTOLiquidityTokenBalance
      , "block" .= sushiswapLiquidityPositionDTOBlock
      , "timestamp" .= sushiswapLiquidityPositionDTOTimestamp
      , "vid" .= sushiswapLiquidityPositionDTOVid
      ]


-- | Construct a value of type 'SushiswapLiquidityPositionDTO' (by applying it's required fields, if any)
mkSushiswapLiquidityPositionDTO
  :: SushiswapLiquidityPositionDTO
mkSushiswapLiquidityPositionDTO =
  SushiswapLiquidityPositionDTO
  { sushiswapLiquidityPositionDTOEntryTime = Nothing
  , sushiswapLiquidityPositionDTORecvTime = Nothing
  , sushiswapLiquidityPositionDTOBlockNumber = Nothing
  , sushiswapLiquidityPositionDTOId = Nothing
  , sushiswapLiquidityPositionDTOUser = Nothing
  , sushiswapLiquidityPositionDTOPair = Nothing
  , sushiswapLiquidityPositionDTOLiquidityTokenBalance = Nothing
  , sushiswapLiquidityPositionDTOBlock = Nothing
  , sushiswapLiquidityPositionDTOTimestamp = Nothing
  , sushiswapLiquidityPositionDTOVid = Nothing
  }

-- ** SushiswapLiquidityPositionSnapshotDTO
-- | SushiswapLiquidityPositionSnapshotDTO
-- This entity is used to store data about a user's liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
data SushiswapLiquidityPositionSnapshotDTO = SushiswapLiquidityPositionSnapshotDTO
  { sushiswapLiquidityPositionSnapshotDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapLiquidityPositionSnapshotDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapLiquidityPositionSnapshotDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapLiquidityPositionSnapshotDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;pair address&gt;-&lt;user address&gt;-&lt;timestamp&gt;
  , sushiswapLiquidityPositionSnapshotDTOLiquidityPosition :: !(Maybe Text) -- ^ "liquidity_position" - Reference to LP identifier.
  , sushiswapLiquidityPositionSnapshotDTOTimestamp :: !(Maybe Int) -- ^ "timestamp" - Creation time.
  , sushiswapLiquidityPositionSnapshotDTOBlock :: !(Maybe Int) -- ^ "block" - Block in which snapshot has been created.
  , sushiswapLiquidityPositionSnapshotDTOUser :: !(Maybe Text) -- ^ "user" - Reference to user.
  , sushiswapLiquidityPositionSnapshotDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to the pair liquidity is being provided on.
  , sushiswapLiquidityPositionSnapshotDTOToken0PriceUsd :: !(Maybe Text) -- ^ "token_0_price_usd" - Snapshot of token0 price in USD.
  , sushiswapLiquidityPositionSnapshotDTOToken1PriceUsd :: !(Maybe Text) -- ^ "token_1_price_usd" - Snapshot of token0 price in USD.
  , sushiswapLiquidityPositionSnapshotDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Snapshot of pair token0 reserves.
  , sushiswapLiquidityPositionSnapshotDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Snapshot of pair token1 reserves.
  , sushiswapLiquidityPositionSnapshotDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Snapshot of pair reserves in USD.
  , sushiswapLiquidityPositionSnapshotDTOLiquidityTokenTotalSupply :: !(Maybe Text) -- ^ "liquidity_token_total_supply" - Snapshot of pool token supply.
  , sushiswapLiquidityPositionSnapshotDTOLiquidityTokenBalance :: !(Maybe Text) -- ^ "liquidity_token_balance" - Snapshot of users pool token balance.
  , sushiswapLiquidityPositionSnapshotDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapLiquidityPositionSnapshotDTO
instance A.FromJSON SushiswapLiquidityPositionSnapshotDTO where
  parseJSON = A.withObject "SushiswapLiquidityPositionSnapshotDTO" $ \o ->
    SushiswapLiquidityPositionSnapshotDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "liquidity_position")
      <*> (o .:? "timestamp")
      <*> (o .:? "block")
      <*> (o .:? "user")
      <*> (o .:? "pair")
      <*> (o .:? "token_0_price_usd")
      <*> (o .:? "token_1_price_usd")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "liquidity_token_total_supply")
      <*> (o .:? "liquidity_token_balance")
      <*> (o .:? "vid")

-- | ToJSON SushiswapLiquidityPositionSnapshotDTO
instance A.ToJSON SushiswapLiquidityPositionSnapshotDTO where
  toJSON SushiswapLiquidityPositionSnapshotDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapLiquidityPositionSnapshotDTOEntryTime
      , "recv_time" .= sushiswapLiquidityPositionSnapshotDTORecvTime
      , "block_number" .= sushiswapLiquidityPositionSnapshotDTOBlockNumber
      , "id" .= sushiswapLiquidityPositionSnapshotDTOId
      , "liquidity_position" .= sushiswapLiquidityPositionSnapshotDTOLiquidityPosition
      , "timestamp" .= sushiswapLiquidityPositionSnapshotDTOTimestamp
      , "block" .= sushiswapLiquidityPositionSnapshotDTOBlock
      , "user" .= sushiswapLiquidityPositionSnapshotDTOUser
      , "pair" .= sushiswapLiquidityPositionSnapshotDTOPair
      , "token_0_price_usd" .= sushiswapLiquidityPositionSnapshotDTOToken0PriceUsd
      , "token_1_price_usd" .= sushiswapLiquidityPositionSnapshotDTOToken1PriceUsd
      , "reserve_0" .= sushiswapLiquidityPositionSnapshotDTOReserve0
      , "reserve_1" .= sushiswapLiquidityPositionSnapshotDTOReserve1
      , "reserve_usd" .= sushiswapLiquidityPositionSnapshotDTOReserveUsd
      , "liquidity_token_total_supply" .= sushiswapLiquidityPositionSnapshotDTOLiquidityTokenTotalSupply
      , "liquidity_token_balance" .= sushiswapLiquidityPositionSnapshotDTOLiquidityTokenBalance
      , "vid" .= sushiswapLiquidityPositionSnapshotDTOVid
      ]


-- | Construct a value of type 'SushiswapLiquidityPositionSnapshotDTO' (by applying it's required fields, if any)
mkSushiswapLiquidityPositionSnapshotDTO
  :: SushiswapLiquidityPositionSnapshotDTO
mkSushiswapLiquidityPositionSnapshotDTO =
  SushiswapLiquidityPositionSnapshotDTO
  { sushiswapLiquidityPositionSnapshotDTOEntryTime = Nothing
  , sushiswapLiquidityPositionSnapshotDTORecvTime = Nothing
  , sushiswapLiquidityPositionSnapshotDTOBlockNumber = Nothing
  , sushiswapLiquidityPositionSnapshotDTOId = Nothing
  , sushiswapLiquidityPositionSnapshotDTOLiquidityPosition = Nothing
  , sushiswapLiquidityPositionSnapshotDTOTimestamp = Nothing
  , sushiswapLiquidityPositionSnapshotDTOBlock = Nothing
  , sushiswapLiquidityPositionSnapshotDTOUser = Nothing
  , sushiswapLiquidityPositionSnapshotDTOPair = Nothing
  , sushiswapLiquidityPositionSnapshotDTOToken0PriceUsd = Nothing
  , sushiswapLiquidityPositionSnapshotDTOToken1PriceUsd = Nothing
  , sushiswapLiquidityPositionSnapshotDTOReserve0 = Nothing
  , sushiswapLiquidityPositionSnapshotDTOReserve1 = Nothing
  , sushiswapLiquidityPositionSnapshotDTOReserveUsd = Nothing
  , sushiswapLiquidityPositionSnapshotDTOLiquidityTokenTotalSupply = Nothing
  , sushiswapLiquidityPositionSnapshotDTOLiquidityTokenBalance = Nothing
  , sushiswapLiquidityPositionSnapshotDTOVid = Nothing
  }

-- ** SushiswapMintDTO
-- | SushiswapMintDTO
-- Mint entities are created for every emitted Mint event on the Sushiswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
data SushiswapMintDTO = SushiswapMintDTO
  { sushiswapMintDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapMintDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapMintDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapMintDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;transaction hash&gt;-&lt;index in the transaction mint array&gt;.
  , sushiswapMintDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to the transaction Mint was included in.
  , sushiswapMintDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of Mint, used to sort recent liquidity provisions.
  , sushiswapMintDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , sushiswapMintDTOTo :: !(Maybe Text) -- ^ "to" - Recipient of liquidity tokens.
  , sushiswapMintDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Amount of liquidity tokens minted.
  , sushiswapMintDTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the liquidity provision.
  , sushiswapMintDTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token0 provided.
  , sushiswapMintDTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token1 provided.
  , sushiswapMintDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Index in the transaction event was emitted.
  , sushiswapMintDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived USD value of token0 amount plus token1 amount.
  , sushiswapMintDTOFeeTo :: !(Maybe Text) -- ^ "fee_to" - Address of fee recipient (if fee is on).
  , sushiswapMintDTOFeeLiquidity :: !(Maybe Text) -- ^ "fee_liquidity" - Amount of liquidity sent to fee recipient (if fee is on).
  , sushiswapMintDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapMintDTO
instance A.FromJSON SushiswapMintDTO where
  parseJSON = A.withObject "SushiswapMintDTO" $ \o ->
    SushiswapMintDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "to")
      <*> (o .:? "liquidity")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "fee_to")
      <*> (o .:? "fee_liquidity")
      <*> (o .:? "vid")

-- | ToJSON SushiswapMintDTO
instance A.ToJSON SushiswapMintDTO where
  toJSON SushiswapMintDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapMintDTOEntryTime
      , "recv_time" .= sushiswapMintDTORecvTime
      , "block_number" .= sushiswapMintDTOBlockNumber
      , "id" .= sushiswapMintDTOId
      , "transaction" .= sushiswapMintDTOTransaction
      , "timestamp" .= sushiswapMintDTOTimestamp
      , "pair" .= sushiswapMintDTOPair
      , "to" .= sushiswapMintDTOTo
      , "liquidity" .= sushiswapMintDTOLiquidity
      , "sender" .= sushiswapMintDTOSender
      , "amount_0" .= sushiswapMintDTOAmount0
      , "amount_1" .= sushiswapMintDTOAmount1
      , "log_index" .= sushiswapMintDTOLogIndex
      , "amount_usd" .= sushiswapMintDTOAmountUsd
      , "fee_to" .= sushiswapMintDTOFeeTo
      , "fee_liquidity" .= sushiswapMintDTOFeeLiquidity
      , "vid" .= sushiswapMintDTOVid
      ]


-- | Construct a value of type 'SushiswapMintDTO' (by applying it's required fields, if any)
mkSushiswapMintDTO
  :: SushiswapMintDTO
mkSushiswapMintDTO =
  SushiswapMintDTO
  { sushiswapMintDTOEntryTime = Nothing
  , sushiswapMintDTORecvTime = Nothing
  , sushiswapMintDTOBlockNumber = Nothing
  , sushiswapMintDTOId = Nothing
  , sushiswapMintDTOTransaction = Nothing
  , sushiswapMintDTOTimestamp = Nothing
  , sushiswapMintDTOPair = Nothing
  , sushiswapMintDTOTo = Nothing
  , sushiswapMintDTOLiquidity = Nothing
  , sushiswapMintDTOSender = Nothing
  , sushiswapMintDTOAmount0 = Nothing
  , sushiswapMintDTOAmount1 = Nothing
  , sushiswapMintDTOLogIndex = Nothing
  , sushiswapMintDTOAmountUsd = Nothing
  , sushiswapMintDTOFeeTo = Nothing
  , sushiswapMintDTOFeeLiquidity = Nothing
  , sushiswapMintDTOVid = Nothing
  }

-- ** SushiswapPairDTO
-- | SushiswapPairDTO
-- Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
data SushiswapPairDTO = SushiswapPairDTO
  { sushiswapPairDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapPairDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapPairDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapPairDTOId :: !(Maybe Text) -- ^ "id" - Pair contract address.
  , sushiswapPairDTOFactory :: !(Maybe Text) -- ^ "factory" - Factory contract address.
  , sushiswapPairDTOName :: !(Maybe Text) -- ^ "name" - Friendly name, format: &lt;token0 name&gt;-&lt;token1 name&gt;
  , sushiswapPairDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pair contract.
  , sushiswapPairDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token0 as stored in pair contract.
  , sushiswapPairDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0.
  , sushiswapPairDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1.
  , sushiswapPairDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token distributed to LPs.
  , sushiswapPairDTOReserveEth :: !(Maybe Text) -- ^ "reserve_eth" - Total liquidity in pair stored as an amount of ETH.
  , sushiswapPairDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Total liquidity amount in pair stored as an amount of USD.
  , sushiswapPairDTOTrackedReserveEth :: !(Maybe Text) -- ^ "tracked_reserve_eth" - Total liquidity with only tracked amount.
  , sushiswapPairDTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - Token0 per token1.
  , sushiswapPairDTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - Token1 per token0.
  , sushiswapPairDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Amount of token0 swapped on this pair.
  , sushiswapPairDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Amount of token1 swapped on this pair.
  , sushiswapPairDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
  , sushiswapPairDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
  , sushiswapPairDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - All time amount of transactions on this pair.
  , sushiswapPairDTOLiquidityProviderCount :: !(Maybe Text) -- ^ "liquidity_provider_count" - Total number of LPs.
  , sushiswapPairDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp.
  , sushiswapPairDTOBlock :: !(Maybe Text) -- ^ "block" - Block number in which pair information was created in.
  , sushiswapPairDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , sushiswapPairDTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapPairDTO
instance A.FromJSON SushiswapPairDTO where
  parseJSON = A.withObject "SushiswapPairDTO" $ \o ->
    SushiswapPairDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "factory")
      <*> (o .:? "name")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_eth")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "tracked_reserve_eth")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "timestamp")
      <*> (o .:? "block")
      <*> (o .:? "vid")
      <*> (o .:? "evaluated_ask")

-- | ToJSON SushiswapPairDTO
instance A.ToJSON SushiswapPairDTO where
  toJSON SushiswapPairDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapPairDTOEntryTime
      , "recv_time" .= sushiswapPairDTORecvTime
      , "block_number" .= sushiswapPairDTOBlockNumber
      , "id" .= sushiswapPairDTOId
      , "factory" .= sushiswapPairDTOFactory
      , "name" .= sushiswapPairDTOName
      , "token_0" .= sushiswapPairDTOToken0
      , "token_1" .= sushiswapPairDTOToken1
      , "reserve_0" .= sushiswapPairDTOReserve0
      , "reserve_1" .= sushiswapPairDTOReserve1
      , "total_supply" .= sushiswapPairDTOTotalSupply
      , "reserve_eth" .= sushiswapPairDTOReserveEth
      , "reserve_usd" .= sushiswapPairDTOReserveUsd
      , "tracked_reserve_eth" .= sushiswapPairDTOTrackedReserveEth
      , "token_0_price" .= sushiswapPairDTOToken0Price
      , "token_1_price" .= sushiswapPairDTOToken1Price
      , "volume_token_0" .= sushiswapPairDTOVolumeToken0
      , "volume_token_1" .= sushiswapPairDTOVolumeToken1
      , "volume_usd" .= sushiswapPairDTOVolumeUsd
      , "untracked_volume_usd" .= sushiswapPairDTOUntrackedVolumeUsd
      , "tx_count" .= sushiswapPairDTOTxCount
      , "liquidity_provider_count" .= sushiswapPairDTOLiquidityProviderCount
      , "timestamp" .= sushiswapPairDTOTimestamp
      , "block" .= sushiswapPairDTOBlock
      , "vid" .= sushiswapPairDTOVid
      , "evaluated_ask" .= sushiswapPairDTOEvaluatedAsk
      ]


-- | Construct a value of type 'SushiswapPairDTO' (by applying it's required fields, if any)
mkSushiswapPairDTO
  :: SushiswapPairDTO
mkSushiswapPairDTO =
  SushiswapPairDTO
  { sushiswapPairDTOEntryTime = Nothing
  , sushiswapPairDTORecvTime = Nothing
  , sushiswapPairDTOBlockNumber = Nothing
  , sushiswapPairDTOId = Nothing
  , sushiswapPairDTOFactory = Nothing
  , sushiswapPairDTOName = Nothing
  , sushiswapPairDTOToken0 = Nothing
  , sushiswapPairDTOToken1 = Nothing
  , sushiswapPairDTOReserve0 = Nothing
  , sushiswapPairDTOReserve1 = Nothing
  , sushiswapPairDTOTotalSupply = Nothing
  , sushiswapPairDTOReserveEth = Nothing
  , sushiswapPairDTOReserveUsd = Nothing
  , sushiswapPairDTOTrackedReserveEth = Nothing
  , sushiswapPairDTOToken0Price = Nothing
  , sushiswapPairDTOToken1Price = Nothing
  , sushiswapPairDTOVolumeToken0 = Nothing
  , sushiswapPairDTOVolumeToken1 = Nothing
  , sushiswapPairDTOVolumeUsd = Nothing
  , sushiswapPairDTOUntrackedVolumeUsd = Nothing
  , sushiswapPairDTOTxCount = Nothing
  , sushiswapPairDTOLiquidityProviderCount = Nothing
  , sushiswapPairDTOTimestamp = Nothing
  , sushiswapPairDTOBlock = Nothing
  , sushiswapPairDTOVid = Nothing
  , sushiswapPairDTOEvaluatedAsk = Nothing
  }

-- ** SushiswapPairDayDataDTO
-- | SushiswapPairDayDataDTO
-- Tracks pair data across each day.
data SushiswapPairDayDataDTO = SushiswapPairDayDataDTO
  { sushiswapPairDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapPairDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapPairDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapPairDayDataDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;pair id&gt;-&lt;day start timestamp&gt;.
  , sushiswapPairDayDataDTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , sushiswapPairDayDataDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , sushiswapPairDayDataDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0.
  , sushiswapPairDayDataDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1.
  , sushiswapPairDayDataDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0 (updated during each transaction on pair).
  , sushiswapPairDayDataDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1 (updated during each transaction on pair).
  , sushiswapPairDayDataDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token distributed to LPs.
  , sushiswapPairDayDataDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Reserve of token0 plus token1 stored as a derived USD amount.
  , sushiswapPairDayDataDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Total amount of token0 swapped throughout day.
  , sushiswapPairDayDataDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Total amount of token1 swapped throughout day.
  , sushiswapPairDayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total volume within pair throughout day.
  , sushiswapPairDayDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Amount of transactions on pair throughout day.
  , sushiswapPairDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapPairDayDataDTO
instance A.FromJSON SushiswapPairDayDataDTO where
  parseJSON = A.withObject "SushiswapPairDayDataDTO" $ \o ->
    SushiswapPairDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pair")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON SushiswapPairDayDataDTO
instance A.ToJSON SushiswapPairDayDataDTO where
  toJSON SushiswapPairDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapPairDayDataDTOEntryTime
      , "recv_time" .= sushiswapPairDayDataDTORecvTime
      , "block_number" .= sushiswapPairDayDataDTOBlockNumber
      , "id" .= sushiswapPairDayDataDTOId
      , "date" .= sushiswapPairDayDataDTODate
      , "pair" .= sushiswapPairDayDataDTOPair
      , "token_0" .= sushiswapPairDayDataDTOToken0
      , "token_1" .= sushiswapPairDayDataDTOToken1
      , "reserve_0" .= sushiswapPairDayDataDTOReserve0
      , "reserve_1" .= sushiswapPairDayDataDTOReserve1
      , "total_supply" .= sushiswapPairDayDataDTOTotalSupply
      , "reserve_usd" .= sushiswapPairDayDataDTOReserveUsd
      , "volume_token_0" .= sushiswapPairDayDataDTOVolumeToken0
      , "volume_token_1" .= sushiswapPairDayDataDTOVolumeToken1
      , "volume_usd" .= sushiswapPairDayDataDTOVolumeUsd
      , "tx_count" .= sushiswapPairDayDataDTOTxCount
      , "vid" .= sushiswapPairDayDataDTOVid
      ]


-- | Construct a value of type 'SushiswapPairDayDataDTO' (by applying it's required fields, if any)
mkSushiswapPairDayDataDTO
  :: SushiswapPairDayDataDTO
mkSushiswapPairDayDataDTO =
  SushiswapPairDayDataDTO
  { sushiswapPairDayDataDTOEntryTime = Nothing
  , sushiswapPairDayDataDTORecvTime = Nothing
  , sushiswapPairDayDataDTOBlockNumber = Nothing
  , sushiswapPairDayDataDTOId = Nothing
  , sushiswapPairDayDataDTODate = Nothing
  , sushiswapPairDayDataDTOPair = Nothing
  , sushiswapPairDayDataDTOToken0 = Nothing
  , sushiswapPairDayDataDTOToken1 = Nothing
  , sushiswapPairDayDataDTOReserve0 = Nothing
  , sushiswapPairDayDataDTOReserve1 = Nothing
  , sushiswapPairDayDataDTOTotalSupply = Nothing
  , sushiswapPairDayDataDTOReserveUsd = Nothing
  , sushiswapPairDayDataDTOVolumeToken0 = Nothing
  , sushiswapPairDayDataDTOVolumeToken1 = Nothing
  , sushiswapPairDayDataDTOVolumeUsd = Nothing
  , sushiswapPairDayDataDTOTxCount = Nothing
  , sushiswapPairDayDataDTOVid = Nothing
  }

-- ** SushiswapPairHourDataDTO
-- | SushiswapPairHourDataDTO
-- Tracks pair data across each hour.
data SushiswapPairHourDataDTO = SushiswapPairHourDataDTO
  { sushiswapPairHourDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapPairHourDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapPairHourDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapPairHourDataDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;pair id&gt;-&lt;hour start timestamp&gt;.
  , sushiswapPairHourDataDTODate :: !(Maybe Int) -- ^ "date" - Hour start timestamp.
  , sushiswapPairHourDataDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , sushiswapPairHourDataDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0 (updated during each transaction on pair).
  , sushiswapPairHourDataDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1 (updated during each transaction on pair).
  , sushiswapPairHourDataDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Reserve of token0 plus token1 stored as a derived USD amount.
  , sushiswapPairHourDataDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Total amount of token0 swapped throughout hour.
  , sushiswapPairHourDataDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Total amount of token1 swapped throughout hour.
  , sushiswapPairHourDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total volume within pair throughout hour.
  , sushiswapPairHourDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Amount of transactions on pair throughout hour.
  , sushiswapPairHourDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapPairHourDataDTO
instance A.FromJSON SushiswapPairHourDataDTO where
  parseJSON = A.withObject "SushiswapPairHourDataDTO" $ \o ->
    SushiswapPairHourDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pair")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON SushiswapPairHourDataDTO
instance A.ToJSON SushiswapPairHourDataDTO where
  toJSON SushiswapPairHourDataDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapPairHourDataDTOEntryTime
      , "recv_time" .= sushiswapPairHourDataDTORecvTime
      , "block_number" .= sushiswapPairHourDataDTOBlockNumber
      , "id" .= sushiswapPairHourDataDTOId
      , "date" .= sushiswapPairHourDataDTODate
      , "pair" .= sushiswapPairHourDataDTOPair
      , "reserve_0" .= sushiswapPairHourDataDTOReserve0
      , "reserve_1" .= sushiswapPairHourDataDTOReserve1
      , "reserve_usd" .= sushiswapPairHourDataDTOReserveUsd
      , "volume_token_0" .= sushiswapPairHourDataDTOVolumeToken0
      , "volume_token_1" .= sushiswapPairHourDataDTOVolumeToken1
      , "volume_usd" .= sushiswapPairHourDataDTOVolumeUsd
      , "tx_count" .= sushiswapPairHourDataDTOTxCount
      , "vid" .= sushiswapPairHourDataDTOVid
      ]


-- | Construct a value of type 'SushiswapPairHourDataDTO' (by applying it's required fields, if any)
mkSushiswapPairHourDataDTO
  :: SushiswapPairHourDataDTO
mkSushiswapPairHourDataDTO =
  SushiswapPairHourDataDTO
  { sushiswapPairHourDataDTOEntryTime = Nothing
  , sushiswapPairHourDataDTORecvTime = Nothing
  , sushiswapPairHourDataDTOBlockNumber = Nothing
  , sushiswapPairHourDataDTOId = Nothing
  , sushiswapPairHourDataDTODate = Nothing
  , sushiswapPairHourDataDTOPair = Nothing
  , sushiswapPairHourDataDTOReserve0 = Nothing
  , sushiswapPairHourDataDTOReserve1 = Nothing
  , sushiswapPairHourDataDTOReserveUsd = Nothing
  , sushiswapPairHourDataDTOVolumeToken0 = Nothing
  , sushiswapPairHourDataDTOVolumeToken1 = Nothing
  , sushiswapPairHourDataDTOVolumeUsd = Nothing
  , sushiswapPairHourDataDTOTxCount = Nothing
  , sushiswapPairHourDataDTOVid = Nothing
  }

-- ** SushiswapSwapDTO
-- | SushiswapSwapDTO
-- Swap are created for each token swap within a pair.
data SushiswapSwapDTO = SushiswapSwapDTO
  { sushiswapSwapDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapSwapDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapSwapDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapSwapDTOId :: !(Maybe Text) -- ^ "id" - Transaction hash plus index in Transaction swap array.
  , sushiswapSwapDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to transaction swap was included in.
  , sushiswapSwapDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of swap, used for sorted lookups.
  , sushiswapSwapDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , sushiswapSwapDTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the swap.
  , sushiswapSwapDTOAmount0In :: !(Maybe Text) -- ^ "amount_0_in" - Amount of token0 sold.
  , sushiswapSwapDTOAmount1In :: !(Maybe Text) -- ^ "amount_1_in" - Amount of token1 sold.
  , sushiswapSwapDTOAmount0Out :: !(Maybe Text) -- ^ "amount_0_out" - Amount of token0 received.
  , sushiswapSwapDTOAmount1Out :: !(Maybe Text) -- ^ "amount_1_out" - Amount of token1 received.
  , sushiswapSwapDTOTo :: !(Maybe Text) -- ^ "to" - Recipient of output tokens.
  , sushiswapSwapDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Event index within transaction.
  , sushiswapSwapDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount of tokens sold in USD.
  , sushiswapSwapDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , sushiswapSwapDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , sushiswapSwapDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  , sushiswapSwapDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , sushiswapSwapDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , sushiswapSwapDTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapSwapDTO
instance A.FromJSON SushiswapSwapDTO where
  parseJSON = A.withObject "SushiswapSwapDTO" $ \o ->
    SushiswapSwapDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0_in")
      <*> (o .:? "amount_1_in")
      <*> (o .:? "amount_0_out")
      <*> (o .:? "amount_1_out")
      <*> (o .:? "to")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "vid")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")

-- | ToJSON SushiswapSwapDTO
instance A.ToJSON SushiswapSwapDTO where
  toJSON SushiswapSwapDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapSwapDTOEntryTime
      , "recv_time" .= sushiswapSwapDTORecvTime
      , "block_number" .= sushiswapSwapDTOBlockNumber
      , "id" .= sushiswapSwapDTOId
      , "transaction" .= sushiswapSwapDTOTransaction
      , "timestamp" .= sushiswapSwapDTOTimestamp
      , "pair" .= sushiswapSwapDTOPair
      , "sender" .= sushiswapSwapDTOSender
      , "amount_0_in" .= sushiswapSwapDTOAmount0In
      , "amount_1_in" .= sushiswapSwapDTOAmount1In
      , "amount_0_out" .= sushiswapSwapDTOAmount0Out
      , "amount_1_out" .= sushiswapSwapDTOAmount1Out
      , "to" .= sushiswapSwapDTOTo
      , "log_index" .= sushiswapSwapDTOLogIndex
      , "amount_usd" .= sushiswapSwapDTOAmountUsd
      , "vid" .= sushiswapSwapDTOVid
      , "pool_id" .= sushiswapSwapDTOPoolId
      , "transaction_id" .= sushiswapSwapDTOTransactionId
      , "evaluated_price" .= sushiswapSwapDTOEvaluatedPrice
      , "evaluated_amount" .= sushiswapSwapDTOEvaluatedAmount
      , "evaluated_aggressor" .= sushiswapSwapDTOEvaluatedAggressor
      ]


-- | Construct a value of type 'SushiswapSwapDTO' (by applying it's required fields, if any)
mkSushiswapSwapDTO
  :: SushiswapSwapDTO
mkSushiswapSwapDTO =
  SushiswapSwapDTO
  { sushiswapSwapDTOEntryTime = Nothing
  , sushiswapSwapDTORecvTime = Nothing
  , sushiswapSwapDTOBlockNumber = Nothing
  , sushiswapSwapDTOId = Nothing
  , sushiswapSwapDTOTransaction = Nothing
  , sushiswapSwapDTOTimestamp = Nothing
  , sushiswapSwapDTOPair = Nothing
  , sushiswapSwapDTOSender = Nothing
  , sushiswapSwapDTOAmount0In = Nothing
  , sushiswapSwapDTOAmount1In = Nothing
  , sushiswapSwapDTOAmount0Out = Nothing
  , sushiswapSwapDTOAmount1Out = Nothing
  , sushiswapSwapDTOTo = Nothing
  , sushiswapSwapDTOLogIndex = Nothing
  , sushiswapSwapDTOAmountUsd = Nothing
  , sushiswapSwapDTOVid = Nothing
  , sushiswapSwapDTOPoolId = Nothing
  , sushiswapSwapDTOTransactionId = Nothing
  , sushiswapSwapDTOEvaluatedPrice = Nothing
  , sushiswapSwapDTOEvaluatedAmount = Nothing
  , sushiswapSwapDTOEvaluatedAggressor = Nothing
  }

-- ** SushiswapTokenDTO
-- | SushiswapTokenDTO
-- Stores aggregated information for a specific token across all pairs that token is included in.
data SushiswapTokenDTO = SushiswapTokenDTO
  { sushiswapTokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapTokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapTokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapTokenDTOId :: !(Maybe Text) -- ^ "id" - Token address.
  , sushiswapTokenDTOFactory :: !(Maybe Text) -- ^ "factory" - Factory address.
  , sushiswapTokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - Token symbol.
  , sushiswapTokenDTOName :: !(Maybe Text) -- ^ "name" - Token name.
  , sushiswapTokenDTODecimals :: !(Maybe Text) -- ^ "decimals" - Token decimals.
  , sushiswapTokenDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token.
  , sushiswapTokenDTOVolume :: !(Maybe Text) -- ^ "volume" - Amount of token traded all time across all pairs.
  , sushiswapTokenDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
  , sushiswapTokenDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
  , sushiswapTokenDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Amount of transactions all time in pairs including token.
  , sushiswapTokenDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Total amount of token provided as liquidity across all pairs.
  , sushiswapTokenDTODerivedEth :: !(Maybe Text) -- ^ "derived_eth" - ETH per token.
  , sushiswapTokenDTOWhitelistPairs :: !(Maybe [Text]) -- ^ "whitelist_pairs" - Array of whitelisted pairs.
  , sushiswapTokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , sushiswapTokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapTokenDTO
instance A.FromJSON SushiswapTokenDTO where
  parseJSON = A.withObject "SushiswapTokenDTO" $ \o ->
    SushiswapTokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "factory")
      <*> (o .:? "symbol")
      <*> (o .:? "name")
      <*> (o .:? "decimals")
      <*> (o .:? "total_supply")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "liquidity")
      <*> (o .:? "derived_eth")
      <*> (o .:? "whitelist_pairs")
      <*> (o .:? "vid")
      <*> (o .:? "token_symbol")

-- | ToJSON SushiswapTokenDTO
instance A.ToJSON SushiswapTokenDTO where
  toJSON SushiswapTokenDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapTokenDTOEntryTime
      , "recv_time" .= sushiswapTokenDTORecvTime
      , "block_number" .= sushiswapTokenDTOBlockNumber
      , "id" .= sushiswapTokenDTOId
      , "factory" .= sushiswapTokenDTOFactory
      , "symbol" .= sushiswapTokenDTOSymbol
      , "name" .= sushiswapTokenDTOName
      , "decimals" .= sushiswapTokenDTODecimals
      , "total_supply" .= sushiswapTokenDTOTotalSupply
      , "volume" .= sushiswapTokenDTOVolume
      , "volume_usd" .= sushiswapTokenDTOVolumeUsd
      , "untracked_volume_usd" .= sushiswapTokenDTOUntrackedVolumeUsd
      , "tx_count" .= sushiswapTokenDTOTxCount
      , "liquidity" .= sushiswapTokenDTOLiquidity
      , "derived_eth" .= sushiswapTokenDTODerivedEth
      , "whitelist_pairs" .= sushiswapTokenDTOWhitelistPairs
      , "vid" .= sushiswapTokenDTOVid
      , "token_symbol" .= sushiswapTokenDTOTokenSymbol
      ]


-- | Construct a value of type 'SushiswapTokenDTO' (by applying it's required fields, if any)
mkSushiswapTokenDTO
  :: SushiswapTokenDTO
mkSushiswapTokenDTO =
  SushiswapTokenDTO
  { sushiswapTokenDTOEntryTime = Nothing
  , sushiswapTokenDTORecvTime = Nothing
  , sushiswapTokenDTOBlockNumber = Nothing
  , sushiswapTokenDTOId = Nothing
  , sushiswapTokenDTOFactory = Nothing
  , sushiswapTokenDTOSymbol = Nothing
  , sushiswapTokenDTOName = Nothing
  , sushiswapTokenDTODecimals = Nothing
  , sushiswapTokenDTOTotalSupply = Nothing
  , sushiswapTokenDTOVolume = Nothing
  , sushiswapTokenDTOVolumeUsd = Nothing
  , sushiswapTokenDTOUntrackedVolumeUsd = Nothing
  , sushiswapTokenDTOTxCount = Nothing
  , sushiswapTokenDTOLiquidity = Nothing
  , sushiswapTokenDTODerivedEth = Nothing
  , sushiswapTokenDTOWhitelistPairs = Nothing
  , sushiswapTokenDTOVid = Nothing
  , sushiswapTokenDTOTokenSymbol = Nothing
  }

-- ** SushiswapTokenDayDataDTO
-- | SushiswapTokenDayDataDTO
-- Token data aggregated across all pairs that include token.
data SushiswapTokenDayDataDTO = SushiswapTokenDayDataDTO
  { sushiswapTokenDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapTokenDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapTokenDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapTokenDayDataDTOId :: !(Maybe Text) -- ^ "id" - Identifier, day start timestamp in unix / 86400.
  , sushiswapTokenDayDataDTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , sushiswapTokenDayDataDTOToken :: !(Maybe Text) -- ^ "token" - Reference to token entity.
  , sushiswapTokenDayDataDTOVolume :: !(Maybe Text) -- ^ "volume" - Amount of token swapped across all pairs throughout day.
  , sushiswapTokenDayDataDTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
  , sushiswapTokenDayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
  , sushiswapTokenDayDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Amount of transactions with this token across all pairs.
  , sushiswapTokenDayDataDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Token amount of token deposited across all pairs.
  , sushiswapTokenDayDataDTOLiquidityEth :: !(Maybe Text) -- ^ "liquidity_eth" - Token amount of token deposited across all pairs stored as amount of ETH.
  , sushiswapTokenDayDataDTOLiquidityUsd :: !(Maybe Text) -- ^ "liquidity_usd" - Token amount of token deposited across all pairs stored as amount of USD.
  , sushiswapTokenDayDataDTOPriceUsd :: !(Maybe Text) -- ^ "price_usd" - Price of token in derived USD.
  , sushiswapTokenDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapTokenDayDataDTO
instance A.FromJSON SushiswapTokenDayDataDTO where
  parseJSON = A.withObject "SushiswapTokenDayDataDTO" $ \o ->
    SushiswapTokenDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "token")
      <*> (o .:? "volume")
      <*> (o .:? "volume_eth")
      <*> (o .:? "volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "liquidity")
      <*> (o .:? "liquidity_eth")
      <*> (o .:? "liquidity_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "vid")

-- | ToJSON SushiswapTokenDayDataDTO
instance A.ToJSON SushiswapTokenDayDataDTO where
  toJSON SushiswapTokenDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapTokenDayDataDTOEntryTime
      , "recv_time" .= sushiswapTokenDayDataDTORecvTime
      , "block_number" .= sushiswapTokenDayDataDTOBlockNumber
      , "id" .= sushiswapTokenDayDataDTOId
      , "date" .= sushiswapTokenDayDataDTODate
      , "token" .= sushiswapTokenDayDataDTOToken
      , "volume" .= sushiswapTokenDayDataDTOVolume
      , "volume_eth" .= sushiswapTokenDayDataDTOVolumeEth
      , "volume_usd" .= sushiswapTokenDayDataDTOVolumeUsd
      , "tx_count" .= sushiswapTokenDayDataDTOTxCount
      , "liquidity" .= sushiswapTokenDayDataDTOLiquidity
      , "liquidity_eth" .= sushiswapTokenDayDataDTOLiquidityEth
      , "liquidity_usd" .= sushiswapTokenDayDataDTOLiquidityUsd
      , "price_usd" .= sushiswapTokenDayDataDTOPriceUsd
      , "vid" .= sushiswapTokenDayDataDTOVid
      ]


-- | Construct a value of type 'SushiswapTokenDayDataDTO' (by applying it's required fields, if any)
mkSushiswapTokenDayDataDTO
  :: SushiswapTokenDayDataDTO
mkSushiswapTokenDayDataDTO =
  SushiswapTokenDayDataDTO
  { sushiswapTokenDayDataDTOEntryTime = Nothing
  , sushiswapTokenDayDataDTORecvTime = Nothing
  , sushiswapTokenDayDataDTOBlockNumber = Nothing
  , sushiswapTokenDayDataDTOId = Nothing
  , sushiswapTokenDayDataDTODate = Nothing
  , sushiswapTokenDayDataDTOToken = Nothing
  , sushiswapTokenDayDataDTOVolume = Nothing
  , sushiswapTokenDayDataDTOVolumeEth = Nothing
  , sushiswapTokenDayDataDTOVolumeUsd = Nothing
  , sushiswapTokenDayDataDTOTxCount = Nothing
  , sushiswapTokenDayDataDTOLiquidity = Nothing
  , sushiswapTokenDayDataDTOLiquidityEth = Nothing
  , sushiswapTokenDayDataDTOLiquidityUsd = Nothing
  , sushiswapTokenDayDataDTOPriceUsd = Nothing
  , sushiswapTokenDayDataDTOVid = Nothing
  }

-- ** SushiswapTransactionDTO
-- | SushiswapTransactionDTO
-- Transaction entities are created for each Ethereum transaction that contains an interaction within Sushiswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
data SushiswapTransactionDTO = SushiswapTransactionDTO
  { sushiswapTransactionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapTransactionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapTransactionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapTransactionDTOId :: !(Maybe Text) -- ^ "id" - Ethereum transaction hash.
  , sushiswapTransactionDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp.
  , sushiswapTransactionDTOMints :: !(Maybe [Text]) -- ^ "mints" - Array of Mint events within the transaction, 0 or greater.
  , sushiswapTransactionDTOBurns :: !(Maybe [Text]) -- ^ "burns" - Array of Burn events within transaction, 0 or greater.
  , sushiswapTransactionDTOSwaps :: !(Maybe [Text]) -- ^ "swaps" - Array of Swap events within transaction, 0 or greater.
  , sushiswapTransactionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapTransactionDTO
instance A.FromJSON SushiswapTransactionDTO where
  parseJSON = A.withObject "SushiswapTransactionDTO" $ \o ->
    SushiswapTransactionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "timestamp")
      <*> (o .:? "mints")
      <*> (o .:? "burns")
      <*> (o .:? "swaps")
      <*> (o .:? "vid")

-- | ToJSON SushiswapTransactionDTO
instance A.ToJSON SushiswapTransactionDTO where
  toJSON SushiswapTransactionDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapTransactionDTOEntryTime
      , "recv_time" .= sushiswapTransactionDTORecvTime
      , "block_number" .= sushiswapTransactionDTOBlockNumber
      , "id" .= sushiswapTransactionDTOId
      , "timestamp" .= sushiswapTransactionDTOTimestamp
      , "mints" .= sushiswapTransactionDTOMints
      , "burns" .= sushiswapTransactionDTOBurns
      , "swaps" .= sushiswapTransactionDTOSwaps
      , "vid" .= sushiswapTransactionDTOVid
      ]


-- | Construct a value of type 'SushiswapTransactionDTO' (by applying it's required fields, if any)
mkSushiswapTransactionDTO
  :: SushiswapTransactionDTO
mkSushiswapTransactionDTO =
  SushiswapTransactionDTO
  { sushiswapTransactionDTOEntryTime = Nothing
  , sushiswapTransactionDTORecvTime = Nothing
  , sushiswapTransactionDTOBlockNumber = Nothing
  , sushiswapTransactionDTOId = Nothing
  , sushiswapTransactionDTOTimestamp = Nothing
  , sushiswapTransactionDTOMints = Nothing
  , sushiswapTransactionDTOBurns = Nothing
  , sushiswapTransactionDTOSwaps = Nothing
  , sushiswapTransactionDTOVid = Nothing
  }

-- ** SushiswapUserDTO
-- | SushiswapUserDTO
data SushiswapUserDTO = SushiswapUserDTO
  { sushiswapUserDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapUserDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapUserDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapUserDTOId :: !(Maybe Text) -- ^ "id" - User address.
  , sushiswapUserDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapUserDTO
instance A.FromJSON SushiswapUserDTO where
  parseJSON = A.withObject "SushiswapUserDTO" $ \o ->
    SushiswapUserDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "vid")

-- | ToJSON SushiswapUserDTO
instance A.ToJSON SushiswapUserDTO where
  toJSON SushiswapUserDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapUserDTOEntryTime
      , "recv_time" .= sushiswapUserDTORecvTime
      , "block_number" .= sushiswapUserDTOBlockNumber
      , "id" .= sushiswapUserDTOId
      , "vid" .= sushiswapUserDTOVid
      ]


-- | Construct a value of type 'SushiswapUserDTO' (by applying it's required fields, if any)
mkSushiswapUserDTO
  :: SushiswapUserDTO
mkSushiswapUserDTO =
  SushiswapUserDTO
  { sushiswapUserDTOEntryTime = Nothing
  , sushiswapUserDTORecvTime = Nothing
  , sushiswapUserDTOBlockNumber = Nothing
  , sushiswapUserDTOId = Nothing
  , sushiswapUserDTOVid = Nothing
  }

-- ** UniswapV2BundleV2DTO
-- | UniswapV2BundleV2DTO
-- The Bundle is used as a global store of derived ETH price in USD. Because there is no guaranteed common base token across pairs, a global reference of USD price is useful for deriving other USD values. The Bundle entity stores an updated weighted average of ETH<->Stablecoin pair prices. This provides a strong estimate for the USD price of ETH.
data UniswapV2BundleV2DTO = UniswapV2BundleV2DTO
  { uniswapV2BundleV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2BundleV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2BundleV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2BundleV2DTOId :: !(Maybe Text) -- ^ "id" - Constant 1.
  , uniswapV2BundleV2DTOEthPrice :: !(Maybe Text) -- ^ "eth_price" - Derived price of ETH in USD based on stablecoin pairs.
  , uniswapV2BundleV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2BundleV2DTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2BundleV2DTO
instance A.FromJSON UniswapV2BundleV2DTO where
  parseJSON = A.withObject "UniswapV2BundleV2DTO" $ \o ->
    UniswapV2BundleV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "eth_price")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON UniswapV2BundleV2DTO
instance A.ToJSON UniswapV2BundleV2DTO where
  toJSON UniswapV2BundleV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2BundleV2DTOEntryTime
      , "recv_time" .= uniswapV2BundleV2DTORecvTime
      , "block_number" .= uniswapV2BundleV2DTOBlockNumber
      , "id" .= uniswapV2BundleV2DTOId
      , "eth_price" .= uniswapV2BundleV2DTOEthPrice
      , "vid" .= uniswapV2BundleV2DTOVid
      , "block_range" .= uniswapV2BundleV2DTOBlockRange
      ]


-- | Construct a value of type 'UniswapV2BundleV2DTO' (by applying it's required fields, if any)
mkUniswapV2BundleV2DTO
  :: UniswapV2BundleV2DTO
mkUniswapV2BundleV2DTO =
  UniswapV2BundleV2DTO
  { uniswapV2BundleV2DTOEntryTime = Nothing
  , uniswapV2BundleV2DTORecvTime = Nothing
  , uniswapV2BundleV2DTOBlockNumber = Nothing
  , uniswapV2BundleV2DTOId = Nothing
  , uniswapV2BundleV2DTOEthPrice = Nothing
  , uniswapV2BundleV2DTOVid = Nothing
  , uniswapV2BundleV2DTOBlockRange = Nothing
  }

-- ** UniswapV2BurnV2DTO
-- | UniswapV2BurnV2DTO
-- Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
data UniswapV2BurnV2DTO = UniswapV2BurnV2DTO
  { uniswapV2BurnV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2BurnV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2BurnV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2BurnV2DTOId :: !(Maybe Text) -- ^ "id" - Transaction hash plus index in the transaction burn array
  , uniswapV2BurnV2DTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to the transaction Burn was included in.
  , uniswapV2BurnV2DTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of Burn, used to sort recent liquidity removals.
  , uniswapV2BurnV2DTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , uniswapV2BurnV2DTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Amount of liquidity tokens burned.
  , uniswapV2BurnV2DTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the liquidity removal.
  , uniswapV2BurnV2DTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token0 removed.
  , uniswapV2BurnV2DTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token1 removed.
  , uniswapV2BurnV2DTOTo :: !(Maybe Text) -- ^ "to" - Recipient of tokens.
  , uniswapV2BurnV2DTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Index in the transaction event was emitted.
  , uniswapV2BurnV2DTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived USD value of token0 amount plus token1 amount.
  , uniswapV2BurnV2DTONeedsComplete :: !(Maybe Bool) -- ^ "needs_complete" - 
  , uniswapV2BurnV2DTOFeeTo :: !(Maybe Text) -- ^ "fee_to" - Address of fee recipient (if fee is on).
  , uniswapV2BurnV2DTOFeeLiquidity :: !(Maybe Text) -- ^ "fee_liquidity" - Amount of tokens sent to fee recipient (if fee is on).
  , uniswapV2BurnV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2BurnV2DTO
instance A.FromJSON UniswapV2BurnV2DTO where
  parseJSON = A.withObject "UniswapV2BurnV2DTO" $ \o ->
    UniswapV2BurnV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "liquidity")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "to")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "needs_complete")
      <*> (o .:? "fee_to")
      <*> (o .:? "fee_liquidity")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2BurnV2DTO
instance A.ToJSON UniswapV2BurnV2DTO where
  toJSON UniswapV2BurnV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2BurnV2DTOEntryTime
      , "recv_time" .= uniswapV2BurnV2DTORecvTime
      , "block_number" .= uniswapV2BurnV2DTOBlockNumber
      , "id" .= uniswapV2BurnV2DTOId
      , "transaction" .= uniswapV2BurnV2DTOTransaction
      , "timestamp" .= uniswapV2BurnV2DTOTimestamp
      , "pair" .= uniswapV2BurnV2DTOPair
      , "liquidity" .= uniswapV2BurnV2DTOLiquidity
      , "sender" .= uniswapV2BurnV2DTOSender
      , "amount_0" .= uniswapV2BurnV2DTOAmount0
      , "amount_1" .= uniswapV2BurnV2DTOAmount1
      , "to" .= uniswapV2BurnV2DTOTo
      , "log_index" .= uniswapV2BurnV2DTOLogIndex
      , "amount_usd" .= uniswapV2BurnV2DTOAmountUsd
      , "needs_complete" .= uniswapV2BurnV2DTONeedsComplete
      , "fee_to" .= uniswapV2BurnV2DTOFeeTo
      , "fee_liquidity" .= uniswapV2BurnV2DTOFeeLiquidity
      , "vid" .= uniswapV2BurnV2DTOVid
      ]


-- | Construct a value of type 'UniswapV2BurnV2DTO' (by applying it's required fields, if any)
mkUniswapV2BurnV2DTO
  :: UniswapV2BurnV2DTO
mkUniswapV2BurnV2DTO =
  UniswapV2BurnV2DTO
  { uniswapV2BurnV2DTOEntryTime = Nothing
  , uniswapV2BurnV2DTORecvTime = Nothing
  , uniswapV2BurnV2DTOBlockNumber = Nothing
  , uniswapV2BurnV2DTOId = Nothing
  , uniswapV2BurnV2DTOTransaction = Nothing
  , uniswapV2BurnV2DTOTimestamp = Nothing
  , uniswapV2BurnV2DTOPair = Nothing
  , uniswapV2BurnV2DTOLiquidity = Nothing
  , uniswapV2BurnV2DTOSender = Nothing
  , uniswapV2BurnV2DTOAmount0 = Nothing
  , uniswapV2BurnV2DTOAmount1 = Nothing
  , uniswapV2BurnV2DTOTo = Nothing
  , uniswapV2BurnV2DTOLogIndex = Nothing
  , uniswapV2BurnV2DTOAmountUsd = Nothing
  , uniswapV2BurnV2DTONeedsComplete = Nothing
  , uniswapV2BurnV2DTOFeeTo = Nothing
  , uniswapV2BurnV2DTOFeeLiquidity = Nothing
  , uniswapV2BurnV2DTOVid = Nothing
  }

-- ** UniswapV2LiquidityPositionSnapshotV2DTO
-- | UniswapV2LiquidityPositionSnapshotV2DTO
-- This entity is used to store data about a user's liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
data UniswapV2LiquidityPositionSnapshotV2DTO = UniswapV2LiquidityPositionSnapshotV2DTO
  { uniswapV2LiquidityPositionSnapshotV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2LiquidityPositionSnapshotV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2LiquidityPositionSnapshotV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2LiquidityPositionSnapshotV2DTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;pair address&gt;-&lt;user address&gt;
  , uniswapV2LiquidityPositionSnapshotV2DTOLiquidityPosition :: !(Maybe Text) -- ^ "liquidity_position" - Reference to LP identifier.
  , uniswapV2LiquidityPositionSnapshotV2DTOTimestamp :: !(Maybe Int) -- ^ "timestamp" - Creation time.
  , uniswapV2LiquidityPositionSnapshotV2DTOBlock :: !(Maybe Int) -- ^ "block" - Number of block in which LP snapshot was recorded.
  , uniswapV2LiquidityPositionSnapshotV2DTOUser :: !(Maybe Text) -- ^ "user" - Reference to user.
  , uniswapV2LiquidityPositionSnapshotV2DTOPair :: !(Maybe Text) -- ^ "pair" - Reference to the pair liquidity is being provided on.
  , uniswapV2LiquidityPositionSnapshotV2DTOToken0PriceUsd :: !(Maybe Text) -- ^ "token_0_price_usd" - Snapshot of token0 price.
  , uniswapV2LiquidityPositionSnapshotV2DTOToken1PriceUsd :: !(Maybe Text) -- ^ "token_1_price_usd" - Snapshot of token0 price.
  , uniswapV2LiquidityPositionSnapshotV2DTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Snapshot of pair token0 reserves.
  , uniswapV2LiquidityPositionSnapshotV2DTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Snapshot of pair token1 reserves.
  , uniswapV2LiquidityPositionSnapshotV2DTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Snapshot of pair reserves in USD.
  , uniswapV2LiquidityPositionSnapshotV2DTOLiquidityTokenTotalSupply :: !(Maybe Text) -- ^ "liquidity_token_total_supply" - Snapshot of pool token supply.
  , uniswapV2LiquidityPositionSnapshotV2DTOLiquidityTokenBalance :: !(Maybe Text) -- ^ "liquidity_token_balance" - Snapshot of users pool token balance.
  , uniswapV2LiquidityPositionSnapshotV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2LiquidityPositionSnapshotV2DTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2LiquidityPositionSnapshotV2DTO
instance A.FromJSON UniswapV2LiquidityPositionSnapshotV2DTO where
  parseJSON = A.withObject "UniswapV2LiquidityPositionSnapshotV2DTO" $ \o ->
    UniswapV2LiquidityPositionSnapshotV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "liquidity_position")
      <*> (o .:? "timestamp")
      <*> (o .:? "block")
      <*> (o .:? "user")
      <*> (o .:? "pair")
      <*> (o .:? "token_0_price_usd")
      <*> (o .:? "token_1_price_usd")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "liquidity_token_total_supply")
      <*> (o .:? "liquidity_token_balance")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON UniswapV2LiquidityPositionSnapshotV2DTO
instance A.ToJSON UniswapV2LiquidityPositionSnapshotV2DTO where
  toJSON UniswapV2LiquidityPositionSnapshotV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2LiquidityPositionSnapshotV2DTOEntryTime
      , "recv_time" .= uniswapV2LiquidityPositionSnapshotV2DTORecvTime
      , "block_number" .= uniswapV2LiquidityPositionSnapshotV2DTOBlockNumber
      , "id" .= uniswapV2LiquidityPositionSnapshotV2DTOId
      , "liquidity_position" .= uniswapV2LiquidityPositionSnapshotV2DTOLiquidityPosition
      , "timestamp" .= uniswapV2LiquidityPositionSnapshotV2DTOTimestamp
      , "block" .= uniswapV2LiquidityPositionSnapshotV2DTOBlock
      , "user" .= uniswapV2LiquidityPositionSnapshotV2DTOUser
      , "pair" .= uniswapV2LiquidityPositionSnapshotV2DTOPair
      , "token_0_price_usd" .= uniswapV2LiquidityPositionSnapshotV2DTOToken0PriceUsd
      , "token_1_price_usd" .= uniswapV2LiquidityPositionSnapshotV2DTOToken1PriceUsd
      , "reserve_0" .= uniswapV2LiquidityPositionSnapshotV2DTOReserve0
      , "reserve_1" .= uniswapV2LiquidityPositionSnapshotV2DTOReserve1
      , "reserve_usd" .= uniswapV2LiquidityPositionSnapshotV2DTOReserveUsd
      , "liquidity_token_total_supply" .= uniswapV2LiquidityPositionSnapshotV2DTOLiquidityTokenTotalSupply
      , "liquidity_token_balance" .= uniswapV2LiquidityPositionSnapshotV2DTOLiquidityTokenBalance
      , "vid" .= uniswapV2LiquidityPositionSnapshotV2DTOVid
      , "block_range" .= uniswapV2LiquidityPositionSnapshotV2DTOBlockRange
      ]


-- | Construct a value of type 'UniswapV2LiquidityPositionSnapshotV2DTO' (by applying it's required fields, if any)
mkUniswapV2LiquidityPositionSnapshotV2DTO
  :: UniswapV2LiquidityPositionSnapshotV2DTO
mkUniswapV2LiquidityPositionSnapshotV2DTO =
  UniswapV2LiquidityPositionSnapshotV2DTO
  { uniswapV2LiquidityPositionSnapshotV2DTOEntryTime = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTORecvTime = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOBlockNumber = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOId = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOLiquidityPosition = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOTimestamp = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOBlock = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOUser = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOPair = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOToken0PriceUsd = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOToken1PriceUsd = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOReserve0 = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOReserve1 = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOReserveUsd = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOLiquidityTokenTotalSupply = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOLiquidityTokenBalance = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOVid = Nothing
  , uniswapV2LiquidityPositionSnapshotV2DTOBlockRange = Nothing
  }

-- ** UniswapV2LiquidityPositionV2DTO
-- | UniswapV2LiquidityPositionV2DTO
-- This entity is used to store data about a user's liquidity position. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more.
data UniswapV2LiquidityPositionV2DTO = UniswapV2LiquidityPositionV2DTO
  { uniswapV2LiquidityPositionV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2LiquidityPositionV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2LiquidityPositionV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2LiquidityPositionV2DTOId :: !(Maybe Text) -- ^ "id" - User address and pair address concatenated with a dash.
  , uniswapV2LiquidityPositionV2DTOUser :: !(Maybe Text) -- ^ "user" - Reference to user.
  , uniswapV2LiquidityPositionV2DTOPair :: !(Maybe Text) -- ^ "pair" - Reference to the pair liquidity is being provided on.
  , uniswapV2LiquidityPositionV2DTOLiquidityTokenBalance :: !(Maybe Text) -- ^ "liquidity_token_balance" - Amount of LP tokens minted for this position.
  , uniswapV2LiquidityPositionV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2LiquidityPositionV2DTO
instance A.FromJSON UniswapV2LiquidityPositionV2DTO where
  parseJSON = A.withObject "UniswapV2LiquidityPositionV2DTO" $ \o ->
    UniswapV2LiquidityPositionV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "pair")
      <*> (o .:? "liquidity_token_balance")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2LiquidityPositionV2DTO
instance A.ToJSON UniswapV2LiquidityPositionV2DTO where
  toJSON UniswapV2LiquidityPositionV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2LiquidityPositionV2DTOEntryTime
      , "recv_time" .= uniswapV2LiquidityPositionV2DTORecvTime
      , "block_number" .= uniswapV2LiquidityPositionV2DTOBlockNumber
      , "id" .= uniswapV2LiquidityPositionV2DTOId
      , "user" .= uniswapV2LiquidityPositionV2DTOUser
      , "pair" .= uniswapV2LiquidityPositionV2DTOPair
      , "liquidity_token_balance" .= uniswapV2LiquidityPositionV2DTOLiquidityTokenBalance
      , "vid" .= uniswapV2LiquidityPositionV2DTOVid
      ]


-- | Construct a value of type 'UniswapV2LiquidityPositionV2DTO' (by applying it's required fields, if any)
mkUniswapV2LiquidityPositionV2DTO
  :: UniswapV2LiquidityPositionV2DTO
mkUniswapV2LiquidityPositionV2DTO =
  UniswapV2LiquidityPositionV2DTO
  { uniswapV2LiquidityPositionV2DTOEntryTime = Nothing
  , uniswapV2LiquidityPositionV2DTORecvTime = Nothing
  , uniswapV2LiquidityPositionV2DTOBlockNumber = Nothing
  , uniswapV2LiquidityPositionV2DTOId = Nothing
  , uniswapV2LiquidityPositionV2DTOUser = Nothing
  , uniswapV2LiquidityPositionV2DTOPair = Nothing
  , uniswapV2LiquidityPositionV2DTOLiquidityTokenBalance = Nothing
  , uniswapV2LiquidityPositionV2DTOVid = Nothing
  }

-- ** UniswapV2MintV2DTO
-- | UniswapV2MintV2DTO
-- Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
data UniswapV2MintV2DTO = UniswapV2MintV2DTO
  { uniswapV2MintV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2MintV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2MintV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2MintV2DTOId :: !(Maybe Text) -- ^ "id" - Transaction hash plus index in the transaction mint array.
  , uniswapV2MintV2DTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to the transaction Mint was included in.
  , uniswapV2MintV2DTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of Mint, used to sort recent liquidity provisions.
  , uniswapV2MintV2DTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , uniswapV2MintV2DTOTo :: !(Maybe Text) -- ^ "to" - Recipient of liquidity tokens.
  , uniswapV2MintV2DTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Amount of liquidity tokens minted.
  , uniswapV2MintV2DTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the liquidity provision.
  , uniswapV2MintV2DTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token0 provided.
  , uniswapV2MintV2DTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token1 provided.
  , uniswapV2MintV2DTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Index in the transaction event was emitted.
  , uniswapV2MintV2DTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived USD value of token0 amount plus token1 amount.
  , uniswapV2MintV2DTOFeeTo :: !(Maybe Text) -- ^ "fee_to" - Address of fee recipient (if fee is on).
  , uniswapV2MintV2DTOFeeLiquidity :: !(Maybe Text) -- ^ "fee_liquidity" - Amount of liquidity sent to fee recipient (if fee is on).
  , uniswapV2MintV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2MintV2DTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2MintV2DTO
instance A.FromJSON UniswapV2MintV2DTO where
  parseJSON = A.withObject "UniswapV2MintV2DTO" $ \o ->
    UniswapV2MintV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "to")
      <*> (o .:? "liquidity")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "fee_to")
      <*> (o .:? "fee_liquidity")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON UniswapV2MintV2DTO
instance A.ToJSON UniswapV2MintV2DTO where
  toJSON UniswapV2MintV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2MintV2DTOEntryTime
      , "recv_time" .= uniswapV2MintV2DTORecvTime
      , "block_number" .= uniswapV2MintV2DTOBlockNumber
      , "id" .= uniswapV2MintV2DTOId
      , "transaction" .= uniswapV2MintV2DTOTransaction
      , "timestamp" .= uniswapV2MintV2DTOTimestamp
      , "pair" .= uniswapV2MintV2DTOPair
      , "to" .= uniswapV2MintV2DTOTo
      , "liquidity" .= uniswapV2MintV2DTOLiquidity
      , "sender" .= uniswapV2MintV2DTOSender
      , "amount_0" .= uniswapV2MintV2DTOAmount0
      , "amount_1" .= uniswapV2MintV2DTOAmount1
      , "log_index" .= uniswapV2MintV2DTOLogIndex
      , "amount_usd" .= uniswapV2MintV2DTOAmountUsd
      , "fee_to" .= uniswapV2MintV2DTOFeeTo
      , "fee_liquidity" .= uniswapV2MintV2DTOFeeLiquidity
      , "vid" .= uniswapV2MintV2DTOVid
      , "block_range" .= uniswapV2MintV2DTOBlockRange
      ]


-- | Construct a value of type 'UniswapV2MintV2DTO' (by applying it's required fields, if any)
mkUniswapV2MintV2DTO
  :: UniswapV2MintV2DTO
mkUniswapV2MintV2DTO =
  UniswapV2MintV2DTO
  { uniswapV2MintV2DTOEntryTime = Nothing
  , uniswapV2MintV2DTORecvTime = Nothing
  , uniswapV2MintV2DTOBlockNumber = Nothing
  , uniswapV2MintV2DTOId = Nothing
  , uniswapV2MintV2DTOTransaction = Nothing
  , uniswapV2MintV2DTOTimestamp = Nothing
  , uniswapV2MintV2DTOPair = Nothing
  , uniswapV2MintV2DTOTo = Nothing
  , uniswapV2MintV2DTOLiquidity = Nothing
  , uniswapV2MintV2DTOSender = Nothing
  , uniswapV2MintV2DTOAmount0 = Nothing
  , uniswapV2MintV2DTOAmount1 = Nothing
  , uniswapV2MintV2DTOLogIndex = Nothing
  , uniswapV2MintV2DTOAmountUsd = Nothing
  , uniswapV2MintV2DTOFeeTo = Nothing
  , uniswapV2MintV2DTOFeeLiquidity = Nothing
  , uniswapV2MintV2DTOVid = Nothing
  , uniswapV2MintV2DTOBlockRange = Nothing
  }

-- ** UniswapV2PairDayDataV2DTO
-- | UniswapV2PairDayDataV2DTO
-- Tracks pair data across each day.
data UniswapV2PairDayDataV2DTO = UniswapV2PairDayDataV2DTO
  { uniswapV2PairDayDataV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2PairDayDataV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2PairDayDataV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2PairDayDataV2DTOId :: !(Maybe Text) -- ^ "id" - 
  , uniswapV2PairDayDataV2DTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , uniswapV2PairDayDataV2DTOPairAddress :: !(Maybe Text) -- ^ "pair_address" - Address for pair contract.
  , uniswapV2PairDayDataV2DTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0.
  , uniswapV2PairDayDataV2DTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1.
  , uniswapV2PairDayDataV2DTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0 (updated during each transaction on pair).
  , uniswapV2PairDayDataV2DTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1 (updated during each transaction on pair).
  , uniswapV2PairDayDataV2DTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token distributed to LPs.
  , uniswapV2PairDayDataV2DTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Reserve of token0 plus token1 stored as a derived USD amount.
  , uniswapV2PairDayDataV2DTODailyVolumeToken0 :: !(Maybe Text) -- ^ "daily_volume_token_0" - Total amount of token0 swapped throughout day.
  , uniswapV2PairDayDataV2DTODailyVolumeToken1 :: !(Maybe Text) -- ^ "daily_volume_token_1" - Total amount of token1 swapped throughout day.
  , uniswapV2PairDayDataV2DTODailyVolumeUsd :: !(Maybe Text) -- ^ "daily_volume_usd" - Total volume within pair throughout day.
  , uniswapV2PairDayDataV2DTODailyTxns :: !(Maybe Text) -- ^ "daily_txns" - Amount of transactions on pair throughout day.
  , uniswapV2PairDayDataV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2PairDayDataV2DTO
instance A.FromJSON UniswapV2PairDayDataV2DTO where
  parseJSON = A.withObject "UniswapV2PairDayDataV2DTO" $ \o ->
    UniswapV2PairDayDataV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pair_address")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "daily_volume_token_0")
      <*> (o .:? "daily_volume_token_1")
      <*> (o .:? "daily_volume_usd")
      <*> (o .:? "daily_txns")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2PairDayDataV2DTO
instance A.ToJSON UniswapV2PairDayDataV2DTO where
  toJSON UniswapV2PairDayDataV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2PairDayDataV2DTOEntryTime
      , "recv_time" .= uniswapV2PairDayDataV2DTORecvTime
      , "block_number" .= uniswapV2PairDayDataV2DTOBlockNumber
      , "id" .= uniswapV2PairDayDataV2DTOId
      , "date" .= uniswapV2PairDayDataV2DTODate
      , "pair_address" .= uniswapV2PairDayDataV2DTOPairAddress
      , "token_0" .= uniswapV2PairDayDataV2DTOToken0
      , "token_1" .= uniswapV2PairDayDataV2DTOToken1
      , "reserve_0" .= uniswapV2PairDayDataV2DTOReserve0
      , "reserve_1" .= uniswapV2PairDayDataV2DTOReserve1
      , "total_supply" .= uniswapV2PairDayDataV2DTOTotalSupply
      , "reserve_usd" .= uniswapV2PairDayDataV2DTOReserveUsd
      , "daily_volume_token_0" .= uniswapV2PairDayDataV2DTODailyVolumeToken0
      , "daily_volume_token_1" .= uniswapV2PairDayDataV2DTODailyVolumeToken1
      , "daily_volume_usd" .= uniswapV2PairDayDataV2DTODailyVolumeUsd
      , "daily_txns" .= uniswapV2PairDayDataV2DTODailyTxns
      , "vid" .= uniswapV2PairDayDataV2DTOVid
      ]


-- | Construct a value of type 'UniswapV2PairDayDataV2DTO' (by applying it's required fields, if any)
mkUniswapV2PairDayDataV2DTO
  :: UniswapV2PairDayDataV2DTO
mkUniswapV2PairDayDataV2DTO =
  UniswapV2PairDayDataV2DTO
  { uniswapV2PairDayDataV2DTOEntryTime = Nothing
  , uniswapV2PairDayDataV2DTORecvTime = Nothing
  , uniswapV2PairDayDataV2DTOBlockNumber = Nothing
  , uniswapV2PairDayDataV2DTOId = Nothing
  , uniswapV2PairDayDataV2DTODate = Nothing
  , uniswapV2PairDayDataV2DTOPairAddress = Nothing
  , uniswapV2PairDayDataV2DTOToken0 = Nothing
  , uniswapV2PairDayDataV2DTOToken1 = Nothing
  , uniswapV2PairDayDataV2DTOReserve0 = Nothing
  , uniswapV2PairDayDataV2DTOReserve1 = Nothing
  , uniswapV2PairDayDataV2DTOTotalSupply = Nothing
  , uniswapV2PairDayDataV2DTOReserveUsd = Nothing
  , uniswapV2PairDayDataV2DTODailyVolumeToken0 = Nothing
  , uniswapV2PairDayDataV2DTODailyVolumeToken1 = Nothing
  , uniswapV2PairDayDataV2DTODailyVolumeUsd = Nothing
  , uniswapV2PairDayDataV2DTODailyTxns = Nothing
  , uniswapV2PairDayDataV2DTOVid = Nothing
  }

-- ** UniswapV2PairHourDataV2DTO
-- | UniswapV2PairHourDataV2DTO
-- Tracks pair data across each hour.
data UniswapV2PairHourDataV2DTO = UniswapV2PairHourDataV2DTO
  { uniswapV2PairHourDataV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2PairHourDataV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2PairHourDataV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2PairHourDataV2DTOId :: !(Maybe Text) -- ^ "id" - 
  , uniswapV2PairHourDataV2DTOHourStartUnix :: !(Maybe Int) -- ^ "hour_start_unix" - Unix timestamp for start of hour.
  , uniswapV2PairHourDataV2DTOPair :: !(Maybe Text) -- ^ "pair" - Address for pair contract.
  , uniswapV2PairHourDataV2DTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0 (updated during each transaction on pair).
  , uniswapV2PairHourDataV2DTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1 (updated during each transaction on pair).
  , uniswapV2PairHourDataV2DTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token distributed to LPs.
  , uniswapV2PairHourDataV2DTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Reserve of token0 plus token1 stored as a derived USD amount.
  , uniswapV2PairHourDataV2DTOHourlyVolumeToken0 :: !(Maybe Text) -- ^ "hourly_volume_token_0" - Total amount of token0 swapped throughout hour.
  , uniswapV2PairHourDataV2DTOHourlyVolumeToken1 :: !(Maybe Text) -- ^ "hourly_volume_token_1" - Total amount of token1 swapped throughout hour.
  , uniswapV2PairHourDataV2DTOHourlyVolumeUsd :: !(Maybe Text) -- ^ "hourly_volume_usd" - Total volume within pair throughout hour.
  , uniswapV2PairHourDataV2DTOHourlyTxns :: !(Maybe Text) -- ^ "hourly_txns" - Amount of transactions on pair throughout hour.
  , uniswapV2PairHourDataV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2PairHourDataV2DTO
instance A.FromJSON UniswapV2PairHourDataV2DTO where
  parseJSON = A.withObject "UniswapV2PairHourDataV2DTO" $ \o ->
    UniswapV2PairHourDataV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "hour_start_unix")
      <*> (o .:? "pair")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "hourly_volume_token_0")
      <*> (o .:? "hourly_volume_token_1")
      <*> (o .:? "hourly_volume_usd")
      <*> (o .:? "hourly_txns")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2PairHourDataV2DTO
instance A.ToJSON UniswapV2PairHourDataV2DTO where
  toJSON UniswapV2PairHourDataV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2PairHourDataV2DTOEntryTime
      , "recv_time" .= uniswapV2PairHourDataV2DTORecvTime
      , "block_number" .= uniswapV2PairHourDataV2DTOBlockNumber
      , "id" .= uniswapV2PairHourDataV2DTOId
      , "hour_start_unix" .= uniswapV2PairHourDataV2DTOHourStartUnix
      , "pair" .= uniswapV2PairHourDataV2DTOPair
      , "reserve_0" .= uniswapV2PairHourDataV2DTOReserve0
      , "reserve_1" .= uniswapV2PairHourDataV2DTOReserve1
      , "total_supply" .= uniswapV2PairHourDataV2DTOTotalSupply
      , "reserve_usd" .= uniswapV2PairHourDataV2DTOReserveUsd
      , "hourly_volume_token_0" .= uniswapV2PairHourDataV2DTOHourlyVolumeToken0
      , "hourly_volume_token_1" .= uniswapV2PairHourDataV2DTOHourlyVolumeToken1
      , "hourly_volume_usd" .= uniswapV2PairHourDataV2DTOHourlyVolumeUsd
      , "hourly_txns" .= uniswapV2PairHourDataV2DTOHourlyTxns
      , "vid" .= uniswapV2PairHourDataV2DTOVid
      ]


-- | Construct a value of type 'UniswapV2PairHourDataV2DTO' (by applying it's required fields, if any)
mkUniswapV2PairHourDataV2DTO
  :: UniswapV2PairHourDataV2DTO
mkUniswapV2PairHourDataV2DTO =
  UniswapV2PairHourDataV2DTO
  { uniswapV2PairHourDataV2DTOEntryTime = Nothing
  , uniswapV2PairHourDataV2DTORecvTime = Nothing
  , uniswapV2PairHourDataV2DTOBlockNumber = Nothing
  , uniswapV2PairHourDataV2DTOId = Nothing
  , uniswapV2PairHourDataV2DTOHourStartUnix = Nothing
  , uniswapV2PairHourDataV2DTOPair = Nothing
  , uniswapV2PairHourDataV2DTOReserve0 = Nothing
  , uniswapV2PairHourDataV2DTOReserve1 = Nothing
  , uniswapV2PairHourDataV2DTOTotalSupply = Nothing
  , uniswapV2PairHourDataV2DTOReserveUsd = Nothing
  , uniswapV2PairHourDataV2DTOHourlyVolumeToken0 = Nothing
  , uniswapV2PairHourDataV2DTOHourlyVolumeToken1 = Nothing
  , uniswapV2PairHourDataV2DTOHourlyVolumeUsd = Nothing
  , uniswapV2PairHourDataV2DTOHourlyTxns = Nothing
  , uniswapV2PairHourDataV2DTOVid = Nothing
  }

-- ** UniswapV2PairV2DTO
-- | UniswapV2PairV2DTO
-- Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
data UniswapV2PairV2DTO = UniswapV2PairV2DTO
  { uniswapV2PairV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2PairV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2PairV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2PairV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2PairV2DTOId :: !(Maybe Text) -- ^ "id" - Pair contract address.
  , uniswapV2PairV2DTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pair contract.
  , uniswapV2PairV2DTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pair contract.
  , uniswapV2PairV2DTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0.
  , uniswapV2PairV2DTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1.
  , uniswapV2PairV2DTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token distributed to LPs.
  , uniswapV2PairV2DTOReserveEth :: !(Maybe Text) -- ^ "reserve_eth" - Total liquidity in pair stored as an amount of ETH.
  , uniswapV2PairV2DTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Total liquidity amount in pair stored as an amount of USD.
  , uniswapV2PairV2DTOTrackedReserveEth :: !(Maybe Text) -- ^ "tracked_reserve_eth" - Total liquidity with only tracked amount.
  , uniswapV2PairV2DTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - Token0 per token1.
  , uniswapV2PairV2DTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - Token1 per token0.
  , uniswapV2PairV2DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Amount of token0 swapped on this pair.
  , uniswapV2PairV2DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Amount of token1 swapped on this pair.
  , uniswapV2PairV2DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
  , uniswapV2PairV2DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
  , uniswapV2PairV2DTOTxCount :: !(Maybe NumericsBigInteger) -- ^ "tx_count"
  , uniswapV2PairV2DTOCreatedAtTimestamp :: !(Maybe DateTime) -- ^ "created_at_timestamp" - Timestamp contract was created.
  , uniswapV2PairV2DTOLiquidityProviderCount :: !(Maybe Text) -- ^ "liquidity_provider_count" - Total number of LPs.
  , uniswapV2PairV2DTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2PairV2DTO
instance A.FromJSON UniswapV2PairV2DTO where
  parseJSON = A.withObject "UniswapV2PairV2DTO" $ \o ->
    UniswapV2PairV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_eth")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "tracked_reserve_eth")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "created_at_timestamp")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "evaluated_ask")

-- | ToJSON UniswapV2PairV2DTO
instance A.ToJSON UniswapV2PairV2DTO where
  toJSON UniswapV2PairV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2PairV2DTOEntryTime
      , "recv_time" .= uniswapV2PairV2DTORecvTime
      , "block_number" .= uniswapV2PairV2DTOBlockNumber
      , "vid" .= uniswapV2PairV2DTOVid
      , "id" .= uniswapV2PairV2DTOId
      , "token_0" .= uniswapV2PairV2DTOToken0
      , "token_1" .= uniswapV2PairV2DTOToken1
      , "reserve_0" .= uniswapV2PairV2DTOReserve0
      , "reserve_1" .= uniswapV2PairV2DTOReserve1
      , "total_supply" .= uniswapV2PairV2DTOTotalSupply
      , "reserve_eth" .= uniswapV2PairV2DTOReserveEth
      , "reserve_usd" .= uniswapV2PairV2DTOReserveUsd
      , "tracked_reserve_eth" .= uniswapV2PairV2DTOTrackedReserveEth
      , "token_0_price" .= uniswapV2PairV2DTOToken0Price
      , "token_1_price" .= uniswapV2PairV2DTOToken1Price
      , "volume_token_0" .= uniswapV2PairV2DTOVolumeToken0
      , "volume_token_1" .= uniswapV2PairV2DTOVolumeToken1
      , "volume_usd" .= uniswapV2PairV2DTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV2PairV2DTOUntrackedVolumeUsd
      , "tx_count" .= uniswapV2PairV2DTOTxCount
      , "created_at_timestamp" .= uniswapV2PairV2DTOCreatedAtTimestamp
      , "liquidity_provider_count" .= uniswapV2PairV2DTOLiquidityProviderCount
      , "evaluated_ask" .= uniswapV2PairV2DTOEvaluatedAsk
      ]


-- | Construct a value of type 'UniswapV2PairV2DTO' (by applying it's required fields, if any)
mkUniswapV2PairV2DTO
  :: UniswapV2PairV2DTO
mkUniswapV2PairV2DTO =
  UniswapV2PairV2DTO
  { uniswapV2PairV2DTOEntryTime = Nothing
  , uniswapV2PairV2DTORecvTime = Nothing
  , uniswapV2PairV2DTOBlockNumber = Nothing
  , uniswapV2PairV2DTOVid = Nothing
  , uniswapV2PairV2DTOId = Nothing
  , uniswapV2PairV2DTOToken0 = Nothing
  , uniswapV2PairV2DTOToken1 = Nothing
  , uniswapV2PairV2DTOReserve0 = Nothing
  , uniswapV2PairV2DTOReserve1 = Nothing
  , uniswapV2PairV2DTOTotalSupply = Nothing
  , uniswapV2PairV2DTOReserveEth = Nothing
  , uniswapV2PairV2DTOReserveUsd = Nothing
  , uniswapV2PairV2DTOTrackedReserveEth = Nothing
  , uniswapV2PairV2DTOToken0Price = Nothing
  , uniswapV2PairV2DTOToken1Price = Nothing
  , uniswapV2PairV2DTOVolumeToken0 = Nothing
  , uniswapV2PairV2DTOVolumeToken1 = Nothing
  , uniswapV2PairV2DTOVolumeUsd = Nothing
  , uniswapV2PairV2DTOUntrackedVolumeUsd = Nothing
  , uniswapV2PairV2DTOTxCount = Nothing
  , uniswapV2PairV2DTOCreatedAtTimestamp = Nothing
  , uniswapV2PairV2DTOLiquidityProviderCount = Nothing
  , uniswapV2PairV2DTOEvaluatedAsk = Nothing
  }

-- ** UniswapV2SwapV2DTO
-- | UniswapV2SwapV2DTO
-- Swap are created for each token swap within a pair.
data UniswapV2SwapV2DTO = UniswapV2SwapV2DTO
  { uniswapV2SwapV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2SwapV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2SwapV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2SwapV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2SwapV2DTOId :: !(Maybe Text) -- ^ "id" - Transaction hash plus index in Transaction swap array.
  , uniswapV2SwapV2DTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to transaction swap was included in.
  , uniswapV2SwapV2DTOTimestamp :: !(Maybe DateTime) -- ^ "timestamp" - Timestamp of swap, used for sorted lookups.
  , uniswapV2SwapV2DTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , uniswapV2SwapV2DTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the swap.
  , uniswapV2SwapV2DTOFrom :: !(Maybe Text) -- ^ "from" - The EOA (Externally Owned Account) that initiated the transaction.
  , uniswapV2SwapV2DTOAmount0In :: !(Maybe Text) -- ^ "amount_0_in" - Amount of token0 sold.
  , uniswapV2SwapV2DTOAmount1In :: !(Maybe Text) -- ^ "amount_1_in" - Amount of token1 sold.
  , uniswapV2SwapV2DTOAmount0Out :: !(Maybe Text) -- ^ "amount_0_out" - Amount of token0 received.
  , uniswapV2SwapV2DTOAmount1Out :: !(Maybe Text) -- ^ "amount_1_out" - Amount of token1 received.
  , uniswapV2SwapV2DTOTo :: !(Maybe Text) -- ^ "to" - Recipient of output tokens.
  , uniswapV2SwapV2DTOLogIndex :: !(Maybe NumericsBigInteger) -- ^ "log_index"
  , uniswapV2SwapV2DTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount of tokens sold in USD.
  , uniswapV2SwapV2DTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , uniswapV2SwapV2DTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , uniswapV2SwapV2DTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  , uniswapV2SwapV2DTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , uniswapV2SwapV2DTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2SwapV2DTO
instance A.FromJSON UniswapV2SwapV2DTO where
  parseJSON = A.withObject "UniswapV2SwapV2DTO" $ \o ->
    UniswapV2SwapV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "sender")
      <*> (o .:? "from")
      <*> (o .:? "amount_0_in")
      <*> (o .:? "amount_1_in")
      <*> (o .:? "amount_0_out")
      <*> (o .:? "amount_1_out")
      <*> (o .:? "to")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")

-- | ToJSON UniswapV2SwapV2DTO
instance A.ToJSON UniswapV2SwapV2DTO where
  toJSON UniswapV2SwapV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2SwapV2DTOEntryTime
      , "recv_time" .= uniswapV2SwapV2DTORecvTime
      , "block_number" .= uniswapV2SwapV2DTOBlockNumber
      , "vid" .= uniswapV2SwapV2DTOVid
      , "id" .= uniswapV2SwapV2DTOId
      , "transaction" .= uniswapV2SwapV2DTOTransaction
      , "timestamp" .= uniswapV2SwapV2DTOTimestamp
      , "pair" .= uniswapV2SwapV2DTOPair
      , "sender" .= uniswapV2SwapV2DTOSender
      , "from" .= uniswapV2SwapV2DTOFrom
      , "amount_0_in" .= uniswapV2SwapV2DTOAmount0In
      , "amount_1_in" .= uniswapV2SwapV2DTOAmount1In
      , "amount_0_out" .= uniswapV2SwapV2DTOAmount0Out
      , "amount_1_out" .= uniswapV2SwapV2DTOAmount1Out
      , "to" .= uniswapV2SwapV2DTOTo
      , "log_index" .= uniswapV2SwapV2DTOLogIndex
      , "amount_usd" .= uniswapV2SwapV2DTOAmountUsd
      , "evaluated_price" .= uniswapV2SwapV2DTOEvaluatedPrice
      , "evaluated_amount" .= uniswapV2SwapV2DTOEvaluatedAmount
      , "evaluated_aggressor" .= uniswapV2SwapV2DTOEvaluatedAggressor
      , "pool_id" .= uniswapV2SwapV2DTOPoolId
      , "transaction_id" .= uniswapV2SwapV2DTOTransactionId
      ]


-- | Construct a value of type 'UniswapV2SwapV2DTO' (by applying it's required fields, if any)
mkUniswapV2SwapV2DTO
  :: UniswapV2SwapV2DTO
mkUniswapV2SwapV2DTO =
  UniswapV2SwapV2DTO
  { uniswapV2SwapV2DTOEntryTime = Nothing
  , uniswapV2SwapV2DTORecvTime = Nothing
  , uniswapV2SwapV2DTOBlockNumber = Nothing
  , uniswapV2SwapV2DTOVid = Nothing
  , uniswapV2SwapV2DTOId = Nothing
  , uniswapV2SwapV2DTOTransaction = Nothing
  , uniswapV2SwapV2DTOTimestamp = Nothing
  , uniswapV2SwapV2DTOPair = Nothing
  , uniswapV2SwapV2DTOSender = Nothing
  , uniswapV2SwapV2DTOFrom = Nothing
  , uniswapV2SwapV2DTOAmount0In = Nothing
  , uniswapV2SwapV2DTOAmount1In = Nothing
  , uniswapV2SwapV2DTOAmount0Out = Nothing
  , uniswapV2SwapV2DTOAmount1Out = Nothing
  , uniswapV2SwapV2DTOTo = Nothing
  , uniswapV2SwapV2DTOLogIndex = Nothing
  , uniswapV2SwapV2DTOAmountUsd = Nothing
  , uniswapV2SwapV2DTOEvaluatedPrice = Nothing
  , uniswapV2SwapV2DTOEvaluatedAmount = Nothing
  , uniswapV2SwapV2DTOEvaluatedAggressor = Nothing
  , uniswapV2SwapV2DTOPoolId = Nothing
  , uniswapV2SwapV2DTOTransactionId = Nothing
  }

-- ** UniswapV2TokenDayDataV2DTO
-- | UniswapV2TokenDayDataV2DTO
-- Token data aggregated across all pairs that include token.
data UniswapV2TokenDayDataV2DTO = UniswapV2TokenDayDataV2DTO
  { uniswapV2TokenDayDataV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2TokenDayDataV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2TokenDayDataV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2TokenDayDataV2DTOId :: !(Maybe Text) -- ^ "id" - Token address and day id (day start timestamp in unix / 86400) concatenated with a dash.
  , uniswapV2TokenDayDataV2DTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , uniswapV2TokenDayDataV2DTOToken :: !(Maybe Text) -- ^ "token" - Reference to token entity.
  , uniswapV2TokenDayDataV2DTODailyVolumeToken :: !(Maybe Text) -- ^ "daily_volume_token" - Amount of token swapped across all pairs throughout day.
  , uniswapV2TokenDayDataV2DTODailyVolumeEth :: !(Maybe Text) -- ^ "daily_volume_eth" - Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
  , uniswapV2TokenDayDataV2DTODailyVolumeUsd :: !(Maybe Text) -- ^ "daily_volume_usd" - Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
  , uniswapV2TokenDayDataV2DTODailyTxns :: !(Maybe Text) -- ^ "daily_txns" - Amount of transactions with this token across all pairs.
  , uniswapV2TokenDayDataV2DTOTotalLiquidityToken :: !(Maybe Text) -- ^ "total_liquidity_token" - Token amount of token deposited across all pairs.
  , uniswapV2TokenDayDataV2DTOTotalLiquidityEth :: !(Maybe Text) -- ^ "total_liquidity_eth" - Token amount of token deposited across all pairs stored as amount of ETH.
  , uniswapV2TokenDayDataV2DTOTotalLiquidityUsd :: !(Maybe Text) -- ^ "total_liquidity_usd" - Token amount of token deposited across all pairs stored as amount of USD.
  , uniswapV2TokenDayDataV2DTOPriceUsd :: !(Maybe Text) -- ^ "price_usd" - Price of token in derived USD.
  , uniswapV2TokenDayDataV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2TokenDayDataV2DTO
instance A.FromJSON UniswapV2TokenDayDataV2DTO where
  parseJSON = A.withObject "UniswapV2TokenDayDataV2DTO" $ \o ->
    UniswapV2TokenDayDataV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "token")
      <*> (o .:? "daily_volume_token")
      <*> (o .:? "daily_volume_eth")
      <*> (o .:? "daily_volume_usd")
      <*> (o .:? "daily_txns")
      <*> (o .:? "total_liquidity_token")
      <*> (o .:? "total_liquidity_eth")
      <*> (o .:? "total_liquidity_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2TokenDayDataV2DTO
instance A.ToJSON UniswapV2TokenDayDataV2DTO where
  toJSON UniswapV2TokenDayDataV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2TokenDayDataV2DTOEntryTime
      , "recv_time" .= uniswapV2TokenDayDataV2DTORecvTime
      , "block_number" .= uniswapV2TokenDayDataV2DTOBlockNumber
      , "id" .= uniswapV2TokenDayDataV2DTOId
      , "date" .= uniswapV2TokenDayDataV2DTODate
      , "token" .= uniswapV2TokenDayDataV2DTOToken
      , "daily_volume_token" .= uniswapV2TokenDayDataV2DTODailyVolumeToken
      , "daily_volume_eth" .= uniswapV2TokenDayDataV2DTODailyVolumeEth
      , "daily_volume_usd" .= uniswapV2TokenDayDataV2DTODailyVolumeUsd
      , "daily_txns" .= uniswapV2TokenDayDataV2DTODailyTxns
      , "total_liquidity_token" .= uniswapV2TokenDayDataV2DTOTotalLiquidityToken
      , "total_liquidity_eth" .= uniswapV2TokenDayDataV2DTOTotalLiquidityEth
      , "total_liquidity_usd" .= uniswapV2TokenDayDataV2DTOTotalLiquidityUsd
      , "price_usd" .= uniswapV2TokenDayDataV2DTOPriceUsd
      , "vid" .= uniswapV2TokenDayDataV2DTOVid
      ]


-- | Construct a value of type 'UniswapV2TokenDayDataV2DTO' (by applying it's required fields, if any)
mkUniswapV2TokenDayDataV2DTO
  :: UniswapV2TokenDayDataV2DTO
mkUniswapV2TokenDayDataV2DTO =
  UniswapV2TokenDayDataV2DTO
  { uniswapV2TokenDayDataV2DTOEntryTime = Nothing
  , uniswapV2TokenDayDataV2DTORecvTime = Nothing
  , uniswapV2TokenDayDataV2DTOBlockNumber = Nothing
  , uniswapV2TokenDayDataV2DTOId = Nothing
  , uniswapV2TokenDayDataV2DTODate = Nothing
  , uniswapV2TokenDayDataV2DTOToken = Nothing
  , uniswapV2TokenDayDataV2DTODailyVolumeToken = Nothing
  , uniswapV2TokenDayDataV2DTODailyVolumeEth = Nothing
  , uniswapV2TokenDayDataV2DTODailyVolumeUsd = Nothing
  , uniswapV2TokenDayDataV2DTODailyTxns = Nothing
  , uniswapV2TokenDayDataV2DTOTotalLiquidityToken = Nothing
  , uniswapV2TokenDayDataV2DTOTotalLiquidityEth = Nothing
  , uniswapV2TokenDayDataV2DTOTotalLiquidityUsd = Nothing
  , uniswapV2TokenDayDataV2DTOPriceUsd = Nothing
  , uniswapV2TokenDayDataV2DTOVid = Nothing
  }

-- ** UniswapV2TokenV2DTO
-- | UniswapV2TokenV2DTO
-- Stores aggregated information for a specific token across all pairs that token is included in.
data UniswapV2TokenV2DTO = UniswapV2TokenV2DTO
  { uniswapV2TokenV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2TokenV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2TokenV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2TokenV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2TokenV2DTOId :: !(Maybe Text) -- ^ "id" - Token address.
  , uniswapV2TokenV2DTOSymbol :: !(Maybe Text) -- ^ "symbol" - Token symbol.
  , uniswapV2TokenV2DTOName :: !(Maybe Text) -- ^ "name" - Token name.
  , uniswapV2TokenV2DTODecimals :: !(Maybe Int) -- ^ "decimals" - Token decimals.
  , uniswapV2TokenV2DTOTotalSupply :: !(Maybe NumericsBigInteger) -- ^ "total_supply"
  , uniswapV2TokenV2DTOTradeVolume :: !(Maybe Text) -- ^ "trade_volume" - Amount of token traded all time across all pairs.
  , uniswapV2TokenV2DTOTradeVolumeUsd :: !(Maybe Text) -- ^ "trade_volume_usd" - Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
  , uniswapV2TokenV2DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
  , uniswapV2TokenV2DTOTxCount :: !(Maybe NumericsBigInteger) -- ^ "tx_count"
  , uniswapV2TokenV2DTOTotalLiquidity :: !(Maybe Text) -- ^ "total_liquidity" - Total amount of token provided as liquidity across all pairs.
  , uniswapV2TokenV2DTODerivedEth :: !(Maybe Text) -- ^ "derived_eth" - ETH per token.
  , uniswapV2TokenV2DTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2TokenV2DTO
instance A.FromJSON UniswapV2TokenV2DTO where
  parseJSON = A.withObject "UniswapV2TokenV2DTO" $ \o ->
    UniswapV2TokenV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "symbol")
      <*> (o .:? "name")
      <*> (o .:? "decimals")
      <*> (o .:? "total_supply")
      <*> (o .:? "trade_volume")
      <*> (o .:? "trade_volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "total_liquidity")
      <*> (o .:? "derived_eth")
      <*> (o .:? "token_symbol")

-- | ToJSON UniswapV2TokenV2DTO
instance A.ToJSON UniswapV2TokenV2DTO where
  toJSON UniswapV2TokenV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2TokenV2DTOEntryTime
      , "recv_time" .= uniswapV2TokenV2DTORecvTime
      , "block_number" .= uniswapV2TokenV2DTOBlockNumber
      , "vid" .= uniswapV2TokenV2DTOVid
      , "id" .= uniswapV2TokenV2DTOId
      , "symbol" .= uniswapV2TokenV2DTOSymbol
      , "name" .= uniswapV2TokenV2DTOName
      , "decimals" .= uniswapV2TokenV2DTODecimals
      , "total_supply" .= uniswapV2TokenV2DTOTotalSupply
      , "trade_volume" .= uniswapV2TokenV2DTOTradeVolume
      , "trade_volume_usd" .= uniswapV2TokenV2DTOTradeVolumeUsd
      , "untracked_volume_usd" .= uniswapV2TokenV2DTOUntrackedVolumeUsd
      , "tx_count" .= uniswapV2TokenV2DTOTxCount
      , "total_liquidity" .= uniswapV2TokenV2DTOTotalLiquidity
      , "derived_eth" .= uniswapV2TokenV2DTODerivedEth
      , "token_symbol" .= uniswapV2TokenV2DTOTokenSymbol
      ]


-- | Construct a value of type 'UniswapV2TokenV2DTO' (by applying it's required fields, if any)
mkUniswapV2TokenV2DTO
  :: UniswapV2TokenV2DTO
mkUniswapV2TokenV2DTO =
  UniswapV2TokenV2DTO
  { uniswapV2TokenV2DTOEntryTime = Nothing
  , uniswapV2TokenV2DTORecvTime = Nothing
  , uniswapV2TokenV2DTOBlockNumber = Nothing
  , uniswapV2TokenV2DTOVid = Nothing
  , uniswapV2TokenV2DTOId = Nothing
  , uniswapV2TokenV2DTOSymbol = Nothing
  , uniswapV2TokenV2DTOName = Nothing
  , uniswapV2TokenV2DTODecimals = Nothing
  , uniswapV2TokenV2DTOTotalSupply = Nothing
  , uniswapV2TokenV2DTOTradeVolume = Nothing
  , uniswapV2TokenV2DTOTradeVolumeUsd = Nothing
  , uniswapV2TokenV2DTOUntrackedVolumeUsd = Nothing
  , uniswapV2TokenV2DTOTxCount = Nothing
  , uniswapV2TokenV2DTOTotalLiquidity = Nothing
  , uniswapV2TokenV2DTODerivedEth = Nothing
  , uniswapV2TokenV2DTOTokenSymbol = Nothing
  }

-- ** UniswapV2TransactionV2DTO
-- | UniswapV2TransactionV2DTO
-- Transaction entities are created for each Ethereum transaction that contains an interaction within Uniswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
data UniswapV2TransactionV2DTO = UniswapV2TransactionV2DTO
  { uniswapV2TransactionV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2TransactionV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2TransactionV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2TransactionV2DTOId :: !(Maybe Text) -- ^ "id" - Ethereum transaction hash.
  , uniswapV2TransactionV2DTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp.
  , uniswapV2TransactionV2DTOMints :: !(Maybe [Text]) -- ^ "mints" - Array of Mint events within the transaction, 0 or greater.
  , uniswapV2TransactionV2DTOBurns :: !(Maybe [Text]) -- ^ "burns" - Array of Burn events within transaction, 0 or greater.
  , uniswapV2TransactionV2DTOSwaps :: !(Maybe [Text]) -- ^ "swaps" - Array of Swap events within transaction, 0 or greater.
  , uniswapV2TransactionV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2TransactionV2DTO
instance A.FromJSON UniswapV2TransactionV2DTO where
  parseJSON = A.withObject "UniswapV2TransactionV2DTO" $ \o ->
    UniswapV2TransactionV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "timestamp")
      <*> (o .:? "mints")
      <*> (o .:? "burns")
      <*> (o .:? "swaps")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2TransactionV2DTO
instance A.ToJSON UniswapV2TransactionV2DTO where
  toJSON UniswapV2TransactionV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2TransactionV2DTOEntryTime
      , "recv_time" .= uniswapV2TransactionV2DTORecvTime
      , "block_number" .= uniswapV2TransactionV2DTOBlockNumber
      , "id" .= uniswapV2TransactionV2DTOId
      , "timestamp" .= uniswapV2TransactionV2DTOTimestamp
      , "mints" .= uniswapV2TransactionV2DTOMints
      , "burns" .= uniswapV2TransactionV2DTOBurns
      , "swaps" .= uniswapV2TransactionV2DTOSwaps
      , "vid" .= uniswapV2TransactionV2DTOVid
      ]


-- | Construct a value of type 'UniswapV2TransactionV2DTO' (by applying it's required fields, if any)
mkUniswapV2TransactionV2DTO
  :: UniswapV2TransactionV2DTO
mkUniswapV2TransactionV2DTO =
  UniswapV2TransactionV2DTO
  { uniswapV2TransactionV2DTOEntryTime = Nothing
  , uniswapV2TransactionV2DTORecvTime = Nothing
  , uniswapV2TransactionV2DTOBlockNumber = Nothing
  , uniswapV2TransactionV2DTOId = Nothing
  , uniswapV2TransactionV2DTOTimestamp = Nothing
  , uniswapV2TransactionV2DTOMints = Nothing
  , uniswapV2TransactionV2DTOBurns = Nothing
  , uniswapV2TransactionV2DTOSwaps = Nothing
  , uniswapV2TransactionV2DTOVid = Nothing
  }

-- ** UniswapV2UniswapDayDataV2DTO
-- | UniswapV2UniswapDayDataV2DTO
-- Tracks data across all pairs aggregated into a daily bucket.
data UniswapV2UniswapDayDataV2DTO = UniswapV2UniswapDayDataV2DTO
  { uniswapV2UniswapDayDataV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2UniswapDayDataV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2UniswapDayDataV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2UniswapDayDataV2DTOId :: !(Maybe Text) -- ^ "id" - Unix timestamp for start of day / 86400 giving a unique day index.
  , uniswapV2UniswapDayDataV2DTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , uniswapV2UniswapDayDataV2DTODailyVolumeEth :: !(Maybe Text) -- ^ "daily_volume_eth" - Total volume across all pairs on this day, stored as a derived amount of ETH.
  , uniswapV2UniswapDayDataV2DTODailyVolumeUsd :: !(Maybe Text) -- ^ "daily_volume_usd" - Total volume across all pairs on this day, stored as a derived amount of USD.
  , uniswapV2UniswapDayDataV2DTODailyVolumeUntracked :: !(Maybe Text) -- ^ "daily_volume_untracked" - Total volume across all pairs on this day, untracked.
  , uniswapV2UniswapDayDataV2DTOTotalVolumeEth :: !(Maybe Text) -- ^ "total_volume_eth" - All time volume across all pairs in ETH up to and including this day.
  , uniswapV2UniswapDayDataV2DTOTotalLiquidityEth :: !(Maybe Text) -- ^ "total_liquidity_eth" - Total liquidity across all pairs in ETH up to and including this day.
  , uniswapV2UniswapDayDataV2DTOTotalVolumeUsd :: !(Maybe Text) -- ^ "total_volume_usd" - All time volume across all pairs in USD up to and including this day.
  , uniswapV2UniswapDayDataV2DTOTotalLiquidityUsd :: !(Maybe Text) -- ^ "total_liquidity_usd" - Total liquidity across all pairs in USD up to and including this day.
  , uniswapV2UniswapDayDataV2DTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Number of transactions throughout this day.
  , uniswapV2UniswapDayDataV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2UniswapDayDataV2DTO
instance A.FromJSON UniswapV2UniswapDayDataV2DTO where
  parseJSON = A.withObject "UniswapV2UniswapDayDataV2DTO" $ \o ->
    UniswapV2UniswapDayDataV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "daily_volume_eth")
      <*> (o .:? "daily_volume_usd")
      <*> (o .:? "daily_volume_untracked")
      <*> (o .:? "total_volume_eth")
      <*> (o .:? "total_liquidity_eth")
      <*> (o .:? "total_volume_usd")
      <*> (o .:? "total_liquidity_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2UniswapDayDataV2DTO
instance A.ToJSON UniswapV2UniswapDayDataV2DTO where
  toJSON UniswapV2UniswapDayDataV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2UniswapDayDataV2DTOEntryTime
      , "recv_time" .= uniswapV2UniswapDayDataV2DTORecvTime
      , "block_number" .= uniswapV2UniswapDayDataV2DTOBlockNumber
      , "id" .= uniswapV2UniswapDayDataV2DTOId
      , "date" .= uniswapV2UniswapDayDataV2DTODate
      , "daily_volume_eth" .= uniswapV2UniswapDayDataV2DTODailyVolumeEth
      , "daily_volume_usd" .= uniswapV2UniswapDayDataV2DTODailyVolumeUsd
      , "daily_volume_untracked" .= uniswapV2UniswapDayDataV2DTODailyVolumeUntracked
      , "total_volume_eth" .= uniswapV2UniswapDayDataV2DTOTotalVolumeEth
      , "total_liquidity_eth" .= uniswapV2UniswapDayDataV2DTOTotalLiquidityEth
      , "total_volume_usd" .= uniswapV2UniswapDayDataV2DTOTotalVolumeUsd
      , "total_liquidity_usd" .= uniswapV2UniswapDayDataV2DTOTotalLiquidityUsd
      , "tx_count" .= uniswapV2UniswapDayDataV2DTOTxCount
      , "vid" .= uniswapV2UniswapDayDataV2DTOVid
      ]


-- | Construct a value of type 'UniswapV2UniswapDayDataV2DTO' (by applying it's required fields, if any)
mkUniswapV2UniswapDayDataV2DTO
  :: UniswapV2UniswapDayDataV2DTO
mkUniswapV2UniswapDayDataV2DTO =
  UniswapV2UniswapDayDataV2DTO
  { uniswapV2UniswapDayDataV2DTOEntryTime = Nothing
  , uniswapV2UniswapDayDataV2DTORecvTime = Nothing
  , uniswapV2UniswapDayDataV2DTOBlockNumber = Nothing
  , uniswapV2UniswapDayDataV2DTOId = Nothing
  , uniswapV2UniswapDayDataV2DTODate = Nothing
  , uniswapV2UniswapDayDataV2DTODailyVolumeEth = Nothing
  , uniswapV2UniswapDayDataV2DTODailyVolumeUsd = Nothing
  , uniswapV2UniswapDayDataV2DTODailyVolumeUntracked = Nothing
  , uniswapV2UniswapDayDataV2DTOTotalVolumeEth = Nothing
  , uniswapV2UniswapDayDataV2DTOTotalLiquidityEth = Nothing
  , uniswapV2UniswapDayDataV2DTOTotalVolumeUsd = Nothing
  , uniswapV2UniswapDayDataV2DTOTotalLiquidityUsd = Nothing
  , uniswapV2UniswapDayDataV2DTOTxCount = Nothing
  , uniswapV2UniswapDayDataV2DTOVid = Nothing
  }

-- ** UniswapV2UniswapFactoryV2DTO
-- | UniswapV2UniswapFactoryV2DTO
-- The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
data UniswapV2UniswapFactoryV2DTO = UniswapV2UniswapFactoryV2DTO
  { uniswapV2UniswapFactoryV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2UniswapFactoryV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2UniswapFactoryV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2UniswapFactoryV2DTOId :: !(Maybe Text) -- ^ "id" - Factory address.
  , uniswapV2UniswapFactoryV2DTOPairCount :: !(Maybe Int) -- ^ "pair_count" - Amount of pairs created by the Uniswap factory.
  , uniswapV2UniswapFactoryV2DTOTotalVolumeUsd :: !(Maybe Text) -- ^ "total_volume_usd" - All time USD volume across all pairs (USD is derived).
  , uniswapV2UniswapFactoryV2DTOTotalVolumeEth :: !(Maybe Text) -- ^ "total_volume_eth" - All time volume in ETH across all pairs (ETH is derived).
  , uniswapV2UniswapFactoryV2DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Untracked volume USD.
  , uniswapV2UniswapFactoryV2DTOTotalLiquidityUsd :: !(Maybe Text) -- ^ "total_liquidity_usd" - Total liquidity across all pairs stored as a derived USD amount.
  , uniswapV2UniswapFactoryV2DTOTotalLiquidityEth :: !(Maybe Text) -- ^ "total_liquidity_eth" - Total liquidity across all pairs stored as a derived ETH amount.
  , uniswapV2UniswapFactoryV2DTOTxCount :: !(Maybe Text) -- ^ "tx_count" - All time amount of transactions across all pairs.
  , uniswapV2UniswapFactoryV2DTOVid :: !(Maybe Integer) -- ^ "vid" - .
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2UniswapFactoryV2DTO
instance A.FromJSON UniswapV2UniswapFactoryV2DTO where
  parseJSON = A.withObject "UniswapV2UniswapFactoryV2DTO" $ \o ->
    UniswapV2UniswapFactoryV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pair_count")
      <*> (o .:? "total_volume_usd")
      <*> (o .:? "total_volume_eth")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_liquidity_usd")
      <*> (o .:? "total_liquidity_eth")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2UniswapFactoryV2DTO
instance A.ToJSON UniswapV2UniswapFactoryV2DTO where
  toJSON UniswapV2UniswapFactoryV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2UniswapFactoryV2DTOEntryTime
      , "recv_time" .= uniswapV2UniswapFactoryV2DTORecvTime
      , "block_number" .= uniswapV2UniswapFactoryV2DTOBlockNumber
      , "id" .= uniswapV2UniswapFactoryV2DTOId
      , "pair_count" .= uniswapV2UniswapFactoryV2DTOPairCount
      , "total_volume_usd" .= uniswapV2UniswapFactoryV2DTOTotalVolumeUsd
      , "total_volume_eth" .= uniswapV2UniswapFactoryV2DTOTotalVolumeEth
      , "untracked_volume_usd" .= uniswapV2UniswapFactoryV2DTOUntrackedVolumeUsd
      , "total_liquidity_usd" .= uniswapV2UniswapFactoryV2DTOTotalLiquidityUsd
      , "total_liquidity_eth" .= uniswapV2UniswapFactoryV2DTOTotalLiquidityEth
      , "tx_count" .= uniswapV2UniswapFactoryV2DTOTxCount
      , "vid" .= uniswapV2UniswapFactoryV2DTOVid
      ]


-- | Construct a value of type 'UniswapV2UniswapFactoryV2DTO' (by applying it's required fields, if any)
mkUniswapV2UniswapFactoryV2DTO
  :: UniswapV2UniswapFactoryV2DTO
mkUniswapV2UniswapFactoryV2DTO =
  UniswapV2UniswapFactoryV2DTO
  { uniswapV2UniswapFactoryV2DTOEntryTime = Nothing
  , uniswapV2UniswapFactoryV2DTORecvTime = Nothing
  , uniswapV2UniswapFactoryV2DTOBlockNumber = Nothing
  , uniswapV2UniswapFactoryV2DTOId = Nothing
  , uniswapV2UniswapFactoryV2DTOPairCount = Nothing
  , uniswapV2UniswapFactoryV2DTOTotalVolumeUsd = Nothing
  , uniswapV2UniswapFactoryV2DTOTotalVolumeEth = Nothing
  , uniswapV2UniswapFactoryV2DTOUntrackedVolumeUsd = Nothing
  , uniswapV2UniswapFactoryV2DTOTotalLiquidityUsd = Nothing
  , uniswapV2UniswapFactoryV2DTOTotalLiquidityEth = Nothing
  , uniswapV2UniswapFactoryV2DTOTxCount = Nothing
  , uniswapV2UniswapFactoryV2DTOVid = Nothing
  }

-- ** UniswapV2UserV2DTO
-- | UniswapV2UserV2DTO
-- A user entity is created for any address that provides liquidity to a pool on Uniswap. This entity can be used to track open positions for users.
data UniswapV2UserV2DTO = UniswapV2UserV2DTO
  { uniswapV2UserV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2UserV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2UserV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2UserV2DTOId :: !(Maybe Text) -- ^ "id" - User address.
  , uniswapV2UserV2DTOUsdSwapped :: !(Maybe Text) -- ^ "usd_swapped" - Total USD value swapped.
  , uniswapV2UserV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2UserV2DTO
instance A.FromJSON UniswapV2UserV2DTO where
  parseJSON = A.withObject "UniswapV2UserV2DTO" $ \o ->
    UniswapV2UserV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "usd_swapped")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2UserV2DTO
instance A.ToJSON UniswapV2UserV2DTO where
  toJSON UniswapV2UserV2DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2UserV2DTOEntryTime
      , "recv_time" .= uniswapV2UserV2DTORecvTime
      , "block_number" .= uniswapV2UserV2DTOBlockNumber
      , "id" .= uniswapV2UserV2DTOId
      , "usd_swapped" .= uniswapV2UserV2DTOUsdSwapped
      , "vid" .= uniswapV2UserV2DTOVid
      ]


-- | Construct a value of type 'UniswapV2UserV2DTO' (by applying it's required fields, if any)
mkUniswapV2UserV2DTO
  :: UniswapV2UserV2DTO
mkUniswapV2UserV2DTO =
  UniswapV2UserV2DTO
  { uniswapV2UserV2DTOEntryTime = Nothing
  , uniswapV2UserV2DTORecvTime = Nothing
  , uniswapV2UserV2DTOBlockNumber = Nothing
  , uniswapV2UserV2DTOId = Nothing
  , uniswapV2UserV2DTOUsdSwapped = Nothing
  , uniswapV2UserV2DTOVid = Nothing
  }

-- ** UniswapV3BundleV3DTO
-- | UniswapV3BundleV3DTO
-- The Bundle is used as a global store of derived ETH price in USD. This provides a strong estimate for the USD price of ETH.
data UniswapV3BundleV3DTO = UniswapV3BundleV3DTO
  { uniswapV3BundleV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3BundleV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3BundleV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3BundleV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , uniswapV3BundleV3DTOEthPriceUsd :: !(Maybe Text) -- ^ "eth_price_usd" - Price of ETH in usd.
  , uniswapV3BundleV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3BundleV3DTO
instance A.FromJSON UniswapV3BundleV3DTO where
  parseJSON = A.withObject "UniswapV3BundleV3DTO" $ \o ->
    UniswapV3BundleV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "eth_price_usd")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3BundleV3DTO
instance A.ToJSON UniswapV3BundleV3DTO where
  toJSON UniswapV3BundleV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3BundleV3DTOEntryTime
      , "recv_time" .= uniswapV3BundleV3DTORecvTime
      , "block_number" .= uniswapV3BundleV3DTOBlockNumber
      , "id" .= uniswapV3BundleV3DTOId
      , "eth_price_usd" .= uniswapV3BundleV3DTOEthPriceUsd
      , "vid" .= uniswapV3BundleV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3BundleV3DTO' (by applying it's required fields, if any)
mkUniswapV3BundleV3DTO
  :: UniswapV3BundleV3DTO
mkUniswapV3BundleV3DTO =
  UniswapV3BundleV3DTO
  { uniswapV3BundleV3DTOEntryTime = Nothing
  , uniswapV3BundleV3DTORecvTime = Nothing
  , uniswapV3BundleV3DTOBlockNumber = Nothing
  , uniswapV3BundleV3DTOId = Nothing
  , uniswapV3BundleV3DTOEthPriceUsd = Nothing
  , uniswapV3BundleV3DTOVid = Nothing
  }

-- ** UniswapV3BurnV3DTO
-- | UniswapV3BurnV3DTO
-- Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
data UniswapV3BurnV3DTO = UniswapV3BurnV3DTO
  { uniswapV3BurnV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3BurnV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3BurnV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3BurnV3DTOId :: !(Maybe Text) -- ^ "id" - Transaction hash + &#39;#&#39; + index in mints Transaction array.
  , uniswapV3BurnV3DTOTransaction :: !(Maybe Text) -- ^ "transaction" - Transaction burn was included in.
  , uniswapV3BurnV3DTOPool :: !(Maybe Text) -- ^ "pool" - Pool position is within.
  , uniswapV3BurnV3DTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pool contract.
  , uniswapV3BurnV3DTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pool contract.
  , uniswapV3BurnV3DTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp.
  , uniswapV3BurnV3DTOOwner :: !(Maybe Text) -- ^ "owner" - Owner of position where liquidity was burned.
  , uniswapV3BurnV3DTOOrigin :: !(Maybe Text) -- ^ "origin" - Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
  , uniswapV3BurnV3DTOAmount :: !(Maybe Text) -- ^ "amount" - Amount of liquidity burned.
  , uniswapV3BurnV3DTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token 0 burned.
  , uniswapV3BurnV3DTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token 1 burned.
  , uniswapV3BurnV3DTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount based on available prices of tokens.
  , uniswapV3BurnV3DTOTickLower :: !(Maybe Text) -- ^ "tick_lower" - Lower tick of position.
  , uniswapV3BurnV3DTOTickUpper :: !(Maybe Text) -- ^ "tick_upper" - Upper tick of position.
  , uniswapV3BurnV3DTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Position within the transactions.
  , uniswapV3BurnV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3BurnV3DTO
instance A.FromJSON UniswapV3BurnV3DTO where
  parseJSON = A.withObject "UniswapV3BurnV3DTO" $ \o ->
    UniswapV3BurnV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "timestamp")
      <*> (o .:? "owner")
      <*> (o .:? "origin")
      <*> (o .:? "amount")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "amount_usd")
      <*> (o .:? "tick_lower")
      <*> (o .:? "tick_upper")
      <*> (o .:? "log_index")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3BurnV3DTO
instance A.ToJSON UniswapV3BurnV3DTO where
  toJSON UniswapV3BurnV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3BurnV3DTOEntryTime
      , "recv_time" .= uniswapV3BurnV3DTORecvTime
      , "block_number" .= uniswapV3BurnV3DTOBlockNumber
      , "id" .= uniswapV3BurnV3DTOId
      , "transaction" .= uniswapV3BurnV3DTOTransaction
      , "pool" .= uniswapV3BurnV3DTOPool
      , "token_0" .= uniswapV3BurnV3DTOToken0
      , "token_1" .= uniswapV3BurnV3DTOToken1
      , "timestamp" .= uniswapV3BurnV3DTOTimestamp
      , "owner" .= uniswapV3BurnV3DTOOwner
      , "origin" .= uniswapV3BurnV3DTOOrigin
      , "amount" .= uniswapV3BurnV3DTOAmount
      , "amount_0" .= uniswapV3BurnV3DTOAmount0
      , "amount_1" .= uniswapV3BurnV3DTOAmount1
      , "amount_usd" .= uniswapV3BurnV3DTOAmountUsd
      , "tick_lower" .= uniswapV3BurnV3DTOTickLower
      , "tick_upper" .= uniswapV3BurnV3DTOTickUpper
      , "log_index" .= uniswapV3BurnV3DTOLogIndex
      , "vid" .= uniswapV3BurnV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3BurnV3DTO' (by applying it's required fields, if any)
mkUniswapV3BurnV3DTO
  :: UniswapV3BurnV3DTO
mkUniswapV3BurnV3DTO =
  UniswapV3BurnV3DTO
  { uniswapV3BurnV3DTOEntryTime = Nothing
  , uniswapV3BurnV3DTORecvTime = Nothing
  , uniswapV3BurnV3DTOBlockNumber = Nothing
  , uniswapV3BurnV3DTOId = Nothing
  , uniswapV3BurnV3DTOTransaction = Nothing
  , uniswapV3BurnV3DTOPool = Nothing
  , uniswapV3BurnV3DTOToken0 = Nothing
  , uniswapV3BurnV3DTOToken1 = Nothing
  , uniswapV3BurnV3DTOTimestamp = Nothing
  , uniswapV3BurnV3DTOOwner = Nothing
  , uniswapV3BurnV3DTOOrigin = Nothing
  , uniswapV3BurnV3DTOAmount = Nothing
  , uniswapV3BurnV3DTOAmount0 = Nothing
  , uniswapV3BurnV3DTOAmount1 = Nothing
  , uniswapV3BurnV3DTOAmountUsd = Nothing
  , uniswapV3BurnV3DTOTickLower = Nothing
  , uniswapV3BurnV3DTOTickUpper = Nothing
  , uniswapV3BurnV3DTOLogIndex = Nothing
  , uniswapV3BurnV3DTOVid = Nothing
  }

-- ** UniswapV3FactoryV3DTO
-- | UniswapV3FactoryV3DTO
-- The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
data UniswapV3FactoryV3DTO = UniswapV3FactoryV3DTO
  { uniswapV3FactoryV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3FactoryV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3FactoryV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3FactoryV3DTOId :: !(Maybe Text) -- ^ "id" - Factory address.
  , uniswapV3FactoryV3DTOPoolCount :: !(Maybe Text) -- ^ "pool_count" - Amount of pools created.
  , uniswapV3FactoryV3DTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Amount of transactions all time.
  , uniswapV3FactoryV3DTOTotalVolumeUsd :: !(Maybe Text) -- ^ "total_volume_usd" - Total volume all time in derived USD.
  , uniswapV3FactoryV3DTOTotalVolumeEth :: !(Maybe Text) -- ^ "total_volume_eth" - Total volume all time in derived ETH.
  , uniswapV3FactoryV3DTOTotalFeesUsd :: !(Maybe Text) -- ^ "total_fees_usd" - Total swap fees all time in USD.
  , uniswapV3FactoryV3DTOTotalFeesEth :: !(Maybe Text) -- ^ "total_fees_eth" - All volume even through less reliable USD values.
  , uniswapV3FactoryV3DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - All volume even through less reliable USD values.
  , uniswapV3FactoryV3DTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - Total value locked derived in USD.
  , uniswapV3FactoryV3DTOTotalValueLockedEth :: !(Maybe Text) -- ^ "total_value_locked_eth" - Total value locked derived in ETH.
  , uniswapV3FactoryV3DTOTotalValueLockedUsdUntracked :: !(Maybe Text) -- ^ "total_value_locked_usd_untracked" - Total value locked derived in USD untracked.
  , uniswapV3FactoryV3DTOTotalValueLockedEthUntracked :: !(Maybe Text) -- ^ "total_value_locked_eth_untracked" - Total value locked derived in ETH untracked.
  , uniswapV3FactoryV3DTOOwner :: !(Maybe Text) -- ^ "owner" - Current owner of the factory.
  , uniswapV3FactoryV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3FactoryV3DTO
instance A.FromJSON UniswapV3FactoryV3DTO where
  parseJSON = A.withObject "UniswapV3FactoryV3DTO" $ \o ->
    UniswapV3FactoryV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool_count")
      <*> (o .:? "tx_count")
      <*> (o .:? "total_volume_usd")
      <*> (o .:? "total_volume_eth")
      <*> (o .:? "total_fees_usd")
      <*> (o .:? "total_fees_eth")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "total_value_locked_eth")
      <*> (o .:? "total_value_locked_usd_untracked")
      <*> (o .:? "total_value_locked_eth_untracked")
      <*> (o .:? "owner")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3FactoryV3DTO
instance A.ToJSON UniswapV3FactoryV3DTO where
  toJSON UniswapV3FactoryV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3FactoryV3DTOEntryTime
      , "recv_time" .= uniswapV3FactoryV3DTORecvTime
      , "block_number" .= uniswapV3FactoryV3DTOBlockNumber
      , "id" .= uniswapV3FactoryV3DTOId
      , "pool_count" .= uniswapV3FactoryV3DTOPoolCount
      , "tx_count" .= uniswapV3FactoryV3DTOTxCount
      , "total_volume_usd" .= uniswapV3FactoryV3DTOTotalVolumeUsd
      , "total_volume_eth" .= uniswapV3FactoryV3DTOTotalVolumeEth
      , "total_fees_usd" .= uniswapV3FactoryV3DTOTotalFeesUsd
      , "total_fees_eth" .= uniswapV3FactoryV3DTOTotalFeesEth
      , "untracked_volume_usd" .= uniswapV3FactoryV3DTOUntrackedVolumeUsd
      , "total_value_locked_usd" .= uniswapV3FactoryV3DTOTotalValueLockedUsd
      , "total_value_locked_eth" .= uniswapV3FactoryV3DTOTotalValueLockedEth
      , "total_value_locked_usd_untracked" .= uniswapV3FactoryV3DTOTotalValueLockedUsdUntracked
      , "total_value_locked_eth_untracked" .= uniswapV3FactoryV3DTOTotalValueLockedEthUntracked
      , "owner" .= uniswapV3FactoryV3DTOOwner
      , "vid" .= uniswapV3FactoryV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3FactoryV3DTO' (by applying it's required fields, if any)
mkUniswapV3FactoryV3DTO
  :: UniswapV3FactoryV3DTO
mkUniswapV3FactoryV3DTO =
  UniswapV3FactoryV3DTO
  { uniswapV3FactoryV3DTOEntryTime = Nothing
  , uniswapV3FactoryV3DTORecvTime = Nothing
  , uniswapV3FactoryV3DTOBlockNumber = Nothing
  , uniswapV3FactoryV3DTOId = Nothing
  , uniswapV3FactoryV3DTOPoolCount = Nothing
  , uniswapV3FactoryV3DTOTxCount = Nothing
  , uniswapV3FactoryV3DTOTotalVolumeUsd = Nothing
  , uniswapV3FactoryV3DTOTotalVolumeEth = Nothing
  , uniswapV3FactoryV3DTOTotalFeesUsd = Nothing
  , uniswapV3FactoryV3DTOTotalFeesEth = Nothing
  , uniswapV3FactoryV3DTOUntrackedVolumeUsd = Nothing
  , uniswapV3FactoryV3DTOTotalValueLockedUsd = Nothing
  , uniswapV3FactoryV3DTOTotalValueLockedEth = Nothing
  , uniswapV3FactoryV3DTOTotalValueLockedUsdUntracked = Nothing
  , uniswapV3FactoryV3DTOTotalValueLockedEthUntracked = Nothing
  , uniswapV3FactoryV3DTOOwner = Nothing
  , uniswapV3FactoryV3DTOVid = Nothing
  }

-- ** UniswapV3MintV3DTO
-- | UniswapV3MintV3DTO
-- Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, and more.
data UniswapV3MintV3DTO = UniswapV3MintV3DTO
  { uniswapV3MintV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3MintV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3MintV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3MintV3DTOId :: !(Maybe Text) -- ^ "id" - Transaction hash + &#39;#&#39; + index in mints Transaction array.
  , uniswapV3MintV3DTOTransaction :: !(Maybe Text) -- ^ "transaction" - Which txn the mint was included in.
  , uniswapV3MintV3DTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Time of transaction.
  , uniswapV3MintV3DTOPool :: !(Maybe Text) -- ^ "pool" - Pool address.
  , uniswapV3MintV3DTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pool contract.
  , uniswapV3MintV3DTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pool contract.
  , uniswapV3MintV3DTOOwner :: !(Maybe Text) -- ^ "owner" - Owner of position where liquidity minted to.
  , uniswapV3MintV3DTOSender :: !(Maybe Text) -- ^ "sender" - The address that minted the liquidity.
  , uniswapV3MintV3DTOOrigin :: !(Maybe Text) -- ^ "origin" - Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
  , uniswapV3MintV3DTOAmount :: !(Maybe Text) -- ^ "amount" - Amount of liquidity minted.
  , uniswapV3MintV3DTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token 0 minted.
  , uniswapV3MintV3DTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token 1 minted.
  , uniswapV3MintV3DTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount based on available prices of tokens.
  , uniswapV3MintV3DTOTickLower :: !(Maybe Text) -- ^ "tick_lower" - Lower tick of the position.
  , uniswapV3MintV3DTOTickUpper :: !(Maybe Text) -- ^ "tick_upper" - Upper tick of the position.
  , uniswapV3MintV3DTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Order within the transaction.
  , uniswapV3MintV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3MintV3DTO
instance A.FromJSON UniswapV3MintV3DTO where
  parseJSON = A.withObject "UniswapV3MintV3DTO" $ \o ->
    UniswapV3MintV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "owner")
      <*> (o .:? "sender")
      <*> (o .:? "origin")
      <*> (o .:? "amount")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "amount_usd")
      <*> (o .:? "tick_lower")
      <*> (o .:? "tick_upper")
      <*> (o .:? "log_index")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3MintV3DTO
instance A.ToJSON UniswapV3MintV3DTO where
  toJSON UniswapV3MintV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3MintV3DTOEntryTime
      , "recv_time" .= uniswapV3MintV3DTORecvTime
      , "block_number" .= uniswapV3MintV3DTOBlockNumber
      , "id" .= uniswapV3MintV3DTOId
      , "transaction" .= uniswapV3MintV3DTOTransaction
      , "timestamp" .= uniswapV3MintV3DTOTimestamp
      , "pool" .= uniswapV3MintV3DTOPool
      , "token_0" .= uniswapV3MintV3DTOToken0
      , "token_1" .= uniswapV3MintV3DTOToken1
      , "owner" .= uniswapV3MintV3DTOOwner
      , "sender" .= uniswapV3MintV3DTOSender
      , "origin" .= uniswapV3MintV3DTOOrigin
      , "amount" .= uniswapV3MintV3DTOAmount
      , "amount_0" .= uniswapV3MintV3DTOAmount0
      , "amount_1" .= uniswapV3MintV3DTOAmount1
      , "amount_usd" .= uniswapV3MintV3DTOAmountUsd
      , "tick_lower" .= uniswapV3MintV3DTOTickLower
      , "tick_upper" .= uniswapV3MintV3DTOTickUpper
      , "log_index" .= uniswapV3MintV3DTOLogIndex
      , "vid" .= uniswapV3MintV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3MintV3DTO' (by applying it's required fields, if any)
mkUniswapV3MintV3DTO
  :: UniswapV3MintV3DTO
mkUniswapV3MintV3DTO =
  UniswapV3MintV3DTO
  { uniswapV3MintV3DTOEntryTime = Nothing
  , uniswapV3MintV3DTORecvTime = Nothing
  , uniswapV3MintV3DTOBlockNumber = Nothing
  , uniswapV3MintV3DTOId = Nothing
  , uniswapV3MintV3DTOTransaction = Nothing
  , uniswapV3MintV3DTOTimestamp = Nothing
  , uniswapV3MintV3DTOPool = Nothing
  , uniswapV3MintV3DTOToken0 = Nothing
  , uniswapV3MintV3DTOToken1 = Nothing
  , uniswapV3MintV3DTOOwner = Nothing
  , uniswapV3MintV3DTOSender = Nothing
  , uniswapV3MintV3DTOOrigin = Nothing
  , uniswapV3MintV3DTOAmount = Nothing
  , uniswapV3MintV3DTOAmount0 = Nothing
  , uniswapV3MintV3DTOAmount1 = Nothing
  , uniswapV3MintV3DTOAmountUsd = Nothing
  , uniswapV3MintV3DTOTickLower = Nothing
  , uniswapV3MintV3DTOTickUpper = Nothing
  , uniswapV3MintV3DTOLogIndex = Nothing
  , uniswapV3MintV3DTOVid = Nothing
  }

-- ** UniswapV3PoolDayDataV3DTO
-- | UniswapV3PoolDayDataV3DTO
-- Data accumulated and condensed into day stats for each pool.
data UniswapV3PoolDayDataV3DTO = UniswapV3PoolDayDataV3DTO
  { uniswapV3PoolDayDataV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3PoolDayDataV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3PoolDayDataV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3PoolDayDataV3DTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;pool address&gt;-&lt;day id&gt;.
  , uniswapV3PoolDayDataV3DTODate :: !(Maybe Int) -- ^ "date" - Timestamp rounded to current day by dividing by 86400
  , uniswapV3PoolDayDataV3DTOPool :: !(Maybe Text) -- ^ "pool" - Pointer to pool.
  , uniswapV3PoolDayDataV3DTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - In range liquidity at end of period.
  , uniswapV3PoolDayDataV3DTOSqrtPrice :: !(Maybe Text) -- ^ "sqrt_price" - Current price tracker at end of period.
  , uniswapV3PoolDayDataV3DTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - Price of token0 - derived from sqrtPrice.
  , uniswapV3PoolDayDataV3DTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - Price of token1 - derived from sqrtPrice.
  , uniswapV3PoolDayDataV3DTOTick :: !(Maybe Text) -- ^ "tick" - Current tick at end of period.
  , uniswapV3PoolDayDataV3DTOFeeGrowthGlobal0x128 :: !(Maybe Text) -- ^ "fee_growth_global_0x128" - Tracker for global fee growth.
  , uniswapV3PoolDayDataV3DTOFeeGrowthGlobal1x128 :: !(Maybe Text) -- ^ "fee_growth_global_1x128" - Tracker for global fee growth.
  , uniswapV3PoolDayDataV3DTOTvlUsd :: !(Maybe Text) -- ^ "tvl_usd" - Total value locked derived in USD at end of period.
  , uniswapV3PoolDayDataV3DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Volume in token0.
  , uniswapV3PoolDayDataV3DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Volume in token1.
  , uniswapV3PoolDayDataV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Volume in USD.
  , uniswapV3PoolDayDataV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3PoolDayDataV3DTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Number of transactions during period.
  , uniswapV3PoolDayDataV3DTOOpen :: !(Maybe Text) -- ^ "open" - Opening price of token0.
  , uniswapV3PoolDayDataV3DTOHigh :: !(Maybe Text) -- ^ "high" - High price of token0.
  , uniswapV3PoolDayDataV3DTOLow :: !(Maybe Text) -- ^ "low" - Low price of token0.
  , uniswapV3PoolDayDataV3DTOClose :: !(Maybe Text) -- ^ "close" - Close price of token0.
  , uniswapV3PoolDayDataV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3PoolDayDataV3DTO
instance A.FromJSON UniswapV3PoolDayDataV3DTO where
  parseJSON = A.withObject "UniswapV3PoolDayDataV3DTO" $ \o ->
    UniswapV3PoolDayDataV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pool")
      <*> (o .:? "liquidity")
      <*> (o .:? "sqrt_price")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "tick")
      <*> (o .:? "fee_growth_global_0x128")
      <*> (o .:? "fee_growth_global_1x128")
      <*> (o .:? "tvl_usd")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3PoolDayDataV3DTO
instance A.ToJSON UniswapV3PoolDayDataV3DTO where
  toJSON UniswapV3PoolDayDataV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3PoolDayDataV3DTOEntryTime
      , "recv_time" .= uniswapV3PoolDayDataV3DTORecvTime
      , "block_number" .= uniswapV3PoolDayDataV3DTOBlockNumber
      , "id" .= uniswapV3PoolDayDataV3DTOId
      , "date" .= uniswapV3PoolDayDataV3DTODate
      , "pool" .= uniswapV3PoolDayDataV3DTOPool
      , "liquidity" .= uniswapV3PoolDayDataV3DTOLiquidity
      , "sqrt_price" .= uniswapV3PoolDayDataV3DTOSqrtPrice
      , "token_0_price" .= uniswapV3PoolDayDataV3DTOToken0Price
      , "token_1_price" .= uniswapV3PoolDayDataV3DTOToken1Price
      , "tick" .= uniswapV3PoolDayDataV3DTOTick
      , "fee_growth_global_0x128" .= uniswapV3PoolDayDataV3DTOFeeGrowthGlobal0x128
      , "fee_growth_global_1x128" .= uniswapV3PoolDayDataV3DTOFeeGrowthGlobal1x128
      , "tvl_usd" .= uniswapV3PoolDayDataV3DTOTvlUsd
      , "volume_token_0" .= uniswapV3PoolDayDataV3DTOVolumeToken0
      , "volume_token_1" .= uniswapV3PoolDayDataV3DTOVolumeToken1
      , "volume_usd" .= uniswapV3PoolDayDataV3DTOVolumeUsd
      , "fees_usd" .= uniswapV3PoolDayDataV3DTOFeesUsd
      , "tx_count" .= uniswapV3PoolDayDataV3DTOTxCount
      , "open" .= uniswapV3PoolDayDataV3DTOOpen
      , "high" .= uniswapV3PoolDayDataV3DTOHigh
      , "low" .= uniswapV3PoolDayDataV3DTOLow
      , "close" .= uniswapV3PoolDayDataV3DTOClose
      , "vid" .= uniswapV3PoolDayDataV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3PoolDayDataV3DTO' (by applying it's required fields, if any)
mkUniswapV3PoolDayDataV3DTO
  :: UniswapV3PoolDayDataV3DTO
mkUniswapV3PoolDayDataV3DTO =
  UniswapV3PoolDayDataV3DTO
  { uniswapV3PoolDayDataV3DTOEntryTime = Nothing
  , uniswapV3PoolDayDataV3DTORecvTime = Nothing
  , uniswapV3PoolDayDataV3DTOBlockNumber = Nothing
  , uniswapV3PoolDayDataV3DTOId = Nothing
  , uniswapV3PoolDayDataV3DTODate = Nothing
  , uniswapV3PoolDayDataV3DTOPool = Nothing
  , uniswapV3PoolDayDataV3DTOLiquidity = Nothing
  , uniswapV3PoolDayDataV3DTOSqrtPrice = Nothing
  , uniswapV3PoolDayDataV3DTOToken0Price = Nothing
  , uniswapV3PoolDayDataV3DTOToken1Price = Nothing
  , uniswapV3PoolDayDataV3DTOTick = Nothing
  , uniswapV3PoolDayDataV3DTOFeeGrowthGlobal0x128 = Nothing
  , uniswapV3PoolDayDataV3DTOFeeGrowthGlobal1x128 = Nothing
  , uniswapV3PoolDayDataV3DTOTvlUsd = Nothing
  , uniswapV3PoolDayDataV3DTOVolumeToken0 = Nothing
  , uniswapV3PoolDayDataV3DTOVolumeToken1 = Nothing
  , uniswapV3PoolDayDataV3DTOVolumeUsd = Nothing
  , uniswapV3PoolDayDataV3DTOFeesUsd = Nothing
  , uniswapV3PoolDayDataV3DTOTxCount = Nothing
  , uniswapV3PoolDayDataV3DTOOpen = Nothing
  , uniswapV3PoolDayDataV3DTOHigh = Nothing
  , uniswapV3PoolDayDataV3DTOLow = Nothing
  , uniswapV3PoolDayDataV3DTOClose = Nothing
  , uniswapV3PoolDayDataV3DTOVid = Nothing
  }

-- ** UniswapV3PoolHourDataV3DTO
-- | UniswapV3PoolHourDataV3DTO
-- Hourly stats tracker for pool.
data UniswapV3PoolHourDataV3DTO = UniswapV3PoolHourDataV3DTO
  { uniswapV3PoolHourDataV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3PoolHourDataV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3PoolHourDataV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3PoolHourDataV3DTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;pool address&gt;-&lt;day id&gt;
  , uniswapV3PoolHourDataV3DTOPeriodStartUnix :: !(Maybe Int) -- ^ "period_start_unix" - Unix timestamp for start of hour.
  , uniswapV3PoolHourDataV3DTOPool :: !(Maybe Text) -- ^ "pool" - Pointer to pool.
  , uniswapV3PoolHourDataV3DTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - In range liquidity at end of period.
  , uniswapV3PoolHourDataV3DTOSqrtPrice :: !(Maybe Text) -- ^ "sqrt_price" - Current price tracker at end of period.
  , uniswapV3PoolHourDataV3DTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - Price of token0 - derived from sqrtPrice.
  , uniswapV3PoolHourDataV3DTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - Price of token1 - derived from sqrtPrice.
  , uniswapV3PoolHourDataV3DTOTick :: !(Maybe Text) -- ^ "tick" - Current tick at end of period.
  , uniswapV3PoolHourDataV3DTOFeeGrowthGlobal0x128 :: !(Maybe Text) -- ^ "fee_growth_global_0x128" - Tracker for global fee growth.
  , uniswapV3PoolHourDataV3DTOFeeGrowthGlobal1x128 :: !(Maybe Text) -- ^ "fee_growth_global_1x128" - Tracker for global fee growth.
  , uniswapV3PoolHourDataV3DTOTvlUsd :: !(Maybe Text) -- ^ "tvl_usd" - Total value locked derived in USD at end of period.
  , uniswapV3PoolHourDataV3DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Volume in token0.
  , uniswapV3PoolHourDataV3DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Volume in token1.
  , uniswapV3PoolHourDataV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Volume in USD.
  , uniswapV3PoolHourDataV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3PoolHourDataV3DTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Number of transactions during period.
  , uniswapV3PoolHourDataV3DTOOpen :: !(Maybe Text) -- ^ "open" - Opening price of token0.
  , uniswapV3PoolHourDataV3DTOHigh :: !(Maybe Text) -- ^ "high" - High price of token0.
  , uniswapV3PoolHourDataV3DTOLow :: !(Maybe Text) -- ^ "low" - Low price of token0.
  , uniswapV3PoolHourDataV3DTOClose :: !(Maybe Text) -- ^ "close" - Close price of token0.
  , uniswapV3PoolHourDataV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3PoolHourDataV3DTO
instance A.FromJSON UniswapV3PoolHourDataV3DTO where
  parseJSON = A.withObject "UniswapV3PoolHourDataV3DTO" $ \o ->
    UniswapV3PoolHourDataV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "period_start_unix")
      <*> (o .:? "pool")
      <*> (o .:? "liquidity")
      <*> (o .:? "sqrt_price")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "tick")
      <*> (o .:? "fee_growth_global_0x128")
      <*> (o .:? "fee_growth_global_1x128")
      <*> (o .:? "tvl_usd")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3PoolHourDataV3DTO
instance A.ToJSON UniswapV3PoolHourDataV3DTO where
  toJSON UniswapV3PoolHourDataV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3PoolHourDataV3DTOEntryTime
      , "recv_time" .= uniswapV3PoolHourDataV3DTORecvTime
      , "block_number" .= uniswapV3PoolHourDataV3DTOBlockNumber
      , "id" .= uniswapV3PoolHourDataV3DTOId
      , "period_start_unix" .= uniswapV3PoolHourDataV3DTOPeriodStartUnix
      , "pool" .= uniswapV3PoolHourDataV3DTOPool
      , "liquidity" .= uniswapV3PoolHourDataV3DTOLiquidity
      , "sqrt_price" .= uniswapV3PoolHourDataV3DTOSqrtPrice
      , "token_0_price" .= uniswapV3PoolHourDataV3DTOToken0Price
      , "token_1_price" .= uniswapV3PoolHourDataV3DTOToken1Price
      , "tick" .= uniswapV3PoolHourDataV3DTOTick
      , "fee_growth_global_0x128" .= uniswapV3PoolHourDataV3DTOFeeGrowthGlobal0x128
      , "fee_growth_global_1x128" .= uniswapV3PoolHourDataV3DTOFeeGrowthGlobal1x128
      , "tvl_usd" .= uniswapV3PoolHourDataV3DTOTvlUsd
      , "volume_token_0" .= uniswapV3PoolHourDataV3DTOVolumeToken0
      , "volume_token_1" .= uniswapV3PoolHourDataV3DTOVolumeToken1
      , "volume_usd" .= uniswapV3PoolHourDataV3DTOVolumeUsd
      , "fees_usd" .= uniswapV3PoolHourDataV3DTOFeesUsd
      , "tx_count" .= uniswapV3PoolHourDataV3DTOTxCount
      , "open" .= uniswapV3PoolHourDataV3DTOOpen
      , "high" .= uniswapV3PoolHourDataV3DTOHigh
      , "low" .= uniswapV3PoolHourDataV3DTOLow
      , "close" .= uniswapV3PoolHourDataV3DTOClose
      , "vid" .= uniswapV3PoolHourDataV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3PoolHourDataV3DTO' (by applying it's required fields, if any)
mkUniswapV3PoolHourDataV3DTO
  :: UniswapV3PoolHourDataV3DTO
mkUniswapV3PoolHourDataV3DTO =
  UniswapV3PoolHourDataV3DTO
  { uniswapV3PoolHourDataV3DTOEntryTime = Nothing
  , uniswapV3PoolHourDataV3DTORecvTime = Nothing
  , uniswapV3PoolHourDataV3DTOBlockNumber = Nothing
  , uniswapV3PoolHourDataV3DTOId = Nothing
  , uniswapV3PoolHourDataV3DTOPeriodStartUnix = Nothing
  , uniswapV3PoolHourDataV3DTOPool = Nothing
  , uniswapV3PoolHourDataV3DTOLiquidity = Nothing
  , uniswapV3PoolHourDataV3DTOSqrtPrice = Nothing
  , uniswapV3PoolHourDataV3DTOToken0Price = Nothing
  , uniswapV3PoolHourDataV3DTOToken1Price = Nothing
  , uniswapV3PoolHourDataV3DTOTick = Nothing
  , uniswapV3PoolHourDataV3DTOFeeGrowthGlobal0x128 = Nothing
  , uniswapV3PoolHourDataV3DTOFeeGrowthGlobal1x128 = Nothing
  , uniswapV3PoolHourDataV3DTOTvlUsd = Nothing
  , uniswapV3PoolHourDataV3DTOVolumeToken0 = Nothing
  , uniswapV3PoolHourDataV3DTOVolumeToken1 = Nothing
  , uniswapV3PoolHourDataV3DTOVolumeUsd = Nothing
  , uniswapV3PoolHourDataV3DTOFeesUsd = Nothing
  , uniswapV3PoolHourDataV3DTOTxCount = Nothing
  , uniswapV3PoolHourDataV3DTOOpen = Nothing
  , uniswapV3PoolHourDataV3DTOHigh = Nothing
  , uniswapV3PoolHourDataV3DTOLow = Nothing
  , uniswapV3PoolHourDataV3DTOClose = Nothing
  , uniswapV3PoolHourDataV3DTOVid = Nothing
  }

-- ** UniswapV3PoolV3DTO
-- | UniswapV3PoolV3DTO
-- Information about a pool. Includes references to each token within the pool, volume information, liquidity information, and more. The pool entity mirrors the pool smart contract, and also contains aggregated information about use.
data UniswapV3PoolV3DTO = UniswapV3PoolV3DTO
  { uniswapV3PoolV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3PoolV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3PoolV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3PoolV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3PoolV3DTOId :: !(Maybe Text) -- ^ "id" - Pool address.
  , uniswapV3PoolV3DTOCreatedAtTimestamp :: !(Maybe DateTime) -- ^ "created_at_timestamp" - Creation time.
  , uniswapV3PoolV3DTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pool contract.
  , uniswapV3PoolV3DTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pool contract.
  , uniswapV3PoolV3DTOFeeTier :: !(Maybe NumericsBigInteger) -- ^ "fee_tier"
  , uniswapV3PoolV3DTOLiquidity :: !(Maybe NumericsBigInteger) -- ^ "liquidity"
  , uniswapV3PoolV3DTOSqrtPrice :: !(Maybe NumericsBigInteger) -- ^ "sqrt_price"
  , uniswapV3PoolV3DTOFeeGrowthGlobal0x128 :: !(Maybe NumericsBigInteger) -- ^ "fee_growth_global_0x128"
  , uniswapV3PoolV3DTOFeeGrowthGlobal1x128 :: !(Maybe NumericsBigInteger) -- ^ "fee_growth_global_1x128"
  , uniswapV3PoolV3DTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - Token0 per token1.
  , uniswapV3PoolV3DTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - Token1 per token0.
  , uniswapV3PoolV3DTOTick :: !(Maybe NumericsBigInteger) -- ^ "tick"
  , uniswapV3PoolV3DTOObservationIndex :: !(Maybe NumericsBigInteger) -- ^ "observation_index"
  , uniswapV3PoolV3DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - All time token0 swapped.
  , uniswapV3PoolV3DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - All time token1 swapped.
  , uniswapV3PoolV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - All time USD swapped.
  , uniswapV3PoolV3DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - All time USD swapped, unfiltered for unreliable USD pools.
  , uniswapV3PoolV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3PoolV3DTOTxCount :: !(Maybe NumericsBigInteger) -- ^ "tx_count"
  , uniswapV3PoolV3DTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - All time fees collected token0.
  , uniswapV3PoolV3DTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - All time fees collected token1.
  , uniswapV3PoolV3DTOCollectedFeesUsd :: !(Maybe Text) -- ^ "collected_fees_usd" - All time fees collected derived USD.
  , uniswapV3PoolV3DTOTotalValueLockedToken0 :: !(Maybe Text) -- ^ "total_value_locked_token_0" - Total token 0 across all ticks.
  , uniswapV3PoolV3DTOTotalValueLockedToken1 :: !(Maybe Text) -- ^ "total_value_locked_token_1" - 
  , uniswapV3PoolV3DTOTotalValueLockedEth :: !(Maybe Text) -- ^ "total_value_locked_eth" - Total token 1 across all ticks.
  , uniswapV3PoolV3DTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - Total value locked USD.
  , uniswapV3PoolV3DTOTotalValueLockedUsdUntracked :: !(Maybe Text) -- ^ "total_value_locked_usd_untracked" - Total value locked derived ETH.
  , uniswapV3PoolV3DTOLiquidityProviderCount :: !(Maybe Text) -- ^ "liquidity_provider_count" - Liquidity providers count, used to detect new exchanges.
  , uniswapV3PoolV3DTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3PoolV3DTO
instance A.FromJSON UniswapV3PoolV3DTO where
  parseJSON = A.withObject "UniswapV3PoolV3DTO" $ \o ->
    UniswapV3PoolV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "created_at_timestamp")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "fee_tier")
      <*> (o .:? "liquidity")
      <*> (o .:? "sqrt_price")
      <*> (o .:? "fee_growth_global_0x128")
      <*> (o .:? "fee_growth_global_1x128")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "tick")
      <*> (o .:? "observation_index")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "collected_fees_usd")
      <*> (o .:? "total_value_locked_token_0")
      <*> (o .:? "total_value_locked_token_1")
      <*> (o .:? "total_value_locked_eth")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "total_value_locked_usd_untracked")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "evaluated_ask")

-- | ToJSON UniswapV3PoolV3DTO
instance A.ToJSON UniswapV3PoolV3DTO where
  toJSON UniswapV3PoolV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3PoolV3DTOEntryTime
      , "recv_time" .= uniswapV3PoolV3DTORecvTime
      , "block_number" .= uniswapV3PoolV3DTOBlockNumber
      , "vid" .= uniswapV3PoolV3DTOVid
      , "id" .= uniswapV3PoolV3DTOId
      , "created_at_timestamp" .= uniswapV3PoolV3DTOCreatedAtTimestamp
      , "token_0" .= uniswapV3PoolV3DTOToken0
      , "token_1" .= uniswapV3PoolV3DTOToken1
      , "fee_tier" .= uniswapV3PoolV3DTOFeeTier
      , "liquidity" .= uniswapV3PoolV3DTOLiquidity
      , "sqrt_price" .= uniswapV3PoolV3DTOSqrtPrice
      , "fee_growth_global_0x128" .= uniswapV3PoolV3DTOFeeGrowthGlobal0x128
      , "fee_growth_global_1x128" .= uniswapV3PoolV3DTOFeeGrowthGlobal1x128
      , "token_0_price" .= uniswapV3PoolV3DTOToken0Price
      , "token_1_price" .= uniswapV3PoolV3DTOToken1Price
      , "tick" .= uniswapV3PoolV3DTOTick
      , "observation_index" .= uniswapV3PoolV3DTOObservationIndex
      , "volume_token_0" .= uniswapV3PoolV3DTOVolumeToken0
      , "volume_token_1" .= uniswapV3PoolV3DTOVolumeToken1
      , "volume_usd" .= uniswapV3PoolV3DTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV3PoolV3DTOUntrackedVolumeUsd
      , "fees_usd" .= uniswapV3PoolV3DTOFeesUsd
      , "tx_count" .= uniswapV3PoolV3DTOTxCount
      , "collected_fees_token_0" .= uniswapV3PoolV3DTOCollectedFeesToken0
      , "collected_fees_token_1" .= uniswapV3PoolV3DTOCollectedFeesToken1
      , "collected_fees_usd" .= uniswapV3PoolV3DTOCollectedFeesUsd
      , "total_value_locked_token_0" .= uniswapV3PoolV3DTOTotalValueLockedToken0
      , "total_value_locked_token_1" .= uniswapV3PoolV3DTOTotalValueLockedToken1
      , "total_value_locked_eth" .= uniswapV3PoolV3DTOTotalValueLockedEth
      , "total_value_locked_usd" .= uniswapV3PoolV3DTOTotalValueLockedUsd
      , "total_value_locked_usd_untracked" .= uniswapV3PoolV3DTOTotalValueLockedUsdUntracked
      , "liquidity_provider_count" .= uniswapV3PoolV3DTOLiquidityProviderCount
      , "evaluated_ask" .= uniswapV3PoolV3DTOEvaluatedAsk
      ]


-- | Construct a value of type 'UniswapV3PoolV3DTO' (by applying it's required fields, if any)
mkUniswapV3PoolV3DTO
  :: UniswapV3PoolV3DTO
mkUniswapV3PoolV3DTO =
  UniswapV3PoolV3DTO
  { uniswapV3PoolV3DTOEntryTime = Nothing
  , uniswapV3PoolV3DTORecvTime = Nothing
  , uniswapV3PoolV3DTOBlockNumber = Nothing
  , uniswapV3PoolV3DTOVid = Nothing
  , uniswapV3PoolV3DTOId = Nothing
  , uniswapV3PoolV3DTOCreatedAtTimestamp = Nothing
  , uniswapV3PoolV3DTOToken0 = Nothing
  , uniswapV3PoolV3DTOToken1 = Nothing
  , uniswapV3PoolV3DTOFeeTier = Nothing
  , uniswapV3PoolV3DTOLiquidity = Nothing
  , uniswapV3PoolV3DTOSqrtPrice = Nothing
  , uniswapV3PoolV3DTOFeeGrowthGlobal0x128 = Nothing
  , uniswapV3PoolV3DTOFeeGrowthGlobal1x128 = Nothing
  , uniswapV3PoolV3DTOToken0Price = Nothing
  , uniswapV3PoolV3DTOToken1Price = Nothing
  , uniswapV3PoolV3DTOTick = Nothing
  , uniswapV3PoolV3DTOObservationIndex = Nothing
  , uniswapV3PoolV3DTOVolumeToken0 = Nothing
  , uniswapV3PoolV3DTOVolumeToken1 = Nothing
  , uniswapV3PoolV3DTOVolumeUsd = Nothing
  , uniswapV3PoolV3DTOUntrackedVolumeUsd = Nothing
  , uniswapV3PoolV3DTOFeesUsd = Nothing
  , uniswapV3PoolV3DTOTxCount = Nothing
  , uniswapV3PoolV3DTOCollectedFeesToken0 = Nothing
  , uniswapV3PoolV3DTOCollectedFeesToken1 = Nothing
  , uniswapV3PoolV3DTOCollectedFeesUsd = Nothing
  , uniswapV3PoolV3DTOTotalValueLockedToken0 = Nothing
  , uniswapV3PoolV3DTOTotalValueLockedToken1 = Nothing
  , uniswapV3PoolV3DTOTotalValueLockedEth = Nothing
  , uniswapV3PoolV3DTOTotalValueLockedUsd = Nothing
  , uniswapV3PoolV3DTOTotalValueLockedUsdUntracked = Nothing
  , uniswapV3PoolV3DTOLiquidityProviderCount = Nothing
  , uniswapV3PoolV3DTOEvaluatedAsk = Nothing
  }

-- ** UniswapV3PositionSnapshotV3DTO
-- | UniswapV3PositionSnapshotV3DTO
data UniswapV3PositionSnapshotV3DTO = UniswapV3PositionSnapshotV3DTO
  { uniswapV3PositionSnapshotV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3PositionSnapshotV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3PositionSnapshotV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3PositionSnapshotV3DTOId :: !(Maybe Text) -- ^ "id" - NFT token identifier, format: &lt;NFT token id&gt;#&lt;block number&gt;
  , uniswapV3PositionSnapshotV3DTOOwner :: !(Maybe Text) -- ^ "owner" - Owner of the NFT.
  , uniswapV3PositionSnapshotV3DTOPool :: !(Maybe Text) -- ^ "pool" - Pool the position is within.
  , uniswapV3PositionSnapshotV3DTOPosition :: !(Maybe Text) -- ^ "position" - Position of which the snap was taken of.
  , uniswapV3PositionSnapshotV3DTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of block in which the snap was created.
  , uniswapV3PositionSnapshotV3DTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Total position liquidity.
  , uniswapV3PositionSnapshotV3DTODepositedToken0 :: !(Maybe Text) -- ^ "deposited_token_0" - Amount of token 0 ever deposited to position.
  , uniswapV3PositionSnapshotV3DTODepositedToken1 :: !(Maybe Text) -- ^ "deposited_token_1" - Amount of token 1 ever deposited to position.
  , uniswapV3PositionSnapshotV3DTOWithdrawnToken0 :: !(Maybe Text) -- ^ "withdrawn_token_0" - Amount of token 0 ever withdrawn from position (without fees).
  , uniswapV3PositionSnapshotV3DTOWithdrawnToken1 :: !(Maybe Text) -- ^ "withdrawn_token_1" - Amount of token 1 ever withdrawn from position (without fees).
  , uniswapV3PositionSnapshotV3DTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - All time collected fees in token0.
  , uniswapV3PositionSnapshotV3DTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - All time collected fees in token1.
  , uniswapV3PositionSnapshotV3DTOTransaction :: !(Maybe Text) -- ^ "transaction" - Transaction in which the snapshot was initialized.
  , uniswapV3PositionSnapshotV3DTOFeeGrowthInside0LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_0_last_x128" - Variable needed for fee computation.
  , uniswapV3PositionSnapshotV3DTOFeeGrowthInside1LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_1_last_x128" - Variable needed for fee computation.
  , uniswapV3PositionSnapshotV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3PositionSnapshotV3DTO
instance A.FromJSON UniswapV3PositionSnapshotV3DTO where
  parseJSON = A.withObject "UniswapV3PositionSnapshotV3DTO" $ \o ->
    UniswapV3PositionSnapshotV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "owner")
      <*> (o .:? "pool")
      <*> (o .:? "position")
      <*> (o .:? "timestamp")
      <*> (o .:? "liquidity")
      <*> (o .:? "deposited_token_0")
      <*> (o .:? "deposited_token_1")
      <*> (o .:? "withdrawn_token_0")
      <*> (o .:? "withdrawn_token_1")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "transaction")
      <*> (o .:? "fee_growth_inside_0_last_x128")
      <*> (o .:? "fee_growth_inside_1_last_x128")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3PositionSnapshotV3DTO
instance A.ToJSON UniswapV3PositionSnapshotV3DTO where
  toJSON UniswapV3PositionSnapshotV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3PositionSnapshotV3DTOEntryTime
      , "recv_time" .= uniswapV3PositionSnapshotV3DTORecvTime
      , "block_number" .= uniswapV3PositionSnapshotV3DTOBlockNumber
      , "id" .= uniswapV3PositionSnapshotV3DTOId
      , "owner" .= uniswapV3PositionSnapshotV3DTOOwner
      , "pool" .= uniswapV3PositionSnapshotV3DTOPool
      , "position" .= uniswapV3PositionSnapshotV3DTOPosition
      , "timestamp" .= uniswapV3PositionSnapshotV3DTOTimestamp
      , "liquidity" .= uniswapV3PositionSnapshotV3DTOLiquidity
      , "deposited_token_0" .= uniswapV3PositionSnapshotV3DTODepositedToken0
      , "deposited_token_1" .= uniswapV3PositionSnapshotV3DTODepositedToken1
      , "withdrawn_token_0" .= uniswapV3PositionSnapshotV3DTOWithdrawnToken0
      , "withdrawn_token_1" .= uniswapV3PositionSnapshotV3DTOWithdrawnToken1
      , "collected_fees_token_0" .= uniswapV3PositionSnapshotV3DTOCollectedFeesToken0
      , "collected_fees_token_1" .= uniswapV3PositionSnapshotV3DTOCollectedFeesToken1
      , "transaction" .= uniswapV3PositionSnapshotV3DTOTransaction
      , "fee_growth_inside_0_last_x128" .= uniswapV3PositionSnapshotV3DTOFeeGrowthInside0LastX128
      , "fee_growth_inside_1_last_x128" .= uniswapV3PositionSnapshotV3DTOFeeGrowthInside1LastX128
      , "vid" .= uniswapV3PositionSnapshotV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3PositionSnapshotV3DTO' (by applying it's required fields, if any)
mkUniswapV3PositionSnapshotV3DTO
  :: UniswapV3PositionSnapshotV3DTO
mkUniswapV3PositionSnapshotV3DTO =
  UniswapV3PositionSnapshotV3DTO
  { uniswapV3PositionSnapshotV3DTOEntryTime = Nothing
  , uniswapV3PositionSnapshotV3DTORecvTime = Nothing
  , uniswapV3PositionSnapshotV3DTOBlockNumber = Nothing
  , uniswapV3PositionSnapshotV3DTOId = Nothing
  , uniswapV3PositionSnapshotV3DTOOwner = Nothing
  , uniswapV3PositionSnapshotV3DTOPool = Nothing
  , uniswapV3PositionSnapshotV3DTOPosition = Nothing
  , uniswapV3PositionSnapshotV3DTOTimestamp = Nothing
  , uniswapV3PositionSnapshotV3DTOLiquidity = Nothing
  , uniswapV3PositionSnapshotV3DTODepositedToken0 = Nothing
  , uniswapV3PositionSnapshotV3DTODepositedToken1 = Nothing
  , uniswapV3PositionSnapshotV3DTOWithdrawnToken0 = Nothing
  , uniswapV3PositionSnapshotV3DTOWithdrawnToken1 = Nothing
  , uniswapV3PositionSnapshotV3DTOCollectedFeesToken0 = Nothing
  , uniswapV3PositionSnapshotV3DTOCollectedFeesToken1 = Nothing
  , uniswapV3PositionSnapshotV3DTOTransaction = Nothing
  , uniswapV3PositionSnapshotV3DTOFeeGrowthInside0LastX128 = Nothing
  , uniswapV3PositionSnapshotV3DTOFeeGrowthInside1LastX128 = Nothing
  , uniswapV3PositionSnapshotV3DTOVid = Nothing
  }

-- ** UniswapV3PositionV3DTO
-- | UniswapV3PositionV3DTO
-- Positions created through NonfungiblePositionManager. Positions are represented as NFTs (ERC-721 tokens) as opposed to the fungible ERC-20 tokens on Uniswap V1 and V2.
data UniswapV3PositionV3DTO = UniswapV3PositionV3DTO
  { uniswapV3PositionV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3PositionV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3PositionV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3PositionV3DTOId :: !(Maybe Text) -- ^ "id" - NFT token identifier.
  , uniswapV3PositionV3DTOOwner :: !(Maybe Text) -- ^ "owner" - Owner of the NFT.
  , uniswapV3PositionV3DTOPool :: !(Maybe Text) -- ^ "pool" - Pool position is within.
  , uniswapV3PositionV3DTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pair contract.
  , uniswapV3PositionV3DTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pair contract.
  , uniswapV3PositionV3DTOTickLower :: !(Maybe Text) -- ^ "tick_lower" - Lower tick of the position.
  , uniswapV3PositionV3DTOTickUpper :: !(Maybe Text) -- ^ "tick_upper" - Upper tick of the position.
  , uniswapV3PositionV3DTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Total position liquidity.
  , uniswapV3PositionV3DTODepositedToken0 :: !(Maybe Text) -- ^ "deposited_token_0" - Amount of token 0 ever deposited to position.
  , uniswapV3PositionV3DTODepositedToken1 :: !(Maybe Text) -- ^ "deposited_token_1" - Amount of token 1 ever deposited to position.
  , uniswapV3PositionV3DTOWithdrawnToken0 :: !(Maybe Text) -- ^ "withdrawn_token_0" - Amount of token 0 ever withdrawn from position (without fees).
  , uniswapV3PositionV3DTOWithdrawnToken1 :: !(Maybe Text) -- ^ "withdrawn_token_1" - Amount of token 1 ever withdrawn from position (without fees).
  , uniswapV3PositionV3DTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - All time collected fees in token0.
  , uniswapV3PositionV3DTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - All time collected fees in token1.
  , uniswapV3PositionV3DTOTransaction :: !(Maybe Text) -- ^ "transaction" - Transaction in which the position was initialized.
  , uniswapV3PositionV3DTOFeeGrowthInside0LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_0_last_x128" - Variable needed for fee computation.
  , uniswapV3PositionV3DTOFeeGrowthInside1LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_1_last_x128" - Variable needed for fee computation.
  , uniswapV3PositionV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3PositionV3DTO
instance A.FromJSON UniswapV3PositionV3DTO where
  parseJSON = A.withObject "UniswapV3PositionV3DTO" $ \o ->
    UniswapV3PositionV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "owner")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "tick_lower")
      <*> (o .:? "tick_upper")
      <*> (o .:? "liquidity")
      <*> (o .:? "deposited_token_0")
      <*> (o .:? "deposited_token_1")
      <*> (o .:? "withdrawn_token_0")
      <*> (o .:? "withdrawn_token_1")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "transaction")
      <*> (o .:? "fee_growth_inside_0_last_x128")
      <*> (o .:? "fee_growth_inside_1_last_x128")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3PositionV3DTO
instance A.ToJSON UniswapV3PositionV3DTO where
  toJSON UniswapV3PositionV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3PositionV3DTOEntryTime
      , "recv_time" .= uniswapV3PositionV3DTORecvTime
      , "block_number" .= uniswapV3PositionV3DTOBlockNumber
      , "id" .= uniswapV3PositionV3DTOId
      , "owner" .= uniswapV3PositionV3DTOOwner
      , "pool" .= uniswapV3PositionV3DTOPool
      , "token_0" .= uniswapV3PositionV3DTOToken0
      , "token_1" .= uniswapV3PositionV3DTOToken1
      , "tick_lower" .= uniswapV3PositionV3DTOTickLower
      , "tick_upper" .= uniswapV3PositionV3DTOTickUpper
      , "liquidity" .= uniswapV3PositionV3DTOLiquidity
      , "deposited_token_0" .= uniswapV3PositionV3DTODepositedToken0
      , "deposited_token_1" .= uniswapV3PositionV3DTODepositedToken1
      , "withdrawn_token_0" .= uniswapV3PositionV3DTOWithdrawnToken0
      , "withdrawn_token_1" .= uniswapV3PositionV3DTOWithdrawnToken1
      , "collected_fees_token_0" .= uniswapV3PositionV3DTOCollectedFeesToken0
      , "collected_fees_token_1" .= uniswapV3PositionV3DTOCollectedFeesToken1
      , "transaction" .= uniswapV3PositionV3DTOTransaction
      , "fee_growth_inside_0_last_x128" .= uniswapV3PositionV3DTOFeeGrowthInside0LastX128
      , "fee_growth_inside_1_last_x128" .= uniswapV3PositionV3DTOFeeGrowthInside1LastX128
      , "vid" .= uniswapV3PositionV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3PositionV3DTO' (by applying it's required fields, if any)
mkUniswapV3PositionV3DTO
  :: UniswapV3PositionV3DTO
mkUniswapV3PositionV3DTO =
  UniswapV3PositionV3DTO
  { uniswapV3PositionV3DTOEntryTime = Nothing
  , uniswapV3PositionV3DTORecvTime = Nothing
  , uniswapV3PositionV3DTOBlockNumber = Nothing
  , uniswapV3PositionV3DTOId = Nothing
  , uniswapV3PositionV3DTOOwner = Nothing
  , uniswapV3PositionV3DTOPool = Nothing
  , uniswapV3PositionV3DTOToken0 = Nothing
  , uniswapV3PositionV3DTOToken1 = Nothing
  , uniswapV3PositionV3DTOTickLower = Nothing
  , uniswapV3PositionV3DTOTickUpper = Nothing
  , uniswapV3PositionV3DTOLiquidity = Nothing
  , uniswapV3PositionV3DTODepositedToken0 = Nothing
  , uniswapV3PositionV3DTODepositedToken1 = Nothing
  , uniswapV3PositionV3DTOWithdrawnToken0 = Nothing
  , uniswapV3PositionV3DTOWithdrawnToken1 = Nothing
  , uniswapV3PositionV3DTOCollectedFeesToken0 = Nothing
  , uniswapV3PositionV3DTOCollectedFeesToken1 = Nothing
  , uniswapV3PositionV3DTOTransaction = Nothing
  , uniswapV3PositionV3DTOFeeGrowthInside0LastX128 = Nothing
  , uniswapV3PositionV3DTOFeeGrowthInside1LastX128 = Nothing
  , uniswapV3PositionV3DTOVid = Nothing
  }

-- ** UniswapV3SwapV3DTO
-- | UniswapV3SwapV3DTO
-- Swap are created for each token swap within a pair.
data UniswapV3SwapV3DTO = UniswapV3SwapV3DTO
  { uniswapV3SwapV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3SwapV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3SwapV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3SwapV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3SwapV3DTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: transaction hash + \&quot;#\&quot; + index in swaps Transaction array.
  , uniswapV3SwapV3DTOTransaction :: !(Maybe Text) -- ^ "transaction" - Pointer to transaction.
  , uniswapV3SwapV3DTOTimestamp :: !(Maybe DateTime) -- ^ "timestamp" - Timestamp of transaction.
  , uniswapV3SwapV3DTOPool :: !(Maybe Text) -- ^ "pool" - Pool swap occured within.
  , uniswapV3SwapV3DTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pair contract.
  , uniswapV3SwapV3DTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pair contract.
  , uniswapV3SwapV3DTOSender :: !(Maybe Text) -- ^ "sender" - Sender of the swap.
  , uniswapV3SwapV3DTORecipient :: !(Maybe Text) -- ^ "recipient" - Recipient of the swap.
  , uniswapV3SwapV3DTOOrigin :: !(Maybe Text) -- ^ "origin" - Transaction origin: the EOA (Externally Owned Account) that initiated the transaction
  , uniswapV3SwapV3DTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Delta of token0 swapped.
  , uniswapV3SwapV3DTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Delta of token1 swapped.
  , uniswapV3SwapV3DTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount of tokens sold in USD.
  , uniswapV3SwapV3DTOSqrtPriceX96 :: !(Maybe NumericsBigInteger) -- ^ "sqrt_price_x96"
  , uniswapV3SwapV3DTOTick :: !(Maybe NumericsBigInteger) -- ^ "tick"
  , uniswapV3SwapV3DTOLogIndex :: !(Maybe NumericsBigInteger) -- ^ "log_index"
  , uniswapV3SwapV3DTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , uniswapV3SwapV3DTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , uniswapV3SwapV3DTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  , uniswapV3SwapV3DTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , uniswapV3SwapV3DTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3SwapV3DTO
instance A.FromJSON UniswapV3SwapV3DTO where
  parseJSON = A.withObject "UniswapV3SwapV3DTO" $ \o ->
    UniswapV3SwapV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "sender")
      <*> (o .:? "recipient")
      <*> (o .:? "origin")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "amount_usd")
      <*> (o .:? "sqrt_price_x96")
      <*> (o .:? "tick")
      <*> (o .:? "log_index")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")

-- | ToJSON UniswapV3SwapV3DTO
instance A.ToJSON UniswapV3SwapV3DTO where
  toJSON UniswapV3SwapV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3SwapV3DTOEntryTime
      , "recv_time" .= uniswapV3SwapV3DTORecvTime
      , "block_number" .= uniswapV3SwapV3DTOBlockNumber
      , "vid" .= uniswapV3SwapV3DTOVid
      , "id" .= uniswapV3SwapV3DTOId
      , "transaction" .= uniswapV3SwapV3DTOTransaction
      , "timestamp" .= uniswapV3SwapV3DTOTimestamp
      , "pool" .= uniswapV3SwapV3DTOPool
      , "token_0" .= uniswapV3SwapV3DTOToken0
      , "token_1" .= uniswapV3SwapV3DTOToken1
      , "sender" .= uniswapV3SwapV3DTOSender
      , "recipient" .= uniswapV3SwapV3DTORecipient
      , "origin" .= uniswapV3SwapV3DTOOrigin
      , "amount_0" .= uniswapV3SwapV3DTOAmount0
      , "amount_1" .= uniswapV3SwapV3DTOAmount1
      , "amount_usd" .= uniswapV3SwapV3DTOAmountUsd
      , "sqrt_price_x96" .= uniswapV3SwapV3DTOSqrtPriceX96
      , "tick" .= uniswapV3SwapV3DTOTick
      , "log_index" .= uniswapV3SwapV3DTOLogIndex
      , "evaluated_price" .= uniswapV3SwapV3DTOEvaluatedPrice
      , "evaluated_amount" .= uniswapV3SwapV3DTOEvaluatedAmount
      , "evaluated_aggressor" .= uniswapV3SwapV3DTOEvaluatedAggressor
      , "pool_id" .= uniswapV3SwapV3DTOPoolId
      , "transaction_id" .= uniswapV3SwapV3DTOTransactionId
      ]


-- | Construct a value of type 'UniswapV3SwapV3DTO' (by applying it's required fields, if any)
mkUniswapV3SwapV3DTO
  :: UniswapV3SwapV3DTO
mkUniswapV3SwapV3DTO =
  UniswapV3SwapV3DTO
  { uniswapV3SwapV3DTOEntryTime = Nothing
  , uniswapV3SwapV3DTORecvTime = Nothing
  , uniswapV3SwapV3DTOBlockNumber = Nothing
  , uniswapV3SwapV3DTOVid = Nothing
  , uniswapV3SwapV3DTOId = Nothing
  , uniswapV3SwapV3DTOTransaction = Nothing
  , uniswapV3SwapV3DTOTimestamp = Nothing
  , uniswapV3SwapV3DTOPool = Nothing
  , uniswapV3SwapV3DTOToken0 = Nothing
  , uniswapV3SwapV3DTOToken1 = Nothing
  , uniswapV3SwapV3DTOSender = Nothing
  , uniswapV3SwapV3DTORecipient = Nothing
  , uniswapV3SwapV3DTOOrigin = Nothing
  , uniswapV3SwapV3DTOAmount0 = Nothing
  , uniswapV3SwapV3DTOAmount1 = Nothing
  , uniswapV3SwapV3DTOAmountUsd = Nothing
  , uniswapV3SwapV3DTOSqrtPriceX96 = Nothing
  , uniswapV3SwapV3DTOTick = Nothing
  , uniswapV3SwapV3DTOLogIndex = Nothing
  , uniswapV3SwapV3DTOEvaluatedPrice = Nothing
  , uniswapV3SwapV3DTOEvaluatedAmount = Nothing
  , uniswapV3SwapV3DTOEvaluatedAggressor = Nothing
  , uniswapV3SwapV3DTOPoolId = Nothing
  , uniswapV3SwapV3DTOTransactionId = Nothing
  }

-- ** UniswapV3TickDayDataV3DTO
-- | UniswapV3TickDayDataV3DTO
-- Data accumulated and condensed into day stats for each exchange. Entity gets saved only if there is a change during the day
data UniswapV3TickDayDataV3DTO = UniswapV3TickDayDataV3DTO
  { uniswapV3TickDayDataV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TickDayDataV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TickDayDataV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TickDayDataV3DTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;pool address&gt;-&lt;tick index&gt;-&lt;timestamp&gt;.
  , uniswapV3TickDayDataV3DTODate :: !(Maybe Int) -- ^ "date" - Timestamp rounded to current day by dividing by 86400.
  , uniswapV3TickDayDataV3DTOPool :: !(Maybe Text) -- ^ "pool" - Pointer to pool.
  , uniswapV3TickDayDataV3DTOTick :: !(Maybe Text) -- ^ "tick" - Pointer to tick.
  , uniswapV3TickDayDataV3DTOLiquidityGross :: !(Maybe Text) -- ^ "liquidity_gross" - Total liquidity pool has as tick lower or upper at end of period.
  , uniswapV3TickDayDataV3DTOLiquidityNet :: !(Maybe Text) -- ^ "liquidity_net" - How much liquidity changes when tick crossed at end of period.
  , uniswapV3TickDayDataV3DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Hourly volume of token0 with this tick in range.
  , uniswapV3TickDayDataV3DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Hourly volume of token1 with this tick in range.
  , uniswapV3TickDayDataV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Hourly volume in derived USD with this tick in range.
  , uniswapV3TickDayDataV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3TickDayDataV3DTOFeeGrowthOutside0x128 :: !(Maybe Text) -- ^ "fee_growth_outside_0x128" - Variable needed for fee computation.
  , uniswapV3TickDayDataV3DTOFeeGrowthOutside1x128 :: !(Maybe Text) -- ^ "fee_growth_outside_1x128" - Variable needed for fee computation.
  , uniswapV3TickDayDataV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TickDayDataV3DTO
instance A.FromJSON UniswapV3TickDayDataV3DTO where
  parseJSON = A.withObject "UniswapV3TickDayDataV3DTO" $ \o ->
    UniswapV3TickDayDataV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pool")
      <*> (o .:? "tick")
      <*> (o .:? "liquidity_gross")
      <*> (o .:? "liquidity_net")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "fee_growth_outside_0x128")
      <*> (o .:? "fee_growth_outside_1x128")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3TickDayDataV3DTO
instance A.ToJSON UniswapV3TickDayDataV3DTO where
  toJSON UniswapV3TickDayDataV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TickDayDataV3DTOEntryTime
      , "recv_time" .= uniswapV3TickDayDataV3DTORecvTime
      , "block_number" .= uniswapV3TickDayDataV3DTOBlockNumber
      , "id" .= uniswapV3TickDayDataV3DTOId
      , "date" .= uniswapV3TickDayDataV3DTODate
      , "pool" .= uniswapV3TickDayDataV3DTOPool
      , "tick" .= uniswapV3TickDayDataV3DTOTick
      , "liquidity_gross" .= uniswapV3TickDayDataV3DTOLiquidityGross
      , "liquidity_net" .= uniswapV3TickDayDataV3DTOLiquidityNet
      , "volume_token_0" .= uniswapV3TickDayDataV3DTOVolumeToken0
      , "volume_token_1" .= uniswapV3TickDayDataV3DTOVolumeToken1
      , "volume_usd" .= uniswapV3TickDayDataV3DTOVolumeUsd
      , "fees_usd" .= uniswapV3TickDayDataV3DTOFeesUsd
      , "fee_growth_outside_0x128" .= uniswapV3TickDayDataV3DTOFeeGrowthOutside0x128
      , "fee_growth_outside_1x128" .= uniswapV3TickDayDataV3DTOFeeGrowthOutside1x128
      , "vid" .= uniswapV3TickDayDataV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3TickDayDataV3DTO' (by applying it's required fields, if any)
mkUniswapV3TickDayDataV3DTO
  :: UniswapV3TickDayDataV3DTO
mkUniswapV3TickDayDataV3DTO =
  UniswapV3TickDayDataV3DTO
  { uniswapV3TickDayDataV3DTOEntryTime = Nothing
  , uniswapV3TickDayDataV3DTORecvTime = Nothing
  , uniswapV3TickDayDataV3DTOBlockNumber = Nothing
  , uniswapV3TickDayDataV3DTOId = Nothing
  , uniswapV3TickDayDataV3DTODate = Nothing
  , uniswapV3TickDayDataV3DTOPool = Nothing
  , uniswapV3TickDayDataV3DTOTick = Nothing
  , uniswapV3TickDayDataV3DTOLiquidityGross = Nothing
  , uniswapV3TickDayDataV3DTOLiquidityNet = Nothing
  , uniswapV3TickDayDataV3DTOVolumeToken0 = Nothing
  , uniswapV3TickDayDataV3DTOVolumeToken1 = Nothing
  , uniswapV3TickDayDataV3DTOVolumeUsd = Nothing
  , uniswapV3TickDayDataV3DTOFeesUsd = Nothing
  , uniswapV3TickDayDataV3DTOFeeGrowthOutside0x128 = Nothing
  , uniswapV3TickDayDataV3DTOFeeGrowthOutside1x128 = Nothing
  , uniswapV3TickDayDataV3DTOVid = Nothing
  }

-- ** UniswapV3TickV3DTO
-- | UniswapV3TickV3DTO
-- Ticks are the boundaries between discrete areas in price space.
data UniswapV3TickV3DTO = UniswapV3TickV3DTO
  { uniswapV3TickV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TickV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TickV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TickV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3TickV3DTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: &lt;pool address&gt;#&lt;tick index&gt;
  , uniswapV3TickV3DTOPoolAddress :: !(Maybe Text) -- ^ "pool_address" - Pool address.
  , uniswapV3TickV3DTOTickIdx :: !(Maybe NumericsBigInteger) -- ^ "tick_idx"
  , uniswapV3TickV3DTOPool :: !(Maybe Text) -- ^ "pool" - Pool address.
  , uniswapV3TickV3DTOLiquidityGross :: !(Maybe NumericsBigInteger) -- ^ "liquidity_gross"
  , uniswapV3TickV3DTOLiquidityNet :: !(Maybe NumericsBigInteger) -- ^ "liquidity_net"
  , uniswapV3TickV3DTOPrice0 :: !(Maybe Text) -- ^ "price_0" - Calculated price of token0 of tick within this pool - constant.
  , uniswapV3TickV3DTOPrice1 :: !(Maybe Text) -- ^ "price_1" - Calculated price of token1 of tick within this pool - constant.
  , uniswapV3TickV3DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Lifetime volume of token0 with this tick in range.
  , uniswapV3TickV3DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Lifetime volume of token1 with this tick in range.
  , uniswapV3TickV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Lifetime volume in derived USD with this tick in range.
  , uniswapV3TickV3DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Lifetime volume in untracked USD with this tick in range.
  , uniswapV3TickV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3TickV3DTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - All time collected fees in token0.
  , uniswapV3TickV3DTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - All time collected fees in token1.
  , uniswapV3TickV3DTOCollectedFeesUsd :: !(Maybe Text) -- ^ "collected_fees_usd" - All time collected fees in USD.
  , uniswapV3TickV3DTOCreatedAtTimestamp :: !(Maybe DateTime) -- ^ "created_at_timestamp" - Created time.
  , uniswapV3TickV3DTOLiquidityProviderCount :: !(Maybe NumericsBigInteger) -- ^ "liquidity_provider_count"
  , uniswapV3TickV3DTOFeeGrowthOutside0x128 :: !(Maybe NumericsBigInteger) -- ^ "fee_growth_outside_0x128"
  , uniswapV3TickV3DTOFeeGrowthOutside1x128 :: !(Maybe NumericsBigInteger) -- ^ "fee_growth_outside_1x128"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TickV3DTO
instance A.FromJSON UniswapV3TickV3DTO where
  parseJSON = A.withObject "UniswapV3TickV3DTO" $ \o ->
    UniswapV3TickV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "pool_address")
      <*> (o .:? "tick_idx")
      <*> (o .:? "pool")
      <*> (o .:? "liquidity_gross")
      <*> (o .:? "liquidity_net")
      <*> (o .:? "price_0")
      <*> (o .:? "price_1")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "collected_fees_usd")
      <*> (o .:? "created_at_timestamp")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "fee_growth_outside_0x128")
      <*> (o .:? "fee_growth_outside_1x128")

-- | ToJSON UniswapV3TickV3DTO
instance A.ToJSON UniswapV3TickV3DTO where
  toJSON UniswapV3TickV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TickV3DTOEntryTime
      , "recv_time" .= uniswapV3TickV3DTORecvTime
      , "block_number" .= uniswapV3TickV3DTOBlockNumber
      , "vid" .= uniswapV3TickV3DTOVid
      , "id" .= uniswapV3TickV3DTOId
      , "pool_address" .= uniswapV3TickV3DTOPoolAddress
      , "tick_idx" .= uniswapV3TickV3DTOTickIdx
      , "pool" .= uniswapV3TickV3DTOPool
      , "liquidity_gross" .= uniswapV3TickV3DTOLiquidityGross
      , "liquidity_net" .= uniswapV3TickV3DTOLiquidityNet
      , "price_0" .= uniswapV3TickV3DTOPrice0
      , "price_1" .= uniswapV3TickV3DTOPrice1
      , "volume_token_0" .= uniswapV3TickV3DTOVolumeToken0
      , "volume_token_1" .= uniswapV3TickV3DTOVolumeToken1
      , "volume_usd" .= uniswapV3TickV3DTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV3TickV3DTOUntrackedVolumeUsd
      , "fees_usd" .= uniswapV3TickV3DTOFeesUsd
      , "collected_fees_token_0" .= uniswapV3TickV3DTOCollectedFeesToken0
      , "collected_fees_token_1" .= uniswapV3TickV3DTOCollectedFeesToken1
      , "collected_fees_usd" .= uniswapV3TickV3DTOCollectedFeesUsd
      , "created_at_timestamp" .= uniswapV3TickV3DTOCreatedAtTimestamp
      , "liquidity_provider_count" .= uniswapV3TickV3DTOLiquidityProviderCount
      , "fee_growth_outside_0x128" .= uniswapV3TickV3DTOFeeGrowthOutside0x128
      , "fee_growth_outside_1x128" .= uniswapV3TickV3DTOFeeGrowthOutside1x128
      ]


-- | Construct a value of type 'UniswapV3TickV3DTO' (by applying it's required fields, if any)
mkUniswapV3TickV3DTO
  :: UniswapV3TickV3DTO
mkUniswapV3TickV3DTO =
  UniswapV3TickV3DTO
  { uniswapV3TickV3DTOEntryTime = Nothing
  , uniswapV3TickV3DTORecvTime = Nothing
  , uniswapV3TickV3DTOBlockNumber = Nothing
  , uniswapV3TickV3DTOVid = Nothing
  , uniswapV3TickV3DTOId = Nothing
  , uniswapV3TickV3DTOPoolAddress = Nothing
  , uniswapV3TickV3DTOTickIdx = Nothing
  , uniswapV3TickV3DTOPool = Nothing
  , uniswapV3TickV3DTOLiquidityGross = Nothing
  , uniswapV3TickV3DTOLiquidityNet = Nothing
  , uniswapV3TickV3DTOPrice0 = Nothing
  , uniswapV3TickV3DTOPrice1 = Nothing
  , uniswapV3TickV3DTOVolumeToken0 = Nothing
  , uniswapV3TickV3DTOVolumeToken1 = Nothing
  , uniswapV3TickV3DTOVolumeUsd = Nothing
  , uniswapV3TickV3DTOUntrackedVolumeUsd = Nothing
  , uniswapV3TickV3DTOFeesUsd = Nothing
  , uniswapV3TickV3DTOCollectedFeesToken0 = Nothing
  , uniswapV3TickV3DTOCollectedFeesToken1 = Nothing
  , uniswapV3TickV3DTOCollectedFeesUsd = Nothing
  , uniswapV3TickV3DTOCreatedAtTimestamp = Nothing
  , uniswapV3TickV3DTOLiquidityProviderCount = Nothing
  , uniswapV3TickV3DTOFeeGrowthOutside0x128 = Nothing
  , uniswapV3TickV3DTOFeeGrowthOutside1x128 = Nothing
  }

-- ** UniswapV3TokenHourDataV3DTO
-- | UniswapV3TokenHourDataV3DTO
-- Token data aggregated across all pairs that include token.
data UniswapV3TokenHourDataV3DTO = UniswapV3TokenHourDataV3DTO
  { uniswapV3TokenHourDataV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TokenHourDataV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TokenHourDataV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TokenHourDataV3DTOId :: !(Maybe Text) -- ^ "id" - Token address concatendated with date.
  , uniswapV3TokenHourDataV3DTOPeriodStartUnix :: !(Maybe Int) -- ^ "period_start_unix" - Unix timestamp for start of hour.
  , uniswapV3TokenHourDataV3DTOToken :: !(Maybe Text) -- ^ "token" - Pointer to token.
  , uniswapV3TokenHourDataV3DTOVolume :: !(Maybe Text) -- ^ "volume" - Volume in token units.
  , uniswapV3TokenHourDataV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Volume in derived USD.
  , uniswapV3TokenHourDataV3DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Volume in USD even on pools with less reliable USD values.
  , uniswapV3TokenHourDataV3DTOTotalValueLocked :: !(Maybe Text) -- ^ "total_value_locked" - Liquidity across all pools in token units.
  , uniswapV3TokenHourDataV3DTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - Liquidity across all pools in derived USD.
  , uniswapV3TokenHourDataV3DTOPriceUsd :: !(Maybe Text) -- ^ "price_usd" - Price at end of period in USD.
  , uniswapV3TokenHourDataV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3TokenHourDataV3DTOOpen :: !(Maybe Text) -- ^ "open" - Opening price USD.
  , uniswapV3TokenHourDataV3DTOHigh :: !(Maybe Text) -- ^ "high" - High price USD.
  , uniswapV3TokenHourDataV3DTOLow :: !(Maybe Text) -- ^ "low" - Low price USD.
  , uniswapV3TokenHourDataV3DTOClose :: !(Maybe Text) -- ^ "close" - Close price USD.
  , uniswapV3TokenHourDataV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TokenHourDataV3DTO
instance A.FromJSON UniswapV3TokenHourDataV3DTO where
  parseJSON = A.withObject "UniswapV3TokenHourDataV3DTO" $ \o ->
    UniswapV3TokenHourDataV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "period_start_unix")
      <*> (o .:? "token")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_value_locked")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3TokenHourDataV3DTO
instance A.ToJSON UniswapV3TokenHourDataV3DTO where
  toJSON UniswapV3TokenHourDataV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TokenHourDataV3DTOEntryTime
      , "recv_time" .= uniswapV3TokenHourDataV3DTORecvTime
      , "block_number" .= uniswapV3TokenHourDataV3DTOBlockNumber
      , "id" .= uniswapV3TokenHourDataV3DTOId
      , "period_start_unix" .= uniswapV3TokenHourDataV3DTOPeriodStartUnix
      , "token" .= uniswapV3TokenHourDataV3DTOToken
      , "volume" .= uniswapV3TokenHourDataV3DTOVolume
      , "volume_usd" .= uniswapV3TokenHourDataV3DTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV3TokenHourDataV3DTOUntrackedVolumeUsd
      , "total_value_locked" .= uniswapV3TokenHourDataV3DTOTotalValueLocked
      , "total_value_locked_usd" .= uniswapV3TokenHourDataV3DTOTotalValueLockedUsd
      , "price_usd" .= uniswapV3TokenHourDataV3DTOPriceUsd
      , "fees_usd" .= uniswapV3TokenHourDataV3DTOFeesUsd
      , "open" .= uniswapV3TokenHourDataV3DTOOpen
      , "high" .= uniswapV3TokenHourDataV3DTOHigh
      , "low" .= uniswapV3TokenHourDataV3DTOLow
      , "close" .= uniswapV3TokenHourDataV3DTOClose
      , "vid" .= uniswapV3TokenHourDataV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3TokenHourDataV3DTO' (by applying it's required fields, if any)
mkUniswapV3TokenHourDataV3DTO
  :: UniswapV3TokenHourDataV3DTO
mkUniswapV3TokenHourDataV3DTO =
  UniswapV3TokenHourDataV3DTO
  { uniswapV3TokenHourDataV3DTOEntryTime = Nothing
  , uniswapV3TokenHourDataV3DTORecvTime = Nothing
  , uniswapV3TokenHourDataV3DTOBlockNumber = Nothing
  , uniswapV3TokenHourDataV3DTOId = Nothing
  , uniswapV3TokenHourDataV3DTOPeriodStartUnix = Nothing
  , uniswapV3TokenHourDataV3DTOToken = Nothing
  , uniswapV3TokenHourDataV3DTOVolume = Nothing
  , uniswapV3TokenHourDataV3DTOVolumeUsd = Nothing
  , uniswapV3TokenHourDataV3DTOUntrackedVolumeUsd = Nothing
  , uniswapV3TokenHourDataV3DTOTotalValueLocked = Nothing
  , uniswapV3TokenHourDataV3DTOTotalValueLockedUsd = Nothing
  , uniswapV3TokenHourDataV3DTOPriceUsd = Nothing
  , uniswapV3TokenHourDataV3DTOFeesUsd = Nothing
  , uniswapV3TokenHourDataV3DTOOpen = Nothing
  , uniswapV3TokenHourDataV3DTOHigh = Nothing
  , uniswapV3TokenHourDataV3DTOLow = Nothing
  , uniswapV3TokenHourDataV3DTOClose = Nothing
  , uniswapV3TokenHourDataV3DTOVid = Nothing
  }

-- ** UniswapV3TokenV3DTO
-- | UniswapV3TokenV3DTO
-- Stores aggregated information for a specific token across all pairs that token is included in.
data UniswapV3TokenV3DTO = UniswapV3TokenV3DTO
  { uniswapV3TokenV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TokenV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TokenV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TokenV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3TokenV3DTOId :: !(Maybe Text) -- ^ "id" - Token address.
  , uniswapV3TokenV3DTOSymbol :: !(Maybe Text) -- ^ "symbol" - Token symbol.
  , uniswapV3TokenV3DTOName :: !(Maybe Text) -- ^ "name" - Token name.
  , uniswapV3TokenV3DTODecimals :: !(Maybe Int) -- ^ "decimals" - Token decimals.
  , uniswapV3TokenV3DTOTotalSupply :: !(Maybe NumericsBigInteger) -- ^ "total_supply"
  , uniswapV3TokenV3DTOVolume :: !(Maybe Text) -- ^ "volume" - Volume in token units.
  , uniswapV3TokenV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Volume in derived USD.
  , uniswapV3TokenV3DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Volume in USD even on pools with less reliable USD values.
  , uniswapV3TokenV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3TokenV3DTOTxCount :: !(Maybe NumericsBigInteger) -- ^ "tx_count"
  , uniswapV3TokenV3DTOPoolCount :: !(Maybe NumericsBigInteger) -- ^ "pool_count"
  , uniswapV3TokenV3DTOTotalValueLocked :: !(Maybe Text) -- ^ "total_value_locked" - Liquidity across all pools in token units.
  , uniswapV3TokenV3DTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - Liquidity across all pools in derived USD.
  , uniswapV3TokenV3DTOTotalValueLockedUsdUntracked :: !(Maybe Text) -- ^ "total_value_locked_usd_untracked" - TVL derived in USD untracked.
  , uniswapV3TokenV3DTODerivedEth :: !(Maybe Text) -- ^ "derived_eth" - Derived price in ETH.
  , uniswapV3TokenV3DTOWhitelistPools :: !(Maybe [Text]) -- ^ "whitelist_pools" - Pools token is in that are white listed for USD pricing.
  , uniswapV3TokenV3DTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TokenV3DTO
instance A.FromJSON UniswapV3TokenV3DTO where
  parseJSON = A.withObject "UniswapV3TokenV3DTO" $ \o ->
    UniswapV3TokenV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "symbol")
      <*> (o .:? "name")
      <*> (o .:? "decimals")
      <*> (o .:? "total_supply")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "pool_count")
      <*> (o .:? "total_value_locked")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "total_value_locked_usd_untracked")
      <*> (o .:? "derived_eth")
      <*> (o .:? "whitelist_pools")
      <*> (o .:? "token_symbol")

-- | ToJSON UniswapV3TokenV3DTO
instance A.ToJSON UniswapV3TokenV3DTO where
  toJSON UniswapV3TokenV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TokenV3DTOEntryTime
      , "recv_time" .= uniswapV3TokenV3DTORecvTime
      , "block_number" .= uniswapV3TokenV3DTOBlockNumber
      , "vid" .= uniswapV3TokenV3DTOVid
      , "id" .= uniswapV3TokenV3DTOId
      , "symbol" .= uniswapV3TokenV3DTOSymbol
      , "name" .= uniswapV3TokenV3DTOName
      , "decimals" .= uniswapV3TokenV3DTODecimals
      , "total_supply" .= uniswapV3TokenV3DTOTotalSupply
      , "volume" .= uniswapV3TokenV3DTOVolume
      , "volume_usd" .= uniswapV3TokenV3DTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV3TokenV3DTOUntrackedVolumeUsd
      , "fees_usd" .= uniswapV3TokenV3DTOFeesUsd
      , "tx_count" .= uniswapV3TokenV3DTOTxCount
      , "pool_count" .= uniswapV3TokenV3DTOPoolCount
      , "total_value_locked" .= uniswapV3TokenV3DTOTotalValueLocked
      , "total_value_locked_usd" .= uniswapV3TokenV3DTOTotalValueLockedUsd
      , "total_value_locked_usd_untracked" .= uniswapV3TokenV3DTOTotalValueLockedUsdUntracked
      , "derived_eth" .= uniswapV3TokenV3DTODerivedEth
      , "whitelist_pools" .= uniswapV3TokenV3DTOWhitelistPools
      , "token_symbol" .= uniswapV3TokenV3DTOTokenSymbol
      ]


-- | Construct a value of type 'UniswapV3TokenV3DTO' (by applying it's required fields, if any)
mkUniswapV3TokenV3DTO
  :: UniswapV3TokenV3DTO
mkUniswapV3TokenV3DTO =
  UniswapV3TokenV3DTO
  { uniswapV3TokenV3DTOEntryTime = Nothing
  , uniswapV3TokenV3DTORecvTime = Nothing
  , uniswapV3TokenV3DTOBlockNumber = Nothing
  , uniswapV3TokenV3DTOVid = Nothing
  , uniswapV3TokenV3DTOId = Nothing
  , uniswapV3TokenV3DTOSymbol = Nothing
  , uniswapV3TokenV3DTOName = Nothing
  , uniswapV3TokenV3DTODecimals = Nothing
  , uniswapV3TokenV3DTOTotalSupply = Nothing
  , uniswapV3TokenV3DTOVolume = Nothing
  , uniswapV3TokenV3DTOVolumeUsd = Nothing
  , uniswapV3TokenV3DTOUntrackedVolumeUsd = Nothing
  , uniswapV3TokenV3DTOFeesUsd = Nothing
  , uniswapV3TokenV3DTOTxCount = Nothing
  , uniswapV3TokenV3DTOPoolCount = Nothing
  , uniswapV3TokenV3DTOTotalValueLocked = Nothing
  , uniswapV3TokenV3DTOTotalValueLockedUsd = Nothing
  , uniswapV3TokenV3DTOTotalValueLockedUsdUntracked = Nothing
  , uniswapV3TokenV3DTODerivedEth = Nothing
  , uniswapV3TokenV3DTOWhitelistPools = Nothing
  , uniswapV3TokenV3DTOTokenSymbol = Nothing
  }

-- ** UniswapV3TokenV3DayDataDTO
-- | UniswapV3TokenV3DayDataDTO
-- Token data aggregated across all pairs that include token.
data UniswapV3TokenV3DayDataDTO = UniswapV3TokenV3DayDataDTO
  { uniswapV3TokenV3DayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TokenV3DayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TokenV3DayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TokenV3DayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3TokenV3DayDataDTOId :: !(Maybe Text) -- ^ "id" - Token address concatendated with date.
  , uniswapV3TokenV3DayDataDTODate :: !(Maybe Int) -- ^ "date" - Timestamp rounded to current day by dividing by 86400.
  , uniswapV3TokenV3DayDataDTOToken :: !(Maybe Text) -- ^ "token" - Pointer to token.
  , uniswapV3TokenV3DayDataDTOVolume :: !(Maybe Text) -- ^ "volume" - Volume in token units.
  , uniswapV3TokenV3DayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Volume in derived USD.
  , uniswapV3TokenV3DayDataDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Volume in USD even on pools with less reliable USD values.
  , uniswapV3TokenV3DayDataDTOTotalValueLocked :: !(Maybe Text) -- ^ "total_value_locked" - Liquidity across all pools in token units.
  , uniswapV3TokenV3DayDataDTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - Liquidity across all pools in derived USD.
  , uniswapV3TokenV3DayDataDTOPriceUsd :: !(Maybe Text) -- ^ "price_usd" - Price at end of period in USD.
  , uniswapV3TokenV3DayDataDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3TokenV3DayDataDTOOpen :: !(Maybe Text) -- ^ "open" - Opening price USD.
  , uniswapV3TokenV3DayDataDTOHigh :: !(Maybe Text) -- ^ "high" - High price USD.
  , uniswapV3TokenV3DayDataDTOLow :: !(Maybe Text) -- ^ "low" - Low price USD.
  , uniswapV3TokenV3DayDataDTOClose :: !(Maybe Text) -- ^ "close" - Close price USD.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TokenV3DayDataDTO
instance A.FromJSON UniswapV3TokenV3DayDataDTO where
  parseJSON = A.withObject "UniswapV3TokenV3DayDataDTO" $ \o ->
    UniswapV3TokenV3DayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "token")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_value_locked")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")

-- | ToJSON UniswapV3TokenV3DayDataDTO
instance A.ToJSON UniswapV3TokenV3DayDataDTO where
  toJSON UniswapV3TokenV3DayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TokenV3DayDataDTOEntryTime
      , "recv_time" .= uniswapV3TokenV3DayDataDTORecvTime
      , "block_number" .= uniswapV3TokenV3DayDataDTOBlockNumber
      , "vid" .= uniswapV3TokenV3DayDataDTOVid
      , "id" .= uniswapV3TokenV3DayDataDTOId
      , "date" .= uniswapV3TokenV3DayDataDTODate
      , "token" .= uniswapV3TokenV3DayDataDTOToken
      , "volume" .= uniswapV3TokenV3DayDataDTOVolume
      , "volume_usd" .= uniswapV3TokenV3DayDataDTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV3TokenV3DayDataDTOUntrackedVolumeUsd
      , "total_value_locked" .= uniswapV3TokenV3DayDataDTOTotalValueLocked
      , "total_value_locked_usd" .= uniswapV3TokenV3DayDataDTOTotalValueLockedUsd
      , "price_usd" .= uniswapV3TokenV3DayDataDTOPriceUsd
      , "fees_usd" .= uniswapV3TokenV3DayDataDTOFeesUsd
      , "open" .= uniswapV3TokenV3DayDataDTOOpen
      , "high" .= uniswapV3TokenV3DayDataDTOHigh
      , "low" .= uniswapV3TokenV3DayDataDTOLow
      , "close" .= uniswapV3TokenV3DayDataDTOClose
      ]


-- | Construct a value of type 'UniswapV3TokenV3DayDataDTO' (by applying it's required fields, if any)
mkUniswapV3TokenV3DayDataDTO
  :: UniswapV3TokenV3DayDataDTO
mkUniswapV3TokenV3DayDataDTO =
  UniswapV3TokenV3DayDataDTO
  { uniswapV3TokenV3DayDataDTOEntryTime = Nothing
  , uniswapV3TokenV3DayDataDTORecvTime = Nothing
  , uniswapV3TokenV3DayDataDTOBlockNumber = Nothing
  , uniswapV3TokenV3DayDataDTOVid = Nothing
  , uniswapV3TokenV3DayDataDTOId = Nothing
  , uniswapV3TokenV3DayDataDTODate = Nothing
  , uniswapV3TokenV3DayDataDTOToken = Nothing
  , uniswapV3TokenV3DayDataDTOVolume = Nothing
  , uniswapV3TokenV3DayDataDTOVolumeUsd = Nothing
  , uniswapV3TokenV3DayDataDTOUntrackedVolumeUsd = Nothing
  , uniswapV3TokenV3DayDataDTOTotalValueLocked = Nothing
  , uniswapV3TokenV3DayDataDTOTotalValueLockedUsd = Nothing
  , uniswapV3TokenV3DayDataDTOPriceUsd = Nothing
  , uniswapV3TokenV3DayDataDTOFeesUsd = Nothing
  , uniswapV3TokenV3DayDataDTOOpen = Nothing
  , uniswapV3TokenV3DayDataDTOHigh = Nothing
  , uniswapV3TokenV3DayDataDTOLow = Nothing
  , uniswapV3TokenV3DayDataDTOClose = Nothing
  }

-- ** UniswapV3TransactionV3DTO
-- | UniswapV3TransactionV3DTO
data UniswapV3TransactionV3DTO = UniswapV3TransactionV3DTO
  { uniswapV3TransactionV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TransactionV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TransactionV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TransactionV3DTOId :: !(Maybe Text) -- ^ "id" - Transaction hash.
  , uniswapV3TransactionV3DTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp txn was confirmed.
  , uniswapV3TransactionV3DTOGasUsed :: !(Maybe Text) -- ^ "gas_used" - Gas used during txn execution.
  , uniswapV3TransactionV3DTOGasPrice :: !(Maybe Text) -- ^ "gas_price" - 
  , uniswapV3TransactionV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TransactionV3DTO
instance A.FromJSON UniswapV3TransactionV3DTO where
  parseJSON = A.withObject "UniswapV3TransactionV3DTO" $ \o ->
    UniswapV3TransactionV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "timestamp")
      <*> (o .:? "gas_used")
      <*> (o .:? "gas_price")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3TransactionV3DTO
instance A.ToJSON UniswapV3TransactionV3DTO where
  toJSON UniswapV3TransactionV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TransactionV3DTOEntryTime
      , "recv_time" .= uniswapV3TransactionV3DTORecvTime
      , "block_number" .= uniswapV3TransactionV3DTOBlockNumber
      , "id" .= uniswapV3TransactionV3DTOId
      , "timestamp" .= uniswapV3TransactionV3DTOTimestamp
      , "gas_used" .= uniswapV3TransactionV3DTOGasUsed
      , "gas_price" .= uniswapV3TransactionV3DTOGasPrice
      , "vid" .= uniswapV3TransactionV3DTOVid
      ]


-- | Construct a value of type 'UniswapV3TransactionV3DTO' (by applying it's required fields, if any)
mkUniswapV3TransactionV3DTO
  :: UniswapV3TransactionV3DTO
mkUniswapV3TransactionV3DTO =
  UniswapV3TransactionV3DTO
  { uniswapV3TransactionV3DTOEntryTime = Nothing
  , uniswapV3TransactionV3DTORecvTime = Nothing
  , uniswapV3TransactionV3DTOBlockNumber = Nothing
  , uniswapV3TransactionV3DTOId = Nothing
  , uniswapV3TransactionV3DTOTimestamp = Nothing
  , uniswapV3TransactionV3DTOGasUsed = Nothing
  , uniswapV3TransactionV3DTOGasPrice = Nothing
  , uniswapV3TransactionV3DTOVid = Nothing
  }

-- ** UniswapV3UniswapDayDataV3DTO
-- | UniswapV3UniswapDayDataV3DTO
-- Data accumulated and condensed into day stats for all of Uniswap.
data UniswapV3UniswapDayDataV3DTO = UniswapV3UniswapDayDataV3DTO
  { uniswapV3UniswapDayDataV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3UniswapDayDataV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3UniswapDayDataV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3UniswapDayDataV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3UniswapDayDataV3DTOId :: !(Maybe Text) -- ^ "id" - Timestamp rounded to current day by dividing by 86400.
  , uniswapV3UniswapDayDataV3DTODate :: !(Maybe Int) -- ^ "date" - Timestamp rounded to current day by dividing by 86400.
  , uniswapV3UniswapDayDataV3DTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - Total volume across all pairs on this day, stored as a derived amount of ETH.
  , uniswapV3UniswapDayDataV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total volume across all pairs on this day, stored as a derived amount of USD.
  , uniswapV3UniswapDayDataV3DTOVolumeUsdUntracked :: !(Maybe Text) -- ^ "volume_usd_untracked" - Total daily volume in Uniswap derived in terms of USD untracked.
  , uniswapV3UniswapDayDataV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD
  , uniswapV3UniswapDayDataV3DTOTxCount :: !(Maybe NumericsBigInteger) -- ^ "tx_count"
  , uniswapV3UniswapDayDataV3DTOTvlUsd :: !(Maybe Text) -- ^ "tvl_usd" - Tvl in terms of USD.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3UniswapDayDataV3DTO
instance A.FromJSON UniswapV3UniswapDayDataV3DTO where
  parseJSON = A.withObject "UniswapV3UniswapDayDataV3DTO" $ \o ->
    UniswapV3UniswapDayDataV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "volume_eth")
      <*> (o .:? "volume_usd")
      <*> (o .:? "volume_usd_untracked")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "tvl_usd")

-- | ToJSON UniswapV3UniswapDayDataV3DTO
instance A.ToJSON UniswapV3UniswapDayDataV3DTO where
  toJSON UniswapV3UniswapDayDataV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3UniswapDayDataV3DTOEntryTime
      , "recv_time" .= uniswapV3UniswapDayDataV3DTORecvTime
      , "block_number" .= uniswapV3UniswapDayDataV3DTOBlockNumber
      , "vid" .= uniswapV3UniswapDayDataV3DTOVid
      , "id" .= uniswapV3UniswapDayDataV3DTOId
      , "date" .= uniswapV3UniswapDayDataV3DTODate
      , "volume_eth" .= uniswapV3UniswapDayDataV3DTOVolumeEth
      , "volume_usd" .= uniswapV3UniswapDayDataV3DTOVolumeUsd
      , "volume_usd_untracked" .= uniswapV3UniswapDayDataV3DTOVolumeUsdUntracked
      , "fees_usd" .= uniswapV3UniswapDayDataV3DTOFeesUsd
      , "tx_count" .= uniswapV3UniswapDayDataV3DTOTxCount
      , "tvl_usd" .= uniswapV3UniswapDayDataV3DTOTvlUsd
      ]


-- | Construct a value of type 'UniswapV3UniswapDayDataV3DTO' (by applying it's required fields, if any)
mkUniswapV3UniswapDayDataV3DTO
  :: UniswapV3UniswapDayDataV3DTO
mkUniswapV3UniswapDayDataV3DTO =
  UniswapV3UniswapDayDataV3DTO
  { uniswapV3UniswapDayDataV3DTOEntryTime = Nothing
  , uniswapV3UniswapDayDataV3DTORecvTime = Nothing
  , uniswapV3UniswapDayDataV3DTOBlockNumber = Nothing
  , uniswapV3UniswapDayDataV3DTOVid = Nothing
  , uniswapV3UniswapDayDataV3DTOId = Nothing
  , uniswapV3UniswapDayDataV3DTODate = Nothing
  , uniswapV3UniswapDayDataV3DTOVolumeEth = Nothing
  , uniswapV3UniswapDayDataV3DTOVolumeUsd = Nothing
  , uniswapV3UniswapDayDataV3DTOVolumeUsdUntracked = Nothing
  , uniswapV3UniswapDayDataV3DTOFeesUsd = Nothing
  , uniswapV3UniswapDayDataV3DTOTxCount = Nothing
  , uniswapV3UniswapDayDataV3DTOTvlUsd = Nothing
  }


-- * Enums


-- ** TransactionsETradeAggressiveSide

-- | Enum of 'Text'
data TransactionsETradeAggressiveSide
  = TransactionsETradeAggressiveSide'Buy -- ^ @"Buy"@
  | TransactionsETradeAggressiveSide'Sell -- ^ @"Sell"@
  | TransactionsETradeAggressiveSide'EstimatedBuy -- ^ @"EstimatedBuy"@
  | TransactionsETradeAggressiveSide'EstimatedSell -- ^ @"EstimatedSell"@
  | TransactionsETradeAggressiveSide'Unknown -- ^ @"Unknown"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TransactionsETradeAggressiveSide where toJSON = A.toJSON . fromTransactionsETradeAggressiveSide
instance A.FromJSON TransactionsETradeAggressiveSide where parseJSON o = P.either P.fail (pure . P.id) . toTransactionsETradeAggressiveSide =<< A.parseJSON o
instance WH.ToHttpApiData TransactionsETradeAggressiveSide where toQueryParam = WH.toQueryParam . fromTransactionsETradeAggressiveSide
instance WH.FromHttpApiData TransactionsETradeAggressiveSide where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTransactionsETradeAggressiveSide
instance MimeRender MimeMultipartFormData TransactionsETradeAggressiveSide where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TransactionsETradeAggressiveSide' enum
fromTransactionsETradeAggressiveSide :: TransactionsETradeAggressiveSide -> Text
fromTransactionsETradeAggressiveSide = \case
  TransactionsETradeAggressiveSide'Buy -> "Buy"
  TransactionsETradeAggressiveSide'Sell -> "Sell"
  TransactionsETradeAggressiveSide'EstimatedBuy -> "EstimatedBuy"
  TransactionsETradeAggressiveSide'EstimatedSell -> "EstimatedSell"
  TransactionsETradeAggressiveSide'Unknown -> "Unknown"

-- | parse 'TransactionsETradeAggressiveSide' enum
toTransactionsETradeAggressiveSide :: Text -> P.Either String TransactionsETradeAggressiveSide
toTransactionsETradeAggressiveSide = \case
  "Buy" -> P.Right TransactionsETradeAggressiveSide'Buy
  "Sell" -> P.Right TransactionsETradeAggressiveSide'Sell
  "EstimatedBuy" -> P.Right TransactionsETradeAggressiveSide'EstimatedBuy
  "EstimatedSell" -> P.Right TransactionsETradeAggressiveSide'EstimatedSell
  "Unknown" -> P.Right TransactionsETradeAggressiveSide'Unknown
  s -> P.Left $ "toTransactionsETradeAggressiveSide: enum parse failure: " P.++ P.show s



