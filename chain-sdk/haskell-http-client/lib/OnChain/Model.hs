{-
   OnChain API

    This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

   OpenAPI Version: 3.0.1
   OnChain API API version: v1
   Contact: support@coinapi.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OnChain.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OnChain.Model where

import OnChain.Core
import OnChain.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** ChainId
newtype ChainId = ChainId { unChainId :: Text } deriving (P.Eq, P.Show)

-- ** EndBlock
newtype EndBlock = EndBlock { unEndBlock :: Integer } deriving (P.Eq, P.Show)

-- ** EndDate
newtype EndDate = EndDate { unEndDate :: DateTime } deriving (P.Eq, P.Show)

-- ** FilterPoolId
newtype FilterPoolId = FilterPoolId { unFilterPoolId :: Text } deriving (P.Eq, P.Show)

-- ** FilterTokenId
newtype FilterTokenId = FilterTokenId { unFilterTokenId :: Text } deriving (P.Eq, P.Show)

-- ** PoolId
newtype PoolId = PoolId { unPoolId :: Text } deriving (P.Eq, P.Show)

-- ** StartBlock
newtype StartBlock = StartBlock { unStartBlock :: Integer } deriving (P.Eq, P.Show)

-- ** StartDate
newtype StartDate = StartDate { unStartDate :: DateTime } deriving (P.Eq, P.Show)

-- ** TokenId
newtype TokenId = TokenId { unTokenId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** BigInteger
-- | BigInteger
data BigInteger = BigInteger
  { bigIntegerIsPowerOfTwo :: !(Maybe Bool) -- ^ /ReadOnly/ "is_power_of_two"
  , bigIntegerIsZero :: !(Maybe Bool) -- ^ /ReadOnly/ "is_zero"
  , bigIntegerIsOne :: !(Maybe Bool) -- ^ /ReadOnly/ "is_one"
  , bigIntegerIsEven :: !(Maybe Bool) -- ^ /ReadOnly/ "is_even"
  , bigIntegerSign :: !(Maybe Int) -- ^ /ReadOnly/ "sign"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BigInteger
instance A.FromJSON BigInteger where
  parseJSON = A.withObject "BigInteger" $ \o ->
    BigInteger
      <$> (o .:? "is_power_of_two")
      <*> (o .:? "is_zero")
      <*> (o .:? "is_one")
      <*> (o .:? "is_even")
      <*> (o .:? "sign")

-- | ToJSON BigInteger
instance A.ToJSON BigInteger where
  toJSON BigInteger {..} =
   _omitNulls
      [ "is_power_of_two" .= bigIntegerIsPowerOfTwo
      , "is_zero" .= bigIntegerIsZero
      , "is_one" .= bigIntegerIsOne
      , "is_even" .= bigIntegerIsEven
      , "sign" .= bigIntegerSign
      ]


-- | Construct a value of type 'BigInteger' (by applying it's required fields, if any)
mkBigInteger
  :: BigInteger
mkBigInteger =
  BigInteger
  { bigIntegerIsPowerOfTwo = Nothing
  , bigIntegerIsZero = Nothing
  , bigIntegerIsOne = Nothing
  , bigIntegerIsEven = Nothing
  , bigIntegerSign = Nothing
  }

-- ** BundleV3DTO
-- | BundleV3DTO
data BundleV3DTO = BundleV3DTO
  { bundleV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , bundleV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , bundleV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , bundleV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , bundleV3DTOEthPriceUsd :: !(Maybe Text) -- ^ "eth_price_usd" - 
  , bundleV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BundleV3DTO
instance A.FromJSON BundleV3DTO where
  parseJSON = A.withObject "BundleV3DTO" $ \o ->
    BundleV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "eth_price_usd")
      <*> (o .:? "vid")

-- | ToJSON BundleV3DTO
instance A.ToJSON BundleV3DTO where
  toJSON BundleV3DTO {..} =
   _omitNulls
      [ "entry_time" .= bundleV3DTOEntryTime
      , "recv_time" .= bundleV3DTORecvTime
      , "block_number" .= bundleV3DTOBlockNumber
      , "id" .= bundleV3DTOId
      , "eth_price_usd" .= bundleV3DTOEthPriceUsd
      , "vid" .= bundleV3DTOVid
      ]


-- | Construct a value of type 'BundleV3DTO' (by applying it's required fields, if any)
mkBundleV3DTO
  :: BundleV3DTO
mkBundleV3DTO =
  BundleV3DTO
  { bundleV3DTOEntryTime = Nothing
  , bundleV3DTORecvTime = Nothing
  , bundleV3DTOBlockNumber = Nothing
  , bundleV3DTOId = Nothing
  , bundleV3DTOEthPriceUsd = Nothing
  , bundleV3DTOVid = Nothing
  }

-- ** BurnV3DTO
-- | BurnV3DTO
data BurnV3DTO = BurnV3DTO
  { burnV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , burnV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , burnV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , burnV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , burnV3DTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , burnV3DTOPool :: !(Maybe Text) -- ^ "pool" - 
  , burnV3DTOToken0 :: !(Maybe Text) -- ^ "token_0" - 
  , burnV3DTOToken1 :: !(Maybe Text) -- ^ "token_1" - 
  , burnV3DTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , burnV3DTOOwner :: !(Maybe Text) -- ^ "owner" - 
  , burnV3DTOOrigin :: !(Maybe Text) -- ^ "origin" - 
  , burnV3DTOAmount :: !(Maybe Text) -- ^ "amount" - 
  , burnV3DTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - 
  , burnV3DTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - 
  , burnV3DTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - 
  , burnV3DTOTickLower :: !(Maybe Text) -- ^ "tick_lower" - 
  , burnV3DTOTickUpper :: !(Maybe Text) -- ^ "tick_upper" - 
  , burnV3DTOLogIndex :: !(Maybe Text) -- ^ "log_index" - 
  , burnV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BurnV3DTO
instance A.FromJSON BurnV3DTO where
  parseJSON = A.withObject "BurnV3DTO" $ \o ->
    BurnV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "timestamp")
      <*> (o .:? "owner")
      <*> (o .:? "origin")
      <*> (o .:? "amount")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "amount_usd")
      <*> (o .:? "tick_lower")
      <*> (o .:? "tick_upper")
      <*> (o .:? "log_index")
      <*> (o .:? "vid")

-- | ToJSON BurnV3DTO
instance A.ToJSON BurnV3DTO where
  toJSON BurnV3DTO {..} =
   _omitNulls
      [ "entry_time" .= burnV3DTOEntryTime
      , "recv_time" .= burnV3DTORecvTime
      , "block_number" .= burnV3DTOBlockNumber
      , "id" .= burnV3DTOId
      , "transaction" .= burnV3DTOTransaction
      , "pool" .= burnV3DTOPool
      , "token_0" .= burnV3DTOToken0
      , "token_1" .= burnV3DTOToken1
      , "timestamp" .= burnV3DTOTimestamp
      , "owner" .= burnV3DTOOwner
      , "origin" .= burnV3DTOOrigin
      , "amount" .= burnV3DTOAmount
      , "amount_0" .= burnV3DTOAmount0
      , "amount_1" .= burnV3DTOAmount1
      , "amount_usd" .= burnV3DTOAmountUsd
      , "tick_lower" .= burnV3DTOTickLower
      , "tick_upper" .= burnV3DTOTickUpper
      , "log_index" .= burnV3DTOLogIndex
      , "vid" .= burnV3DTOVid
      ]


-- | Construct a value of type 'BurnV3DTO' (by applying it's required fields, if any)
mkBurnV3DTO
  :: BurnV3DTO
mkBurnV3DTO =
  BurnV3DTO
  { burnV3DTOEntryTime = Nothing
  , burnV3DTORecvTime = Nothing
  , burnV3DTOBlockNumber = Nothing
  , burnV3DTOId = Nothing
  , burnV3DTOTransaction = Nothing
  , burnV3DTOPool = Nothing
  , burnV3DTOToken0 = Nothing
  , burnV3DTOToken1 = Nothing
  , burnV3DTOTimestamp = Nothing
  , burnV3DTOOwner = Nothing
  , burnV3DTOOrigin = Nothing
  , burnV3DTOAmount = Nothing
  , burnV3DTOAmount0 = Nothing
  , burnV3DTOAmount1 = Nothing
  , burnV3DTOAmountUsd = Nothing
  , burnV3DTOTickLower = Nothing
  , burnV3DTOTickUpper = Nothing
  , burnV3DTOLogIndex = Nothing
  , burnV3DTOVid = Nothing
  }

-- ** FactoryV3DTO
-- | FactoryV3DTO
data FactoryV3DTO = FactoryV3DTO
  { factoryV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , factoryV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , factoryV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , factoryV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , factoryV3DTOPoolCount :: !(Maybe Text) -- ^ "pool_count" - 
  , factoryV3DTOTxCount :: !(Maybe Text) -- ^ "tx_count" - 
  , factoryV3DTOTotalVolumeUsd :: !(Maybe Text) -- ^ "total_volume_usd" - 
  , factoryV3DTOTotalVolumeEth :: !(Maybe Text) -- ^ "total_volume_eth" - 
  , factoryV3DTOTotalFeesUsd :: !(Maybe Text) -- ^ "total_fees_usd" - 
  , factoryV3DTOTotalFeesEth :: !(Maybe Text) -- ^ "total_fees_eth" - 
  , factoryV3DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - 
  , factoryV3DTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - 
  , factoryV3DTOTotalValueLockedEth :: !(Maybe Text) -- ^ "total_value_locked_eth" - 
  , factoryV3DTOTotalValueLockedUsdUntracked :: !(Maybe Text) -- ^ "total_value_locked_usd_untracked" - 
  , factoryV3DTOTotalValueLockedEthUntracked :: !(Maybe Text) -- ^ "total_value_locked_eth_untracked" - 
  , factoryV3DTOOwner :: !(Maybe Text) -- ^ "owner" - 
  , factoryV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FactoryV3DTO
instance A.FromJSON FactoryV3DTO where
  parseJSON = A.withObject "FactoryV3DTO" $ \o ->
    FactoryV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool_count")
      <*> (o .:? "tx_count")
      <*> (o .:? "total_volume_usd")
      <*> (o .:? "total_volume_eth")
      <*> (o .:? "total_fees_usd")
      <*> (o .:? "total_fees_eth")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "total_value_locked_eth")
      <*> (o .:? "total_value_locked_usd_untracked")
      <*> (o .:? "total_value_locked_eth_untracked")
      <*> (o .:? "owner")
      <*> (o .:? "vid")

-- | ToJSON FactoryV3DTO
instance A.ToJSON FactoryV3DTO where
  toJSON FactoryV3DTO {..} =
   _omitNulls
      [ "entry_time" .= factoryV3DTOEntryTime
      , "recv_time" .= factoryV3DTORecvTime
      , "block_number" .= factoryV3DTOBlockNumber
      , "id" .= factoryV3DTOId
      , "pool_count" .= factoryV3DTOPoolCount
      , "tx_count" .= factoryV3DTOTxCount
      , "total_volume_usd" .= factoryV3DTOTotalVolumeUsd
      , "total_volume_eth" .= factoryV3DTOTotalVolumeEth
      , "total_fees_usd" .= factoryV3DTOTotalFeesUsd
      , "total_fees_eth" .= factoryV3DTOTotalFeesEth
      , "untracked_volume_usd" .= factoryV3DTOUntrackedVolumeUsd
      , "total_value_locked_usd" .= factoryV3DTOTotalValueLockedUsd
      , "total_value_locked_eth" .= factoryV3DTOTotalValueLockedEth
      , "total_value_locked_usd_untracked" .= factoryV3DTOTotalValueLockedUsdUntracked
      , "total_value_locked_eth_untracked" .= factoryV3DTOTotalValueLockedEthUntracked
      , "owner" .= factoryV3DTOOwner
      , "vid" .= factoryV3DTOVid
      ]


-- | Construct a value of type 'FactoryV3DTO' (by applying it's required fields, if any)
mkFactoryV3DTO
  :: FactoryV3DTO
mkFactoryV3DTO =
  FactoryV3DTO
  { factoryV3DTOEntryTime = Nothing
  , factoryV3DTORecvTime = Nothing
  , factoryV3DTOBlockNumber = Nothing
  , factoryV3DTOId = Nothing
  , factoryV3DTOPoolCount = Nothing
  , factoryV3DTOTxCount = Nothing
  , factoryV3DTOTotalVolumeUsd = Nothing
  , factoryV3DTOTotalVolumeEth = Nothing
  , factoryV3DTOTotalFeesUsd = Nothing
  , factoryV3DTOTotalFeesEth = Nothing
  , factoryV3DTOUntrackedVolumeUsd = Nothing
  , factoryV3DTOTotalValueLockedUsd = Nothing
  , factoryV3DTOTotalValueLockedEth = Nothing
  , factoryV3DTOTotalValueLockedUsdUntracked = Nothing
  , factoryV3DTOTotalValueLockedEthUntracked = Nothing
  , factoryV3DTOOwner = Nothing
  , factoryV3DTOVid = Nothing
  }

-- ** MintV3DTO
-- | MintV3DTO
data MintV3DTO = MintV3DTO
  { mintV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , mintV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , mintV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , mintV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , mintV3DTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , mintV3DTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , mintV3DTOPool :: !(Maybe Text) -- ^ "pool" - 
  , mintV3DTOToken0 :: !(Maybe Text) -- ^ "token_0" - 
  , mintV3DTOToken1 :: !(Maybe Text) -- ^ "token_1" - 
  , mintV3DTOOwner :: !(Maybe Text) -- ^ "owner" - 
  , mintV3DTOSender :: !(Maybe Text) -- ^ "sender" - 
  , mintV3DTOOrigin :: !(Maybe Text) -- ^ "origin" - 
  , mintV3DTOAmount :: !(Maybe Text) -- ^ "amount" - 
  , mintV3DTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - 
  , mintV3DTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - 
  , mintV3DTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - 
  , mintV3DTOTickLower :: !(Maybe Text) -- ^ "tick_lower" - 
  , mintV3DTOTickUpper :: !(Maybe Text) -- ^ "tick_upper" - 
  , mintV3DTOLogIndex :: !(Maybe Text) -- ^ "log_index" - 
  , mintV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MintV3DTO
instance A.FromJSON MintV3DTO where
  parseJSON = A.withObject "MintV3DTO" $ \o ->
    MintV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "owner")
      <*> (o .:? "sender")
      <*> (o .:? "origin")
      <*> (o .:? "amount")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "amount_usd")
      <*> (o .:? "tick_lower")
      <*> (o .:? "tick_upper")
      <*> (o .:? "log_index")
      <*> (o .:? "vid")

-- | ToJSON MintV3DTO
instance A.ToJSON MintV3DTO where
  toJSON MintV3DTO {..} =
   _omitNulls
      [ "entry_time" .= mintV3DTOEntryTime
      , "recv_time" .= mintV3DTORecvTime
      , "block_number" .= mintV3DTOBlockNumber
      , "id" .= mintV3DTOId
      , "transaction" .= mintV3DTOTransaction
      , "timestamp" .= mintV3DTOTimestamp
      , "pool" .= mintV3DTOPool
      , "token_0" .= mintV3DTOToken0
      , "token_1" .= mintV3DTOToken1
      , "owner" .= mintV3DTOOwner
      , "sender" .= mintV3DTOSender
      , "origin" .= mintV3DTOOrigin
      , "amount" .= mintV3DTOAmount
      , "amount_0" .= mintV3DTOAmount0
      , "amount_1" .= mintV3DTOAmount1
      , "amount_usd" .= mintV3DTOAmountUsd
      , "tick_lower" .= mintV3DTOTickLower
      , "tick_upper" .= mintV3DTOTickUpper
      , "log_index" .= mintV3DTOLogIndex
      , "vid" .= mintV3DTOVid
      ]


-- | Construct a value of type 'MintV3DTO' (by applying it's required fields, if any)
mkMintV3DTO
  :: MintV3DTO
mkMintV3DTO =
  MintV3DTO
  { mintV3DTOEntryTime = Nothing
  , mintV3DTORecvTime = Nothing
  , mintV3DTOBlockNumber = Nothing
  , mintV3DTOId = Nothing
  , mintV3DTOTransaction = Nothing
  , mintV3DTOTimestamp = Nothing
  , mintV3DTOPool = Nothing
  , mintV3DTOToken0 = Nothing
  , mintV3DTOToken1 = Nothing
  , mintV3DTOOwner = Nothing
  , mintV3DTOSender = Nothing
  , mintV3DTOOrigin = Nothing
  , mintV3DTOAmount = Nothing
  , mintV3DTOAmount0 = Nothing
  , mintV3DTOAmount1 = Nothing
  , mintV3DTOAmountUsd = Nothing
  , mintV3DTOTickLower = Nothing
  , mintV3DTOTickUpper = Nothing
  , mintV3DTOLogIndex = Nothing
  , mintV3DTOVid = Nothing
  }

-- ** PairDTO
-- | PairDTO
data PairDTO = PairDTO
  { pairDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , pairDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , pairDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , pairDTOId :: !(Maybe Text) -- ^ "id" - 
  , pairDTOFactory :: !(Maybe Text) -- ^ "factory" - 
  , pairDTOName :: !(Maybe Text) -- ^ "name" - 
  , pairDTOToken0 :: !(Maybe Text) -- ^ "token_0" - 
  , pairDTOToken1 :: !(Maybe Text) -- ^ "token_1" - 
  , pairDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - 
  , pairDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - 
  , pairDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - 
  , pairDTOReserveEth :: !(Maybe Text) -- ^ "reserve_eth" - 
  , pairDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - 
  , pairDTOTrackedReserveEth :: !(Maybe Text) -- ^ "tracked_reserve_eth" - 
  , pairDTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - 
  , pairDTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - 
  , pairDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - 
  , pairDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - 
  , pairDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - 
  , pairDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - 
  , pairDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - 
  , pairDTOLiquidityProviderCount :: !(Maybe Text) -- ^ "liquidity_provider_count" - 
  , pairDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , pairDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , pairDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , pairDTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PairDTO
instance A.FromJSON PairDTO where
  parseJSON = A.withObject "PairDTO" $ \o ->
    PairDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "factory")
      <*> (o .:? "name")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_eth")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "tracked_reserve_eth")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "timestamp")
      <*> (o .:? "block")
      <*> (o .:? "vid")
      <*> (o .:? "evaluated_ask")

-- | ToJSON PairDTO
instance A.ToJSON PairDTO where
  toJSON PairDTO {..} =
   _omitNulls
      [ "entry_time" .= pairDTOEntryTime
      , "recv_time" .= pairDTORecvTime
      , "block_number" .= pairDTOBlockNumber
      , "id" .= pairDTOId
      , "factory" .= pairDTOFactory
      , "name" .= pairDTOName
      , "token_0" .= pairDTOToken0
      , "token_1" .= pairDTOToken1
      , "reserve_0" .= pairDTOReserve0
      , "reserve_1" .= pairDTOReserve1
      , "total_supply" .= pairDTOTotalSupply
      , "reserve_eth" .= pairDTOReserveEth
      , "reserve_usd" .= pairDTOReserveUsd
      , "tracked_reserve_eth" .= pairDTOTrackedReserveEth
      , "token_0_price" .= pairDTOToken0Price
      , "token_1_price" .= pairDTOToken1Price
      , "volume_token_0" .= pairDTOVolumeToken0
      , "volume_token_1" .= pairDTOVolumeToken1
      , "volume_usd" .= pairDTOVolumeUsd
      , "untracked_volume_usd" .= pairDTOUntrackedVolumeUsd
      , "tx_count" .= pairDTOTxCount
      , "liquidity_provider_count" .= pairDTOLiquidityProviderCount
      , "timestamp" .= pairDTOTimestamp
      , "block" .= pairDTOBlock
      , "vid" .= pairDTOVid
      , "evaluated_ask" .= pairDTOEvaluatedAsk
      ]


-- | Construct a value of type 'PairDTO' (by applying it's required fields, if any)
mkPairDTO
  :: PairDTO
mkPairDTO =
  PairDTO
  { pairDTOEntryTime = Nothing
  , pairDTORecvTime = Nothing
  , pairDTOBlockNumber = Nothing
  , pairDTOId = Nothing
  , pairDTOFactory = Nothing
  , pairDTOName = Nothing
  , pairDTOToken0 = Nothing
  , pairDTOToken1 = Nothing
  , pairDTOReserve0 = Nothing
  , pairDTOReserve1 = Nothing
  , pairDTOTotalSupply = Nothing
  , pairDTOReserveEth = Nothing
  , pairDTOReserveUsd = Nothing
  , pairDTOTrackedReserveEth = Nothing
  , pairDTOToken0Price = Nothing
  , pairDTOToken1Price = Nothing
  , pairDTOVolumeToken0 = Nothing
  , pairDTOVolumeToken1 = Nothing
  , pairDTOVolumeUsd = Nothing
  , pairDTOUntrackedVolumeUsd = Nothing
  , pairDTOTxCount = Nothing
  , pairDTOLiquidityProviderCount = Nothing
  , pairDTOTimestamp = Nothing
  , pairDTOBlock = Nothing
  , pairDTOVid = Nothing
  , pairDTOEvaluatedAsk = Nothing
  }

-- ** PairV2DTO
-- | PairV2DTO
data PairV2DTO = PairV2DTO
  { pairV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , pairV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , pairV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , pairV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , pairV2DTOId :: !(Maybe Text) -- ^ "id" - 
  , pairV2DTOToken0 :: !(Maybe Text) -- ^ "token_0" - 
  , pairV2DTOToken1 :: !(Maybe Text) -- ^ "token_1" - 
  , pairV2DTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - 
  , pairV2DTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - 
  , pairV2DTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - 
  , pairV2DTOReserveEth :: !(Maybe Text) -- ^ "reserve_eth" - 
  , pairV2DTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - 
  , pairV2DTOTrackedReserveEth :: !(Maybe Text) -- ^ "tracked_reserve_eth" - 
  , pairV2DTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - 
  , pairV2DTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - 
  , pairV2DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - 
  , pairV2DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - 
  , pairV2DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - 
  , pairV2DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - 
  , pairV2DTOTxCount :: !(Maybe BigInteger) -- ^ "tx_count"
  , pairV2DTOCreatedAtTimestamp :: !(Maybe DateTime) -- ^ "created_at_timestamp" - 
  , pairV2DTOLiquidityProviderCount :: !(Maybe Text) -- ^ "liquidity_provider_count" - 
  , pairV2DTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PairV2DTO
instance A.FromJSON PairV2DTO where
  parseJSON = A.withObject "PairV2DTO" $ \o ->
    PairV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_eth")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "tracked_reserve_eth")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "created_at_timestamp")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "evaluated_ask")

-- | ToJSON PairV2DTO
instance A.ToJSON PairV2DTO where
  toJSON PairV2DTO {..} =
   _omitNulls
      [ "entry_time" .= pairV2DTOEntryTime
      , "recv_time" .= pairV2DTORecvTime
      , "block_number" .= pairV2DTOBlockNumber
      , "vid" .= pairV2DTOVid
      , "id" .= pairV2DTOId
      , "token_0" .= pairV2DTOToken0
      , "token_1" .= pairV2DTOToken1
      , "reserve_0" .= pairV2DTOReserve0
      , "reserve_1" .= pairV2DTOReserve1
      , "total_supply" .= pairV2DTOTotalSupply
      , "reserve_eth" .= pairV2DTOReserveEth
      , "reserve_usd" .= pairV2DTOReserveUsd
      , "tracked_reserve_eth" .= pairV2DTOTrackedReserveEth
      , "token_0_price" .= pairV2DTOToken0Price
      , "token_1_price" .= pairV2DTOToken1Price
      , "volume_token_0" .= pairV2DTOVolumeToken0
      , "volume_token_1" .= pairV2DTOVolumeToken1
      , "volume_usd" .= pairV2DTOVolumeUsd
      , "untracked_volume_usd" .= pairV2DTOUntrackedVolumeUsd
      , "tx_count" .= pairV2DTOTxCount
      , "created_at_timestamp" .= pairV2DTOCreatedAtTimestamp
      , "liquidity_provider_count" .= pairV2DTOLiquidityProviderCount
      , "evaluated_ask" .= pairV2DTOEvaluatedAsk
      ]


-- | Construct a value of type 'PairV2DTO' (by applying it's required fields, if any)
mkPairV2DTO
  :: PairV2DTO
mkPairV2DTO =
  PairV2DTO
  { pairV2DTOEntryTime = Nothing
  , pairV2DTORecvTime = Nothing
  , pairV2DTOBlockNumber = Nothing
  , pairV2DTOVid = Nothing
  , pairV2DTOId = Nothing
  , pairV2DTOToken0 = Nothing
  , pairV2DTOToken1 = Nothing
  , pairV2DTOReserve0 = Nothing
  , pairV2DTOReserve1 = Nothing
  , pairV2DTOTotalSupply = Nothing
  , pairV2DTOReserveEth = Nothing
  , pairV2DTOReserveUsd = Nothing
  , pairV2DTOTrackedReserveEth = Nothing
  , pairV2DTOToken0Price = Nothing
  , pairV2DTOToken1Price = Nothing
  , pairV2DTOVolumeToken0 = Nothing
  , pairV2DTOVolumeToken1 = Nothing
  , pairV2DTOVolumeUsd = Nothing
  , pairV2DTOUntrackedVolumeUsd = Nothing
  , pairV2DTOTxCount = Nothing
  , pairV2DTOCreatedAtTimestamp = Nothing
  , pairV2DTOLiquidityProviderCount = Nothing
  , pairV2DTOEvaluatedAsk = Nothing
  }

-- ** PoolDayDataV3DTO
-- | PoolDayDataV3DTO
data PoolDayDataV3DTO = PoolDayDataV3DTO
  { poolDayDataV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , poolDayDataV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , poolDayDataV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , poolDayDataV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , poolDayDataV3DTODate :: !(Maybe Int) -- ^ "date" - 
  , poolDayDataV3DTOPool :: !(Maybe Text) -- ^ "pool" - 
  , poolDayDataV3DTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - 
  , poolDayDataV3DTOSqrtPrice :: !(Maybe Text) -- ^ "sqrt_price" - 
  , poolDayDataV3DTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - 
  , poolDayDataV3DTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - 
  , poolDayDataV3DTOTick :: !(Maybe Text) -- ^ "tick" - 
  , poolDayDataV3DTOFeeGrowthGlobal0x128 :: !(Maybe Text) -- ^ "fee_growth_global_0x128" - 
  , poolDayDataV3DTOFeeGrowthGlobal1x128 :: !(Maybe Text) -- ^ "fee_growth_global_1x128" - 
  , poolDayDataV3DTOTvlUsd :: !(Maybe Text) -- ^ "tvl_usd" - 
  , poolDayDataV3DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - 
  , poolDayDataV3DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - 
  , poolDayDataV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - 
  , poolDayDataV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - 
  , poolDayDataV3DTOTxCount :: !(Maybe Text) -- ^ "tx_count" - 
  , poolDayDataV3DTOOpen :: !(Maybe Text) -- ^ "open" - 
  , poolDayDataV3DTOHigh :: !(Maybe Text) -- ^ "high" - 
  , poolDayDataV3DTOLow :: !(Maybe Text) -- ^ "low" - 
  , poolDayDataV3DTOClose :: !(Maybe Text) -- ^ "close" - 
  , poolDayDataV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PoolDayDataV3DTO
instance A.FromJSON PoolDayDataV3DTO where
  parseJSON = A.withObject "PoolDayDataV3DTO" $ \o ->
    PoolDayDataV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pool")
      <*> (o .:? "liquidity")
      <*> (o .:? "sqrt_price")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "tick")
      <*> (o .:? "fee_growth_global_0x128")
      <*> (o .:? "fee_growth_global_1x128")
      <*> (o .:? "tvl_usd")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")
      <*> (o .:? "vid")

-- | ToJSON PoolDayDataV3DTO
instance A.ToJSON PoolDayDataV3DTO where
  toJSON PoolDayDataV3DTO {..} =
   _omitNulls
      [ "entry_time" .= poolDayDataV3DTOEntryTime
      , "recv_time" .= poolDayDataV3DTORecvTime
      , "block_number" .= poolDayDataV3DTOBlockNumber
      , "id" .= poolDayDataV3DTOId
      , "date" .= poolDayDataV3DTODate
      , "pool" .= poolDayDataV3DTOPool
      , "liquidity" .= poolDayDataV3DTOLiquidity
      , "sqrt_price" .= poolDayDataV3DTOSqrtPrice
      , "token_0_price" .= poolDayDataV3DTOToken0Price
      , "token_1_price" .= poolDayDataV3DTOToken1Price
      , "tick" .= poolDayDataV3DTOTick
      , "fee_growth_global_0x128" .= poolDayDataV3DTOFeeGrowthGlobal0x128
      , "fee_growth_global_1x128" .= poolDayDataV3DTOFeeGrowthGlobal1x128
      , "tvl_usd" .= poolDayDataV3DTOTvlUsd
      , "volume_token_0" .= poolDayDataV3DTOVolumeToken0
      , "volume_token_1" .= poolDayDataV3DTOVolumeToken1
      , "volume_usd" .= poolDayDataV3DTOVolumeUsd
      , "fees_usd" .= poolDayDataV3DTOFeesUsd
      , "tx_count" .= poolDayDataV3DTOTxCount
      , "open" .= poolDayDataV3DTOOpen
      , "high" .= poolDayDataV3DTOHigh
      , "low" .= poolDayDataV3DTOLow
      , "close" .= poolDayDataV3DTOClose
      , "vid" .= poolDayDataV3DTOVid
      ]


-- | Construct a value of type 'PoolDayDataV3DTO' (by applying it's required fields, if any)
mkPoolDayDataV3DTO
  :: PoolDayDataV3DTO
mkPoolDayDataV3DTO =
  PoolDayDataV3DTO
  { poolDayDataV3DTOEntryTime = Nothing
  , poolDayDataV3DTORecvTime = Nothing
  , poolDayDataV3DTOBlockNumber = Nothing
  , poolDayDataV3DTOId = Nothing
  , poolDayDataV3DTODate = Nothing
  , poolDayDataV3DTOPool = Nothing
  , poolDayDataV3DTOLiquidity = Nothing
  , poolDayDataV3DTOSqrtPrice = Nothing
  , poolDayDataV3DTOToken0Price = Nothing
  , poolDayDataV3DTOToken1Price = Nothing
  , poolDayDataV3DTOTick = Nothing
  , poolDayDataV3DTOFeeGrowthGlobal0x128 = Nothing
  , poolDayDataV3DTOFeeGrowthGlobal1x128 = Nothing
  , poolDayDataV3DTOTvlUsd = Nothing
  , poolDayDataV3DTOVolumeToken0 = Nothing
  , poolDayDataV3DTOVolumeToken1 = Nothing
  , poolDayDataV3DTOVolumeUsd = Nothing
  , poolDayDataV3DTOFeesUsd = Nothing
  , poolDayDataV3DTOTxCount = Nothing
  , poolDayDataV3DTOOpen = Nothing
  , poolDayDataV3DTOHigh = Nothing
  , poolDayDataV3DTOLow = Nothing
  , poolDayDataV3DTOClose = Nothing
  , poolDayDataV3DTOVid = Nothing
  }

-- ** PoolHourDataV3DTO
-- | PoolHourDataV3DTO
data PoolHourDataV3DTO = PoolHourDataV3DTO
  { poolHourDataV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , poolHourDataV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , poolHourDataV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , poolHourDataV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , poolHourDataV3DTOPeriodStartUnix :: !(Maybe Int) -- ^ "period_start_unix" - 
  , poolHourDataV3DTOPool :: !(Maybe Text) -- ^ "pool" - 
  , poolHourDataV3DTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - 
  , poolHourDataV3DTOSqrtPrice :: !(Maybe Text) -- ^ "sqrt_price" - 
  , poolHourDataV3DTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - 
  , poolHourDataV3DTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - 
  , poolHourDataV3DTOTick :: !(Maybe Text) -- ^ "tick" - 
  , poolHourDataV3DTOFeeGrowthGlobal0x128 :: !(Maybe Text) -- ^ "fee_growth_global_0x128" - 
  , poolHourDataV3DTOFeeGrowthGlobal1x128 :: !(Maybe Text) -- ^ "fee_growth_global_1x128" - 
  , poolHourDataV3DTOTvlUsd :: !(Maybe Text) -- ^ "tvl_usd" - 
  , poolHourDataV3DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - 
  , poolHourDataV3DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - 
  , poolHourDataV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - 
  , poolHourDataV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - 
  , poolHourDataV3DTOTxCount :: !(Maybe Text) -- ^ "tx_count" - 
  , poolHourDataV3DTOOpen :: !(Maybe Text) -- ^ "open" - 
  , poolHourDataV3DTOHigh :: !(Maybe Text) -- ^ "high" - 
  , poolHourDataV3DTOLow :: !(Maybe Text) -- ^ "low" - 
  , poolHourDataV3DTOClose :: !(Maybe Text) -- ^ "close" - 
  , poolHourDataV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PoolHourDataV3DTO
instance A.FromJSON PoolHourDataV3DTO where
  parseJSON = A.withObject "PoolHourDataV3DTO" $ \o ->
    PoolHourDataV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "period_start_unix")
      <*> (o .:? "pool")
      <*> (o .:? "liquidity")
      <*> (o .:? "sqrt_price")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "tick")
      <*> (o .:? "fee_growth_global_0x128")
      <*> (o .:? "fee_growth_global_1x128")
      <*> (o .:? "tvl_usd")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")
      <*> (o .:? "vid")

-- | ToJSON PoolHourDataV3DTO
instance A.ToJSON PoolHourDataV3DTO where
  toJSON PoolHourDataV3DTO {..} =
   _omitNulls
      [ "entry_time" .= poolHourDataV3DTOEntryTime
      , "recv_time" .= poolHourDataV3DTORecvTime
      , "block_number" .= poolHourDataV3DTOBlockNumber
      , "id" .= poolHourDataV3DTOId
      , "period_start_unix" .= poolHourDataV3DTOPeriodStartUnix
      , "pool" .= poolHourDataV3DTOPool
      , "liquidity" .= poolHourDataV3DTOLiquidity
      , "sqrt_price" .= poolHourDataV3DTOSqrtPrice
      , "token_0_price" .= poolHourDataV3DTOToken0Price
      , "token_1_price" .= poolHourDataV3DTOToken1Price
      , "tick" .= poolHourDataV3DTOTick
      , "fee_growth_global_0x128" .= poolHourDataV3DTOFeeGrowthGlobal0x128
      , "fee_growth_global_1x128" .= poolHourDataV3DTOFeeGrowthGlobal1x128
      , "tvl_usd" .= poolHourDataV3DTOTvlUsd
      , "volume_token_0" .= poolHourDataV3DTOVolumeToken0
      , "volume_token_1" .= poolHourDataV3DTOVolumeToken1
      , "volume_usd" .= poolHourDataV3DTOVolumeUsd
      , "fees_usd" .= poolHourDataV3DTOFeesUsd
      , "tx_count" .= poolHourDataV3DTOTxCount
      , "open" .= poolHourDataV3DTOOpen
      , "high" .= poolHourDataV3DTOHigh
      , "low" .= poolHourDataV3DTOLow
      , "close" .= poolHourDataV3DTOClose
      , "vid" .= poolHourDataV3DTOVid
      ]


-- | Construct a value of type 'PoolHourDataV3DTO' (by applying it's required fields, if any)
mkPoolHourDataV3DTO
  :: PoolHourDataV3DTO
mkPoolHourDataV3DTO =
  PoolHourDataV3DTO
  { poolHourDataV3DTOEntryTime = Nothing
  , poolHourDataV3DTORecvTime = Nothing
  , poolHourDataV3DTOBlockNumber = Nothing
  , poolHourDataV3DTOId = Nothing
  , poolHourDataV3DTOPeriodStartUnix = Nothing
  , poolHourDataV3DTOPool = Nothing
  , poolHourDataV3DTOLiquidity = Nothing
  , poolHourDataV3DTOSqrtPrice = Nothing
  , poolHourDataV3DTOToken0Price = Nothing
  , poolHourDataV3DTOToken1Price = Nothing
  , poolHourDataV3DTOTick = Nothing
  , poolHourDataV3DTOFeeGrowthGlobal0x128 = Nothing
  , poolHourDataV3DTOFeeGrowthGlobal1x128 = Nothing
  , poolHourDataV3DTOTvlUsd = Nothing
  , poolHourDataV3DTOVolumeToken0 = Nothing
  , poolHourDataV3DTOVolumeToken1 = Nothing
  , poolHourDataV3DTOVolumeUsd = Nothing
  , poolHourDataV3DTOFeesUsd = Nothing
  , poolHourDataV3DTOTxCount = Nothing
  , poolHourDataV3DTOOpen = Nothing
  , poolHourDataV3DTOHigh = Nothing
  , poolHourDataV3DTOLow = Nothing
  , poolHourDataV3DTOClose = Nothing
  , poolHourDataV3DTOVid = Nothing
  }

-- ** PoolV3DTO
-- | PoolV3DTO
data PoolV3DTO = PoolV3DTO
  { poolV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , poolV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , poolV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , poolV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , poolV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , poolV3DTOCreatedAtTimestamp :: !(Maybe DateTime) -- ^ "created_at_timestamp" - 
  , poolV3DTOToken0 :: !(Maybe Text) -- ^ "token_0" - 
  , poolV3DTOToken1 :: !(Maybe Text) -- ^ "token_1" - 
  , poolV3DTOFeeTier :: !(Maybe BigInteger) -- ^ "fee_tier"
  , poolV3DTOLiquidity :: !(Maybe BigInteger) -- ^ "liquidity"
  , poolV3DTOSqrtPrice :: !(Maybe BigInteger) -- ^ "sqrt_price"
  , poolV3DTOFeeGrowthGlobal0x128 :: !(Maybe BigInteger) -- ^ "fee_growth_global_0x128"
  , poolV3DTOFeeGrowthGlobal1x128 :: !(Maybe BigInteger) -- ^ "fee_growth_global_1x128"
  , poolV3DTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - 
  , poolV3DTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - 
  , poolV3DTOTick :: !(Maybe BigInteger) -- ^ "tick"
  , poolV3DTOObservationIndex :: !(Maybe BigInteger) -- ^ "observation_index"
  , poolV3DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - 
  , poolV3DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - 
  , poolV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - 
  , poolV3DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - 
  , poolV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - 
  , poolV3DTOTxCount :: !(Maybe BigInteger) -- ^ "tx_count"
  , poolV3DTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - 
  , poolV3DTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - 
  , poolV3DTOCollectedFeesUsd :: !(Maybe Text) -- ^ "collected_fees_usd" - 
  , poolV3DTOTotalValueLockedToken0 :: !(Maybe Text) -- ^ "total_value_locked_token_0" - 
  , poolV3DTOTotalValueLockedToken1 :: !(Maybe Text) -- ^ "total_value_locked_token_1" - 
  , poolV3DTOTotalValueLockedEth :: !(Maybe Text) -- ^ "total_value_locked_eth" - 
  , poolV3DTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - 
  , poolV3DTOTotalValueLockedUsdUntracked :: !(Maybe Text) -- ^ "total_value_locked_usd_untracked" - 
  , poolV3DTOLiquidityProviderCount :: !(Maybe Text) -- ^ "liquidity_provider_count" - 
  , poolV3DTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PoolV3DTO
instance A.FromJSON PoolV3DTO where
  parseJSON = A.withObject "PoolV3DTO" $ \o ->
    PoolV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "created_at_timestamp")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "fee_tier")
      <*> (o .:? "liquidity")
      <*> (o .:? "sqrt_price")
      <*> (o .:? "fee_growth_global_0x128")
      <*> (o .:? "fee_growth_global_1x128")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "tick")
      <*> (o .:? "observation_index")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "collected_fees_usd")
      <*> (o .:? "total_value_locked_token_0")
      <*> (o .:? "total_value_locked_token_1")
      <*> (o .:? "total_value_locked_eth")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "total_value_locked_usd_untracked")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "evaluated_ask")

-- | ToJSON PoolV3DTO
instance A.ToJSON PoolV3DTO where
  toJSON PoolV3DTO {..} =
   _omitNulls
      [ "entry_time" .= poolV3DTOEntryTime
      , "recv_time" .= poolV3DTORecvTime
      , "block_number" .= poolV3DTOBlockNumber
      , "vid" .= poolV3DTOVid
      , "id" .= poolV3DTOId
      , "created_at_timestamp" .= poolV3DTOCreatedAtTimestamp
      , "token_0" .= poolV3DTOToken0
      , "token_1" .= poolV3DTOToken1
      , "fee_tier" .= poolV3DTOFeeTier
      , "liquidity" .= poolV3DTOLiquidity
      , "sqrt_price" .= poolV3DTOSqrtPrice
      , "fee_growth_global_0x128" .= poolV3DTOFeeGrowthGlobal0x128
      , "fee_growth_global_1x128" .= poolV3DTOFeeGrowthGlobal1x128
      , "token_0_price" .= poolV3DTOToken0Price
      , "token_1_price" .= poolV3DTOToken1Price
      , "tick" .= poolV3DTOTick
      , "observation_index" .= poolV3DTOObservationIndex
      , "volume_token_0" .= poolV3DTOVolumeToken0
      , "volume_token_1" .= poolV3DTOVolumeToken1
      , "volume_usd" .= poolV3DTOVolumeUsd
      , "untracked_volume_usd" .= poolV3DTOUntrackedVolumeUsd
      , "fees_usd" .= poolV3DTOFeesUsd
      , "tx_count" .= poolV3DTOTxCount
      , "collected_fees_token_0" .= poolV3DTOCollectedFeesToken0
      , "collected_fees_token_1" .= poolV3DTOCollectedFeesToken1
      , "collected_fees_usd" .= poolV3DTOCollectedFeesUsd
      , "total_value_locked_token_0" .= poolV3DTOTotalValueLockedToken0
      , "total_value_locked_token_1" .= poolV3DTOTotalValueLockedToken1
      , "total_value_locked_eth" .= poolV3DTOTotalValueLockedEth
      , "total_value_locked_usd" .= poolV3DTOTotalValueLockedUsd
      , "total_value_locked_usd_untracked" .= poolV3DTOTotalValueLockedUsdUntracked
      , "liquidity_provider_count" .= poolV3DTOLiquidityProviderCount
      , "evaluated_ask" .= poolV3DTOEvaluatedAsk
      ]


-- | Construct a value of type 'PoolV3DTO' (by applying it's required fields, if any)
mkPoolV3DTO
  :: PoolV3DTO
mkPoolV3DTO =
  PoolV3DTO
  { poolV3DTOEntryTime = Nothing
  , poolV3DTORecvTime = Nothing
  , poolV3DTOBlockNumber = Nothing
  , poolV3DTOVid = Nothing
  , poolV3DTOId = Nothing
  , poolV3DTOCreatedAtTimestamp = Nothing
  , poolV3DTOToken0 = Nothing
  , poolV3DTOToken1 = Nothing
  , poolV3DTOFeeTier = Nothing
  , poolV3DTOLiquidity = Nothing
  , poolV3DTOSqrtPrice = Nothing
  , poolV3DTOFeeGrowthGlobal0x128 = Nothing
  , poolV3DTOFeeGrowthGlobal1x128 = Nothing
  , poolV3DTOToken0Price = Nothing
  , poolV3DTOToken1Price = Nothing
  , poolV3DTOTick = Nothing
  , poolV3DTOObservationIndex = Nothing
  , poolV3DTOVolumeToken0 = Nothing
  , poolV3DTOVolumeToken1 = Nothing
  , poolV3DTOVolumeUsd = Nothing
  , poolV3DTOUntrackedVolumeUsd = Nothing
  , poolV3DTOFeesUsd = Nothing
  , poolV3DTOTxCount = Nothing
  , poolV3DTOCollectedFeesToken0 = Nothing
  , poolV3DTOCollectedFeesToken1 = Nothing
  , poolV3DTOCollectedFeesUsd = Nothing
  , poolV3DTOTotalValueLockedToken0 = Nothing
  , poolV3DTOTotalValueLockedToken1 = Nothing
  , poolV3DTOTotalValueLockedEth = Nothing
  , poolV3DTOTotalValueLockedUsd = Nothing
  , poolV3DTOTotalValueLockedUsdUntracked = Nothing
  , poolV3DTOLiquidityProviderCount = Nothing
  , poolV3DTOEvaluatedAsk = Nothing
  }

-- ** PositionSnapshotV3DTO
-- | PositionSnapshotV3DTO
data PositionSnapshotV3DTO = PositionSnapshotV3DTO
  { positionSnapshotV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , positionSnapshotV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , positionSnapshotV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , positionSnapshotV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , positionSnapshotV3DTOOwner :: !(Maybe Text) -- ^ "owner" - THIS IS SUPER OWNER
  , positionSnapshotV3DTOPool :: !(Maybe Text) -- ^ "pool" - 
  , positionSnapshotV3DTOPosition :: !(Maybe Text) -- ^ "position" - 
  , positionSnapshotV3DTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , positionSnapshotV3DTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - 
  , positionSnapshotV3DTODepositedToken0 :: !(Maybe Text) -- ^ "deposited_token_0" - 
  , positionSnapshotV3DTODepositedToken1 :: !(Maybe Text) -- ^ "deposited_token_1" - 
  , positionSnapshotV3DTOWithdrawnToken0 :: !(Maybe Text) -- ^ "withdrawn_token_0" - 
  , positionSnapshotV3DTOWithdrawnToken1 :: !(Maybe Text) -- ^ "withdrawn_token_1" - 
  , positionSnapshotV3DTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - 
  , positionSnapshotV3DTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - 
  , positionSnapshotV3DTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , positionSnapshotV3DTOFeeGrowthInside0LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_0_last_x128" - 
  , positionSnapshotV3DTOFeeGrowthInside1LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_1_last_x128" - 
  , positionSnapshotV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PositionSnapshotV3DTO
instance A.FromJSON PositionSnapshotV3DTO where
  parseJSON = A.withObject "PositionSnapshotV3DTO" $ \o ->
    PositionSnapshotV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "owner")
      <*> (o .:? "pool")
      <*> (o .:? "position")
      <*> (o .:? "timestamp")
      <*> (o .:? "liquidity")
      <*> (o .:? "deposited_token_0")
      <*> (o .:? "deposited_token_1")
      <*> (o .:? "withdrawn_token_0")
      <*> (o .:? "withdrawn_token_1")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "transaction")
      <*> (o .:? "fee_growth_inside_0_last_x128")
      <*> (o .:? "fee_growth_inside_1_last_x128")
      <*> (o .:? "vid")

-- | ToJSON PositionSnapshotV3DTO
instance A.ToJSON PositionSnapshotV3DTO where
  toJSON PositionSnapshotV3DTO {..} =
   _omitNulls
      [ "entry_time" .= positionSnapshotV3DTOEntryTime
      , "recv_time" .= positionSnapshotV3DTORecvTime
      , "block_number" .= positionSnapshotV3DTOBlockNumber
      , "id" .= positionSnapshotV3DTOId
      , "owner" .= positionSnapshotV3DTOOwner
      , "pool" .= positionSnapshotV3DTOPool
      , "position" .= positionSnapshotV3DTOPosition
      , "timestamp" .= positionSnapshotV3DTOTimestamp
      , "liquidity" .= positionSnapshotV3DTOLiquidity
      , "deposited_token_0" .= positionSnapshotV3DTODepositedToken0
      , "deposited_token_1" .= positionSnapshotV3DTODepositedToken1
      , "withdrawn_token_0" .= positionSnapshotV3DTOWithdrawnToken0
      , "withdrawn_token_1" .= positionSnapshotV3DTOWithdrawnToken1
      , "collected_fees_token_0" .= positionSnapshotV3DTOCollectedFeesToken0
      , "collected_fees_token_1" .= positionSnapshotV3DTOCollectedFeesToken1
      , "transaction" .= positionSnapshotV3DTOTransaction
      , "fee_growth_inside_0_last_x128" .= positionSnapshotV3DTOFeeGrowthInside0LastX128
      , "fee_growth_inside_1_last_x128" .= positionSnapshotV3DTOFeeGrowthInside1LastX128
      , "vid" .= positionSnapshotV3DTOVid
      ]


-- | Construct a value of type 'PositionSnapshotV3DTO' (by applying it's required fields, if any)
mkPositionSnapshotV3DTO
  :: PositionSnapshotV3DTO
mkPositionSnapshotV3DTO =
  PositionSnapshotV3DTO
  { positionSnapshotV3DTOEntryTime = Nothing
  , positionSnapshotV3DTORecvTime = Nothing
  , positionSnapshotV3DTOBlockNumber = Nothing
  , positionSnapshotV3DTOId = Nothing
  , positionSnapshotV3DTOOwner = Nothing
  , positionSnapshotV3DTOPool = Nothing
  , positionSnapshotV3DTOPosition = Nothing
  , positionSnapshotV3DTOTimestamp = Nothing
  , positionSnapshotV3DTOLiquidity = Nothing
  , positionSnapshotV3DTODepositedToken0 = Nothing
  , positionSnapshotV3DTODepositedToken1 = Nothing
  , positionSnapshotV3DTOWithdrawnToken0 = Nothing
  , positionSnapshotV3DTOWithdrawnToken1 = Nothing
  , positionSnapshotV3DTOCollectedFeesToken0 = Nothing
  , positionSnapshotV3DTOCollectedFeesToken1 = Nothing
  , positionSnapshotV3DTOTransaction = Nothing
  , positionSnapshotV3DTOFeeGrowthInside0LastX128 = Nothing
  , positionSnapshotV3DTOFeeGrowthInside1LastX128 = Nothing
  , positionSnapshotV3DTOVid = Nothing
  }

-- ** PositionV3DTO
-- | PositionV3DTO
data PositionV3DTO = PositionV3DTO
  { positionV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , positionV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , positionV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , positionV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , positionV3DTOOwner :: !(Maybe Text) -- ^ "owner" - 
  , positionV3DTOPool :: !(Maybe Text) -- ^ "pool" - 
  , positionV3DTOToken0 :: !(Maybe Text) -- ^ "token_0" - 
  , positionV3DTOToken1 :: !(Maybe Text) -- ^ "token_1" - 
  , positionV3DTOTickLower :: !(Maybe Text) -- ^ "tick_lower" - 
  , positionV3DTOTickUpper :: !(Maybe Text) -- ^ "tick_upper" - 
  , positionV3DTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - 
  , positionV3DTODepositedToken0 :: !(Maybe Text) -- ^ "deposited_token_0" - 
  , positionV3DTODepositedToken1 :: !(Maybe Text) -- ^ "deposited_token_1" - 
  , positionV3DTOWithdrawnToken0 :: !(Maybe Text) -- ^ "withdrawn_token_0" - 
  , positionV3DTOWithdrawnToken1 :: !(Maybe Text) -- ^ "withdrawn_token_1" - 
  , positionV3DTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - 
  , positionV3DTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - 
  , positionV3DTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , positionV3DTOFeeGrowthInside0LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_0_last_x128" - 
  , positionV3DTOFeeGrowthInside1LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_1_last_x128" - 
  , positionV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PositionV3DTO
instance A.FromJSON PositionV3DTO where
  parseJSON = A.withObject "PositionV3DTO" $ \o ->
    PositionV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "owner")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "tick_lower")
      <*> (o .:? "tick_upper")
      <*> (o .:? "liquidity")
      <*> (o .:? "deposited_token_0")
      <*> (o .:? "deposited_token_1")
      <*> (o .:? "withdrawn_token_0")
      <*> (o .:? "withdrawn_token_1")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "transaction")
      <*> (o .:? "fee_growth_inside_0_last_x128")
      <*> (o .:? "fee_growth_inside_1_last_x128")
      <*> (o .:? "vid")

-- | ToJSON PositionV3DTO
instance A.ToJSON PositionV3DTO where
  toJSON PositionV3DTO {..} =
   _omitNulls
      [ "entry_time" .= positionV3DTOEntryTime
      , "recv_time" .= positionV3DTORecvTime
      , "block_number" .= positionV3DTOBlockNumber
      , "id" .= positionV3DTOId
      , "owner" .= positionV3DTOOwner
      , "pool" .= positionV3DTOPool
      , "token_0" .= positionV3DTOToken0
      , "token_1" .= positionV3DTOToken1
      , "tick_lower" .= positionV3DTOTickLower
      , "tick_upper" .= positionV3DTOTickUpper
      , "liquidity" .= positionV3DTOLiquidity
      , "deposited_token_0" .= positionV3DTODepositedToken0
      , "deposited_token_1" .= positionV3DTODepositedToken1
      , "withdrawn_token_0" .= positionV3DTOWithdrawnToken0
      , "withdrawn_token_1" .= positionV3DTOWithdrawnToken1
      , "collected_fees_token_0" .= positionV3DTOCollectedFeesToken0
      , "collected_fees_token_1" .= positionV3DTOCollectedFeesToken1
      , "transaction" .= positionV3DTOTransaction
      , "fee_growth_inside_0_last_x128" .= positionV3DTOFeeGrowthInside0LastX128
      , "fee_growth_inside_1_last_x128" .= positionV3DTOFeeGrowthInside1LastX128
      , "vid" .= positionV3DTOVid
      ]


-- | Construct a value of type 'PositionV3DTO' (by applying it's required fields, if any)
mkPositionV3DTO
  :: PositionV3DTO
mkPositionV3DTO =
  PositionV3DTO
  { positionV3DTOEntryTime = Nothing
  , positionV3DTORecvTime = Nothing
  , positionV3DTOBlockNumber = Nothing
  , positionV3DTOId = Nothing
  , positionV3DTOOwner = Nothing
  , positionV3DTOPool = Nothing
  , positionV3DTOToken0 = Nothing
  , positionV3DTOToken1 = Nothing
  , positionV3DTOTickLower = Nothing
  , positionV3DTOTickUpper = Nothing
  , positionV3DTOLiquidity = Nothing
  , positionV3DTODepositedToken0 = Nothing
  , positionV3DTODepositedToken1 = Nothing
  , positionV3DTOWithdrawnToken0 = Nothing
  , positionV3DTOWithdrawnToken1 = Nothing
  , positionV3DTOCollectedFeesToken0 = Nothing
  , positionV3DTOCollectedFeesToken1 = Nothing
  , positionV3DTOTransaction = Nothing
  , positionV3DTOFeeGrowthInside0LastX128 = Nothing
  , positionV3DTOFeeGrowthInside1LastX128 = Nothing
  , positionV3DTOVid = Nothing
  }

-- ** SwapDTO
-- | SwapDTO
data SwapDTO = SwapDTO
  { swapDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , swapDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , swapDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , swapDTOId :: !(Maybe Text) -- ^ "id" - 
  , swapDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , swapDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , swapDTOPair :: !(Maybe Text) -- ^ "pair" - 
  , swapDTOSender :: !(Maybe Text) -- ^ "sender" - 
  , swapDTOAmount0In :: !(Maybe Text) -- ^ "amount_0_in" - 
  , swapDTOAmount1In :: !(Maybe Text) -- ^ "amount_1_in" - 
  , swapDTOAmount0Out :: !(Maybe Text) -- ^ "amount_0_out" - 
  , swapDTOAmount1Out :: !(Maybe Text) -- ^ "amount_1_out" - 
  , swapDTOTo :: !(Maybe Text) -- ^ "to" - 
  , swapDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - 
  , swapDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - 
  , swapDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , swapDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , swapDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  , swapDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , swapDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , swapDTOEvaluatedAggressor :: !(Maybe ETradeAggressiveSide) -- ^ "evaluated_aggressor"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwapDTO
instance A.FromJSON SwapDTO where
  parseJSON = A.withObject "SwapDTO" $ \o ->
    SwapDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0_in")
      <*> (o .:? "amount_1_in")
      <*> (o .:? "amount_0_out")
      <*> (o .:? "amount_1_out")
      <*> (o .:? "to")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "vid")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")

-- | ToJSON SwapDTO
instance A.ToJSON SwapDTO where
  toJSON SwapDTO {..} =
   _omitNulls
      [ "entry_time" .= swapDTOEntryTime
      , "recv_time" .= swapDTORecvTime
      , "block_number" .= swapDTOBlockNumber
      , "id" .= swapDTOId
      , "transaction" .= swapDTOTransaction
      , "timestamp" .= swapDTOTimestamp
      , "pair" .= swapDTOPair
      , "sender" .= swapDTOSender
      , "amount_0_in" .= swapDTOAmount0In
      , "amount_1_in" .= swapDTOAmount1In
      , "amount_0_out" .= swapDTOAmount0Out
      , "amount_1_out" .= swapDTOAmount1Out
      , "to" .= swapDTOTo
      , "log_index" .= swapDTOLogIndex
      , "amount_usd" .= swapDTOAmountUsd
      , "vid" .= swapDTOVid
      , "pool_id" .= swapDTOPoolId
      , "transaction_id" .= swapDTOTransactionId
      , "evaluated_price" .= swapDTOEvaluatedPrice
      , "evaluated_amount" .= swapDTOEvaluatedAmount
      , "evaluated_aggressor" .= swapDTOEvaluatedAggressor
      ]


-- | Construct a value of type 'SwapDTO' (by applying it's required fields, if any)
mkSwapDTO
  :: SwapDTO
mkSwapDTO =
  SwapDTO
  { swapDTOEntryTime = Nothing
  , swapDTORecvTime = Nothing
  , swapDTOBlockNumber = Nothing
  , swapDTOId = Nothing
  , swapDTOTransaction = Nothing
  , swapDTOTimestamp = Nothing
  , swapDTOPair = Nothing
  , swapDTOSender = Nothing
  , swapDTOAmount0In = Nothing
  , swapDTOAmount1In = Nothing
  , swapDTOAmount0Out = Nothing
  , swapDTOAmount1Out = Nothing
  , swapDTOTo = Nothing
  , swapDTOLogIndex = Nothing
  , swapDTOAmountUsd = Nothing
  , swapDTOVid = Nothing
  , swapDTOPoolId = Nothing
  , swapDTOTransactionId = Nothing
  , swapDTOEvaluatedPrice = Nothing
  , swapDTOEvaluatedAmount = Nothing
  , swapDTOEvaluatedAggressor = Nothing
  }

-- ** SwapV2DTO
-- | SwapV2DTO
data SwapV2DTO = SwapV2DTO
  { swapV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , swapV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , swapV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , swapV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , swapV2DTOId :: !(Maybe Text) -- ^ "id" - 
  , swapV2DTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , swapV2DTOTimestamp :: !(Maybe DateTime) -- ^ "timestamp" - 
  , swapV2DTOPair :: !(Maybe Text) -- ^ "pair" - 
  , swapV2DTOSender :: !(Maybe Text) -- ^ "sender" - 
  , swapV2DTOFrom :: !(Maybe Text) -- ^ "from" - 
  , swapV2DTOAmount0In :: !(Maybe Text) -- ^ "amount_0_in" - 
  , swapV2DTOAmount1In :: !(Maybe Text) -- ^ "amount_1_in" - 
  , swapV2DTOAmount0Out :: !(Maybe Text) -- ^ "amount_0_out" - 
  , swapV2DTOAmount1Out :: !(Maybe Text) -- ^ "amount_1_out" - 
  , swapV2DTOTo :: !(Maybe Text) -- ^ "to" - 
  , swapV2DTOLogIndex :: !(Maybe BigInteger) -- ^ "log_index"
  , swapV2DTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - 
  , swapV2DTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , swapV2DTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , swapV2DTOEvaluatedAggressor :: !(Maybe ETradeAggressiveSide) -- ^ "evaluated_aggressor"
  , swapV2DTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , swapV2DTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwapV2DTO
instance A.FromJSON SwapV2DTO where
  parseJSON = A.withObject "SwapV2DTO" $ \o ->
    SwapV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "sender")
      <*> (o .:? "from")
      <*> (o .:? "amount_0_in")
      <*> (o .:? "amount_1_in")
      <*> (o .:? "amount_0_out")
      <*> (o .:? "amount_1_out")
      <*> (o .:? "to")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")

-- | ToJSON SwapV2DTO
instance A.ToJSON SwapV2DTO where
  toJSON SwapV2DTO {..} =
   _omitNulls
      [ "entry_time" .= swapV2DTOEntryTime
      , "recv_time" .= swapV2DTORecvTime
      , "block_number" .= swapV2DTOBlockNumber
      , "vid" .= swapV2DTOVid
      , "id" .= swapV2DTOId
      , "transaction" .= swapV2DTOTransaction
      , "timestamp" .= swapV2DTOTimestamp
      , "pair" .= swapV2DTOPair
      , "sender" .= swapV2DTOSender
      , "from" .= swapV2DTOFrom
      , "amount_0_in" .= swapV2DTOAmount0In
      , "amount_1_in" .= swapV2DTOAmount1In
      , "amount_0_out" .= swapV2DTOAmount0Out
      , "amount_1_out" .= swapV2DTOAmount1Out
      , "to" .= swapV2DTOTo
      , "log_index" .= swapV2DTOLogIndex
      , "amount_usd" .= swapV2DTOAmountUsd
      , "evaluated_price" .= swapV2DTOEvaluatedPrice
      , "evaluated_amount" .= swapV2DTOEvaluatedAmount
      , "evaluated_aggressor" .= swapV2DTOEvaluatedAggressor
      , "pool_id" .= swapV2DTOPoolId
      , "transaction_id" .= swapV2DTOTransactionId
      ]


-- | Construct a value of type 'SwapV2DTO' (by applying it's required fields, if any)
mkSwapV2DTO
  :: SwapV2DTO
mkSwapV2DTO =
  SwapV2DTO
  { swapV2DTOEntryTime = Nothing
  , swapV2DTORecvTime = Nothing
  , swapV2DTOBlockNumber = Nothing
  , swapV2DTOVid = Nothing
  , swapV2DTOId = Nothing
  , swapV2DTOTransaction = Nothing
  , swapV2DTOTimestamp = Nothing
  , swapV2DTOPair = Nothing
  , swapV2DTOSender = Nothing
  , swapV2DTOFrom = Nothing
  , swapV2DTOAmount0In = Nothing
  , swapV2DTOAmount1In = Nothing
  , swapV2DTOAmount0Out = Nothing
  , swapV2DTOAmount1Out = Nothing
  , swapV2DTOTo = Nothing
  , swapV2DTOLogIndex = Nothing
  , swapV2DTOAmountUsd = Nothing
  , swapV2DTOEvaluatedPrice = Nothing
  , swapV2DTOEvaluatedAmount = Nothing
  , swapV2DTOEvaluatedAggressor = Nothing
  , swapV2DTOPoolId = Nothing
  , swapV2DTOTransactionId = Nothing
  }

-- ** SwapV3DTO
-- | SwapV3DTO
data SwapV3DTO = SwapV3DTO
  { swapV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , swapV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , swapV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , swapV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , swapV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , swapV3DTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , swapV3DTOTimestamp :: !(Maybe DateTime) -- ^ "timestamp" - 
  , swapV3DTOPool :: !(Maybe Text) -- ^ "pool" - 
  , swapV3DTOToken0 :: !(Maybe Text) -- ^ "token_0" - 
  , swapV3DTOToken1 :: !(Maybe Text) -- ^ "token_1" - 
  , swapV3DTOSender :: !(Maybe Text) -- ^ "sender" - 
  , swapV3DTORecipient :: !(Maybe Text) -- ^ "recipient" - 
  , swapV3DTOOrigin :: !(Maybe Text) -- ^ "origin" - 
  , swapV3DTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - 
  , swapV3DTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - 
  , swapV3DTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - 
  , swapV3DTOSqrtPriceX96 :: !(Maybe BigInteger) -- ^ "sqrt_price_x96"
  , swapV3DTOTick :: !(Maybe BigInteger) -- ^ "tick"
  , swapV3DTOLogIndex :: !(Maybe BigInteger) -- ^ "log_index"
  , swapV3DTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , swapV3DTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , swapV3DTOEvaluatedAggressor :: !(Maybe ETradeAggressiveSide) -- ^ "evaluated_aggressor"
  , swapV3DTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , swapV3DTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwapV3DTO
instance A.FromJSON SwapV3DTO where
  parseJSON = A.withObject "SwapV3DTO" $ \o ->
    SwapV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "sender")
      <*> (o .:? "recipient")
      <*> (o .:? "origin")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "amount_usd")
      <*> (o .:? "sqrt_price_x96")
      <*> (o .:? "tick")
      <*> (o .:? "log_index")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")

-- | ToJSON SwapV3DTO
instance A.ToJSON SwapV3DTO where
  toJSON SwapV3DTO {..} =
   _omitNulls
      [ "entry_time" .= swapV3DTOEntryTime
      , "recv_time" .= swapV3DTORecvTime
      , "block_number" .= swapV3DTOBlockNumber
      , "vid" .= swapV3DTOVid
      , "id" .= swapV3DTOId
      , "transaction" .= swapV3DTOTransaction
      , "timestamp" .= swapV3DTOTimestamp
      , "pool" .= swapV3DTOPool
      , "token_0" .= swapV3DTOToken0
      , "token_1" .= swapV3DTOToken1
      , "sender" .= swapV3DTOSender
      , "recipient" .= swapV3DTORecipient
      , "origin" .= swapV3DTOOrigin
      , "amount_0" .= swapV3DTOAmount0
      , "amount_1" .= swapV3DTOAmount1
      , "amount_usd" .= swapV3DTOAmountUsd
      , "sqrt_price_x96" .= swapV3DTOSqrtPriceX96
      , "tick" .= swapV3DTOTick
      , "log_index" .= swapV3DTOLogIndex
      , "evaluated_price" .= swapV3DTOEvaluatedPrice
      , "evaluated_amount" .= swapV3DTOEvaluatedAmount
      , "evaluated_aggressor" .= swapV3DTOEvaluatedAggressor
      , "pool_id" .= swapV3DTOPoolId
      , "transaction_id" .= swapV3DTOTransactionId
      ]


-- | Construct a value of type 'SwapV3DTO' (by applying it's required fields, if any)
mkSwapV3DTO
  :: SwapV3DTO
mkSwapV3DTO =
  SwapV3DTO
  { swapV3DTOEntryTime = Nothing
  , swapV3DTORecvTime = Nothing
  , swapV3DTOBlockNumber = Nothing
  , swapV3DTOVid = Nothing
  , swapV3DTOId = Nothing
  , swapV3DTOTransaction = Nothing
  , swapV3DTOTimestamp = Nothing
  , swapV3DTOPool = Nothing
  , swapV3DTOToken0 = Nothing
  , swapV3DTOToken1 = Nothing
  , swapV3DTOSender = Nothing
  , swapV3DTORecipient = Nothing
  , swapV3DTOOrigin = Nothing
  , swapV3DTOAmount0 = Nothing
  , swapV3DTOAmount1 = Nothing
  , swapV3DTOAmountUsd = Nothing
  , swapV3DTOSqrtPriceX96 = Nothing
  , swapV3DTOTick = Nothing
  , swapV3DTOLogIndex = Nothing
  , swapV3DTOEvaluatedPrice = Nothing
  , swapV3DTOEvaluatedAmount = Nothing
  , swapV3DTOEvaluatedAggressor = Nothing
  , swapV3DTOPoolId = Nothing
  , swapV3DTOTransactionId = Nothing
  }

-- ** TickDayDataV3DTO
-- | TickDayDataV3DTO
data TickDayDataV3DTO = TickDayDataV3DTO
  { tickDayDataV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , tickDayDataV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , tickDayDataV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , tickDayDataV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , tickDayDataV3DTODate :: !(Maybe Int) -- ^ "date" - 
  , tickDayDataV3DTOPool :: !(Maybe Text) -- ^ "pool" - 
  , tickDayDataV3DTOTick :: !(Maybe Text) -- ^ "tick" - 
  , tickDayDataV3DTOLiquidityGross :: !(Maybe Text) -- ^ "liquidity_gross" - 
  , tickDayDataV3DTOLiquidityNet :: !(Maybe Text) -- ^ "liquidity_net" - 
  , tickDayDataV3DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - 
  , tickDayDataV3DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - 
  , tickDayDataV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - 
  , tickDayDataV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - 
  , tickDayDataV3DTOFeeGrowthOutside0x128 :: !(Maybe Text) -- ^ "fee_growth_outside_0x128" - 
  , tickDayDataV3DTOFeeGrowthOutside1x128 :: !(Maybe Text) -- ^ "fee_growth_outside_1x128" - 
  , tickDayDataV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TickDayDataV3DTO
instance A.FromJSON TickDayDataV3DTO where
  parseJSON = A.withObject "TickDayDataV3DTO" $ \o ->
    TickDayDataV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pool")
      <*> (o .:? "tick")
      <*> (o .:? "liquidity_gross")
      <*> (o .:? "liquidity_net")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "fee_growth_outside_0x128")
      <*> (o .:? "fee_growth_outside_1x128")
      <*> (o .:? "vid")

-- | ToJSON TickDayDataV3DTO
instance A.ToJSON TickDayDataV3DTO where
  toJSON TickDayDataV3DTO {..} =
   _omitNulls
      [ "entry_time" .= tickDayDataV3DTOEntryTime
      , "recv_time" .= tickDayDataV3DTORecvTime
      , "block_number" .= tickDayDataV3DTOBlockNumber
      , "id" .= tickDayDataV3DTOId
      , "date" .= tickDayDataV3DTODate
      , "pool" .= tickDayDataV3DTOPool
      , "tick" .= tickDayDataV3DTOTick
      , "liquidity_gross" .= tickDayDataV3DTOLiquidityGross
      , "liquidity_net" .= tickDayDataV3DTOLiquidityNet
      , "volume_token_0" .= tickDayDataV3DTOVolumeToken0
      , "volume_token_1" .= tickDayDataV3DTOVolumeToken1
      , "volume_usd" .= tickDayDataV3DTOVolumeUsd
      , "fees_usd" .= tickDayDataV3DTOFeesUsd
      , "fee_growth_outside_0x128" .= tickDayDataV3DTOFeeGrowthOutside0x128
      , "fee_growth_outside_1x128" .= tickDayDataV3DTOFeeGrowthOutside1x128
      , "vid" .= tickDayDataV3DTOVid
      ]


-- | Construct a value of type 'TickDayDataV3DTO' (by applying it's required fields, if any)
mkTickDayDataV3DTO
  :: TickDayDataV3DTO
mkTickDayDataV3DTO =
  TickDayDataV3DTO
  { tickDayDataV3DTOEntryTime = Nothing
  , tickDayDataV3DTORecvTime = Nothing
  , tickDayDataV3DTOBlockNumber = Nothing
  , tickDayDataV3DTOId = Nothing
  , tickDayDataV3DTODate = Nothing
  , tickDayDataV3DTOPool = Nothing
  , tickDayDataV3DTOTick = Nothing
  , tickDayDataV3DTOLiquidityGross = Nothing
  , tickDayDataV3DTOLiquidityNet = Nothing
  , tickDayDataV3DTOVolumeToken0 = Nothing
  , tickDayDataV3DTOVolumeToken1 = Nothing
  , tickDayDataV3DTOVolumeUsd = Nothing
  , tickDayDataV3DTOFeesUsd = Nothing
  , tickDayDataV3DTOFeeGrowthOutside0x128 = Nothing
  , tickDayDataV3DTOFeeGrowthOutside1x128 = Nothing
  , tickDayDataV3DTOVid = Nothing
  }

-- ** TickV3DTO
-- | TickV3DTO
data TickV3DTO = TickV3DTO
  { tickV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , tickV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , tickV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , tickV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , tickV3DTOId :: !(Maybe Text) -- ^ "id" - 
  , tickV3DTOPoolAddress :: !(Maybe Text) -- ^ "pool_address" - 
  , tickV3DTOTickIdx :: !(Maybe BigInteger) -- ^ "tick_idx"
  , tickV3DTOPool :: !(Maybe Text) -- ^ "pool" - 
  , tickV3DTOLiquidityGross :: !(Maybe BigInteger) -- ^ "liquidity_gross"
  , tickV3DTOLiquidityNet :: !(Maybe BigInteger) -- ^ "liquidity_net"
  , tickV3DTOPrice0 :: !(Maybe Text) -- ^ "price_0" - 
  , tickV3DTOPrice1 :: !(Maybe Text) -- ^ "price_1" - 
  , tickV3DTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - 
  , tickV3DTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - 
  , tickV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - 
  , tickV3DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - 
  , tickV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - 
  , tickV3DTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - 
  , tickV3DTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - 
  , tickV3DTOCollectedFeesUsd :: !(Maybe Text) -- ^ "collected_fees_usd" - 
  , tickV3DTOCreatedAtTimestamp :: !(Maybe DateTime) -- ^ "created_at_timestamp" - 
  , tickV3DTOLiquidityProviderCount :: !(Maybe BigInteger) -- ^ "liquidity_provider_count"
  , tickV3DTOFeeGrowthOutside0x128 :: !(Maybe BigInteger) -- ^ "fee_growth_outside_0x128"
  , tickV3DTOFeeGrowthOutside1x128 :: !(Maybe BigInteger) -- ^ "fee_growth_outside_1x128"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TickV3DTO
instance A.FromJSON TickV3DTO where
  parseJSON = A.withObject "TickV3DTO" $ \o ->
    TickV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "pool_address")
      <*> (o .:? "tick_idx")
      <*> (o .:? "pool")
      <*> (o .:? "liquidity_gross")
      <*> (o .:? "liquidity_net")
      <*> (o .:? "price_0")
      <*> (o .:? "price_1")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "collected_fees_usd")
      <*> (o .:? "created_at_timestamp")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "fee_growth_outside_0x128")
      <*> (o .:? "fee_growth_outside_1x128")

-- | ToJSON TickV3DTO
instance A.ToJSON TickV3DTO where
  toJSON TickV3DTO {..} =
   _omitNulls
      [ "entry_time" .= tickV3DTOEntryTime
      , "recv_time" .= tickV3DTORecvTime
      , "block_number" .= tickV3DTOBlockNumber
      , "vid" .= tickV3DTOVid
      , "id" .= tickV3DTOId
      , "pool_address" .= tickV3DTOPoolAddress
      , "tick_idx" .= tickV3DTOTickIdx
      , "pool" .= tickV3DTOPool
      , "liquidity_gross" .= tickV3DTOLiquidityGross
      , "liquidity_net" .= tickV3DTOLiquidityNet
      , "price_0" .= tickV3DTOPrice0
      , "price_1" .= tickV3DTOPrice1
      , "volume_token_0" .= tickV3DTOVolumeToken0
      , "volume_token_1" .= tickV3DTOVolumeToken1
      , "volume_usd" .= tickV3DTOVolumeUsd
      , "untracked_volume_usd" .= tickV3DTOUntrackedVolumeUsd
      , "fees_usd" .= tickV3DTOFeesUsd
      , "collected_fees_token_0" .= tickV3DTOCollectedFeesToken0
      , "collected_fees_token_1" .= tickV3DTOCollectedFeesToken1
      , "collected_fees_usd" .= tickV3DTOCollectedFeesUsd
      , "created_at_timestamp" .= tickV3DTOCreatedAtTimestamp
      , "liquidity_provider_count" .= tickV3DTOLiquidityProviderCount
      , "fee_growth_outside_0x128" .= tickV3DTOFeeGrowthOutside0x128
      , "fee_growth_outside_1x128" .= tickV3DTOFeeGrowthOutside1x128
      ]


-- | Construct a value of type 'TickV3DTO' (by applying it's required fields, if any)
mkTickV3DTO
  :: TickV3DTO
mkTickV3DTO =
  TickV3DTO
  { tickV3DTOEntryTime = Nothing
  , tickV3DTORecvTime = Nothing
  , tickV3DTOBlockNumber = Nothing
  , tickV3DTOVid = Nothing
  , tickV3DTOId = Nothing
  , tickV3DTOPoolAddress = Nothing
  , tickV3DTOTickIdx = Nothing
  , tickV3DTOPool = Nothing
  , tickV3DTOLiquidityGross = Nothing
  , tickV3DTOLiquidityNet = Nothing
  , tickV3DTOPrice0 = Nothing
  , tickV3DTOPrice1 = Nothing
  , tickV3DTOVolumeToken0 = Nothing
  , tickV3DTOVolumeToken1 = Nothing
  , tickV3DTOVolumeUsd = Nothing
  , tickV3DTOUntrackedVolumeUsd = Nothing
  , tickV3DTOFeesUsd = Nothing
  , tickV3DTOCollectedFeesToken0 = Nothing
  , tickV3DTOCollectedFeesToken1 = Nothing
  , tickV3DTOCollectedFeesUsd = Nothing
  , tickV3DTOCreatedAtTimestamp = Nothing
  , tickV3DTOLiquidityProviderCount = Nothing
  , tickV3DTOFeeGrowthOutside0x128 = Nothing
  , tickV3DTOFeeGrowthOutside1x128 = Nothing
  }

-- ** TokenDTO
-- | TokenDTO
data TokenDTO = TokenDTO
  { tokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , tokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , tokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , tokenDTOId :: !(Maybe Text) -- ^ "id" - 
  , tokenDTOFactory :: !(Maybe Text) -- ^ "factory" - 
  , tokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - 
  , tokenDTOName :: !(Maybe Text) -- ^ "name" - 
  , tokenDTODecimals :: !(Maybe Text) -- ^ "decimals" - 
  , tokenDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - 
  , tokenDTOVolume :: !(Maybe Text) -- ^ "volume" - 
  , tokenDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - 
  , tokenDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - 
  , tokenDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - 
  , tokenDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - 
  , tokenDTODerivedEth :: !(Maybe Text) -- ^ "derived_eth" - 
  , tokenDTOWhitelistPairs :: !(Maybe [Text]) -- ^ "whitelist_pairs" - 
  , tokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , tokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenDTO
instance A.FromJSON TokenDTO where
  parseJSON = A.withObject "TokenDTO" $ \o ->
    TokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "factory")
      <*> (o .:? "symbol")
      <*> (o .:? "name")
      <*> (o .:? "decimals")
      <*> (o .:? "total_supply")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "liquidity")
      <*> (o .:? "derived_eth")
      <*> (o .:? "whitelist_pairs")
      <*> (o .:? "vid")
      <*> (o .:? "token_symbol")

-- | ToJSON TokenDTO
instance A.ToJSON TokenDTO where
  toJSON TokenDTO {..} =
   _omitNulls
      [ "entry_time" .= tokenDTOEntryTime
      , "recv_time" .= tokenDTORecvTime
      , "block_number" .= tokenDTOBlockNumber
      , "id" .= tokenDTOId
      , "factory" .= tokenDTOFactory
      , "symbol" .= tokenDTOSymbol
      , "name" .= tokenDTOName
      , "decimals" .= tokenDTODecimals
      , "total_supply" .= tokenDTOTotalSupply
      , "volume" .= tokenDTOVolume
      , "volume_usd" .= tokenDTOVolumeUsd
      , "untracked_volume_usd" .= tokenDTOUntrackedVolumeUsd
      , "tx_count" .= tokenDTOTxCount
      , "liquidity" .= tokenDTOLiquidity
      , "derived_eth" .= tokenDTODerivedEth
      , "whitelist_pairs" .= tokenDTOWhitelistPairs
      , "vid" .= tokenDTOVid
      , "token_symbol" .= tokenDTOTokenSymbol
      ]


-- | Construct a value of type 'TokenDTO' (by applying it's required fields, if any)
mkTokenDTO
  :: TokenDTO
mkTokenDTO =
  TokenDTO
  { tokenDTOEntryTime = Nothing
  , tokenDTORecvTime = Nothing
  , tokenDTOBlockNumber = Nothing
  , tokenDTOId = Nothing
  , tokenDTOFactory = Nothing
  , tokenDTOSymbol = Nothing
  , tokenDTOName = Nothing
  , tokenDTODecimals = Nothing
  , tokenDTOTotalSupply = Nothing
  , tokenDTOVolume = Nothing
  , tokenDTOVolumeUsd = Nothing
  , tokenDTOUntrackedVolumeUsd = Nothing
  , tokenDTOTxCount = Nothing
  , tokenDTOLiquidity = Nothing
  , tokenDTODerivedEth = Nothing
  , tokenDTOWhitelistPairs = Nothing
  , tokenDTOVid = Nothing
  , tokenDTOTokenSymbol = Nothing
  }

-- ** TokenHourDataV3DTO
-- | TokenHourDataV3DTO
-- Token data aggregated across all pairs that include token.
data TokenHourDataV3DTO = TokenHourDataV3DTO
  { tokenHourDataV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , tokenHourDataV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , tokenHourDataV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , tokenHourDataV3DTOId :: !(Maybe Text) -- ^ "id" - token address concatendated with date
  , tokenHourDataV3DTOPeriodStartUnix :: !(Maybe Int) -- ^ "period_start_unix" - unix timestamp for start of hour
  , tokenHourDataV3DTOToken :: !(Maybe Text) -- ^ "token" - pointer to token
  , tokenHourDataV3DTOVolume :: !(Maybe Text) -- ^ "volume" - volume in token units
  , tokenHourDataV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - volume in derived USD
  , tokenHourDataV3DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - volume in USD even on pools with less reliable USD values
  , tokenHourDataV3DTOTotalValueLocked :: !(Maybe Text) -- ^ "total_value_locked" - liquidity across all pools in token units
  , tokenHourDataV3DTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - liquidity across all pools in derived USD
  , tokenHourDataV3DTOPriceUsd :: !(Maybe Text) -- ^ "price_usd" - price at end of period in USD
  , tokenHourDataV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - fees in USD
  , tokenHourDataV3DTOOpen :: !(Maybe Text) -- ^ "open" - opening price USD
  , tokenHourDataV3DTOHigh :: !(Maybe Text) -- ^ "high" - high price USD
  , tokenHourDataV3DTOLow :: !(Maybe Text) -- ^ "low" - low price USD
  , tokenHourDataV3DTOClose :: !(Maybe Text) -- ^ "close" - close price USD
  , tokenHourDataV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenHourDataV3DTO
instance A.FromJSON TokenHourDataV3DTO where
  parseJSON = A.withObject "TokenHourDataV3DTO" $ \o ->
    TokenHourDataV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "period_start_unix")
      <*> (o .:? "token")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_value_locked")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")
      <*> (o .:? "vid")

-- | ToJSON TokenHourDataV3DTO
instance A.ToJSON TokenHourDataV3DTO where
  toJSON TokenHourDataV3DTO {..} =
   _omitNulls
      [ "entry_time" .= tokenHourDataV3DTOEntryTime
      , "recv_time" .= tokenHourDataV3DTORecvTime
      , "block_number" .= tokenHourDataV3DTOBlockNumber
      , "id" .= tokenHourDataV3DTOId
      , "period_start_unix" .= tokenHourDataV3DTOPeriodStartUnix
      , "token" .= tokenHourDataV3DTOToken
      , "volume" .= tokenHourDataV3DTOVolume
      , "volume_usd" .= tokenHourDataV3DTOVolumeUsd
      , "untracked_volume_usd" .= tokenHourDataV3DTOUntrackedVolumeUsd
      , "total_value_locked" .= tokenHourDataV3DTOTotalValueLocked
      , "total_value_locked_usd" .= tokenHourDataV3DTOTotalValueLockedUsd
      , "price_usd" .= tokenHourDataV3DTOPriceUsd
      , "fees_usd" .= tokenHourDataV3DTOFeesUsd
      , "open" .= tokenHourDataV3DTOOpen
      , "high" .= tokenHourDataV3DTOHigh
      , "low" .= tokenHourDataV3DTOLow
      , "close" .= tokenHourDataV3DTOClose
      , "vid" .= tokenHourDataV3DTOVid
      ]


-- | Construct a value of type 'TokenHourDataV3DTO' (by applying it's required fields, if any)
mkTokenHourDataV3DTO
  :: TokenHourDataV3DTO
mkTokenHourDataV3DTO =
  TokenHourDataV3DTO
  { tokenHourDataV3DTOEntryTime = Nothing
  , tokenHourDataV3DTORecvTime = Nothing
  , tokenHourDataV3DTOBlockNumber = Nothing
  , tokenHourDataV3DTOId = Nothing
  , tokenHourDataV3DTOPeriodStartUnix = Nothing
  , tokenHourDataV3DTOToken = Nothing
  , tokenHourDataV3DTOVolume = Nothing
  , tokenHourDataV3DTOVolumeUsd = Nothing
  , tokenHourDataV3DTOUntrackedVolumeUsd = Nothing
  , tokenHourDataV3DTOTotalValueLocked = Nothing
  , tokenHourDataV3DTOTotalValueLockedUsd = Nothing
  , tokenHourDataV3DTOPriceUsd = Nothing
  , tokenHourDataV3DTOFeesUsd = Nothing
  , tokenHourDataV3DTOOpen = Nothing
  , tokenHourDataV3DTOHigh = Nothing
  , tokenHourDataV3DTOLow = Nothing
  , tokenHourDataV3DTOClose = Nothing
  , tokenHourDataV3DTOVid = Nothing
  }

-- ** TokenV2DTO
-- | TokenV2DTO
-- Stores aggregated information for a specific token across all pairs that token is included in.
data TokenV2DTO = TokenV2DTO
  { tokenV2DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , tokenV2DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , tokenV2DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , tokenV2DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , tokenV2DTOId :: !(Maybe Text) -- ^ "id" - token address
  , tokenV2DTOSymbol :: !(Maybe Text) -- ^ "symbol" - token symbol
  , tokenV2DTOName :: !(Maybe Text) -- ^ "name" - token name
  , tokenV2DTODecimals :: !(Maybe Int) -- ^ "decimals" - token decimals
  , tokenV2DTOTotalSupply :: !(Maybe BigInteger) -- ^ "total_supply"
  , tokenV2DTOTradeVolume :: !(Maybe Text) -- ^ "trade_volume" - amount of token traded all time across all pairs
  , tokenV2DTOTradeVolumeUsd :: !(Maybe Text) -- ^ "trade_volume_usd" - amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold)
  , tokenV2DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - amount of token in USD traded all time across pairs (no minimum liquidity threshold)
  , tokenV2DTOTxCount :: !(Maybe BigInteger) -- ^ "tx_count"
  , tokenV2DTOTotalLiquidity :: !(Maybe Text) -- ^ "total_liquidity" - total amount of token provided as liquidity across all pairs
  , tokenV2DTODerivedEth :: !(Maybe Text) -- ^ "derived_eth" - ETH per token
  , tokenV2DTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenV2DTO
instance A.FromJSON TokenV2DTO where
  parseJSON = A.withObject "TokenV2DTO" $ \o ->
    TokenV2DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "symbol")
      <*> (o .:? "name")
      <*> (o .:? "decimals")
      <*> (o .:? "total_supply")
      <*> (o .:? "trade_volume")
      <*> (o .:? "trade_volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "total_liquidity")
      <*> (o .:? "derived_eth")
      <*> (o .:? "token_symbol")

-- | ToJSON TokenV2DTO
instance A.ToJSON TokenV2DTO where
  toJSON TokenV2DTO {..} =
   _omitNulls
      [ "entry_time" .= tokenV2DTOEntryTime
      , "recv_time" .= tokenV2DTORecvTime
      , "block_number" .= tokenV2DTOBlockNumber
      , "vid" .= tokenV2DTOVid
      , "id" .= tokenV2DTOId
      , "symbol" .= tokenV2DTOSymbol
      , "name" .= tokenV2DTOName
      , "decimals" .= tokenV2DTODecimals
      , "total_supply" .= tokenV2DTOTotalSupply
      , "trade_volume" .= tokenV2DTOTradeVolume
      , "trade_volume_usd" .= tokenV2DTOTradeVolumeUsd
      , "untracked_volume_usd" .= tokenV2DTOUntrackedVolumeUsd
      , "tx_count" .= tokenV2DTOTxCount
      , "total_liquidity" .= tokenV2DTOTotalLiquidity
      , "derived_eth" .= tokenV2DTODerivedEth
      , "token_symbol" .= tokenV2DTOTokenSymbol
      ]


-- | Construct a value of type 'TokenV2DTO' (by applying it's required fields, if any)
mkTokenV2DTO
  :: TokenV2DTO
mkTokenV2DTO =
  TokenV2DTO
  { tokenV2DTOEntryTime = Nothing
  , tokenV2DTORecvTime = Nothing
  , tokenV2DTOBlockNumber = Nothing
  , tokenV2DTOVid = Nothing
  , tokenV2DTOId = Nothing
  , tokenV2DTOSymbol = Nothing
  , tokenV2DTOName = Nothing
  , tokenV2DTODecimals = Nothing
  , tokenV2DTOTotalSupply = Nothing
  , tokenV2DTOTradeVolume = Nothing
  , tokenV2DTOTradeVolumeUsd = Nothing
  , tokenV2DTOUntrackedVolumeUsd = Nothing
  , tokenV2DTOTxCount = Nothing
  , tokenV2DTOTotalLiquidity = Nothing
  , tokenV2DTODerivedEth = Nothing
  , tokenV2DTOTokenSymbol = Nothing
  }

-- ** TokenV3DTO
-- | TokenV3DTO
-- Stores aggregated information for a specific token across all pairs that token is included in.
data TokenV3DTO = TokenV3DTO
  { tokenV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , tokenV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , tokenV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , tokenV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , tokenV3DTOId :: !(Maybe Text) -- ^ "id" - token address
  , tokenV3DTOSymbol :: !(Maybe Text) -- ^ "symbol" - token symbol
  , tokenV3DTOName :: !(Maybe Text) -- ^ "name" - token name
  , tokenV3DTODecimals :: !(Maybe Int) -- ^ "decimals" - token decimals
  , tokenV3DTOTotalSupply :: !(Maybe BigInteger) -- ^ "total_supply"
  , tokenV3DTOVolume :: !(Maybe Text) -- ^ "volume" - volume in token units
  , tokenV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - volume in derived USD
  , tokenV3DTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - volume in USD even on pools with less reliable USD values
  , tokenV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - fees in USD
  , tokenV3DTOTxCount :: !(Maybe BigInteger) -- ^ "tx_count"
  , tokenV3DTOPoolCount :: !(Maybe BigInteger) -- ^ "pool_count"
  , tokenV3DTOTotalValueLocked :: !(Maybe Text) -- ^ "total_value_locked" - liquidity across all pools in token units
  , tokenV3DTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - liquidity across all pools in derived USD
  , tokenV3DTOTotalValueLockedUsdUntracked :: !(Maybe Text) -- ^ "total_value_locked_usd_untracked" - TVL derived in USD untracked
  , tokenV3DTODerivedEth :: !(Maybe Text) -- ^ "derived_eth" - derived price in ETH
  , tokenV3DTOWhitelistPools :: !(Maybe [Text]) -- ^ "whitelist_pools" - pools token is in that are white listed for USD pricing
  , tokenV3DTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenV3DTO
instance A.FromJSON TokenV3DTO where
  parseJSON = A.withObject "TokenV3DTO" $ \o ->
    TokenV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "symbol")
      <*> (o .:? "name")
      <*> (o .:? "decimals")
      <*> (o .:? "total_supply")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "pool_count")
      <*> (o .:? "total_value_locked")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "total_value_locked_usd_untracked")
      <*> (o .:? "derived_eth")
      <*> (o .:? "whitelist_pools")
      <*> (o .:? "token_symbol")

-- | ToJSON TokenV3DTO
instance A.ToJSON TokenV3DTO where
  toJSON TokenV3DTO {..} =
   _omitNulls
      [ "entry_time" .= tokenV3DTOEntryTime
      , "recv_time" .= tokenV3DTORecvTime
      , "block_number" .= tokenV3DTOBlockNumber
      , "vid" .= tokenV3DTOVid
      , "id" .= tokenV3DTOId
      , "symbol" .= tokenV3DTOSymbol
      , "name" .= tokenV3DTOName
      , "decimals" .= tokenV3DTODecimals
      , "total_supply" .= tokenV3DTOTotalSupply
      , "volume" .= tokenV3DTOVolume
      , "volume_usd" .= tokenV3DTOVolumeUsd
      , "untracked_volume_usd" .= tokenV3DTOUntrackedVolumeUsd
      , "fees_usd" .= tokenV3DTOFeesUsd
      , "tx_count" .= tokenV3DTOTxCount
      , "pool_count" .= tokenV3DTOPoolCount
      , "total_value_locked" .= tokenV3DTOTotalValueLocked
      , "total_value_locked_usd" .= tokenV3DTOTotalValueLockedUsd
      , "total_value_locked_usd_untracked" .= tokenV3DTOTotalValueLockedUsdUntracked
      , "derived_eth" .= tokenV3DTODerivedEth
      , "whitelist_pools" .= tokenV3DTOWhitelistPools
      , "token_symbol" .= tokenV3DTOTokenSymbol
      ]


-- | Construct a value of type 'TokenV3DTO' (by applying it's required fields, if any)
mkTokenV3DTO
  :: TokenV3DTO
mkTokenV3DTO =
  TokenV3DTO
  { tokenV3DTOEntryTime = Nothing
  , tokenV3DTORecvTime = Nothing
  , tokenV3DTOBlockNumber = Nothing
  , tokenV3DTOVid = Nothing
  , tokenV3DTOId = Nothing
  , tokenV3DTOSymbol = Nothing
  , tokenV3DTOName = Nothing
  , tokenV3DTODecimals = Nothing
  , tokenV3DTOTotalSupply = Nothing
  , tokenV3DTOVolume = Nothing
  , tokenV3DTOVolumeUsd = Nothing
  , tokenV3DTOUntrackedVolumeUsd = Nothing
  , tokenV3DTOFeesUsd = Nothing
  , tokenV3DTOTxCount = Nothing
  , tokenV3DTOPoolCount = Nothing
  , tokenV3DTOTotalValueLocked = Nothing
  , tokenV3DTOTotalValueLockedUsd = Nothing
  , tokenV3DTOTotalValueLockedUsdUntracked = Nothing
  , tokenV3DTODerivedEth = Nothing
  , tokenV3DTOWhitelistPools = Nothing
  , tokenV3DTOTokenSymbol = Nothing
  }

-- ** TokenV3DayDataDTO
-- | TokenV3DayDataDTO
-- Token data aggregated across all pairs that include token.
data TokenV3DayDataDTO = TokenV3DayDataDTO
  { tokenV3DayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , tokenV3DayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , tokenV3DayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , tokenV3DayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , tokenV3DayDataDTOId :: !(Maybe Text) -- ^ "id" - token address concatendated with date
  , tokenV3DayDataDTODate :: !(Maybe Int) -- ^ "date" - timestamp rounded to current day by dividing by 86400
  , tokenV3DayDataDTOToken :: !(Maybe Text) -- ^ "token" - pointer to token
  , tokenV3DayDataDTOVolume :: !(Maybe Text) -- ^ "volume" - volume in token units
  , tokenV3DayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - volume in derived USD
  , tokenV3DayDataDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - volume in USD even on pools with less reliable USD values
  , tokenV3DayDataDTOTotalValueLocked :: !(Maybe Text) -- ^ "total_value_locked" - liquidity across all pools in token units
  , tokenV3DayDataDTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - liquidity across all pools in derived USD
  , tokenV3DayDataDTOPriceUsd :: !(Maybe Text) -- ^ "price_usd" - price at end of period in USD
  , tokenV3DayDataDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - fees in USD
  , tokenV3DayDataDTOOpen :: !(Maybe Text) -- ^ "open" - opening price USD
  , tokenV3DayDataDTOHigh :: !(Maybe Text) -- ^ "high" - high price USD
  , tokenV3DayDataDTOLow :: !(Maybe Text) -- ^ "low" - low price USD
  , tokenV3DayDataDTOClose :: !(Maybe Text) -- ^ "close" - close price USD
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenV3DayDataDTO
instance A.FromJSON TokenV3DayDataDTO where
  parseJSON = A.withObject "TokenV3DayDataDTO" $ \o ->
    TokenV3DayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "token")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_value_locked")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")

-- | ToJSON TokenV3DayDataDTO
instance A.ToJSON TokenV3DayDataDTO where
  toJSON TokenV3DayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= tokenV3DayDataDTOEntryTime
      , "recv_time" .= tokenV3DayDataDTORecvTime
      , "block_number" .= tokenV3DayDataDTOBlockNumber
      , "vid" .= tokenV3DayDataDTOVid
      , "id" .= tokenV3DayDataDTOId
      , "date" .= tokenV3DayDataDTODate
      , "token" .= tokenV3DayDataDTOToken
      , "volume" .= tokenV3DayDataDTOVolume
      , "volume_usd" .= tokenV3DayDataDTOVolumeUsd
      , "untracked_volume_usd" .= tokenV3DayDataDTOUntrackedVolumeUsd
      , "total_value_locked" .= tokenV3DayDataDTOTotalValueLocked
      , "total_value_locked_usd" .= tokenV3DayDataDTOTotalValueLockedUsd
      , "price_usd" .= tokenV3DayDataDTOPriceUsd
      , "fees_usd" .= tokenV3DayDataDTOFeesUsd
      , "open" .= tokenV3DayDataDTOOpen
      , "high" .= tokenV3DayDataDTOHigh
      , "low" .= tokenV3DayDataDTOLow
      , "close" .= tokenV3DayDataDTOClose
      ]


-- | Construct a value of type 'TokenV3DayDataDTO' (by applying it's required fields, if any)
mkTokenV3DayDataDTO
  :: TokenV3DayDataDTO
mkTokenV3DayDataDTO =
  TokenV3DayDataDTO
  { tokenV3DayDataDTOEntryTime = Nothing
  , tokenV3DayDataDTORecvTime = Nothing
  , tokenV3DayDataDTOBlockNumber = Nothing
  , tokenV3DayDataDTOVid = Nothing
  , tokenV3DayDataDTOId = Nothing
  , tokenV3DayDataDTODate = Nothing
  , tokenV3DayDataDTOToken = Nothing
  , tokenV3DayDataDTOVolume = Nothing
  , tokenV3DayDataDTOVolumeUsd = Nothing
  , tokenV3DayDataDTOUntrackedVolumeUsd = Nothing
  , tokenV3DayDataDTOTotalValueLocked = Nothing
  , tokenV3DayDataDTOTotalValueLockedUsd = Nothing
  , tokenV3DayDataDTOPriceUsd = Nothing
  , tokenV3DayDataDTOFeesUsd = Nothing
  , tokenV3DayDataDTOOpen = Nothing
  , tokenV3DayDataDTOHigh = Nothing
  , tokenV3DayDataDTOLow = Nothing
  , tokenV3DayDataDTOClose = Nothing
  }

-- ** UniswapDayDataV3DTO
-- | UniswapDayDataV3DTO
-- Data accumulated and condensed into day stats for all of Uniswap
data UniswapDayDataV3DTO = UniswapDayDataV3DTO
  { uniswapDayDataV3DTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapDayDataV3DTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapDayDataV3DTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - 
  , uniswapDayDataV3DTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapDayDataV3DTOId :: !(Maybe Text) -- ^ "id" - timestamp rounded to current day by dividing by 86400
  , uniswapDayDataV3DTODate :: !(Maybe Int) -- ^ "date" - timestamp rounded to current day by dividing by 86400
  , uniswapDayDataV3DTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - total volume across all pairs on this day, stored as a derived amount of ETH
  , uniswapDayDataV3DTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - total volume across all pairs on this day, stored as a derived amount of USD
  , uniswapDayDataV3DTOVolumeUsdUntracked :: !(Maybe Text) -- ^ "volume_usd_untracked" - total daily volume in Uniswap derived in terms of USD untracked
  , uniswapDayDataV3DTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - fees in USD
  , uniswapDayDataV3DTOTxCount :: !(Maybe BigInteger) -- ^ "tx_count"
  , uniswapDayDataV3DTOTvlUsd :: !(Maybe Text) -- ^ "tvl_usd" - tvl in terms of USD
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapDayDataV3DTO
instance A.FromJSON UniswapDayDataV3DTO where
  parseJSON = A.withObject "UniswapDayDataV3DTO" $ \o ->
    UniswapDayDataV3DTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "volume_eth")
      <*> (o .:? "volume_usd")
      <*> (o .:? "volume_usd_untracked")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "tvl_usd")

-- | ToJSON UniswapDayDataV3DTO
instance A.ToJSON UniswapDayDataV3DTO where
  toJSON UniswapDayDataV3DTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapDayDataV3DTOEntryTime
      , "recv_time" .= uniswapDayDataV3DTORecvTime
      , "block_number" .= uniswapDayDataV3DTOBlockNumber
      , "vid" .= uniswapDayDataV3DTOVid
      , "id" .= uniswapDayDataV3DTOId
      , "date" .= uniswapDayDataV3DTODate
      , "volume_eth" .= uniswapDayDataV3DTOVolumeEth
      , "volume_usd" .= uniswapDayDataV3DTOVolumeUsd
      , "volume_usd_untracked" .= uniswapDayDataV3DTOVolumeUsdUntracked
      , "fees_usd" .= uniswapDayDataV3DTOFeesUsd
      , "tx_count" .= uniswapDayDataV3DTOTxCount
      , "tvl_usd" .= uniswapDayDataV3DTOTvlUsd
      ]


-- | Construct a value of type 'UniswapDayDataV3DTO' (by applying it's required fields, if any)
mkUniswapDayDataV3DTO
  :: UniswapDayDataV3DTO
mkUniswapDayDataV3DTO =
  UniswapDayDataV3DTO
  { uniswapDayDataV3DTOEntryTime = Nothing
  , uniswapDayDataV3DTORecvTime = Nothing
  , uniswapDayDataV3DTOBlockNumber = Nothing
  , uniswapDayDataV3DTOVid = Nothing
  , uniswapDayDataV3DTOId = Nothing
  , uniswapDayDataV3DTODate = Nothing
  , uniswapDayDataV3DTOVolumeEth = Nothing
  , uniswapDayDataV3DTOVolumeUsd = Nothing
  , uniswapDayDataV3DTOVolumeUsdUntracked = Nothing
  , uniswapDayDataV3DTOFeesUsd = Nothing
  , uniswapDayDataV3DTOTxCount = Nothing
  , uniswapDayDataV3DTOTvlUsd = Nothing
  }


-- * Enums


-- ** ETradeAggressiveSide

-- | Enum of 'Text'
data ETradeAggressiveSide
  = ETradeAggressiveSide'Buy -- ^ @"Buy"@
  | ETradeAggressiveSide'Sell -- ^ @"Sell"@
  | ETradeAggressiveSide'EstimatedBuy -- ^ @"EstimatedBuy"@
  | ETradeAggressiveSide'EstimatedSell -- ^ @"EstimatedSell"@
  | ETradeAggressiveSide'Unknown -- ^ @"Unknown"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ETradeAggressiveSide where toJSON = A.toJSON . fromETradeAggressiveSide
instance A.FromJSON ETradeAggressiveSide where parseJSON o = P.either P.fail (pure . P.id) . toETradeAggressiveSide =<< A.parseJSON o
instance WH.ToHttpApiData ETradeAggressiveSide where toQueryParam = WH.toQueryParam . fromETradeAggressiveSide
instance WH.FromHttpApiData ETradeAggressiveSide where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toETradeAggressiveSide
instance MimeRender MimeMultipartFormData ETradeAggressiveSide where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ETradeAggressiveSide' enum
fromETradeAggressiveSide :: ETradeAggressiveSide -> Text
fromETradeAggressiveSide = \case
  ETradeAggressiveSide'Buy -> "Buy"
  ETradeAggressiveSide'Sell -> "Sell"
  ETradeAggressiveSide'EstimatedBuy -> "EstimatedBuy"
  ETradeAggressiveSide'EstimatedSell -> "EstimatedSell"
  ETradeAggressiveSide'Unknown -> "Unknown"

-- | parse 'ETradeAggressiveSide' enum
toETradeAggressiveSide :: Text -> P.Either String ETradeAggressiveSide
toETradeAggressiveSide = \case
  "Buy" -> P.Right ETradeAggressiveSide'Buy
  "Sell" -> P.Right ETradeAggressiveSide'Sell
  "EstimatedBuy" -> P.Right ETradeAggressiveSide'EstimatedBuy
  "EstimatedSell" -> P.Right ETradeAggressiveSide'EstimatedSell
  "Unknown" -> P.Right ETradeAggressiveSide'Unknown
  s -> P.Left $ "toETradeAggressiveSide: enum parse failure: " P.++ P.show s



