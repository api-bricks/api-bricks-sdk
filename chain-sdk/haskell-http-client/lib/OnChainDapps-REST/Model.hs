{-
   On Chain Dapps - REST API

    This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

   OpenAPI Version: 3.0.1
   On Chain Dapps - REST API API version: v1
   Contact: support@coinapi.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OnChainDapps-REST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OnChainDapps-REST.Model where

import OnChainDapps-REST.Core
import OnChainDapps-REST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Address
newtype Address = Address { unAddress :: Text } deriving (P.Eq, P.Show)

-- ** BuyToken
newtype BuyToken = BuyToken { unBuyToken :: Text } deriving (P.Eq, P.Show)

-- ** DappName
newtype DappName = DappName { unDappName :: Text } deriving (P.Eq, P.Show)

-- ** EndBlock
newtype EndBlock = EndBlock { unEndBlock :: Integer } deriving (P.Eq, P.Show)

-- ** EndDate
newtype EndDate = EndDate { unEndDate :: DateTime } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Pair
newtype Pair = Pair { unPair :: Text } deriving (P.Eq, P.Show)

-- ** Pool
newtype Pool = Pool { unPool :: Text } deriving (P.Eq, P.Show)

-- ** SellToken
newtype SellToken = SellToken { unSellToken :: Text } deriving (P.Eq, P.Show)

-- ** StartBlock
newtype StartBlock = StartBlock { unStartBlock :: Integer } deriving (P.Eq, P.Show)

-- ** StartDate
newtype StartDate = StartDate { unStartDate :: DateTime } deriving (P.Eq, P.Show)

-- ** Symbol
newtype Symbol = Symbol { unSymbol :: Text } deriving (P.Eq, P.Show)

-- ** Token0
newtype Token0 = Token0 { unToken0 :: Text } deriving (P.Eq, P.Show)

-- ** Token1
newtype Token1 = Token1 { unToken1 :: Text } deriving (P.Eq, P.Show)

-- ** User
newtype User = User { unUser :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** CRYPTOPUNKSBidDTO
-- | CRYPTOPUNKSBidDTO
data CRYPTOPUNKSBidDTO = CRYPTOPUNKSBidDTO
  { cRYPTOPUNKSBidDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cRYPTOPUNKSBidDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cRYPTOPUNKSBidDTOBlockNumber :: !(Maybe Text) -- ^ "block_number" - 
  , cRYPTOPUNKSBidDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cRYPTOPUNKSBidDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  , cRYPTOPUNKSBidDTOId :: !(Maybe Text) -- ^ "id" - 
  , cRYPTOPUNKSBidDTOTokensBid :: !(Maybe Text) -- ^ "tokens_bid" - 
  , cRYPTOPUNKSBidDTOTokenId :: !(Maybe Text) -- ^ "token_id" - 
  , cRYPTOPUNKSBidDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , cRYPTOPUNKSBidDTOBidder :: !(Maybe Text) -- ^ "bidder" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CRYPTOPUNKSBidDTO
instance A.FromJSON CRYPTOPUNKSBidDTO where
  parseJSON = A.withObject "CRYPTOPUNKSBidDTO" $ \o ->
    CRYPTOPUNKSBidDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")
      <*> (o .:? "id")
      <*> (o .:? "tokens_bid")
      <*> (o .:? "token_id")
      <*> (o .:? "timestamp")
      <*> (o .:? "bidder")

-- | ToJSON CRYPTOPUNKSBidDTO
instance A.ToJSON CRYPTOPUNKSBidDTO where
  toJSON CRYPTOPUNKSBidDTO {..} =
   _omitNulls
      [ "entry_time" .= cRYPTOPUNKSBidDTOEntryTime
      , "recv_time" .= cRYPTOPUNKSBidDTORecvTime
      , "block_number" .= cRYPTOPUNKSBidDTOBlockNumber
      , "vid" .= cRYPTOPUNKSBidDTOVid
      , "block_range" .= cRYPTOPUNKSBidDTOBlockRange
      , "id" .= cRYPTOPUNKSBidDTOId
      , "tokens_bid" .= cRYPTOPUNKSBidDTOTokensBid
      , "token_id" .= cRYPTOPUNKSBidDTOTokenId
      , "timestamp" .= cRYPTOPUNKSBidDTOTimestamp
      , "bidder" .= cRYPTOPUNKSBidDTOBidder
      ]


-- | Construct a value of type 'CRYPTOPUNKSBidDTO' (by applying it's required fields, if any)
mkCRYPTOPUNKSBidDTO
  :: CRYPTOPUNKSBidDTO
mkCRYPTOPUNKSBidDTO =
  CRYPTOPUNKSBidDTO
  { cRYPTOPUNKSBidDTOEntryTime = Nothing
  , cRYPTOPUNKSBidDTORecvTime = Nothing
  , cRYPTOPUNKSBidDTOBlockNumber = Nothing
  , cRYPTOPUNKSBidDTOVid = Nothing
  , cRYPTOPUNKSBidDTOBlockRange = Nothing
  , cRYPTOPUNKSBidDTOId = Nothing
  , cRYPTOPUNKSBidDTOTokensBid = Nothing
  , cRYPTOPUNKSBidDTOTokenId = Nothing
  , cRYPTOPUNKSBidDTOTimestamp = Nothing
  , cRYPTOPUNKSBidDTOBidder = Nothing
  }

-- ** CRYPTOPUNKSCollectionDTO
-- | CRYPTOPUNKSCollectionDTO
data CRYPTOPUNKSCollectionDTO = CRYPTOPUNKSCollectionDTO
  { cRYPTOPUNKSCollectionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cRYPTOPUNKSCollectionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cRYPTOPUNKSCollectionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cRYPTOPUNKSCollectionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cRYPTOPUNKSCollectionDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  , cRYPTOPUNKSCollectionDTOId :: !(Maybe Text) -- ^ "id" - 
  , cRYPTOPUNKSCollectionDTOName :: !(Maybe Text) -- ^ "name" - 
  , cRYPTOPUNKSCollectionDTOSymbol :: !(Maybe Text) -- ^ "symbol" - 
  , cRYPTOPUNKSCollectionDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - 
  , cRYPTOPUNKSCollectionDTORoyaltyFee :: !(Maybe Text) -- ^ "royalty_fee" - 
  , cRYPTOPUNKSCollectionDTOCumulativeTradeVolumeEth :: !(Maybe Text) -- ^ "cumulative_trade_volume_eth" - 
  , cRYPTOPUNKSCollectionDTOMarketplaceRevenueEth :: !(Maybe Text) -- ^ "marketplace_revenue_eth" - 
  , cRYPTOPUNKSCollectionDTOCreatorRevenueEth :: !(Maybe Text) -- ^ "creator_revenue_eth" - 
  , cRYPTOPUNKSCollectionDTOTotalRevenueEth :: !(Maybe Text) -- ^ "total_revenue_eth" - 
  , cRYPTOPUNKSCollectionDTOTradeCount :: !(Maybe Int) -- ^ "trade_count" - 
  , cRYPTOPUNKSCollectionDTOBuyerCount :: !(Maybe Int) -- ^ "buyer_count" - 
  , cRYPTOPUNKSCollectionDTOSellerCount :: !(Maybe Int) -- ^ "seller_count" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CRYPTOPUNKSCollectionDTO
instance A.FromJSON CRYPTOPUNKSCollectionDTO where
  parseJSON = A.withObject "CRYPTOPUNKSCollectionDTO" $ \o ->
    CRYPTOPUNKSCollectionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "symbol")
      <*> (o .:? "total_supply")
      <*> (o .:? "royalty_fee")
      <*> (o .:? "cumulative_trade_volume_eth")
      <*> (o .:? "marketplace_revenue_eth")
      <*> (o .:? "creator_revenue_eth")
      <*> (o .:? "total_revenue_eth")
      <*> (o .:? "trade_count")
      <*> (o .:? "buyer_count")
      <*> (o .:? "seller_count")

-- | ToJSON CRYPTOPUNKSCollectionDTO
instance A.ToJSON CRYPTOPUNKSCollectionDTO where
  toJSON CRYPTOPUNKSCollectionDTO {..} =
   _omitNulls
      [ "entry_time" .= cRYPTOPUNKSCollectionDTOEntryTime
      , "recv_time" .= cRYPTOPUNKSCollectionDTORecvTime
      , "block_number" .= cRYPTOPUNKSCollectionDTOBlockNumber
      , "vid" .= cRYPTOPUNKSCollectionDTOVid
      , "block_range" .= cRYPTOPUNKSCollectionDTOBlockRange
      , "id" .= cRYPTOPUNKSCollectionDTOId
      , "name" .= cRYPTOPUNKSCollectionDTOName
      , "symbol" .= cRYPTOPUNKSCollectionDTOSymbol
      , "total_supply" .= cRYPTOPUNKSCollectionDTOTotalSupply
      , "royalty_fee" .= cRYPTOPUNKSCollectionDTORoyaltyFee
      , "cumulative_trade_volume_eth" .= cRYPTOPUNKSCollectionDTOCumulativeTradeVolumeEth
      , "marketplace_revenue_eth" .= cRYPTOPUNKSCollectionDTOMarketplaceRevenueEth
      , "creator_revenue_eth" .= cRYPTOPUNKSCollectionDTOCreatorRevenueEth
      , "total_revenue_eth" .= cRYPTOPUNKSCollectionDTOTotalRevenueEth
      , "trade_count" .= cRYPTOPUNKSCollectionDTOTradeCount
      , "buyer_count" .= cRYPTOPUNKSCollectionDTOBuyerCount
      , "seller_count" .= cRYPTOPUNKSCollectionDTOSellerCount
      ]


-- | Construct a value of type 'CRYPTOPUNKSCollectionDTO' (by applying it's required fields, if any)
mkCRYPTOPUNKSCollectionDTO
  :: CRYPTOPUNKSCollectionDTO
mkCRYPTOPUNKSCollectionDTO =
  CRYPTOPUNKSCollectionDTO
  { cRYPTOPUNKSCollectionDTOEntryTime = Nothing
  , cRYPTOPUNKSCollectionDTORecvTime = Nothing
  , cRYPTOPUNKSCollectionDTOBlockNumber = Nothing
  , cRYPTOPUNKSCollectionDTOVid = Nothing
  , cRYPTOPUNKSCollectionDTOBlockRange = Nothing
  , cRYPTOPUNKSCollectionDTOId = Nothing
  , cRYPTOPUNKSCollectionDTOName = Nothing
  , cRYPTOPUNKSCollectionDTOSymbol = Nothing
  , cRYPTOPUNKSCollectionDTOTotalSupply = Nothing
  , cRYPTOPUNKSCollectionDTORoyaltyFee = Nothing
  , cRYPTOPUNKSCollectionDTOCumulativeTradeVolumeEth = Nothing
  , cRYPTOPUNKSCollectionDTOMarketplaceRevenueEth = Nothing
  , cRYPTOPUNKSCollectionDTOCreatorRevenueEth = Nothing
  , cRYPTOPUNKSCollectionDTOTotalRevenueEth = Nothing
  , cRYPTOPUNKSCollectionDTOTradeCount = Nothing
  , cRYPTOPUNKSCollectionDTOBuyerCount = Nothing
  , cRYPTOPUNKSCollectionDTOSellerCount = Nothing
  }

-- ** CRYPTOPUNKSCollectionDailySnapshotDTO
-- | CRYPTOPUNKSCollectionDailySnapshotDTO
data CRYPTOPUNKSCollectionDailySnapshotDTO = CRYPTOPUNKSCollectionDailySnapshotDTO
  { cRYPTOPUNKSCollectionDailySnapshotDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cRYPTOPUNKSCollectionDailySnapshotDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cRYPTOPUNKSCollectionDailySnapshotDTOBlockNumber :: !(Maybe Text) -- ^ "block_number" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTOId :: !(Maybe Text) -- ^ "id" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTOCollection :: !(Maybe Text) -- ^ "collection" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTORoyaltyFee :: !(Maybe Text) -- ^ "royalty_fee" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTODailyMinSalePrice :: !(Maybe Text) -- ^ "daily_min_sale_price" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTODailyMaxSalePrice :: !(Maybe Text) -- ^ "daily_max_sale_price" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTOCumulativeTradeVolumeEth :: !(Maybe Text) -- ^ "cumulative_trade_volume_eth" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTODailyTradeVolumeEth :: !(Maybe Text) -- ^ "daily_trade_volume_eth" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTOMarketplaceRevenueEth :: !(Maybe Text) -- ^ "marketplace_revenue_eth" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTOCreatorRevenueEth :: !(Maybe Text) -- ^ "creator_revenue_eth" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTOTotalRevenueEth :: !(Maybe Text) -- ^ "total_revenue_eth" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTOTradeCount :: !(Maybe Int) -- ^ "trade_count" - 
  , cRYPTOPUNKSCollectionDailySnapshotDTODailyTradedItemCount :: !(Maybe Int) -- ^ "daily_traded_item_count" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CRYPTOPUNKSCollectionDailySnapshotDTO
instance A.FromJSON CRYPTOPUNKSCollectionDailySnapshotDTO where
  parseJSON = A.withObject "CRYPTOPUNKSCollectionDailySnapshotDTO" $ \o ->
    CRYPTOPUNKSCollectionDailySnapshotDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")
      <*> (o .:? "id")
      <*> (o .:? "collection")
      <*> (o .:? "timestamp")
      <*> (o .:? "royalty_fee")
      <*> (o .:? "daily_min_sale_price")
      <*> (o .:? "daily_max_sale_price")
      <*> (o .:? "cumulative_trade_volume_eth")
      <*> (o .:? "daily_trade_volume_eth")
      <*> (o .:? "marketplace_revenue_eth")
      <*> (o .:? "creator_revenue_eth")
      <*> (o .:? "total_revenue_eth")
      <*> (o .:? "trade_count")
      <*> (o .:? "daily_traded_item_count")

-- | ToJSON CRYPTOPUNKSCollectionDailySnapshotDTO
instance A.ToJSON CRYPTOPUNKSCollectionDailySnapshotDTO where
  toJSON CRYPTOPUNKSCollectionDailySnapshotDTO {..} =
   _omitNulls
      [ "entry_time" .= cRYPTOPUNKSCollectionDailySnapshotDTOEntryTime
      , "recv_time" .= cRYPTOPUNKSCollectionDailySnapshotDTORecvTime
      , "block_number" .= cRYPTOPUNKSCollectionDailySnapshotDTOBlockNumber
      , "vid" .= cRYPTOPUNKSCollectionDailySnapshotDTOVid
      , "block_range" .= cRYPTOPUNKSCollectionDailySnapshotDTOBlockRange
      , "id" .= cRYPTOPUNKSCollectionDailySnapshotDTOId
      , "collection" .= cRYPTOPUNKSCollectionDailySnapshotDTOCollection
      , "timestamp" .= cRYPTOPUNKSCollectionDailySnapshotDTOTimestamp
      , "royalty_fee" .= cRYPTOPUNKSCollectionDailySnapshotDTORoyaltyFee
      , "daily_min_sale_price" .= cRYPTOPUNKSCollectionDailySnapshotDTODailyMinSalePrice
      , "daily_max_sale_price" .= cRYPTOPUNKSCollectionDailySnapshotDTODailyMaxSalePrice
      , "cumulative_trade_volume_eth" .= cRYPTOPUNKSCollectionDailySnapshotDTOCumulativeTradeVolumeEth
      , "daily_trade_volume_eth" .= cRYPTOPUNKSCollectionDailySnapshotDTODailyTradeVolumeEth
      , "marketplace_revenue_eth" .= cRYPTOPUNKSCollectionDailySnapshotDTOMarketplaceRevenueEth
      , "creator_revenue_eth" .= cRYPTOPUNKSCollectionDailySnapshotDTOCreatorRevenueEth
      , "total_revenue_eth" .= cRYPTOPUNKSCollectionDailySnapshotDTOTotalRevenueEth
      , "trade_count" .= cRYPTOPUNKSCollectionDailySnapshotDTOTradeCount
      , "daily_traded_item_count" .= cRYPTOPUNKSCollectionDailySnapshotDTODailyTradedItemCount
      ]


-- | Construct a value of type 'CRYPTOPUNKSCollectionDailySnapshotDTO' (by applying it's required fields, if any)
mkCRYPTOPUNKSCollectionDailySnapshotDTO
  :: CRYPTOPUNKSCollectionDailySnapshotDTO
mkCRYPTOPUNKSCollectionDailySnapshotDTO =
  CRYPTOPUNKSCollectionDailySnapshotDTO
  { cRYPTOPUNKSCollectionDailySnapshotDTOEntryTime = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTORecvTime = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOBlockNumber = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOVid = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOBlockRange = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOId = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOCollection = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOTimestamp = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTORoyaltyFee = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTODailyMinSalePrice = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTODailyMaxSalePrice = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOCumulativeTradeVolumeEth = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTODailyTradeVolumeEth = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOMarketplaceRevenueEth = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOCreatorRevenueEth = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOTotalRevenueEth = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTOTradeCount = Nothing
  , cRYPTOPUNKSCollectionDailySnapshotDTODailyTradedItemCount = Nothing
  }

-- ** CRYPTOPUNKSDataSourcesDTO
-- | CRYPTOPUNKSDataSourcesDTO
data CRYPTOPUNKSDataSourcesDTO = CRYPTOPUNKSDataSourcesDTO
  { cRYPTOPUNKSDataSourcesDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cRYPTOPUNKSDataSourcesDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cRYPTOPUNKSDataSourcesDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cRYPTOPUNKSDataSourcesDTOVid :: !(Maybe Int) -- ^ "vid" - 
  , cRYPTOPUNKSDataSourcesDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  , cRYPTOPUNKSDataSourcesDTOCausalityRegion :: !(Maybe Int) -- ^ "causality_region" - 
  , cRYPTOPUNKSDataSourcesDTOManifestIdx :: !(Maybe Int) -- ^ "manifest_idx" - 
  , cRYPTOPUNKSDataSourcesDTOParent :: !(Maybe Int) -- ^ "parent" - 
  , cRYPTOPUNKSDataSourcesDTOId :: !(Maybe Text) -- ^ "id" - 
  , cRYPTOPUNKSDataSourcesDTOParam :: !(Maybe Text) -- ^ "param" - 
  , cRYPTOPUNKSDataSourcesDTOContext :: !(Maybe Text) -- ^ "context" - 
  , cRYPTOPUNKSDataSourcesDTODoneAt :: !(Maybe Int) -- ^ "done_at" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CRYPTOPUNKSDataSourcesDTO
instance A.FromJSON CRYPTOPUNKSDataSourcesDTO where
  parseJSON = A.withObject "CRYPTOPUNKSDataSourcesDTO" $ \o ->
    CRYPTOPUNKSDataSourcesDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")
      <*> (o .:? "causality_region")
      <*> (o .:? "manifest_idx")
      <*> (o .:? "parent")
      <*> (o .:? "id")
      <*> (o .:? "param")
      <*> (o .:? "context")
      <*> (o .:? "done_at")

-- | ToJSON CRYPTOPUNKSDataSourcesDTO
instance A.ToJSON CRYPTOPUNKSDataSourcesDTO where
  toJSON CRYPTOPUNKSDataSourcesDTO {..} =
   _omitNulls
      [ "entry_time" .= cRYPTOPUNKSDataSourcesDTOEntryTime
      , "recv_time" .= cRYPTOPUNKSDataSourcesDTORecvTime
      , "block_number" .= cRYPTOPUNKSDataSourcesDTOBlockNumber
      , "vid" .= cRYPTOPUNKSDataSourcesDTOVid
      , "block_range" .= cRYPTOPUNKSDataSourcesDTOBlockRange
      , "causality_region" .= cRYPTOPUNKSDataSourcesDTOCausalityRegion
      , "manifest_idx" .= cRYPTOPUNKSDataSourcesDTOManifestIdx
      , "parent" .= cRYPTOPUNKSDataSourcesDTOParent
      , "id" .= cRYPTOPUNKSDataSourcesDTOId
      , "param" .= cRYPTOPUNKSDataSourcesDTOParam
      , "context" .= cRYPTOPUNKSDataSourcesDTOContext
      , "done_at" .= cRYPTOPUNKSDataSourcesDTODoneAt
      ]


-- | Construct a value of type 'CRYPTOPUNKSDataSourcesDTO' (by applying it's required fields, if any)
mkCRYPTOPUNKSDataSourcesDTO
  :: CRYPTOPUNKSDataSourcesDTO
mkCRYPTOPUNKSDataSourcesDTO =
  CRYPTOPUNKSDataSourcesDTO
  { cRYPTOPUNKSDataSourcesDTOEntryTime = Nothing
  , cRYPTOPUNKSDataSourcesDTORecvTime = Nothing
  , cRYPTOPUNKSDataSourcesDTOBlockNumber = Nothing
  , cRYPTOPUNKSDataSourcesDTOVid = Nothing
  , cRYPTOPUNKSDataSourcesDTOBlockRange = Nothing
  , cRYPTOPUNKSDataSourcesDTOCausalityRegion = Nothing
  , cRYPTOPUNKSDataSourcesDTOManifestIdx = Nothing
  , cRYPTOPUNKSDataSourcesDTOParent = Nothing
  , cRYPTOPUNKSDataSourcesDTOId = Nothing
  , cRYPTOPUNKSDataSourcesDTOParam = Nothing
  , cRYPTOPUNKSDataSourcesDTOContext = Nothing
  , cRYPTOPUNKSDataSourcesDTODoneAt = Nothing
  }

-- ** CRYPTOPUNKSItemDTO
-- | CRYPTOPUNKSItemDTO
data CRYPTOPUNKSItemDTO = CRYPTOPUNKSItemDTO
  { cRYPTOPUNKSItemDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cRYPTOPUNKSItemDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cRYPTOPUNKSItemDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cRYPTOPUNKSItemDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cRYPTOPUNKSItemDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  , cRYPTOPUNKSItemDTOId :: !(Maybe Text) -- ^ "id" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CRYPTOPUNKSItemDTO
instance A.FromJSON CRYPTOPUNKSItemDTO where
  parseJSON = A.withObject "CRYPTOPUNKSItemDTO" $ \o ->
    CRYPTOPUNKSItemDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")
      <*> (o .:? "id")

-- | ToJSON CRYPTOPUNKSItemDTO
instance A.ToJSON CRYPTOPUNKSItemDTO where
  toJSON CRYPTOPUNKSItemDTO {..} =
   _omitNulls
      [ "entry_time" .= cRYPTOPUNKSItemDTOEntryTime
      , "recv_time" .= cRYPTOPUNKSItemDTORecvTime
      , "block_number" .= cRYPTOPUNKSItemDTOBlockNumber
      , "vid" .= cRYPTOPUNKSItemDTOVid
      , "block_range" .= cRYPTOPUNKSItemDTOBlockRange
      , "id" .= cRYPTOPUNKSItemDTOId
      ]


-- | Construct a value of type 'CRYPTOPUNKSItemDTO' (by applying it's required fields, if any)
mkCRYPTOPUNKSItemDTO
  :: CRYPTOPUNKSItemDTO
mkCRYPTOPUNKSItemDTO =
  CRYPTOPUNKSItemDTO
  { cRYPTOPUNKSItemDTOEntryTime = Nothing
  , cRYPTOPUNKSItemDTORecvTime = Nothing
  , cRYPTOPUNKSItemDTOBlockNumber = Nothing
  , cRYPTOPUNKSItemDTOVid = Nothing
  , cRYPTOPUNKSItemDTOBlockRange = Nothing
  , cRYPTOPUNKSItemDTOId = Nothing
  }

-- ** CRYPTOPUNKSMarketPlaceDTO
-- | CRYPTOPUNKSMarketPlaceDTO
data CRYPTOPUNKSMarketPlaceDTO = CRYPTOPUNKSMarketPlaceDTO
  { cRYPTOPUNKSMarketPlaceDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cRYPTOPUNKSMarketPlaceDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cRYPTOPUNKSMarketPlaceDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cRYPTOPUNKSMarketPlaceDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cRYPTOPUNKSMarketPlaceDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  , cRYPTOPUNKSMarketPlaceDTOId :: !(Maybe Text) -- ^ "id" - 
  , cRYPTOPUNKSMarketPlaceDTOName :: !(Maybe Text) -- ^ "name" - 
  , cRYPTOPUNKSMarketPlaceDTOSlug :: !(Maybe Text) -- ^ "slug" - 
  , cRYPTOPUNKSMarketPlaceDTOSchemaVersion :: !(Maybe Text) -- ^ "schema_version" - 
  , cRYPTOPUNKSMarketPlaceDTOSubgraphVersion :: !(Maybe Text) -- ^ "subgraph_version" - 
  , cRYPTOPUNKSMarketPlaceDTOMethodologyVersion :: !(Maybe Text) -- ^ "methodology_version" - 
  , cRYPTOPUNKSMarketPlaceDTOCollectionCount :: !(Maybe Int) -- ^ "collection_count" - 
  , cRYPTOPUNKSMarketPlaceDTOTradeCount :: !(Maybe Int) -- ^ "trade_count" - 
  , cRYPTOPUNKSMarketPlaceDTOCumulativeTradeVolumeEth :: !(Maybe Text) -- ^ "cumulative_trade_volume_eth" - 
  , cRYPTOPUNKSMarketPlaceDTOMarketplaceRevenueEth :: !(Maybe Text) -- ^ "marketplace_revenue_eth" - 
  , cRYPTOPUNKSMarketPlaceDTOCreatorRevenueEth :: !(Maybe Text) -- ^ "creator_revenue_eth" - 
  , cRYPTOPUNKSMarketPlaceDTOTotalRevenueEth :: !(Maybe Text) -- ^ "total_revenue_eth" - 
  , cRYPTOPUNKSMarketPlaceDTOCumulativeUniqueTraders :: !(Maybe Int) -- ^ "cumulative_unique_traders" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CRYPTOPUNKSMarketPlaceDTO
instance A.FromJSON CRYPTOPUNKSMarketPlaceDTO where
  parseJSON = A.withObject "CRYPTOPUNKSMarketPlaceDTO" $ \o ->
    CRYPTOPUNKSMarketPlaceDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "slug")
      <*> (o .:? "schema_version")
      <*> (o .:? "subgraph_version")
      <*> (o .:? "methodology_version")
      <*> (o .:? "collection_count")
      <*> (o .:? "trade_count")
      <*> (o .:? "cumulative_trade_volume_eth")
      <*> (o .:? "marketplace_revenue_eth")
      <*> (o .:? "creator_revenue_eth")
      <*> (o .:? "total_revenue_eth")
      <*> (o .:? "cumulative_unique_traders")

-- | ToJSON CRYPTOPUNKSMarketPlaceDTO
instance A.ToJSON CRYPTOPUNKSMarketPlaceDTO where
  toJSON CRYPTOPUNKSMarketPlaceDTO {..} =
   _omitNulls
      [ "entry_time" .= cRYPTOPUNKSMarketPlaceDTOEntryTime
      , "recv_time" .= cRYPTOPUNKSMarketPlaceDTORecvTime
      , "block_number" .= cRYPTOPUNKSMarketPlaceDTOBlockNumber
      , "vid" .= cRYPTOPUNKSMarketPlaceDTOVid
      , "block_range" .= cRYPTOPUNKSMarketPlaceDTOBlockRange
      , "id" .= cRYPTOPUNKSMarketPlaceDTOId
      , "name" .= cRYPTOPUNKSMarketPlaceDTOName
      , "slug" .= cRYPTOPUNKSMarketPlaceDTOSlug
      , "schema_version" .= cRYPTOPUNKSMarketPlaceDTOSchemaVersion
      , "subgraph_version" .= cRYPTOPUNKSMarketPlaceDTOSubgraphVersion
      , "methodology_version" .= cRYPTOPUNKSMarketPlaceDTOMethodologyVersion
      , "collection_count" .= cRYPTOPUNKSMarketPlaceDTOCollectionCount
      , "trade_count" .= cRYPTOPUNKSMarketPlaceDTOTradeCount
      , "cumulative_trade_volume_eth" .= cRYPTOPUNKSMarketPlaceDTOCumulativeTradeVolumeEth
      , "marketplace_revenue_eth" .= cRYPTOPUNKSMarketPlaceDTOMarketplaceRevenueEth
      , "creator_revenue_eth" .= cRYPTOPUNKSMarketPlaceDTOCreatorRevenueEth
      , "total_revenue_eth" .= cRYPTOPUNKSMarketPlaceDTOTotalRevenueEth
      , "cumulative_unique_traders" .= cRYPTOPUNKSMarketPlaceDTOCumulativeUniqueTraders
      ]


-- | Construct a value of type 'CRYPTOPUNKSMarketPlaceDTO' (by applying it's required fields, if any)
mkCRYPTOPUNKSMarketPlaceDTO
  :: CRYPTOPUNKSMarketPlaceDTO
mkCRYPTOPUNKSMarketPlaceDTO =
  CRYPTOPUNKSMarketPlaceDTO
  { cRYPTOPUNKSMarketPlaceDTOEntryTime = Nothing
  , cRYPTOPUNKSMarketPlaceDTORecvTime = Nothing
  , cRYPTOPUNKSMarketPlaceDTOBlockNumber = Nothing
  , cRYPTOPUNKSMarketPlaceDTOVid = Nothing
  , cRYPTOPUNKSMarketPlaceDTOBlockRange = Nothing
  , cRYPTOPUNKSMarketPlaceDTOId = Nothing
  , cRYPTOPUNKSMarketPlaceDTOName = Nothing
  , cRYPTOPUNKSMarketPlaceDTOSlug = Nothing
  , cRYPTOPUNKSMarketPlaceDTOSchemaVersion = Nothing
  , cRYPTOPUNKSMarketPlaceDTOSubgraphVersion = Nothing
  , cRYPTOPUNKSMarketPlaceDTOMethodologyVersion = Nothing
  , cRYPTOPUNKSMarketPlaceDTOCollectionCount = Nothing
  , cRYPTOPUNKSMarketPlaceDTOTradeCount = Nothing
  , cRYPTOPUNKSMarketPlaceDTOCumulativeTradeVolumeEth = Nothing
  , cRYPTOPUNKSMarketPlaceDTOMarketplaceRevenueEth = Nothing
  , cRYPTOPUNKSMarketPlaceDTOCreatorRevenueEth = Nothing
  , cRYPTOPUNKSMarketPlaceDTOTotalRevenueEth = Nothing
  , cRYPTOPUNKSMarketPlaceDTOCumulativeUniqueTraders = Nothing
  }

-- ** CRYPTOPUNKSMarketplaceDailySnapshotDTO
-- | CRYPTOPUNKSMarketplaceDailySnapshotDTO
data CRYPTOPUNKSMarketplaceDailySnapshotDTO = CRYPTOPUNKSMarketplaceDailySnapshotDTO
  { cRYPTOPUNKSMarketplaceDailySnapshotDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cRYPTOPUNKSMarketplaceDailySnapshotDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOBlockNumber :: !(Maybe Text) -- ^ "block_number" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOId :: !(Maybe Text) -- ^ "id" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOMarketplace :: !(Maybe Text) -- ^ "marketplace" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOCollectionCount :: !(Maybe Int) -- ^ "collection_count" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOCumulativeTradeVolumeEth :: !(Maybe Text) -- ^ "cumulative_trade_volume_eth" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOMarketplaceRevenueEth :: !(Maybe Text) -- ^ "marketplace_revenue_eth" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOCreatorRevenueEth :: !(Maybe Text) -- ^ "creator_revenue_eth" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOTotalRevenueEth :: !(Maybe Text) -- ^ "total_revenue_eth" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOTradeCount :: !(Maybe Int) -- ^ "trade_count" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOCumulativeUniqueTraders :: !(Maybe Int) -- ^ "cumulative_unique_traders" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTODailyActiveTraders :: !(Maybe Int) -- ^ "daily_active_traders" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTODailyTradedCollectionCount :: !(Maybe Int) -- ^ "daily_traded_collection_count" - 
  , cRYPTOPUNKSMarketplaceDailySnapshotDTODailyTradedItemCount :: !(Maybe Int) -- ^ "daily_traded_item_count" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CRYPTOPUNKSMarketplaceDailySnapshotDTO
instance A.FromJSON CRYPTOPUNKSMarketplaceDailySnapshotDTO where
  parseJSON = A.withObject "CRYPTOPUNKSMarketplaceDailySnapshotDTO" $ \o ->
    CRYPTOPUNKSMarketplaceDailySnapshotDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")
      <*> (o .:? "id")
      <*> (o .:? "marketplace")
      <*> (o .:? "timestamp")
      <*> (o .:? "collection_count")
      <*> (o .:? "cumulative_trade_volume_eth")
      <*> (o .:? "marketplace_revenue_eth")
      <*> (o .:? "creator_revenue_eth")
      <*> (o .:? "total_revenue_eth")
      <*> (o .:? "trade_count")
      <*> (o .:? "cumulative_unique_traders")
      <*> (o .:? "daily_active_traders")
      <*> (o .:? "daily_traded_collection_count")
      <*> (o .:? "daily_traded_item_count")

-- | ToJSON CRYPTOPUNKSMarketplaceDailySnapshotDTO
instance A.ToJSON CRYPTOPUNKSMarketplaceDailySnapshotDTO where
  toJSON CRYPTOPUNKSMarketplaceDailySnapshotDTO {..} =
   _omitNulls
      [ "entry_time" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOEntryTime
      , "recv_time" .= cRYPTOPUNKSMarketplaceDailySnapshotDTORecvTime
      , "block_number" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOBlockNumber
      , "vid" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOVid
      , "block_range" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOBlockRange
      , "id" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOId
      , "marketplace" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOMarketplace
      , "timestamp" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOTimestamp
      , "collection_count" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOCollectionCount
      , "cumulative_trade_volume_eth" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOCumulativeTradeVolumeEth
      , "marketplace_revenue_eth" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOMarketplaceRevenueEth
      , "creator_revenue_eth" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOCreatorRevenueEth
      , "total_revenue_eth" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOTotalRevenueEth
      , "trade_count" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOTradeCount
      , "cumulative_unique_traders" .= cRYPTOPUNKSMarketplaceDailySnapshotDTOCumulativeUniqueTraders
      , "daily_active_traders" .= cRYPTOPUNKSMarketplaceDailySnapshotDTODailyActiveTraders
      , "daily_traded_collection_count" .= cRYPTOPUNKSMarketplaceDailySnapshotDTODailyTradedCollectionCount
      , "daily_traded_item_count" .= cRYPTOPUNKSMarketplaceDailySnapshotDTODailyTradedItemCount
      ]


-- | Construct a value of type 'CRYPTOPUNKSMarketplaceDailySnapshotDTO' (by applying it's required fields, if any)
mkCRYPTOPUNKSMarketplaceDailySnapshotDTO
  :: CRYPTOPUNKSMarketplaceDailySnapshotDTO
mkCRYPTOPUNKSMarketplaceDailySnapshotDTO =
  CRYPTOPUNKSMarketplaceDailySnapshotDTO
  { cRYPTOPUNKSMarketplaceDailySnapshotDTOEntryTime = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTORecvTime = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOBlockNumber = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOVid = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOBlockRange = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOId = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOMarketplace = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOTimestamp = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOCollectionCount = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOCumulativeTradeVolumeEth = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOMarketplaceRevenueEth = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOCreatorRevenueEth = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOTotalRevenueEth = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOTradeCount = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTOCumulativeUniqueTraders = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTODailyActiveTraders = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTODailyTradedCollectionCount = Nothing
  , cRYPTOPUNKSMarketplaceDailySnapshotDTODailyTradedItemCount = Nothing
  }

-- ** CRYPTOPUNKSTradeDTO
-- | CRYPTOPUNKSTradeDTO
data CRYPTOPUNKSTradeDTO = CRYPTOPUNKSTradeDTO
  { cRYPTOPUNKSTradeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cRYPTOPUNKSTradeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cRYPTOPUNKSTradeDTOBlockNumber :: !(Maybe Text) -- ^ "block_number" - 
  , cRYPTOPUNKSTradeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cRYPTOPUNKSTradeDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  , cRYPTOPUNKSTradeDTOId :: !(Maybe Text) -- ^ "id" - 
  , cRYPTOPUNKSTradeDTOTransactionHash :: !(Maybe Text) -- ^ "transaction_hash" - 
  , cRYPTOPUNKSTradeDTOLogIndex :: !(Maybe Int) -- ^ "log_index" - 
  , cRYPTOPUNKSTradeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , cRYPTOPUNKSTradeDTOIsBundle :: !(Maybe Bool) -- ^ "is_bundle" - 
  , cRYPTOPUNKSTradeDTOCollection :: !(Maybe Text) -- ^ "collection" - 
  , cRYPTOPUNKSTradeDTOTokenId :: !(Maybe Text) -- ^ "token_id" - 
  , cRYPTOPUNKSTradeDTOAmount :: !(Maybe Text) -- ^ "amount" - 
  , cRYPTOPUNKSTradeDTOPriceEth :: !(Maybe Text) -- ^ "price_eth" - 
  , cRYPTOPUNKSTradeDTOBuyer :: !(Maybe Text) -- ^ "buyer" - 
  , cRYPTOPUNKSTradeDTOSeller :: !(Maybe Text) -- ^ "seller" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CRYPTOPUNKSTradeDTO
instance A.FromJSON CRYPTOPUNKSTradeDTO where
  parseJSON = A.withObject "CRYPTOPUNKSTradeDTO" $ \o ->
    CRYPTOPUNKSTradeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")
      <*> (o .:? "id")
      <*> (o .:? "transaction_hash")
      <*> (o .:? "log_index")
      <*> (o .:? "timestamp")
      <*> (o .:? "is_bundle")
      <*> (o .:? "collection")
      <*> (o .:? "token_id")
      <*> (o .:? "amount")
      <*> (o .:? "price_eth")
      <*> (o .:? "buyer")
      <*> (o .:? "seller")

-- | ToJSON CRYPTOPUNKSTradeDTO
instance A.ToJSON CRYPTOPUNKSTradeDTO where
  toJSON CRYPTOPUNKSTradeDTO {..} =
   _omitNulls
      [ "entry_time" .= cRYPTOPUNKSTradeDTOEntryTime
      , "recv_time" .= cRYPTOPUNKSTradeDTORecvTime
      , "block_number" .= cRYPTOPUNKSTradeDTOBlockNumber
      , "vid" .= cRYPTOPUNKSTradeDTOVid
      , "block_range" .= cRYPTOPUNKSTradeDTOBlockRange
      , "id" .= cRYPTOPUNKSTradeDTOId
      , "transaction_hash" .= cRYPTOPUNKSTradeDTOTransactionHash
      , "log_index" .= cRYPTOPUNKSTradeDTOLogIndex
      , "timestamp" .= cRYPTOPUNKSTradeDTOTimestamp
      , "is_bundle" .= cRYPTOPUNKSTradeDTOIsBundle
      , "collection" .= cRYPTOPUNKSTradeDTOCollection
      , "token_id" .= cRYPTOPUNKSTradeDTOTokenId
      , "amount" .= cRYPTOPUNKSTradeDTOAmount
      , "price_eth" .= cRYPTOPUNKSTradeDTOPriceEth
      , "buyer" .= cRYPTOPUNKSTradeDTOBuyer
      , "seller" .= cRYPTOPUNKSTradeDTOSeller
      ]


-- | Construct a value of type 'CRYPTOPUNKSTradeDTO' (by applying it's required fields, if any)
mkCRYPTOPUNKSTradeDTO
  :: CRYPTOPUNKSTradeDTO
mkCRYPTOPUNKSTradeDTO =
  CRYPTOPUNKSTradeDTO
  { cRYPTOPUNKSTradeDTOEntryTime = Nothing
  , cRYPTOPUNKSTradeDTORecvTime = Nothing
  , cRYPTOPUNKSTradeDTOBlockNumber = Nothing
  , cRYPTOPUNKSTradeDTOVid = Nothing
  , cRYPTOPUNKSTradeDTOBlockRange = Nothing
  , cRYPTOPUNKSTradeDTOId = Nothing
  , cRYPTOPUNKSTradeDTOTransactionHash = Nothing
  , cRYPTOPUNKSTradeDTOLogIndex = Nothing
  , cRYPTOPUNKSTradeDTOTimestamp = Nothing
  , cRYPTOPUNKSTradeDTOIsBundle = Nothing
  , cRYPTOPUNKSTradeDTOCollection = Nothing
  , cRYPTOPUNKSTradeDTOTokenId = Nothing
  , cRYPTOPUNKSTradeDTOAmount = Nothing
  , cRYPTOPUNKSTradeDTOPriceEth = Nothing
  , cRYPTOPUNKSTradeDTOBuyer = Nothing
  , cRYPTOPUNKSTradeDTOSeller = Nothing
  }

-- ** CRYPTOPUNKSUserDTO
-- | CRYPTOPUNKSUserDTO
data CRYPTOPUNKSUserDTO = CRYPTOPUNKSUserDTO
  { cRYPTOPUNKSUserDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cRYPTOPUNKSUserDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cRYPTOPUNKSUserDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cRYPTOPUNKSUserDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cRYPTOPUNKSUserDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  , cRYPTOPUNKSUserDTOId :: !(Maybe Text) -- ^ "id" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CRYPTOPUNKSUserDTO
instance A.FromJSON CRYPTOPUNKSUserDTO where
  parseJSON = A.withObject "CRYPTOPUNKSUserDTO" $ \o ->
    CRYPTOPUNKSUserDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")
      <*> (o .:? "id")

-- | ToJSON CRYPTOPUNKSUserDTO
instance A.ToJSON CRYPTOPUNKSUserDTO where
  toJSON CRYPTOPUNKSUserDTO {..} =
   _omitNulls
      [ "entry_time" .= cRYPTOPUNKSUserDTOEntryTime
      , "recv_time" .= cRYPTOPUNKSUserDTORecvTime
      , "block_number" .= cRYPTOPUNKSUserDTOBlockNumber
      , "vid" .= cRYPTOPUNKSUserDTOVid
      , "block_range" .= cRYPTOPUNKSUserDTOBlockRange
      , "id" .= cRYPTOPUNKSUserDTOId
      ]


-- | Construct a value of type 'CRYPTOPUNKSUserDTO' (by applying it's required fields, if any)
mkCRYPTOPUNKSUserDTO
  :: CRYPTOPUNKSUserDTO
mkCRYPTOPUNKSUserDTO =
  CRYPTOPUNKSUserDTO
  { cRYPTOPUNKSUserDTOEntryTime = Nothing
  , cRYPTOPUNKSUserDTORecvTime = Nothing
  , cRYPTOPUNKSUserDTOBlockNumber = Nothing
  , cRYPTOPUNKSUserDTOVid = Nothing
  , cRYPTOPUNKSUserDTOBlockRange = Nothing
  , cRYPTOPUNKSUserDTOId = Nothing
  }

-- ** CowOrderDTO
-- | CowOrderDTO
data CowOrderDTO = CowOrderDTO
  { cowOrderDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cowOrderDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cowOrderDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cowOrderDTOId :: !(Maybe Text) -- ^ "id" - User&#39;s address.
  , cowOrderDTOOwner :: !(Maybe Text) -- ^ "owner" - User&#39;s address.
  , cowOrderDTOTradesTimestamp :: !(Maybe Text) -- ^ "trades_timestamp" - Block&#39;s timestamp on trade event.
  , cowOrderDTOInvalidateTimestamp :: !(Maybe Text) -- ^ "invalidate_timestamp" - Block&#39;s timestamp on invalidate event.
  , cowOrderDTOPresignTimestamp :: !(Maybe Text) -- ^ "presign_timestamp" - Block&#39;s timestamp on presign event.
  , cowOrderDTOIsSigned :: !(Maybe Bool) -- ^ "is_signed" - Determines whether order is signed.
  , cowOrderDTOIsValid :: !(Maybe Bool) -- ^ "is_valid" - Determines whether order is valid.
  , cowOrderDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CowOrderDTO
instance A.FromJSON CowOrderDTO where
  parseJSON = A.withObject "CowOrderDTO" $ \o ->
    CowOrderDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "owner")
      <*> (o .:? "trades_timestamp")
      <*> (o .:? "invalidate_timestamp")
      <*> (o .:? "presign_timestamp")
      <*> (o .:? "is_signed")
      <*> (o .:? "is_valid")
      <*> (o .:? "vid")

-- | ToJSON CowOrderDTO
instance A.ToJSON CowOrderDTO where
  toJSON CowOrderDTO {..} =
   _omitNulls
      [ "entry_time" .= cowOrderDTOEntryTime
      , "recv_time" .= cowOrderDTORecvTime
      , "block_number" .= cowOrderDTOBlockNumber
      , "id" .= cowOrderDTOId
      , "owner" .= cowOrderDTOOwner
      , "trades_timestamp" .= cowOrderDTOTradesTimestamp
      , "invalidate_timestamp" .= cowOrderDTOInvalidateTimestamp
      , "presign_timestamp" .= cowOrderDTOPresignTimestamp
      , "is_signed" .= cowOrderDTOIsSigned
      , "is_valid" .= cowOrderDTOIsValid
      , "vid" .= cowOrderDTOVid
      ]


-- | Construct a value of type 'CowOrderDTO' (by applying it's required fields, if any)
mkCowOrderDTO
  :: CowOrderDTO
mkCowOrderDTO =
  CowOrderDTO
  { cowOrderDTOEntryTime = Nothing
  , cowOrderDTORecvTime = Nothing
  , cowOrderDTOBlockNumber = Nothing
  , cowOrderDTOId = Nothing
  , cowOrderDTOOwner = Nothing
  , cowOrderDTOTradesTimestamp = Nothing
  , cowOrderDTOInvalidateTimestamp = Nothing
  , cowOrderDTOPresignTimestamp = Nothing
  , cowOrderDTOIsSigned = Nothing
  , cowOrderDTOIsValid = Nothing
  , cowOrderDTOVid = Nothing
  }

-- ** CowSettlementDTO
-- | CowSettlementDTO
-- A settlement comprises a list of traded tokens with their corresponding price in the batch.
data CowSettlementDTO = CowSettlementDTO
  { cowSettlementDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cowSettlementDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cowSettlementDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cowSettlementDTOId :: !(Maybe Text) -- ^ "id" - Transaction hash.
  , cowSettlementDTOSolver :: !(Maybe Text) -- ^ "solver" - Solver&#39;s address.
  , cowSettlementDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Transaction hash.
  , cowSettlementDTOFirstTradeTimestamp :: !(Maybe Text) -- ^ "first_trade_timestamp" - First trade timestamp.
  , cowSettlementDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CowSettlementDTO
instance A.FromJSON CowSettlementDTO where
  parseJSON = A.withObject "CowSettlementDTO" $ \o ->
    CowSettlementDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "solver")
      <*> (o .:? "tx_hash")
      <*> (o .:? "first_trade_timestamp")
      <*> (o .:? "vid")

-- | ToJSON CowSettlementDTO
instance A.ToJSON CowSettlementDTO where
  toJSON CowSettlementDTO {..} =
   _omitNulls
      [ "entry_time" .= cowSettlementDTOEntryTime
      , "recv_time" .= cowSettlementDTORecvTime
      , "block_number" .= cowSettlementDTOBlockNumber
      , "id" .= cowSettlementDTOId
      , "solver" .= cowSettlementDTOSolver
      , "tx_hash" .= cowSettlementDTOTxHash
      , "first_trade_timestamp" .= cowSettlementDTOFirstTradeTimestamp
      , "vid" .= cowSettlementDTOVid
      ]


-- | Construct a value of type 'CowSettlementDTO' (by applying it's required fields, if any)
mkCowSettlementDTO
  :: CowSettlementDTO
mkCowSettlementDTO =
  CowSettlementDTO
  { cowSettlementDTOEntryTime = Nothing
  , cowSettlementDTORecvTime = Nothing
  , cowSettlementDTOBlockNumber = Nothing
  , cowSettlementDTOId = Nothing
  , cowSettlementDTOSolver = Nothing
  , cowSettlementDTOTxHash = Nothing
  , cowSettlementDTOFirstTradeTimestamp = Nothing
  , cowSettlementDTOVid = Nothing
  }

-- ** CowTokenDTO
-- | CowTokenDTO
-- Stores information for a specific token across all pairs that token is included in.
data CowTokenDTO = CowTokenDTO
  { cowTokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cowTokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cowTokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cowTokenDTOId :: !(Maybe Text) -- ^ "id" - Token&#39;s address.
  , cowTokenDTOAddress :: !(Maybe Text) -- ^ "address" - Token&#39;s address.
  , cowTokenDTOFirstTradeTimestamp :: !(Maybe Text) -- ^ "first_trade_timestamp" - First token trade block timestamp.
  , cowTokenDTOName :: !(Maybe Text) -- ^ "name" - Token name fetched by ERC20 contract call.
  , cowTokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - Token symbol fetched by contract call.
  , cowTokenDTODecimals :: !(Maybe Int) -- ^ "decimals" - Token decimals fetched by contract call.
  , cowTokenDTOTotalVolume :: !(Maybe Text) -- ^ "total_volume" - Sum of total amount traded for this token.
  , cowTokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cowTokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CowTokenDTO
instance A.FromJSON CowTokenDTO where
  parseJSON = A.withObject "CowTokenDTO" $ \o ->
    CowTokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "first_trade_timestamp")
      <*> (o .:? "name")
      <*> (o .:? "symbol")
      <*> (o .:? "decimals")
      <*> (o .:? "total_volume")
      <*> (o .:? "vid")
      <*> (o .:? "token_symbol")

-- | ToJSON CowTokenDTO
instance A.ToJSON CowTokenDTO where
  toJSON CowTokenDTO {..} =
   _omitNulls
      [ "entry_time" .= cowTokenDTOEntryTime
      , "recv_time" .= cowTokenDTORecvTime
      , "block_number" .= cowTokenDTOBlockNumber
      , "id" .= cowTokenDTOId
      , "address" .= cowTokenDTOAddress
      , "first_trade_timestamp" .= cowTokenDTOFirstTradeTimestamp
      , "name" .= cowTokenDTOName
      , "symbol" .= cowTokenDTOSymbol
      , "decimals" .= cowTokenDTODecimals
      , "total_volume" .= cowTokenDTOTotalVolume
      , "vid" .= cowTokenDTOVid
      , "token_symbol" .= cowTokenDTOTokenSymbol
      ]


-- | Construct a value of type 'CowTokenDTO' (by applying it's required fields, if any)
mkCowTokenDTO
  :: CowTokenDTO
mkCowTokenDTO =
  CowTokenDTO
  { cowTokenDTOEntryTime = Nothing
  , cowTokenDTORecvTime = Nothing
  , cowTokenDTOBlockNumber = Nothing
  , cowTokenDTOId = Nothing
  , cowTokenDTOAddress = Nothing
  , cowTokenDTOFirstTradeTimestamp = Nothing
  , cowTokenDTOName = Nothing
  , cowTokenDTOSymbol = Nothing
  , cowTokenDTODecimals = Nothing
  , cowTokenDTOTotalVolume = Nothing
  , cowTokenDTOVid = Nothing
  , cowTokenDTOTokenSymbol = Nothing
  }

-- ** CowTradeDTO
-- | CowTradeDTO
-- Trade entity.
data CowTradeDTO = CowTradeDTO
  { cowTradeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cowTradeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cowTradeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cowTradeDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (order id)|(transaction hash)|(event index).
  , cowTradeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Block&#39;s timestamp.
  , cowTradeDTOGasPrice :: !(Maybe Text) -- ^ "gas_price" - Transaction&#39;s gas price.
  , cowTradeDTOGasLimit :: !(Maybe Text) -- ^ "gas_limit" - Transaction&#39;s gas limit.
  , cowTradeDTOFeeAmount :: !(Maybe Text) -- ^ "fee_amount" - Trade&#39;s fee amount.
  , cowTradeDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Trade event transaction hash.
  , cowTradeDTOSettlement :: !(Maybe Text) -- ^ "settlement" - Reference to settlement.
  , cowTradeDTOBuyAmount :: !(Maybe Text) -- ^ "buy_amount" - Buy amount.
  , cowTradeDTOSellAmount :: !(Maybe Text) -- ^ "sell_amount" - Sell amount.
  , cowTradeDTOSellToken :: !(Maybe Text) -- ^ "sell_token" - Address of token that is sold.
  , cowTradeDTOBuyToken :: !(Maybe Text) -- ^ "buy_token" - Address of token that is bought.
  , cowTradeDTOOrder :: !(Maybe Text) -- ^ "order" - Reference to order.
  , cowTradeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , cowTradeDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , cowTradeDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  , cowTradeDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , cowTradeDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , cowTradeDTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CowTradeDTO
instance A.FromJSON CowTradeDTO where
  parseJSON = A.withObject "CowTradeDTO" $ \o ->
    CowTradeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "timestamp")
      <*> (o .:? "gas_price")
      <*> (o .:? "gas_limit")
      <*> (o .:? "fee_amount")
      <*> (o .:? "tx_hash")
      <*> (o .:? "settlement")
      <*> (o .:? "buy_amount")
      <*> (o .:? "sell_amount")
      <*> (o .:? "sell_token")
      <*> (o .:? "buy_token")
      <*> (o .:? "order")
      <*> (o .:? "vid")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")

-- | ToJSON CowTradeDTO
instance A.ToJSON CowTradeDTO where
  toJSON CowTradeDTO {..} =
   _omitNulls
      [ "entry_time" .= cowTradeDTOEntryTime
      , "recv_time" .= cowTradeDTORecvTime
      , "block_number" .= cowTradeDTOBlockNumber
      , "id" .= cowTradeDTOId
      , "timestamp" .= cowTradeDTOTimestamp
      , "gas_price" .= cowTradeDTOGasPrice
      , "gas_limit" .= cowTradeDTOGasLimit
      , "fee_amount" .= cowTradeDTOFeeAmount
      , "tx_hash" .= cowTradeDTOTxHash
      , "settlement" .= cowTradeDTOSettlement
      , "buy_amount" .= cowTradeDTOBuyAmount
      , "sell_amount" .= cowTradeDTOSellAmount
      , "sell_token" .= cowTradeDTOSellToken
      , "buy_token" .= cowTradeDTOBuyToken
      , "order" .= cowTradeDTOOrder
      , "vid" .= cowTradeDTOVid
      , "pool_id" .= cowTradeDTOPoolId
      , "transaction_id" .= cowTradeDTOTransactionId
      , "evaluated_price" .= cowTradeDTOEvaluatedPrice
      , "evaluated_amount" .= cowTradeDTOEvaluatedAmount
      , "evaluated_aggressor" .= cowTradeDTOEvaluatedAggressor
      ]


-- | Construct a value of type 'CowTradeDTO' (by applying it's required fields, if any)
mkCowTradeDTO
  :: CowTradeDTO
mkCowTradeDTO =
  CowTradeDTO
  { cowTradeDTOEntryTime = Nothing
  , cowTradeDTORecvTime = Nothing
  , cowTradeDTOBlockNumber = Nothing
  , cowTradeDTOId = Nothing
  , cowTradeDTOTimestamp = Nothing
  , cowTradeDTOGasPrice = Nothing
  , cowTradeDTOGasLimit = Nothing
  , cowTradeDTOFeeAmount = Nothing
  , cowTradeDTOTxHash = Nothing
  , cowTradeDTOSettlement = Nothing
  , cowTradeDTOBuyAmount = Nothing
  , cowTradeDTOSellAmount = Nothing
  , cowTradeDTOSellToken = Nothing
  , cowTradeDTOBuyToken = Nothing
  , cowTradeDTOOrder = Nothing
  , cowTradeDTOVid = Nothing
  , cowTradeDTOPoolId = Nothing
  , cowTradeDTOTransactionId = Nothing
  , cowTradeDTOEvaluatedPrice = Nothing
  , cowTradeDTOEvaluatedAmount = Nothing
  , cowTradeDTOEvaluatedAggressor = Nothing
  }

-- ** CowUserDTO
-- | CowUserDTO
data CowUserDTO = CowUserDTO
  { cowUserDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , cowUserDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , cowUserDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , cowUserDTOId :: !(Maybe Text) -- ^ "id" - User&#39;s address.
  , cowUserDTOAddress :: !(Maybe Text) -- ^ "address" - User&#39;s address.
  , cowUserDTOFirstTradeTimestamp :: !(Maybe Text) -- ^ "first_trade_timestamp" - First trade block timestamp.
  , cowUserDTOIsSolver :: !(Maybe Bool) -- ^ "is_solver" - Determines if user has solved a settlement.
  , cowUserDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CowUserDTO
instance A.FromJSON CowUserDTO where
  parseJSON = A.withObject "CowUserDTO" $ \o ->
    CowUserDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "first_trade_timestamp")
      <*> (o .:? "is_solver")
      <*> (o .:? "vid")

-- | ToJSON CowUserDTO
instance A.ToJSON CowUserDTO where
  toJSON CowUserDTO {..} =
   _omitNulls
      [ "entry_time" .= cowUserDTOEntryTime
      , "recv_time" .= cowUserDTORecvTime
      , "block_number" .= cowUserDTOBlockNumber
      , "id" .= cowUserDTOId
      , "address" .= cowUserDTOAddress
      , "first_trade_timestamp" .= cowUserDTOFirstTradeTimestamp
      , "is_solver" .= cowUserDTOIsSolver
      , "vid" .= cowUserDTOVid
      ]


-- | Construct a value of type 'CowUserDTO' (by applying it's required fields, if any)
mkCowUserDTO
  :: CowUserDTO
mkCowUserDTO =
  CowUserDTO
  { cowUserDTOEntryTime = Nothing
  , cowUserDTORecvTime = Nothing
  , cowUserDTOBlockNumber = Nothing
  , cowUserDTOId = Nothing
  , cowUserDTOAddress = Nothing
  , cowUserDTOFirstTradeTimestamp = Nothing
  , cowUserDTOIsSolver = Nothing
  , cowUserDTOVid = Nothing
  }

-- ** CurveAccountDTO
-- | CurveAccountDTO
data CurveAccountDTO = CurveAccountDTO
  { curveAccountDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveAccountDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveAccountDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveAccountDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveAccountDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveAccountDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveAccountDTO
instance A.FromJSON CurveAccountDTO where
  parseJSON = A.withObject "CurveAccountDTO" $ \o ->
    CurveAccountDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "vid")

-- | ToJSON CurveAccountDTO
instance A.ToJSON CurveAccountDTO where
  toJSON CurveAccountDTO {..} =
   _omitNulls
      [ "entry_time" .= curveAccountDTOEntryTime
      , "recv_time" .= curveAccountDTORecvTime
      , "block_number" .= curveAccountDTOBlockNumber
      , "id" .= curveAccountDTOId
      , "address" .= curveAccountDTOAddress
      , "vid" .= curveAccountDTOVid
      ]


-- | Construct a value of type 'CurveAccountDTO' (by applying it's required fields, if any)
mkCurveAccountDTO
  :: CurveAccountDTO
mkCurveAccountDTO =
  CurveAccountDTO
  { curveAccountDTOEntryTime = Nothing
  , curveAccountDTORecvTime = Nothing
  , curveAccountDTOBlockNumber = Nothing
  , curveAccountDTOId = Nothing
  , curveAccountDTOAddress = Nothing
  , curveAccountDTOVid = Nothing
  }

-- ** CurveAddLiquidityEventDTO
-- | CurveAddLiquidityEventDTO
data CurveAddLiquidityEventDTO = CurveAddLiquidityEventDTO
  { curveAddLiquidityEventDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveAddLiquidityEventDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveAddLiquidityEventDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveAddLiquidityEventDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveAddLiquidityEventDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveAddLiquidityEventDTOProvider :: !(Maybe Text) -- ^ "provider" - 
  , curveAddLiquidityEventDTOTokenAmounts :: !(Maybe [Text]) -- ^ "token_amounts" - 
  , curveAddLiquidityEventDTOFees :: !(Maybe [Text]) -- ^ "fees" - 
  , curveAddLiquidityEventDTOInvariant :: !(Maybe Text) -- ^ "invariant" - 
  , curveAddLiquidityEventDTOTokenSupply :: !(Maybe Text) -- ^ "token_supply" - 
  , curveAddLiquidityEventDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveAddLiquidityEventDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveAddLiquidityEventDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveAddLiquidityEventDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveAddLiquidityEventDTO
instance A.FromJSON CurveAddLiquidityEventDTO where
  parseJSON = A.withObject "CurveAddLiquidityEventDTO" $ \o ->
    CurveAddLiquidityEventDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "provider")
      <*> (o .:? "token_amounts")
      <*> (o .:? "fees")
      <*> (o .:? "invariant")
      <*> (o .:? "token_supply")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveAddLiquidityEventDTO
instance A.ToJSON CurveAddLiquidityEventDTO where
  toJSON CurveAddLiquidityEventDTO {..} =
   _omitNulls
      [ "entry_time" .= curveAddLiquidityEventDTOEntryTime
      , "recv_time" .= curveAddLiquidityEventDTORecvTime
      , "block_number" .= curveAddLiquidityEventDTOBlockNumber
      , "id" .= curveAddLiquidityEventDTOId
      , "pool" .= curveAddLiquidityEventDTOPool
      , "provider" .= curveAddLiquidityEventDTOProvider
      , "token_amounts" .= curveAddLiquidityEventDTOTokenAmounts
      , "fees" .= curveAddLiquidityEventDTOFees
      , "invariant" .= curveAddLiquidityEventDTOInvariant
      , "token_supply" .= curveAddLiquidityEventDTOTokenSupply
      , "block" .= curveAddLiquidityEventDTOBlock
      , "timestamp" .= curveAddLiquidityEventDTOTimestamp
      , "transaction" .= curveAddLiquidityEventDTOTransaction
      , "vid" .= curveAddLiquidityEventDTOVid
      ]


-- | Construct a value of type 'CurveAddLiquidityEventDTO' (by applying it's required fields, if any)
mkCurveAddLiquidityEventDTO
  :: CurveAddLiquidityEventDTO
mkCurveAddLiquidityEventDTO =
  CurveAddLiquidityEventDTO
  { curveAddLiquidityEventDTOEntryTime = Nothing
  , curveAddLiquidityEventDTORecvTime = Nothing
  , curveAddLiquidityEventDTOBlockNumber = Nothing
  , curveAddLiquidityEventDTOId = Nothing
  , curveAddLiquidityEventDTOPool = Nothing
  , curveAddLiquidityEventDTOProvider = Nothing
  , curveAddLiquidityEventDTOTokenAmounts = Nothing
  , curveAddLiquidityEventDTOFees = Nothing
  , curveAddLiquidityEventDTOInvariant = Nothing
  , curveAddLiquidityEventDTOTokenSupply = Nothing
  , curveAddLiquidityEventDTOBlock = Nothing
  , curveAddLiquidityEventDTOTimestamp = Nothing
  , curveAddLiquidityEventDTOTransaction = Nothing
  , curveAddLiquidityEventDTOVid = Nothing
  }

-- ** CurveAdminFeeChangeLogDTO
-- | CurveAdminFeeChangeLogDTO
data CurveAdminFeeChangeLogDTO = CurveAdminFeeChangeLogDTO
  { curveAdminFeeChangeLogDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveAdminFeeChangeLogDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveAdminFeeChangeLogDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveAdminFeeChangeLogDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveAdminFeeChangeLogDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveAdminFeeChangeLogDTOValue :: !(Maybe Text) -- ^ "value" - 
  , curveAdminFeeChangeLogDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveAdminFeeChangeLogDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveAdminFeeChangeLogDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveAdminFeeChangeLogDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveAdminFeeChangeLogDTO
instance A.FromJSON CurveAdminFeeChangeLogDTO where
  parseJSON = A.withObject "CurveAdminFeeChangeLogDTO" $ \o ->
    CurveAdminFeeChangeLogDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "value")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveAdminFeeChangeLogDTO
instance A.ToJSON CurveAdminFeeChangeLogDTO where
  toJSON CurveAdminFeeChangeLogDTO {..} =
   _omitNulls
      [ "entry_time" .= curveAdminFeeChangeLogDTOEntryTime
      , "recv_time" .= curveAdminFeeChangeLogDTORecvTime
      , "block_number" .= curveAdminFeeChangeLogDTOBlockNumber
      , "id" .= curveAdminFeeChangeLogDTOId
      , "pool" .= curveAdminFeeChangeLogDTOPool
      , "value" .= curveAdminFeeChangeLogDTOValue
      , "block" .= curveAdminFeeChangeLogDTOBlock
      , "timestamp" .= curveAdminFeeChangeLogDTOTimestamp
      , "transaction" .= curveAdminFeeChangeLogDTOTransaction
      , "vid" .= curveAdminFeeChangeLogDTOVid
      ]


-- | Construct a value of type 'CurveAdminFeeChangeLogDTO' (by applying it's required fields, if any)
mkCurveAdminFeeChangeLogDTO
  :: CurveAdminFeeChangeLogDTO
mkCurveAdminFeeChangeLogDTO =
  CurveAdminFeeChangeLogDTO
  { curveAdminFeeChangeLogDTOEntryTime = Nothing
  , curveAdminFeeChangeLogDTORecvTime = Nothing
  , curveAdminFeeChangeLogDTOBlockNumber = Nothing
  , curveAdminFeeChangeLogDTOId = Nothing
  , curveAdminFeeChangeLogDTOPool = Nothing
  , curveAdminFeeChangeLogDTOValue = Nothing
  , curveAdminFeeChangeLogDTOBlock = Nothing
  , curveAdminFeeChangeLogDTOTimestamp = Nothing
  , curveAdminFeeChangeLogDTOTransaction = Nothing
  , curveAdminFeeChangeLogDTOVid = Nothing
  }

-- ** CurveAmplificationCoeffChangeLogDTO
-- | CurveAmplificationCoeffChangeLogDTO
data CurveAmplificationCoeffChangeLogDTO = CurveAmplificationCoeffChangeLogDTO
  { curveAmplificationCoeffChangeLogDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveAmplificationCoeffChangeLogDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveAmplificationCoeffChangeLogDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveAmplificationCoeffChangeLogDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveAmplificationCoeffChangeLogDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveAmplificationCoeffChangeLogDTOValue :: !(Maybe Text) -- ^ "value" - 
  , curveAmplificationCoeffChangeLogDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveAmplificationCoeffChangeLogDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveAmplificationCoeffChangeLogDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveAmplificationCoeffChangeLogDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveAmplificationCoeffChangeLogDTO
instance A.FromJSON CurveAmplificationCoeffChangeLogDTO where
  parseJSON = A.withObject "CurveAmplificationCoeffChangeLogDTO" $ \o ->
    CurveAmplificationCoeffChangeLogDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "value")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveAmplificationCoeffChangeLogDTO
instance A.ToJSON CurveAmplificationCoeffChangeLogDTO where
  toJSON CurveAmplificationCoeffChangeLogDTO {..} =
   _omitNulls
      [ "entry_time" .= curveAmplificationCoeffChangeLogDTOEntryTime
      , "recv_time" .= curveAmplificationCoeffChangeLogDTORecvTime
      , "block_number" .= curveAmplificationCoeffChangeLogDTOBlockNumber
      , "id" .= curveAmplificationCoeffChangeLogDTOId
      , "pool" .= curveAmplificationCoeffChangeLogDTOPool
      , "value" .= curveAmplificationCoeffChangeLogDTOValue
      , "block" .= curveAmplificationCoeffChangeLogDTOBlock
      , "timestamp" .= curveAmplificationCoeffChangeLogDTOTimestamp
      , "transaction" .= curveAmplificationCoeffChangeLogDTOTransaction
      , "vid" .= curveAmplificationCoeffChangeLogDTOVid
      ]


-- | Construct a value of type 'CurveAmplificationCoeffChangeLogDTO' (by applying it's required fields, if any)
mkCurveAmplificationCoeffChangeLogDTO
  :: CurveAmplificationCoeffChangeLogDTO
mkCurveAmplificationCoeffChangeLogDTO =
  CurveAmplificationCoeffChangeLogDTO
  { curveAmplificationCoeffChangeLogDTOEntryTime = Nothing
  , curveAmplificationCoeffChangeLogDTORecvTime = Nothing
  , curveAmplificationCoeffChangeLogDTOBlockNumber = Nothing
  , curveAmplificationCoeffChangeLogDTOId = Nothing
  , curveAmplificationCoeffChangeLogDTOPool = Nothing
  , curveAmplificationCoeffChangeLogDTOValue = Nothing
  , curveAmplificationCoeffChangeLogDTOBlock = Nothing
  , curveAmplificationCoeffChangeLogDTOTimestamp = Nothing
  , curveAmplificationCoeffChangeLogDTOTransaction = Nothing
  , curveAmplificationCoeffChangeLogDTOVid = Nothing
  }

-- ** CurveCoinDTO
-- | CurveCoinDTO
data CurveCoinDTO = CurveCoinDTO
  { curveCoinDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveCoinDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveCoinDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveCoinDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (pool_id)-(coin_index).
  , curveCoinDTOIndex :: !(Maybe Int) -- ^ "index" - Coin index.
  , curveCoinDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveCoinDTOToken :: !(Maybe Text) -- ^ "token" - 
  , curveCoinDTOUnderlying :: !(Maybe Text) -- ^ "underlying" - 
  , curveCoinDTOBalance :: !(Maybe Text) -- ^ "balance" - 
  , curveCoinDTORate :: !(Maybe Text) -- ^ "rate" - Exchange rate between this coin and the associated underlying coin within the pool.
  , curveCoinDTOUpdated :: !(Maybe Text) -- ^ "updated" - 
  , curveCoinDTOUpdatedAtBlock :: !(Maybe Text) -- ^ "updated_at_block" - 
  , curveCoinDTOUpdatedAtTransaction :: !(Maybe Text) -- ^ "updated_at_transaction" - 
  , curveCoinDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curveCoinDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveCoinDTO
instance A.FromJSON CurveCoinDTO where
  parseJSON = A.withObject "CurveCoinDTO" $ \o ->
    CurveCoinDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "index")
      <*> (o .:? "pool")
      <*> (o .:? "token")
      <*> (o .:? "underlying")
      <*> (o .:? "balance")
      <*> (o .:? "rate")
      <*> (o .:? "updated")
      <*> (o .:? "updated_at_block")
      <*> (o .:? "updated_at_transaction")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON CurveCoinDTO
instance A.ToJSON CurveCoinDTO where
  toJSON CurveCoinDTO {..} =
   _omitNulls
      [ "entry_time" .= curveCoinDTOEntryTime
      , "recv_time" .= curveCoinDTORecvTime
      , "block_number" .= curveCoinDTOBlockNumber
      , "id" .= curveCoinDTOId
      , "index" .= curveCoinDTOIndex
      , "pool" .= curveCoinDTOPool
      , "token" .= curveCoinDTOToken
      , "underlying" .= curveCoinDTOUnderlying
      , "balance" .= curveCoinDTOBalance
      , "rate" .= curveCoinDTORate
      , "updated" .= curveCoinDTOUpdated
      , "updated_at_block" .= curveCoinDTOUpdatedAtBlock
      , "updated_at_transaction" .= curveCoinDTOUpdatedAtTransaction
      , "vid" .= curveCoinDTOVid
      , "block_range" .= curveCoinDTOBlockRange
      ]


-- | Construct a value of type 'CurveCoinDTO' (by applying it's required fields, if any)
mkCurveCoinDTO
  :: CurveCoinDTO
mkCurveCoinDTO =
  CurveCoinDTO
  { curveCoinDTOEntryTime = Nothing
  , curveCoinDTORecvTime = Nothing
  , curveCoinDTOBlockNumber = Nothing
  , curveCoinDTOId = Nothing
  , curveCoinDTOIndex = Nothing
  , curveCoinDTOPool = Nothing
  , curveCoinDTOToken = Nothing
  , curveCoinDTOUnderlying = Nothing
  , curveCoinDTOBalance = Nothing
  , curveCoinDTORate = Nothing
  , curveCoinDTOUpdated = Nothing
  , curveCoinDTOUpdatedAtBlock = Nothing
  , curveCoinDTOUpdatedAtTransaction = Nothing
  , curveCoinDTOVid = Nothing
  , curveCoinDTOBlockRange = Nothing
  }

-- ** CurveContractDTO
-- | CurveContractDTO
data CurveContractDTO = CurveContractDTO
  { curveContractDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveContractDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveContractDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveContractDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveContractDTODescription :: !(Maybe Text) -- ^ "description" - Human-readable description.
  , curveContractDTOAdded :: !(Maybe Text) -- ^ "added" - 
  , curveContractDTOAddedAtBlock :: !(Maybe Text) -- ^ "added_at_block" - 
  , curveContractDTOAddedAtTransaction :: !(Maybe Text) -- ^ "added_at_transaction" - 
  , curveContractDTOModified :: !(Maybe Text) -- ^ "modified" - 
  , curveContractDTOModifiedAtBlock :: !(Maybe Text) -- ^ "modified_at_block" - 
  , curveContractDTOModifiedAtTransaction :: !(Maybe Text) -- ^ "modified_at_transaction" - 
  , curveContractDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveContractDTO
instance A.FromJSON CurveContractDTO where
  parseJSON = A.withObject "CurveContractDTO" $ \o ->
    CurveContractDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "description")
      <*> (o .:? "added")
      <*> (o .:? "added_at_block")
      <*> (o .:? "added_at_transaction")
      <*> (o .:? "modified")
      <*> (o .:? "modified_at_block")
      <*> (o .:? "modified_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveContractDTO
instance A.ToJSON CurveContractDTO where
  toJSON CurveContractDTO {..} =
   _omitNulls
      [ "entry_time" .= curveContractDTOEntryTime
      , "recv_time" .= curveContractDTORecvTime
      , "block_number" .= curveContractDTOBlockNumber
      , "id" .= curveContractDTOId
      , "description" .= curveContractDTODescription
      , "added" .= curveContractDTOAdded
      , "added_at_block" .= curveContractDTOAddedAtBlock
      , "added_at_transaction" .= curveContractDTOAddedAtTransaction
      , "modified" .= curveContractDTOModified
      , "modified_at_block" .= curveContractDTOModifiedAtBlock
      , "modified_at_transaction" .= curveContractDTOModifiedAtTransaction
      , "vid" .= curveContractDTOVid
      ]


-- | Construct a value of type 'CurveContractDTO' (by applying it's required fields, if any)
mkCurveContractDTO
  :: CurveContractDTO
mkCurveContractDTO =
  CurveContractDTO
  { curveContractDTOEntryTime = Nothing
  , curveContractDTORecvTime = Nothing
  , curveContractDTOBlockNumber = Nothing
  , curveContractDTOId = Nothing
  , curveContractDTODescription = Nothing
  , curveContractDTOAdded = Nothing
  , curveContractDTOAddedAtBlock = Nothing
  , curveContractDTOAddedAtTransaction = Nothing
  , curveContractDTOModified = Nothing
  , curveContractDTOModifiedAtBlock = Nothing
  , curveContractDTOModifiedAtTransaction = Nothing
  , curveContractDTOVid = Nothing
  }

-- ** CurveContractVersionDTO
-- | CurveContractVersionDTO
data CurveContractVersionDTO = CurveContractVersionDTO
  { curveContractVersionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveContractVersionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveContractVersionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveContractVersionDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveContractVersionDTOContract :: !(Maybe Text) -- ^ "contract" - 
  , curveContractVersionDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveContractVersionDTOVersion :: !(Maybe Text) -- ^ "version" - 
  , curveContractVersionDTOAdded :: !(Maybe Text) -- ^ "added" - 
  , curveContractVersionDTOAddedAtBlock :: !(Maybe Text) -- ^ "added_at_block" - 
  , curveContractVersionDTOAddedAtTransaction :: !(Maybe Text) -- ^ "added_at_transaction" - 
  , curveContractVersionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveContractVersionDTO
instance A.FromJSON CurveContractVersionDTO where
  parseJSON = A.withObject "CurveContractVersionDTO" $ \o ->
    CurveContractVersionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "contract")
      <*> (o .:? "address")
      <*> (o .:? "version")
      <*> (o .:? "added")
      <*> (o .:? "added_at_block")
      <*> (o .:? "added_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveContractVersionDTO
instance A.ToJSON CurveContractVersionDTO where
  toJSON CurveContractVersionDTO {..} =
   _omitNulls
      [ "entry_time" .= curveContractVersionDTOEntryTime
      , "recv_time" .= curveContractVersionDTORecvTime
      , "block_number" .= curveContractVersionDTOBlockNumber
      , "id" .= curveContractVersionDTOId
      , "contract" .= curveContractVersionDTOContract
      , "address" .= curveContractVersionDTOAddress
      , "version" .= curveContractVersionDTOVersion
      , "added" .= curveContractVersionDTOAdded
      , "added_at_block" .= curveContractVersionDTOAddedAtBlock
      , "added_at_transaction" .= curveContractVersionDTOAddedAtTransaction
      , "vid" .= curveContractVersionDTOVid
      ]


-- | Construct a value of type 'CurveContractVersionDTO' (by applying it's required fields, if any)
mkCurveContractVersionDTO
  :: CurveContractVersionDTO
mkCurveContractVersionDTO =
  CurveContractVersionDTO
  { curveContractVersionDTOEntryTime = Nothing
  , curveContractVersionDTORecvTime = Nothing
  , curveContractVersionDTOBlockNumber = Nothing
  , curveContractVersionDTOId = Nothing
  , curveContractVersionDTOContract = Nothing
  , curveContractVersionDTOAddress = Nothing
  , curveContractVersionDTOVersion = Nothing
  , curveContractVersionDTOAdded = Nothing
  , curveContractVersionDTOAddedAtBlock = Nothing
  , curveContractVersionDTOAddedAtTransaction = Nothing
  , curveContractVersionDTOVid = Nothing
  }

-- ** CurveDailyVolumeDTO
-- | CurveDailyVolumeDTO
data CurveDailyVolumeDTO = CurveDailyVolumeDTO
  { curveDailyVolumeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveDailyVolumeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveDailyVolumeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveDailyVolumeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveDailyVolumeDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveDailyVolumeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveDailyVolumeDTOVolume :: !(Maybe Text) -- ^ "volume" - 
  , curveDailyVolumeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curveDailyVolumeDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveDailyVolumeDTO
instance A.FromJSON CurveDailyVolumeDTO where
  parseJSON = A.withObject "CurveDailyVolumeDTO" $ \o ->
    CurveDailyVolumeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "timestamp")
      <*> (o .:? "volume")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON CurveDailyVolumeDTO
instance A.ToJSON CurveDailyVolumeDTO where
  toJSON CurveDailyVolumeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveDailyVolumeDTOEntryTime
      , "recv_time" .= curveDailyVolumeDTORecvTime
      , "block_number" .= curveDailyVolumeDTOBlockNumber
      , "id" .= curveDailyVolumeDTOId
      , "pool" .= curveDailyVolumeDTOPool
      , "timestamp" .= curveDailyVolumeDTOTimestamp
      , "volume" .= curveDailyVolumeDTOVolume
      , "vid" .= curveDailyVolumeDTOVid
      , "block_range" .= curveDailyVolumeDTOBlockRange
      ]


-- | Construct a value of type 'CurveDailyVolumeDTO' (by applying it's required fields, if any)
mkCurveDailyVolumeDTO
  :: CurveDailyVolumeDTO
mkCurveDailyVolumeDTO =
  CurveDailyVolumeDTO
  { curveDailyVolumeDTOEntryTime = Nothing
  , curveDailyVolumeDTORecvTime = Nothing
  , curveDailyVolumeDTOBlockNumber = Nothing
  , curveDailyVolumeDTOId = Nothing
  , curveDailyVolumeDTOPool = Nothing
  , curveDailyVolumeDTOTimestamp = Nothing
  , curveDailyVolumeDTOVolume = Nothing
  , curveDailyVolumeDTOVid = Nothing
  , curveDailyVolumeDTOBlockRange = Nothing
  }

-- ** CurveExchangeDTO
-- | CurveExchangeDTO
data CurveExchangeDTO = CurveExchangeDTO
  { curveExchangeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveExchangeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveExchangeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveExchangeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveExchangeDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveExchangeDTOBuyer :: !(Maybe Text) -- ^ "buyer" - 
  , curveExchangeDTOReceiver :: !(Maybe Text) -- ^ "receiver" - 
  , curveExchangeDTOTokenSold :: !(Maybe Text) -- ^ "token_sold" - 
  , curveExchangeDTOTokenBought :: !(Maybe Text) -- ^ "token_bought" - 
  , curveExchangeDTOAmountSold :: !(Maybe Text) -- ^ "amount_sold" - 
  , curveExchangeDTOAmountBought :: !(Maybe Text) -- ^ "amount_bought" - 
  , curveExchangeDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveExchangeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveExchangeDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveExchangeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curveExchangeDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , curveExchangeDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , curveExchangeDTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  , curveExchangeDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , curveExchangeDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveExchangeDTO
instance A.FromJSON CurveExchangeDTO where
  parseJSON = A.withObject "CurveExchangeDTO" $ \o ->
    CurveExchangeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "buyer")
      <*> (o .:? "receiver")
      <*> (o .:? "token_sold")
      <*> (o .:? "token_bought")
      <*> (o .:? "amount_sold")
      <*> (o .:? "amount_bought")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")

-- | ToJSON CurveExchangeDTO
instance A.ToJSON CurveExchangeDTO where
  toJSON CurveExchangeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveExchangeDTOEntryTime
      , "recv_time" .= curveExchangeDTORecvTime
      , "block_number" .= curveExchangeDTOBlockNumber
      , "id" .= curveExchangeDTOId
      , "pool" .= curveExchangeDTOPool
      , "buyer" .= curveExchangeDTOBuyer
      , "receiver" .= curveExchangeDTOReceiver
      , "token_sold" .= curveExchangeDTOTokenSold
      , "token_bought" .= curveExchangeDTOTokenBought
      , "amount_sold" .= curveExchangeDTOAmountSold
      , "amount_bought" .= curveExchangeDTOAmountBought
      , "block" .= curveExchangeDTOBlock
      , "timestamp" .= curveExchangeDTOTimestamp
      , "transaction" .= curveExchangeDTOTransaction
      , "vid" .= curveExchangeDTOVid
      , "evaluated_price" .= curveExchangeDTOEvaluatedPrice
      , "evaluated_amount" .= curveExchangeDTOEvaluatedAmount
      , "evaluated_aggressor" .= curveExchangeDTOEvaluatedAggressor
      , "pool_id" .= curveExchangeDTOPoolId
      , "transaction_id" .= curveExchangeDTOTransactionId
      ]


-- | Construct a value of type 'CurveExchangeDTO' (by applying it's required fields, if any)
mkCurveExchangeDTO
  :: CurveExchangeDTO
mkCurveExchangeDTO =
  CurveExchangeDTO
  { curveExchangeDTOEntryTime = Nothing
  , curveExchangeDTORecvTime = Nothing
  , curveExchangeDTOBlockNumber = Nothing
  , curveExchangeDTOId = Nothing
  , curveExchangeDTOPool = Nothing
  , curveExchangeDTOBuyer = Nothing
  , curveExchangeDTOReceiver = Nothing
  , curveExchangeDTOTokenSold = Nothing
  , curveExchangeDTOTokenBought = Nothing
  , curveExchangeDTOAmountSold = Nothing
  , curveExchangeDTOAmountBought = Nothing
  , curveExchangeDTOBlock = Nothing
  , curveExchangeDTOTimestamp = Nothing
  , curveExchangeDTOTransaction = Nothing
  , curveExchangeDTOVid = Nothing
  , curveExchangeDTOEvaluatedPrice = Nothing
  , curveExchangeDTOEvaluatedAmount = Nothing
  , curveExchangeDTOEvaluatedAggressor = Nothing
  , curveExchangeDTOPoolId = Nothing
  , curveExchangeDTOTransactionId = Nothing
  }

-- ** CurveFeeChangeLogDTO
-- | CurveFeeChangeLogDTO
data CurveFeeChangeLogDTO = CurveFeeChangeLogDTO
  { curveFeeChangeLogDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveFeeChangeLogDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveFeeChangeLogDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveFeeChangeLogDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveFeeChangeLogDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveFeeChangeLogDTOValue :: !(Maybe Text) -- ^ "value" - 
  , curveFeeChangeLogDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveFeeChangeLogDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveFeeChangeLogDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveFeeChangeLogDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveFeeChangeLogDTO
instance A.FromJSON CurveFeeChangeLogDTO where
  parseJSON = A.withObject "CurveFeeChangeLogDTO" $ \o ->
    CurveFeeChangeLogDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "value")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveFeeChangeLogDTO
instance A.ToJSON CurveFeeChangeLogDTO where
  toJSON CurveFeeChangeLogDTO {..} =
   _omitNulls
      [ "entry_time" .= curveFeeChangeLogDTOEntryTime
      , "recv_time" .= curveFeeChangeLogDTORecvTime
      , "block_number" .= curveFeeChangeLogDTOBlockNumber
      , "id" .= curveFeeChangeLogDTOId
      , "pool" .= curveFeeChangeLogDTOPool
      , "value" .= curveFeeChangeLogDTOValue
      , "block" .= curveFeeChangeLogDTOBlock
      , "timestamp" .= curveFeeChangeLogDTOTimestamp
      , "transaction" .= curveFeeChangeLogDTOTransaction
      , "vid" .= curveFeeChangeLogDTOVid
      ]


-- | Construct a value of type 'CurveFeeChangeLogDTO' (by applying it's required fields, if any)
mkCurveFeeChangeLogDTO
  :: CurveFeeChangeLogDTO
mkCurveFeeChangeLogDTO =
  CurveFeeChangeLogDTO
  { curveFeeChangeLogDTOEntryTime = Nothing
  , curveFeeChangeLogDTORecvTime = Nothing
  , curveFeeChangeLogDTOBlockNumber = Nothing
  , curveFeeChangeLogDTOId = Nothing
  , curveFeeChangeLogDTOPool = Nothing
  , curveFeeChangeLogDTOValue = Nothing
  , curveFeeChangeLogDTOBlock = Nothing
  , curveFeeChangeLogDTOTimestamp = Nothing
  , curveFeeChangeLogDTOTransaction = Nothing
  , curveFeeChangeLogDTOVid = Nothing
  }

-- ** CurveGaugeDTO
-- | CurveGaugeDTO
data CurveGaugeDTO = CurveGaugeDTO
  { curveGaugeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveGaugeDTOType :: !(Maybe Text) -- ^ "type" - 
  , curveGaugeDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveGaugeDTOCreated :: !(Maybe Text) -- ^ "created" - 
  , curveGaugeDTOCreatedAtBlock :: !(Maybe Text) -- ^ "created_at_block" - 
  , curveGaugeDTOCreatedAtTransaction :: !(Maybe Text) -- ^ "created_at_transaction" - 
  , curveGaugeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeDTO
instance A.FromJSON CurveGaugeDTO where
  parseJSON = A.withObject "CurveGaugeDTO" $ \o ->
    CurveGaugeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "type")
      <*> (o .:? "pool")
      <*> (o .:? "created")
      <*> (o .:? "created_at_block")
      <*> (o .:? "created_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeDTO
instance A.ToJSON CurveGaugeDTO where
  toJSON CurveGaugeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeDTOEntryTime
      , "recv_time" .= curveGaugeDTORecvTime
      , "block_number" .= curveGaugeDTOBlockNumber
      , "id" .= curveGaugeDTOId
      , "address" .= curveGaugeDTOAddress
      , "type" .= curveGaugeDTOType
      , "pool" .= curveGaugeDTOPool
      , "created" .= curveGaugeDTOCreated
      , "created_at_block" .= curveGaugeDTOCreatedAtBlock
      , "created_at_transaction" .= curveGaugeDTOCreatedAtTransaction
      , "vid" .= curveGaugeDTOVid
      ]


-- | Construct a value of type 'CurveGaugeDTO' (by applying it's required fields, if any)
mkCurveGaugeDTO
  :: CurveGaugeDTO
mkCurveGaugeDTO =
  CurveGaugeDTO
  { curveGaugeDTOEntryTime = Nothing
  , curveGaugeDTORecvTime = Nothing
  , curveGaugeDTOBlockNumber = Nothing
  , curveGaugeDTOId = Nothing
  , curveGaugeDTOAddress = Nothing
  , curveGaugeDTOType = Nothing
  , curveGaugeDTOPool = Nothing
  , curveGaugeDTOCreated = Nothing
  , curveGaugeDTOCreatedAtBlock = Nothing
  , curveGaugeDTOCreatedAtTransaction = Nothing
  , curveGaugeDTOVid = Nothing
  }

-- ** CurveGaugeDepositDTO
-- | CurveGaugeDepositDTO
data CurveGaugeDepositDTO = CurveGaugeDepositDTO
  { curveGaugeDepositDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeDepositDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeDepositDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeDepositDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeDepositDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveGaugeDepositDTOProvider :: !(Maybe Text) -- ^ "provider" - 
  , curveGaugeDepositDTOValue :: !(Maybe Text) -- ^ "value" - 
  , curveGaugeDepositDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curveGaugeDepositDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeDepositDTO
instance A.FromJSON CurveGaugeDepositDTO where
  parseJSON = A.withObject "CurveGaugeDepositDTO" $ \o ->
    CurveGaugeDepositDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "gauge")
      <*> (o .:? "provider")
      <*> (o .:? "value")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON CurveGaugeDepositDTO
instance A.ToJSON CurveGaugeDepositDTO where
  toJSON CurveGaugeDepositDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeDepositDTOEntryTime
      , "recv_time" .= curveGaugeDepositDTORecvTime
      , "block_number" .= curveGaugeDepositDTOBlockNumber
      , "id" .= curveGaugeDepositDTOId
      , "gauge" .= curveGaugeDepositDTOGauge
      , "provider" .= curveGaugeDepositDTOProvider
      , "value" .= curveGaugeDepositDTOValue
      , "vid" .= curveGaugeDepositDTOVid
      , "block_range" .= curveGaugeDepositDTOBlockRange
      ]


-- | Construct a value of type 'CurveGaugeDepositDTO' (by applying it's required fields, if any)
mkCurveGaugeDepositDTO
  :: CurveGaugeDepositDTO
mkCurveGaugeDepositDTO =
  CurveGaugeDepositDTO
  { curveGaugeDepositDTOEntryTime = Nothing
  , curveGaugeDepositDTORecvTime = Nothing
  , curveGaugeDepositDTOBlockNumber = Nothing
  , curveGaugeDepositDTOId = Nothing
  , curveGaugeDepositDTOGauge = Nothing
  , curveGaugeDepositDTOProvider = Nothing
  , curveGaugeDepositDTOValue = Nothing
  , curveGaugeDepositDTOVid = Nothing
  , curveGaugeDepositDTOBlockRange = Nothing
  }

-- ** CurveGaugeLiquidityDTO
-- | CurveGaugeLiquidityDTO
data CurveGaugeLiquidityDTO = CurveGaugeLiquidityDTO
  { curveGaugeLiquidityDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeLiquidityDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeLiquidityDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeLiquidityDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeLiquidityDTOUser :: !(Maybe Text) -- ^ "user" - 
  , curveGaugeLiquidityDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveGaugeLiquidityDTOOriginalBalance :: !(Maybe Text) -- ^ "original_balance" - 
  , curveGaugeLiquidityDTOOriginalSupply :: !(Maybe Text) -- ^ "original_supply" - 
  , curveGaugeLiquidityDTOWorkingBalance :: !(Maybe Text) -- ^ "working_balance" - 
  , curveGaugeLiquidityDTOWorkingSupply :: !(Maybe Text) -- ^ "working_supply" - 
  , curveGaugeLiquidityDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveGaugeLiquidityDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveGaugeLiquidityDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveGaugeLiquidityDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeLiquidityDTO
instance A.FromJSON CurveGaugeLiquidityDTO where
  parseJSON = A.withObject "CurveGaugeLiquidityDTO" $ \o ->
    CurveGaugeLiquidityDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "gauge")
      <*> (o .:? "original_balance")
      <*> (o .:? "original_supply")
      <*> (o .:? "working_balance")
      <*> (o .:? "working_supply")
      <*> (o .:? "timestamp")
      <*> (o .:? "block")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeLiquidityDTO
instance A.ToJSON CurveGaugeLiquidityDTO where
  toJSON CurveGaugeLiquidityDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeLiquidityDTOEntryTime
      , "recv_time" .= curveGaugeLiquidityDTORecvTime
      , "block_number" .= curveGaugeLiquidityDTOBlockNumber
      , "id" .= curveGaugeLiquidityDTOId
      , "user" .= curveGaugeLiquidityDTOUser
      , "gauge" .= curveGaugeLiquidityDTOGauge
      , "original_balance" .= curveGaugeLiquidityDTOOriginalBalance
      , "original_supply" .= curveGaugeLiquidityDTOOriginalSupply
      , "working_balance" .= curveGaugeLiquidityDTOWorkingBalance
      , "working_supply" .= curveGaugeLiquidityDTOWorkingSupply
      , "timestamp" .= curveGaugeLiquidityDTOTimestamp
      , "block" .= curveGaugeLiquidityDTOBlock
      , "transaction" .= curveGaugeLiquidityDTOTransaction
      , "vid" .= curveGaugeLiquidityDTOVid
      ]


-- | Construct a value of type 'CurveGaugeLiquidityDTO' (by applying it's required fields, if any)
mkCurveGaugeLiquidityDTO
  :: CurveGaugeLiquidityDTO
mkCurveGaugeLiquidityDTO =
  CurveGaugeLiquidityDTO
  { curveGaugeLiquidityDTOEntryTime = Nothing
  , curveGaugeLiquidityDTORecvTime = Nothing
  , curveGaugeLiquidityDTOBlockNumber = Nothing
  , curveGaugeLiquidityDTOId = Nothing
  , curveGaugeLiquidityDTOUser = Nothing
  , curveGaugeLiquidityDTOGauge = Nothing
  , curveGaugeLiquidityDTOOriginalBalance = Nothing
  , curveGaugeLiquidityDTOOriginalSupply = Nothing
  , curveGaugeLiquidityDTOWorkingBalance = Nothing
  , curveGaugeLiquidityDTOWorkingSupply = Nothing
  , curveGaugeLiquidityDTOTimestamp = Nothing
  , curveGaugeLiquidityDTOBlock = Nothing
  , curveGaugeLiquidityDTOTransaction = Nothing
  , curveGaugeLiquidityDTOVid = Nothing
  }

-- ** CurveGaugeTotalWeightDTO
-- | CurveGaugeTotalWeightDTO
data CurveGaugeTotalWeightDTO = CurveGaugeTotalWeightDTO
  { curveGaugeTotalWeightDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeTotalWeightDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeTotalWeightDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeTotalWeightDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeTotalWeightDTOTime :: !(Maybe Text) -- ^ "time" - 
  , curveGaugeTotalWeightDTOWeight :: !(Maybe Text) -- ^ "weight" - 
  , curveGaugeTotalWeightDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeTotalWeightDTO
instance A.FromJSON CurveGaugeTotalWeightDTO where
  parseJSON = A.withObject "CurveGaugeTotalWeightDTO" $ \o ->
    CurveGaugeTotalWeightDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "time")
      <*> (o .:? "weight")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeTotalWeightDTO
instance A.ToJSON CurveGaugeTotalWeightDTO where
  toJSON CurveGaugeTotalWeightDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeTotalWeightDTOEntryTime
      , "recv_time" .= curveGaugeTotalWeightDTORecvTime
      , "block_number" .= curveGaugeTotalWeightDTOBlockNumber
      , "id" .= curveGaugeTotalWeightDTOId
      , "time" .= curveGaugeTotalWeightDTOTime
      , "weight" .= curveGaugeTotalWeightDTOWeight
      , "vid" .= curveGaugeTotalWeightDTOVid
      ]


-- | Construct a value of type 'CurveGaugeTotalWeightDTO' (by applying it's required fields, if any)
mkCurveGaugeTotalWeightDTO
  :: CurveGaugeTotalWeightDTO
mkCurveGaugeTotalWeightDTO =
  CurveGaugeTotalWeightDTO
  { curveGaugeTotalWeightDTOEntryTime = Nothing
  , curveGaugeTotalWeightDTORecvTime = Nothing
  , curveGaugeTotalWeightDTOBlockNumber = Nothing
  , curveGaugeTotalWeightDTOId = Nothing
  , curveGaugeTotalWeightDTOTime = Nothing
  , curveGaugeTotalWeightDTOWeight = Nothing
  , curveGaugeTotalWeightDTOVid = Nothing
  }

-- ** CurveGaugeTypeDTO
-- | CurveGaugeTypeDTO
data CurveGaugeTypeDTO = CurveGaugeTypeDTO
  { curveGaugeTypeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeTypeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeTypeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeTypeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeTypeDTOName :: !(Maybe Text) -- ^ "name" - 
  , curveGaugeTypeDTOGaugeCount :: !(Maybe Text) -- ^ "gauge_count" - 
  , curveGaugeTypeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeTypeDTO
instance A.FromJSON CurveGaugeTypeDTO where
  parseJSON = A.withObject "CurveGaugeTypeDTO" $ \o ->
    CurveGaugeTypeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "gauge_count")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeTypeDTO
instance A.ToJSON CurveGaugeTypeDTO where
  toJSON CurveGaugeTypeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeTypeDTOEntryTime
      , "recv_time" .= curveGaugeTypeDTORecvTime
      , "block_number" .= curveGaugeTypeDTOBlockNumber
      , "id" .= curveGaugeTypeDTOId
      , "name" .= curveGaugeTypeDTOName
      , "gauge_count" .= curveGaugeTypeDTOGaugeCount
      , "vid" .= curveGaugeTypeDTOVid
      ]


-- | Construct a value of type 'CurveGaugeTypeDTO' (by applying it's required fields, if any)
mkCurveGaugeTypeDTO
  :: CurveGaugeTypeDTO
mkCurveGaugeTypeDTO =
  CurveGaugeTypeDTO
  { curveGaugeTypeDTOEntryTime = Nothing
  , curveGaugeTypeDTORecvTime = Nothing
  , curveGaugeTypeDTOBlockNumber = Nothing
  , curveGaugeTypeDTOId = Nothing
  , curveGaugeTypeDTOName = Nothing
  , curveGaugeTypeDTOGaugeCount = Nothing
  , curveGaugeTypeDTOVid = Nothing
  }

-- ** CurveGaugeTypeWeightDTO
-- | CurveGaugeTypeWeightDTO
data CurveGaugeTypeWeightDTO = CurveGaugeTypeWeightDTO
  { curveGaugeTypeWeightDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeTypeWeightDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeTypeWeightDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeTypeWeightDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeTypeWeightDTOType :: !(Maybe Text) -- ^ "type" - 
  , curveGaugeTypeWeightDTOTime :: !(Maybe Text) -- ^ "time" - 
  , curveGaugeTypeWeightDTOWeight :: !(Maybe Text) -- ^ "weight" - 
  , curveGaugeTypeWeightDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeTypeWeightDTO
instance A.FromJSON CurveGaugeTypeWeightDTO where
  parseJSON = A.withObject "CurveGaugeTypeWeightDTO" $ \o ->
    CurveGaugeTypeWeightDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "time")
      <*> (o .:? "weight")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeTypeWeightDTO
instance A.ToJSON CurveGaugeTypeWeightDTO where
  toJSON CurveGaugeTypeWeightDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeTypeWeightDTOEntryTime
      , "recv_time" .= curveGaugeTypeWeightDTORecvTime
      , "block_number" .= curveGaugeTypeWeightDTOBlockNumber
      , "id" .= curveGaugeTypeWeightDTOId
      , "type" .= curveGaugeTypeWeightDTOType
      , "time" .= curveGaugeTypeWeightDTOTime
      , "weight" .= curveGaugeTypeWeightDTOWeight
      , "vid" .= curveGaugeTypeWeightDTOVid
      ]


-- | Construct a value of type 'CurveGaugeTypeWeightDTO' (by applying it's required fields, if any)
mkCurveGaugeTypeWeightDTO
  :: CurveGaugeTypeWeightDTO
mkCurveGaugeTypeWeightDTO =
  CurveGaugeTypeWeightDTO
  { curveGaugeTypeWeightDTOEntryTime = Nothing
  , curveGaugeTypeWeightDTORecvTime = Nothing
  , curveGaugeTypeWeightDTOBlockNumber = Nothing
  , curveGaugeTypeWeightDTOId = Nothing
  , curveGaugeTypeWeightDTOType = Nothing
  , curveGaugeTypeWeightDTOTime = Nothing
  , curveGaugeTypeWeightDTOWeight = Nothing
  , curveGaugeTypeWeightDTOVid = Nothing
  }

-- ** CurveGaugeWeightDTO
-- | CurveGaugeWeightDTO
data CurveGaugeWeightDTO = CurveGaugeWeightDTO
  { curveGaugeWeightDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeWeightDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeWeightDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeWeightDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeWeightDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveGaugeWeightDTOTime :: !(Maybe Text) -- ^ "time" - 
  , curveGaugeWeightDTOWeight :: !(Maybe Text) -- ^ "weight" - 
  , curveGaugeWeightDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeWeightDTO
instance A.FromJSON CurveGaugeWeightDTO where
  parseJSON = A.withObject "CurveGaugeWeightDTO" $ \o ->
    CurveGaugeWeightDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "gauge")
      <*> (o .:? "time")
      <*> (o .:? "weight")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeWeightDTO
instance A.ToJSON CurveGaugeWeightDTO where
  toJSON CurveGaugeWeightDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeWeightDTOEntryTime
      , "recv_time" .= curveGaugeWeightDTORecvTime
      , "block_number" .= curveGaugeWeightDTOBlockNumber
      , "id" .= curveGaugeWeightDTOId
      , "gauge" .= curveGaugeWeightDTOGauge
      , "time" .= curveGaugeWeightDTOTime
      , "weight" .= curveGaugeWeightDTOWeight
      , "vid" .= curveGaugeWeightDTOVid
      ]


-- | Construct a value of type 'CurveGaugeWeightDTO' (by applying it's required fields, if any)
mkCurveGaugeWeightDTO
  :: CurveGaugeWeightDTO
mkCurveGaugeWeightDTO =
  CurveGaugeWeightDTO
  { curveGaugeWeightDTOEntryTime = Nothing
  , curveGaugeWeightDTORecvTime = Nothing
  , curveGaugeWeightDTOBlockNumber = Nothing
  , curveGaugeWeightDTOId = Nothing
  , curveGaugeWeightDTOGauge = Nothing
  , curveGaugeWeightDTOTime = Nothing
  , curveGaugeWeightDTOWeight = Nothing
  , curveGaugeWeightDTOVid = Nothing
  }

-- ** CurveGaugeWeightVoteDTO
-- | CurveGaugeWeightVoteDTO
data CurveGaugeWeightVoteDTO = CurveGaugeWeightVoteDTO
  { curveGaugeWeightVoteDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeWeightVoteDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeWeightVoteDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeWeightVoteDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeWeightVoteDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveGaugeWeightVoteDTOUser :: !(Maybe Text) -- ^ "user" - 
  , curveGaugeWeightVoteDTOTime :: !(Maybe Text) -- ^ "time" - 
  , curveGaugeWeightVoteDTOWeight :: !(Maybe Text) -- ^ "weight" - 
  , curveGaugeWeightVoteDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeWeightVoteDTO
instance A.FromJSON CurveGaugeWeightVoteDTO where
  parseJSON = A.withObject "CurveGaugeWeightVoteDTO" $ \o ->
    CurveGaugeWeightVoteDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "gauge")
      <*> (o .:? "user")
      <*> (o .:? "time")
      <*> (o .:? "weight")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeWeightVoteDTO
instance A.ToJSON CurveGaugeWeightVoteDTO where
  toJSON CurveGaugeWeightVoteDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeWeightVoteDTOEntryTime
      , "recv_time" .= curveGaugeWeightVoteDTORecvTime
      , "block_number" .= curveGaugeWeightVoteDTOBlockNumber
      , "id" .= curveGaugeWeightVoteDTOId
      , "gauge" .= curveGaugeWeightVoteDTOGauge
      , "user" .= curveGaugeWeightVoteDTOUser
      , "time" .= curveGaugeWeightVoteDTOTime
      , "weight" .= curveGaugeWeightVoteDTOWeight
      , "vid" .= curveGaugeWeightVoteDTOVid
      ]


-- | Construct a value of type 'CurveGaugeWeightVoteDTO' (by applying it's required fields, if any)
mkCurveGaugeWeightVoteDTO
  :: CurveGaugeWeightVoteDTO
mkCurveGaugeWeightVoteDTO =
  CurveGaugeWeightVoteDTO
  { curveGaugeWeightVoteDTOEntryTime = Nothing
  , curveGaugeWeightVoteDTORecvTime = Nothing
  , curveGaugeWeightVoteDTOBlockNumber = Nothing
  , curveGaugeWeightVoteDTOId = Nothing
  , curveGaugeWeightVoteDTOGauge = Nothing
  , curveGaugeWeightVoteDTOUser = Nothing
  , curveGaugeWeightVoteDTOTime = Nothing
  , curveGaugeWeightVoteDTOWeight = Nothing
  , curveGaugeWeightVoteDTOVid = Nothing
  }

-- ** CurveGaugeWithdrawDTO
-- | CurveGaugeWithdrawDTO
data CurveGaugeWithdrawDTO = CurveGaugeWithdrawDTO
  { curveGaugeWithdrawDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveGaugeWithdrawDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveGaugeWithdrawDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveGaugeWithdrawDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveGaugeWithdrawDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveGaugeWithdrawDTOProvider :: !(Maybe Text) -- ^ "provider" - 
  , curveGaugeWithdrawDTOValue :: !(Maybe Text) -- ^ "value" - 
  , curveGaugeWithdrawDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveGaugeWithdrawDTO
instance A.FromJSON CurveGaugeWithdrawDTO where
  parseJSON = A.withObject "CurveGaugeWithdrawDTO" $ \o ->
    CurveGaugeWithdrawDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "gauge")
      <*> (o .:? "provider")
      <*> (o .:? "value")
      <*> (o .:? "vid")

-- | ToJSON CurveGaugeWithdrawDTO
instance A.ToJSON CurveGaugeWithdrawDTO where
  toJSON CurveGaugeWithdrawDTO {..} =
   _omitNulls
      [ "entry_time" .= curveGaugeWithdrawDTOEntryTime
      , "recv_time" .= curveGaugeWithdrawDTORecvTime
      , "block_number" .= curveGaugeWithdrawDTOBlockNumber
      , "id" .= curveGaugeWithdrawDTOId
      , "gauge" .= curveGaugeWithdrawDTOGauge
      , "provider" .= curveGaugeWithdrawDTOProvider
      , "value" .= curveGaugeWithdrawDTOValue
      , "vid" .= curveGaugeWithdrawDTOVid
      ]


-- | Construct a value of type 'CurveGaugeWithdrawDTO' (by applying it's required fields, if any)
mkCurveGaugeWithdrawDTO
  :: CurveGaugeWithdrawDTO
mkCurveGaugeWithdrawDTO =
  CurveGaugeWithdrawDTO
  { curveGaugeWithdrawDTOEntryTime = Nothing
  , curveGaugeWithdrawDTORecvTime = Nothing
  , curveGaugeWithdrawDTOBlockNumber = Nothing
  , curveGaugeWithdrawDTOId = Nothing
  , curveGaugeWithdrawDTOGauge = Nothing
  , curveGaugeWithdrawDTOProvider = Nothing
  , curveGaugeWithdrawDTOValue = Nothing
  , curveGaugeWithdrawDTOVid = Nothing
  }

-- ** CurveHourlyVolumeDTO
-- | CurveHourlyVolumeDTO
data CurveHourlyVolumeDTO = CurveHourlyVolumeDTO
  { curveHourlyVolumeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveHourlyVolumeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveHourlyVolumeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveHourlyVolumeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveHourlyVolumeDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveHourlyVolumeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveHourlyVolumeDTOVolume :: !(Maybe Text) -- ^ "volume" - 
  , curveHourlyVolumeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveHourlyVolumeDTO
instance A.FromJSON CurveHourlyVolumeDTO where
  parseJSON = A.withObject "CurveHourlyVolumeDTO" $ \o ->
    CurveHourlyVolumeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "timestamp")
      <*> (o .:? "volume")
      <*> (o .:? "vid")

-- | ToJSON CurveHourlyVolumeDTO
instance A.ToJSON CurveHourlyVolumeDTO where
  toJSON CurveHourlyVolumeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveHourlyVolumeDTOEntryTime
      , "recv_time" .= curveHourlyVolumeDTORecvTime
      , "block_number" .= curveHourlyVolumeDTOBlockNumber
      , "id" .= curveHourlyVolumeDTOId
      , "pool" .= curveHourlyVolumeDTOPool
      , "timestamp" .= curveHourlyVolumeDTOTimestamp
      , "volume" .= curveHourlyVolumeDTOVolume
      , "vid" .= curveHourlyVolumeDTOVid
      ]


-- | Construct a value of type 'CurveHourlyVolumeDTO' (by applying it's required fields, if any)
mkCurveHourlyVolumeDTO
  :: CurveHourlyVolumeDTO
mkCurveHourlyVolumeDTO =
  CurveHourlyVolumeDTO
  { curveHourlyVolumeDTOEntryTime = Nothing
  , curveHourlyVolumeDTORecvTime = Nothing
  , curveHourlyVolumeDTOBlockNumber = Nothing
  , curveHourlyVolumeDTOId = Nothing
  , curveHourlyVolumeDTOPool = Nothing
  , curveHourlyVolumeDTOTimestamp = Nothing
  , curveHourlyVolumeDTOVolume = Nothing
  , curveHourlyVolumeDTOVid = Nothing
  }

-- ** CurveLpTokenDTO
-- | CurveLpTokenDTO
data CurveLpTokenDTO = CurveLpTokenDTO
  { curveLpTokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveLpTokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveLpTokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveLpTokenDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveLpTokenDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveLpTokenDTODecimals :: !(Maybe Text) -- ^ "decimals" - 
  , curveLpTokenDTOName :: !(Maybe Text) -- ^ "name" - 
  , curveLpTokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - 
  , curveLpTokenDTOGauge :: !(Maybe Text) -- ^ "gauge" - 
  , curveLpTokenDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveLpTokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveLpTokenDTO
instance A.FromJSON CurveLpTokenDTO where
  parseJSON = A.withObject "CurveLpTokenDTO" $ \o ->
    CurveLpTokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "decimals")
      <*> (o .:? "name")
      <*> (o .:? "symbol")
      <*> (o .:? "gauge")
      <*> (o .:? "pool")
      <*> (o .:? "vid")

-- | ToJSON CurveLpTokenDTO
instance A.ToJSON CurveLpTokenDTO where
  toJSON CurveLpTokenDTO {..} =
   _omitNulls
      [ "entry_time" .= curveLpTokenDTOEntryTime
      , "recv_time" .= curveLpTokenDTORecvTime
      , "block_number" .= curveLpTokenDTOBlockNumber
      , "id" .= curveLpTokenDTOId
      , "address" .= curveLpTokenDTOAddress
      , "decimals" .= curveLpTokenDTODecimals
      , "name" .= curveLpTokenDTOName
      , "symbol" .= curveLpTokenDTOSymbol
      , "gauge" .= curveLpTokenDTOGauge
      , "pool" .= curveLpTokenDTOPool
      , "vid" .= curveLpTokenDTOVid
      ]


-- | Construct a value of type 'CurveLpTokenDTO' (by applying it's required fields, if any)
mkCurveLpTokenDTO
  :: CurveLpTokenDTO
mkCurveLpTokenDTO =
  CurveLpTokenDTO
  { curveLpTokenDTOEntryTime = Nothing
  , curveLpTokenDTORecvTime = Nothing
  , curveLpTokenDTOBlockNumber = Nothing
  , curveLpTokenDTOId = Nothing
  , curveLpTokenDTOAddress = Nothing
  , curveLpTokenDTODecimals = Nothing
  , curveLpTokenDTOName = Nothing
  , curveLpTokenDTOSymbol = Nothing
  , curveLpTokenDTOGauge = Nothing
  , curveLpTokenDTOPool = Nothing
  , curveLpTokenDTOVid = Nothing
  }

-- ** CurvePoolDTO
-- | CurvePoolDTO
data CurvePoolDTO = CurvePoolDTO
  { curvePoolDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curvePoolDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curvePoolDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curvePoolDTOId :: !(Maybe Text) -- ^ "id" - Pool address.
  , curvePoolDTOName :: !(Maybe Text) -- ^ "name" - Pool&#39;s human-readable name.
  , curvePoolDTOIsMeta :: !(Maybe Bool) -- ^ "is_meta" - Identify whether pool is a metapool.
  , curvePoolDTORegistryAddress :: !(Maybe Text) -- ^ "registry_address" - Registry contract address from where this pool was registered.
  , curvePoolDTOSwapAddress :: !(Maybe Text) -- ^ "swap_address" - Swap contract address.
  , curvePoolDTOLpToken :: !(Maybe Text) -- ^ "lp_token" - Address of the token representing LP share.
  , curvePoolDTOCoinCount :: !(Maybe Text) -- ^ "coin_count" - Number of coins composing the pool.
  , curvePoolDTOUnderlyingCount :: !(Maybe Text) -- ^ "underlying_count" - Number of underlying coins composing the pool.
  , curvePoolDTOA :: !(Maybe Text) -- ^ "a" - Amplification coefficient multiplied by n * (n - 1).
  , curvePoolDTOFee :: !(Maybe Text) -- ^ "fee" - Fee to charge for exchanges.
  , curvePoolDTOAdminFee :: !(Maybe Text) -- ^ "admin_fee" - Admin fee is represented as a percentage of the total fee collected on a swap.
  , curvePoolDTOOwner :: !(Maybe Text) -- ^ "owner" - Admin address.
  , curvePoolDTOVirtualPrice :: !(Maybe Text) -- ^ "virtual_price" - Average dollar value of pool token.
  , curvePoolDTOLocked :: !(Maybe Text) -- ^ "locked" - 
  , curvePoolDTOAddedAt :: !(Maybe DateTime) -- ^ "added_at" - 
  , curvePoolDTOAddedAtBlock :: !(Maybe Text) -- ^ "added_at_block" - 
  , curvePoolDTOAddedAtTransaction :: !(Maybe Text) -- ^ "added_at_transaction" - 
  , curvePoolDTORemovedAt :: !(Maybe Text) -- ^ "removed_at" - 
  , curvePoolDTORemovedAtBlock :: !(Maybe Text) -- ^ "removed_at_block" - 
  , curvePoolDTORemovedAtTransaction :: !(Maybe Text) -- ^ "removed_at_transaction" - 
  , curvePoolDTOExchangeCount :: !(Maybe Text) -- ^ "exchange_count" - 
  , curvePoolDTOGaugeCount :: !(Maybe Text) -- ^ "gauge_count" - 
  , curvePoolDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curvePoolDTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurvePoolDTO
instance A.FromJSON CurvePoolDTO where
  parseJSON = A.withObject "CurvePoolDTO" $ \o ->
    CurvePoolDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "is_meta")
      <*> (o .:? "registry_address")
      <*> (o .:? "swap_address")
      <*> (o .:? "lp_token")
      <*> (o .:? "coin_count")
      <*> (o .:? "underlying_count")
      <*> (o .:? "a")
      <*> (o .:? "fee")
      <*> (o .:? "admin_fee")
      <*> (o .:? "owner")
      <*> (o .:? "virtual_price")
      <*> (o .:? "locked")
      <*> (o .:? "added_at")
      <*> (o .:? "added_at_block")
      <*> (o .:? "added_at_transaction")
      <*> (o .:? "removed_at")
      <*> (o .:? "removed_at_block")
      <*> (o .:? "removed_at_transaction")
      <*> (o .:? "exchange_count")
      <*> (o .:? "gauge_count")
      <*> (o .:? "vid")
      <*> (o .:? "evaluated_ask")

-- | ToJSON CurvePoolDTO
instance A.ToJSON CurvePoolDTO where
  toJSON CurvePoolDTO {..} =
   _omitNulls
      [ "entry_time" .= curvePoolDTOEntryTime
      , "recv_time" .= curvePoolDTORecvTime
      , "block_number" .= curvePoolDTOBlockNumber
      , "id" .= curvePoolDTOId
      , "name" .= curvePoolDTOName
      , "is_meta" .= curvePoolDTOIsMeta
      , "registry_address" .= curvePoolDTORegistryAddress
      , "swap_address" .= curvePoolDTOSwapAddress
      , "lp_token" .= curvePoolDTOLpToken
      , "coin_count" .= curvePoolDTOCoinCount
      , "underlying_count" .= curvePoolDTOUnderlyingCount
      , "a" .= curvePoolDTOA
      , "fee" .= curvePoolDTOFee
      , "admin_fee" .= curvePoolDTOAdminFee
      , "owner" .= curvePoolDTOOwner
      , "virtual_price" .= curvePoolDTOVirtualPrice
      , "locked" .= curvePoolDTOLocked
      , "added_at" .= curvePoolDTOAddedAt
      , "added_at_block" .= curvePoolDTOAddedAtBlock
      , "added_at_transaction" .= curvePoolDTOAddedAtTransaction
      , "removed_at" .= curvePoolDTORemovedAt
      , "removed_at_block" .= curvePoolDTORemovedAtBlock
      , "removed_at_transaction" .= curvePoolDTORemovedAtTransaction
      , "exchange_count" .= curvePoolDTOExchangeCount
      , "gauge_count" .= curvePoolDTOGaugeCount
      , "vid" .= curvePoolDTOVid
      , "evaluated_ask" .= curvePoolDTOEvaluatedAsk
      ]


-- | Construct a value of type 'CurvePoolDTO' (by applying it's required fields, if any)
mkCurvePoolDTO
  :: CurvePoolDTO
mkCurvePoolDTO =
  CurvePoolDTO
  { curvePoolDTOEntryTime = Nothing
  , curvePoolDTORecvTime = Nothing
  , curvePoolDTOBlockNumber = Nothing
  , curvePoolDTOId = Nothing
  , curvePoolDTOName = Nothing
  , curvePoolDTOIsMeta = Nothing
  , curvePoolDTORegistryAddress = Nothing
  , curvePoolDTOSwapAddress = Nothing
  , curvePoolDTOLpToken = Nothing
  , curvePoolDTOCoinCount = Nothing
  , curvePoolDTOUnderlyingCount = Nothing
  , curvePoolDTOA = Nothing
  , curvePoolDTOFee = Nothing
  , curvePoolDTOAdminFee = Nothing
  , curvePoolDTOOwner = Nothing
  , curvePoolDTOVirtualPrice = Nothing
  , curvePoolDTOLocked = Nothing
  , curvePoolDTOAddedAt = Nothing
  , curvePoolDTOAddedAtBlock = Nothing
  , curvePoolDTOAddedAtTransaction = Nothing
  , curvePoolDTORemovedAt = Nothing
  , curvePoolDTORemovedAtBlock = Nothing
  , curvePoolDTORemovedAtTransaction = Nothing
  , curvePoolDTOExchangeCount = Nothing
  , curvePoolDTOGaugeCount = Nothing
  , curvePoolDTOVid = Nothing
  , curvePoolDTOEvaluatedAsk = Nothing
  }

-- ** CurveProposalDTO
-- | CurveProposalDTO
data CurveProposalDTO = CurveProposalDTO
  { curveProposalDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveProposalDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveProposalDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveProposalDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveProposalDTONumber :: !(Maybe Text) -- ^ "number" - Sequential number in related to the realted voting app.
  , curveProposalDTOApp :: !(Maybe Text) -- ^ "app" - Voting app instance.
  , curveProposalDTOCreator :: !(Maybe Text) -- ^ "creator" - Proposal creator&#39;s account.
  , curveProposalDTOExecutionScript :: !(Maybe Text) -- ^ "execution_script" - 
  , curveProposalDTOExpireDate :: !(Maybe Text) -- ^ "expire_date" - 
  , curveProposalDTOMinimumQuorum :: !(Maybe Text) -- ^ "minimum_quorum" - Percentage of positive votes in total possible votes for this proposal to be accepted.
  , curveProposalDTORequiredSupport :: !(Maybe Text) -- ^ "required_support" - Percentage of positive votes needed for this proposal to be accepted.
  , curveProposalDTOSnapshotBlock :: !(Maybe Text) -- ^ "snapshot_block" - 
  , curveProposalDTOVotingPower :: !(Maybe Text) -- ^ "voting_power" - 
  , curveProposalDTOMetadata :: !(Maybe Text) -- ^ "metadata" - Link to metadata file.
  , curveProposalDTOText :: !(Maybe Text) -- ^ "text" - Proposal description text.
  , curveProposalDTOVoteCount :: !(Maybe Text) -- ^ "vote_count" - Number of votes received by the proposal.
  , curveProposalDTOPositiveVoteCount :: !(Maybe Text) -- ^ "positive_vote_count" - Number of positive votes (yes) received by the proposal.
  , curveProposalDTONegativeVoteCount :: !(Maybe Text) -- ^ "negative_vote_count" - Number of negative votes (no) received by the proposal.
  , curveProposalDTOCurrentQuorum :: !(Maybe Text) -- ^ "current_quorum" - 
  , curveProposalDTOCurrentSupport :: !(Maybe Text) -- ^ "current_support" - 
  , curveProposalDTOStakedSupport :: !(Maybe Text) -- ^ "staked_support" - 
  , curveProposalDTOTotalStaked :: !(Maybe Text) -- ^ "total_staked" - 
  , curveProposalDTOCreated :: !(Maybe Text) -- ^ "created" - 
  , curveProposalDTOCreatedAtBlock :: !(Maybe Text) -- ^ "created_at_block" - 
  , curveProposalDTOCreatedAtTransaction :: !(Maybe Text) -- ^ "created_at_transaction" - 
  , curveProposalDTOUpdated :: !(Maybe Text) -- ^ "updated" - 
  , curveProposalDTOUpdatedAtBlock :: !(Maybe Text) -- ^ "updated_at_block" - 
  , curveProposalDTOUpdatedAtTransaction :: !(Maybe Text) -- ^ "updated_at_transaction" - 
  , curveProposalDTOExecuted :: !(Maybe Text) -- ^ "executed" - 
  , curveProposalDTOExecutedAtBlock :: !(Maybe Text) -- ^ "executed_at_block" - 
  , curveProposalDTOExecutedAtTransaction :: !(Maybe Text) -- ^ "executed_at_transaction" - 
  , curveProposalDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveProposalDTO
instance A.FromJSON CurveProposalDTO where
  parseJSON = A.withObject "CurveProposalDTO" $ \o ->
    CurveProposalDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "number")
      <*> (o .:? "app")
      <*> (o .:? "creator")
      <*> (o .:? "execution_script")
      <*> (o .:? "expire_date")
      <*> (o .:? "minimum_quorum")
      <*> (o .:? "required_support")
      <*> (o .:? "snapshot_block")
      <*> (o .:? "voting_power")
      <*> (o .:? "metadata")
      <*> (o .:? "text")
      <*> (o .:? "vote_count")
      <*> (o .:? "positive_vote_count")
      <*> (o .:? "negative_vote_count")
      <*> (o .:? "current_quorum")
      <*> (o .:? "current_support")
      <*> (o .:? "staked_support")
      <*> (o .:? "total_staked")
      <*> (o .:? "created")
      <*> (o .:? "created_at_block")
      <*> (o .:? "created_at_transaction")
      <*> (o .:? "updated")
      <*> (o .:? "updated_at_block")
      <*> (o .:? "updated_at_transaction")
      <*> (o .:? "executed")
      <*> (o .:? "executed_at_block")
      <*> (o .:? "executed_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveProposalDTO
instance A.ToJSON CurveProposalDTO where
  toJSON CurveProposalDTO {..} =
   _omitNulls
      [ "entry_time" .= curveProposalDTOEntryTime
      , "recv_time" .= curveProposalDTORecvTime
      , "block_number" .= curveProposalDTOBlockNumber
      , "id" .= curveProposalDTOId
      , "number" .= curveProposalDTONumber
      , "app" .= curveProposalDTOApp
      , "creator" .= curveProposalDTOCreator
      , "execution_script" .= curveProposalDTOExecutionScript
      , "expire_date" .= curveProposalDTOExpireDate
      , "minimum_quorum" .= curveProposalDTOMinimumQuorum
      , "required_support" .= curveProposalDTORequiredSupport
      , "snapshot_block" .= curveProposalDTOSnapshotBlock
      , "voting_power" .= curveProposalDTOVotingPower
      , "metadata" .= curveProposalDTOMetadata
      , "text" .= curveProposalDTOText
      , "vote_count" .= curveProposalDTOVoteCount
      , "positive_vote_count" .= curveProposalDTOPositiveVoteCount
      , "negative_vote_count" .= curveProposalDTONegativeVoteCount
      , "current_quorum" .= curveProposalDTOCurrentQuorum
      , "current_support" .= curveProposalDTOCurrentSupport
      , "staked_support" .= curveProposalDTOStakedSupport
      , "total_staked" .= curveProposalDTOTotalStaked
      , "created" .= curveProposalDTOCreated
      , "created_at_block" .= curveProposalDTOCreatedAtBlock
      , "created_at_transaction" .= curveProposalDTOCreatedAtTransaction
      , "updated" .= curveProposalDTOUpdated
      , "updated_at_block" .= curveProposalDTOUpdatedAtBlock
      , "updated_at_transaction" .= curveProposalDTOUpdatedAtTransaction
      , "executed" .= curveProposalDTOExecuted
      , "executed_at_block" .= curveProposalDTOExecutedAtBlock
      , "executed_at_transaction" .= curveProposalDTOExecutedAtTransaction
      , "vid" .= curveProposalDTOVid
      ]


-- | Construct a value of type 'CurveProposalDTO' (by applying it's required fields, if any)
mkCurveProposalDTO
  :: CurveProposalDTO
mkCurveProposalDTO =
  CurveProposalDTO
  { curveProposalDTOEntryTime = Nothing
  , curveProposalDTORecvTime = Nothing
  , curveProposalDTOBlockNumber = Nothing
  , curveProposalDTOId = Nothing
  , curveProposalDTONumber = Nothing
  , curveProposalDTOApp = Nothing
  , curveProposalDTOCreator = Nothing
  , curveProposalDTOExecutionScript = Nothing
  , curveProposalDTOExpireDate = Nothing
  , curveProposalDTOMinimumQuorum = Nothing
  , curveProposalDTORequiredSupport = Nothing
  , curveProposalDTOSnapshotBlock = Nothing
  , curveProposalDTOVotingPower = Nothing
  , curveProposalDTOMetadata = Nothing
  , curveProposalDTOText = Nothing
  , curveProposalDTOVoteCount = Nothing
  , curveProposalDTOPositiveVoteCount = Nothing
  , curveProposalDTONegativeVoteCount = Nothing
  , curveProposalDTOCurrentQuorum = Nothing
  , curveProposalDTOCurrentSupport = Nothing
  , curveProposalDTOStakedSupport = Nothing
  , curveProposalDTOTotalStaked = Nothing
  , curveProposalDTOCreated = Nothing
  , curveProposalDTOCreatedAtBlock = Nothing
  , curveProposalDTOCreatedAtTransaction = Nothing
  , curveProposalDTOUpdated = Nothing
  , curveProposalDTOUpdatedAtBlock = Nothing
  , curveProposalDTOUpdatedAtTransaction = Nothing
  , curveProposalDTOExecuted = Nothing
  , curveProposalDTOExecutedAtBlock = Nothing
  , curveProposalDTOExecutedAtTransaction = Nothing
  , curveProposalDTOVid = Nothing
  }

-- ** CurveProposalVoteDTO
-- | CurveProposalVoteDTO
data CurveProposalVoteDTO = CurveProposalVoteDTO
  { curveProposalVoteDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveProposalVoteDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveProposalVoteDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveProposalVoteDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveProposalVoteDTOProposal :: !(Maybe Text) -- ^ "proposal" - 
  , curveProposalVoteDTOSupports :: !(Maybe Bool) -- ^ "supports" - 
  , curveProposalVoteDTOStake :: !(Maybe Text) -- ^ "stake" - 
  , curveProposalVoteDTOVoter :: !(Maybe Text) -- ^ "voter" - 
  , curveProposalVoteDTOCreated :: !(Maybe Text) -- ^ "created" - 
  , curveProposalVoteDTOCreatedAtBlock :: !(Maybe Text) -- ^ "created_at_block" - 
  , curveProposalVoteDTOCreatedAtTransaction :: !(Maybe Text) -- ^ "created_at_transaction" - 
  , curveProposalVoteDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveProposalVoteDTO
instance A.FromJSON CurveProposalVoteDTO where
  parseJSON = A.withObject "CurveProposalVoteDTO" $ \o ->
    CurveProposalVoteDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "proposal")
      <*> (o .:? "supports")
      <*> (o .:? "stake")
      <*> (o .:? "voter")
      <*> (o .:? "created")
      <*> (o .:? "created_at_block")
      <*> (o .:? "created_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveProposalVoteDTO
instance A.ToJSON CurveProposalVoteDTO where
  toJSON CurveProposalVoteDTO {..} =
   _omitNulls
      [ "entry_time" .= curveProposalVoteDTOEntryTime
      , "recv_time" .= curveProposalVoteDTORecvTime
      , "block_number" .= curveProposalVoteDTOBlockNumber
      , "id" .= curveProposalVoteDTOId
      , "proposal" .= curveProposalVoteDTOProposal
      , "supports" .= curveProposalVoteDTOSupports
      , "stake" .= curveProposalVoteDTOStake
      , "voter" .= curveProposalVoteDTOVoter
      , "created" .= curveProposalVoteDTOCreated
      , "created_at_block" .= curveProposalVoteDTOCreatedAtBlock
      , "created_at_transaction" .= curveProposalVoteDTOCreatedAtTransaction
      , "vid" .= curveProposalVoteDTOVid
      ]


-- | Construct a value of type 'CurveProposalVoteDTO' (by applying it's required fields, if any)
mkCurveProposalVoteDTO
  :: CurveProposalVoteDTO
mkCurveProposalVoteDTO =
  CurveProposalVoteDTO
  { curveProposalVoteDTOEntryTime = Nothing
  , curveProposalVoteDTORecvTime = Nothing
  , curveProposalVoteDTOBlockNumber = Nothing
  , curveProposalVoteDTOId = Nothing
  , curveProposalVoteDTOProposal = Nothing
  , curveProposalVoteDTOSupports = Nothing
  , curveProposalVoteDTOStake = Nothing
  , curveProposalVoteDTOVoter = Nothing
  , curveProposalVoteDTOCreated = Nothing
  , curveProposalVoteDTOCreatedAtBlock = Nothing
  , curveProposalVoteDTOCreatedAtTransaction = Nothing
  , curveProposalVoteDTOVid = Nothing
  }

-- ** CurveRemoveLiquidityEventDTO
-- | CurveRemoveLiquidityEventDTO
data CurveRemoveLiquidityEventDTO = CurveRemoveLiquidityEventDTO
  { curveRemoveLiquidityEventDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveRemoveLiquidityEventDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveRemoveLiquidityEventDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveRemoveLiquidityEventDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveRemoveLiquidityEventDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveRemoveLiquidityEventDTOProvider :: !(Maybe Text) -- ^ "provider" - 
  , curveRemoveLiquidityEventDTOTokenAmounts :: !(Maybe [Text]) -- ^ "token_amounts" - 
  , curveRemoveLiquidityEventDTOFees :: !(Maybe [Text]) -- ^ "fees" - 
  , curveRemoveLiquidityEventDTOTokenSupply :: !(Maybe Text) -- ^ "token_supply" - 
  , curveRemoveLiquidityEventDTOInvariant :: !(Maybe Text) -- ^ "invariant" - 
  , curveRemoveLiquidityEventDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveRemoveLiquidityEventDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveRemoveLiquidityEventDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveRemoveLiquidityEventDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveRemoveLiquidityEventDTO
instance A.FromJSON CurveRemoveLiquidityEventDTO where
  parseJSON = A.withObject "CurveRemoveLiquidityEventDTO" $ \o ->
    CurveRemoveLiquidityEventDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "provider")
      <*> (o .:? "token_amounts")
      <*> (o .:? "fees")
      <*> (o .:? "token_supply")
      <*> (o .:? "invariant")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveRemoveLiquidityEventDTO
instance A.ToJSON CurveRemoveLiquidityEventDTO where
  toJSON CurveRemoveLiquidityEventDTO {..} =
   _omitNulls
      [ "entry_time" .= curveRemoveLiquidityEventDTOEntryTime
      , "recv_time" .= curveRemoveLiquidityEventDTORecvTime
      , "block_number" .= curveRemoveLiquidityEventDTOBlockNumber
      , "id" .= curveRemoveLiquidityEventDTOId
      , "pool" .= curveRemoveLiquidityEventDTOPool
      , "provider" .= curveRemoveLiquidityEventDTOProvider
      , "token_amounts" .= curveRemoveLiquidityEventDTOTokenAmounts
      , "fees" .= curveRemoveLiquidityEventDTOFees
      , "token_supply" .= curveRemoveLiquidityEventDTOTokenSupply
      , "invariant" .= curveRemoveLiquidityEventDTOInvariant
      , "block" .= curveRemoveLiquidityEventDTOBlock
      , "timestamp" .= curveRemoveLiquidityEventDTOTimestamp
      , "transaction" .= curveRemoveLiquidityEventDTOTransaction
      , "vid" .= curveRemoveLiquidityEventDTOVid
      ]


-- | Construct a value of type 'CurveRemoveLiquidityEventDTO' (by applying it's required fields, if any)
mkCurveRemoveLiquidityEventDTO
  :: CurveRemoveLiquidityEventDTO
mkCurveRemoveLiquidityEventDTO =
  CurveRemoveLiquidityEventDTO
  { curveRemoveLiquidityEventDTOEntryTime = Nothing
  , curveRemoveLiquidityEventDTORecvTime = Nothing
  , curveRemoveLiquidityEventDTOBlockNumber = Nothing
  , curveRemoveLiquidityEventDTOId = Nothing
  , curveRemoveLiquidityEventDTOPool = Nothing
  , curveRemoveLiquidityEventDTOProvider = Nothing
  , curveRemoveLiquidityEventDTOTokenAmounts = Nothing
  , curveRemoveLiquidityEventDTOFees = Nothing
  , curveRemoveLiquidityEventDTOTokenSupply = Nothing
  , curveRemoveLiquidityEventDTOInvariant = Nothing
  , curveRemoveLiquidityEventDTOBlock = Nothing
  , curveRemoveLiquidityEventDTOTimestamp = Nothing
  , curveRemoveLiquidityEventDTOTransaction = Nothing
  , curveRemoveLiquidityEventDTOVid = Nothing
  }

-- ** CurveRemoveLiquidityOneEventDTO
-- | CurveRemoveLiquidityOneEventDTO
data CurveRemoveLiquidityOneEventDTO = CurveRemoveLiquidityOneEventDTO
  { curveRemoveLiquidityOneEventDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveRemoveLiquidityOneEventDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveRemoveLiquidityOneEventDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveRemoveLiquidityOneEventDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveRemoveLiquidityOneEventDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveRemoveLiquidityOneEventDTOProvider :: !(Maybe Text) -- ^ "provider" - 
  , curveRemoveLiquidityOneEventDTOTokenAmount :: !(Maybe Text) -- ^ "token_amount" - 
  , curveRemoveLiquidityOneEventDTOCoinAmount :: !(Maybe Text) -- ^ "coin_amount" - 
  , curveRemoveLiquidityOneEventDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveRemoveLiquidityOneEventDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveRemoveLiquidityOneEventDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveRemoveLiquidityOneEventDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveRemoveLiquidityOneEventDTO
instance A.FromJSON CurveRemoveLiquidityOneEventDTO where
  parseJSON = A.withObject "CurveRemoveLiquidityOneEventDTO" $ \o ->
    CurveRemoveLiquidityOneEventDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "provider")
      <*> (o .:? "token_amount")
      <*> (o .:? "coin_amount")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveRemoveLiquidityOneEventDTO
instance A.ToJSON CurveRemoveLiquidityOneEventDTO where
  toJSON CurveRemoveLiquidityOneEventDTO {..} =
   _omitNulls
      [ "entry_time" .= curveRemoveLiquidityOneEventDTOEntryTime
      , "recv_time" .= curveRemoveLiquidityOneEventDTORecvTime
      , "block_number" .= curveRemoveLiquidityOneEventDTOBlockNumber
      , "id" .= curveRemoveLiquidityOneEventDTOId
      , "pool" .= curveRemoveLiquidityOneEventDTOPool
      , "provider" .= curveRemoveLiquidityOneEventDTOProvider
      , "token_amount" .= curveRemoveLiquidityOneEventDTOTokenAmount
      , "coin_amount" .= curveRemoveLiquidityOneEventDTOCoinAmount
      , "block" .= curveRemoveLiquidityOneEventDTOBlock
      , "timestamp" .= curveRemoveLiquidityOneEventDTOTimestamp
      , "transaction" .= curveRemoveLiquidityOneEventDTOTransaction
      , "vid" .= curveRemoveLiquidityOneEventDTOVid
      ]


-- | Construct a value of type 'CurveRemoveLiquidityOneEventDTO' (by applying it's required fields, if any)
mkCurveRemoveLiquidityOneEventDTO
  :: CurveRemoveLiquidityOneEventDTO
mkCurveRemoveLiquidityOneEventDTO =
  CurveRemoveLiquidityOneEventDTO
  { curveRemoveLiquidityOneEventDTOEntryTime = Nothing
  , curveRemoveLiquidityOneEventDTORecvTime = Nothing
  , curveRemoveLiquidityOneEventDTOBlockNumber = Nothing
  , curveRemoveLiquidityOneEventDTOId = Nothing
  , curveRemoveLiquidityOneEventDTOPool = Nothing
  , curveRemoveLiquidityOneEventDTOProvider = Nothing
  , curveRemoveLiquidityOneEventDTOTokenAmount = Nothing
  , curveRemoveLiquidityOneEventDTOCoinAmount = Nothing
  , curveRemoveLiquidityOneEventDTOBlock = Nothing
  , curveRemoveLiquidityOneEventDTOTimestamp = Nothing
  , curveRemoveLiquidityOneEventDTOTransaction = Nothing
  , curveRemoveLiquidityOneEventDTOVid = Nothing
  }

-- ** CurveSystemStateDTO
-- | CurveSystemStateDTO
data CurveSystemStateDTO = CurveSystemStateDTO
  { curveSystemStateDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveSystemStateDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveSystemStateDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveSystemStateDTOId :: !(Maybe Text) -- ^ "id" - Singleton ID, equals to &#39;current&#39;.
  , curveSystemStateDTORegistryContract :: !(Maybe Text) -- ^ "registry_contract" - Current pool registry address.
  , curveSystemStateDTOContractCount :: !(Maybe Text) -- ^ "contract_count" - Number of contracts in the AddressProvider registry.
  , curveSystemStateDTOGaugeCount :: !(Maybe Text) -- ^ "gauge_count" - Number of gauges registered.
  , curveSystemStateDTOGaugeTypeCount :: !(Maybe Text) -- ^ "gauge_type_count" - Number of gauge types registered.
  , curveSystemStateDTOPoolCount :: !(Maybe Text) -- ^ "pool_count" - Number of active pools.
  , curveSystemStateDTOTokenCount :: !(Maybe Text) -- ^ "token_count" - Number of tokens registered.
  , curveSystemStateDTOTotalPoolCount :: !(Maybe Text) -- ^ "total_pool_count" - Total number of pools (including removed ones).
  , curveSystemStateDTOUpdated :: !(Maybe Text) -- ^ "updated" - 
  , curveSystemStateDTOUpdatedAtBlock :: !(Maybe Text) -- ^ "updated_at_block" - 
  , curveSystemStateDTOUpdatedAtTransaction :: !(Maybe Text) -- ^ "updated_at_transaction" - 
  , curveSystemStateDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveSystemStateDTO
instance A.FromJSON CurveSystemStateDTO where
  parseJSON = A.withObject "CurveSystemStateDTO" $ \o ->
    CurveSystemStateDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "registry_contract")
      <*> (o .:? "contract_count")
      <*> (o .:? "gauge_count")
      <*> (o .:? "gauge_type_count")
      <*> (o .:? "pool_count")
      <*> (o .:? "token_count")
      <*> (o .:? "total_pool_count")
      <*> (o .:? "updated")
      <*> (o .:? "updated_at_block")
      <*> (o .:? "updated_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveSystemStateDTO
instance A.ToJSON CurveSystemStateDTO where
  toJSON CurveSystemStateDTO {..} =
   _omitNulls
      [ "entry_time" .= curveSystemStateDTOEntryTime
      , "recv_time" .= curveSystemStateDTORecvTime
      , "block_number" .= curveSystemStateDTOBlockNumber
      , "id" .= curveSystemStateDTOId
      , "registry_contract" .= curveSystemStateDTORegistryContract
      , "contract_count" .= curveSystemStateDTOContractCount
      , "gauge_count" .= curveSystemStateDTOGaugeCount
      , "gauge_type_count" .= curveSystemStateDTOGaugeTypeCount
      , "pool_count" .= curveSystemStateDTOPoolCount
      , "token_count" .= curveSystemStateDTOTokenCount
      , "total_pool_count" .= curveSystemStateDTOTotalPoolCount
      , "updated" .= curveSystemStateDTOUpdated
      , "updated_at_block" .= curveSystemStateDTOUpdatedAtBlock
      , "updated_at_transaction" .= curveSystemStateDTOUpdatedAtTransaction
      , "vid" .= curveSystemStateDTOVid
      ]


-- | Construct a value of type 'CurveSystemStateDTO' (by applying it's required fields, if any)
mkCurveSystemStateDTO
  :: CurveSystemStateDTO
mkCurveSystemStateDTO =
  CurveSystemStateDTO
  { curveSystemStateDTOEntryTime = Nothing
  , curveSystemStateDTORecvTime = Nothing
  , curveSystemStateDTOBlockNumber = Nothing
  , curveSystemStateDTOId = Nothing
  , curveSystemStateDTORegistryContract = Nothing
  , curveSystemStateDTOContractCount = Nothing
  , curveSystemStateDTOGaugeCount = Nothing
  , curveSystemStateDTOGaugeTypeCount = Nothing
  , curveSystemStateDTOPoolCount = Nothing
  , curveSystemStateDTOTokenCount = Nothing
  , curveSystemStateDTOTotalPoolCount = Nothing
  , curveSystemStateDTOUpdated = Nothing
  , curveSystemStateDTOUpdatedAtBlock = Nothing
  , curveSystemStateDTOUpdatedAtTransaction = Nothing
  , curveSystemStateDTOVid = Nothing
  }

-- ** CurveTokenDTO
-- | CurveTokenDTO
data CurveTokenDTO = CurveTokenDTO
  { curveTokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveTokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveTokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveTokenDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveTokenDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveTokenDTODecimals :: !(Maybe Text) -- ^ "decimals" - 
  , curveTokenDTOName :: !(Maybe Text) -- ^ "name" - 
  , curveTokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - 
  , curveTokenDTOPools :: !(Maybe [Text]) -- ^ "pools" - 
  , curveTokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , curveTokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveTokenDTO
instance A.FromJSON CurveTokenDTO where
  parseJSON = A.withObject "CurveTokenDTO" $ \o ->
    CurveTokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "decimals")
      <*> (o .:? "name")
      <*> (o .:? "symbol")
      <*> (o .:? "pools")
      <*> (o .:? "vid")
      <*> (o .:? "token_symbol")

-- | ToJSON CurveTokenDTO
instance A.ToJSON CurveTokenDTO where
  toJSON CurveTokenDTO {..} =
   _omitNulls
      [ "entry_time" .= curveTokenDTOEntryTime
      , "recv_time" .= curveTokenDTORecvTime
      , "block_number" .= curveTokenDTOBlockNumber
      , "id" .= curveTokenDTOId
      , "address" .= curveTokenDTOAddress
      , "decimals" .= curveTokenDTODecimals
      , "name" .= curveTokenDTOName
      , "symbol" .= curveTokenDTOSymbol
      , "pools" .= curveTokenDTOPools
      , "vid" .= curveTokenDTOVid
      , "token_symbol" .= curveTokenDTOTokenSymbol
      ]


-- | Construct a value of type 'CurveTokenDTO' (by applying it's required fields, if any)
mkCurveTokenDTO
  :: CurveTokenDTO
mkCurveTokenDTO =
  CurveTokenDTO
  { curveTokenDTOEntryTime = Nothing
  , curveTokenDTORecvTime = Nothing
  , curveTokenDTOBlockNumber = Nothing
  , curveTokenDTOId = Nothing
  , curveTokenDTOAddress = Nothing
  , curveTokenDTODecimals = Nothing
  , curveTokenDTOName = Nothing
  , curveTokenDTOSymbol = Nothing
  , curveTokenDTOPools = Nothing
  , curveTokenDTOVid = Nothing
  , curveTokenDTOTokenSymbol = Nothing
  }

-- ** CurveTransferOwnershipEventDTO
-- | CurveTransferOwnershipEventDTO
data CurveTransferOwnershipEventDTO = CurveTransferOwnershipEventDTO
  { curveTransferOwnershipEventDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveTransferOwnershipEventDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveTransferOwnershipEventDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveTransferOwnershipEventDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveTransferOwnershipEventDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveTransferOwnershipEventDTONewAdmin :: !(Maybe Text) -- ^ "new_admin" - 
  , curveTransferOwnershipEventDTOBlock :: !(Maybe Text) -- ^ "block" - 
  , curveTransferOwnershipEventDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveTransferOwnershipEventDTOTransaction :: !(Maybe Text) -- ^ "transaction" - 
  , curveTransferOwnershipEventDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveTransferOwnershipEventDTO
instance A.FromJSON CurveTransferOwnershipEventDTO where
  parseJSON = A.withObject "CurveTransferOwnershipEventDTO" $ \o ->
    CurveTransferOwnershipEventDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "new_admin")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveTransferOwnershipEventDTO
instance A.ToJSON CurveTransferOwnershipEventDTO where
  toJSON CurveTransferOwnershipEventDTO {..} =
   _omitNulls
      [ "entry_time" .= curveTransferOwnershipEventDTOEntryTime
      , "recv_time" .= curveTransferOwnershipEventDTORecvTime
      , "block_number" .= curveTransferOwnershipEventDTOBlockNumber
      , "id" .= curveTransferOwnershipEventDTOId
      , "pool" .= curveTransferOwnershipEventDTOPool
      , "new_admin" .= curveTransferOwnershipEventDTONewAdmin
      , "block" .= curveTransferOwnershipEventDTOBlock
      , "timestamp" .= curveTransferOwnershipEventDTOTimestamp
      , "transaction" .= curveTransferOwnershipEventDTOTransaction
      , "vid" .= curveTransferOwnershipEventDTOVid
      ]


-- | Construct a value of type 'CurveTransferOwnershipEventDTO' (by applying it's required fields, if any)
mkCurveTransferOwnershipEventDTO
  :: CurveTransferOwnershipEventDTO
mkCurveTransferOwnershipEventDTO =
  CurveTransferOwnershipEventDTO
  { curveTransferOwnershipEventDTOEntryTime = Nothing
  , curveTransferOwnershipEventDTORecvTime = Nothing
  , curveTransferOwnershipEventDTOBlockNumber = Nothing
  , curveTransferOwnershipEventDTOId = Nothing
  , curveTransferOwnershipEventDTOPool = Nothing
  , curveTransferOwnershipEventDTONewAdmin = Nothing
  , curveTransferOwnershipEventDTOBlock = Nothing
  , curveTransferOwnershipEventDTOTimestamp = Nothing
  , curveTransferOwnershipEventDTOTransaction = Nothing
  , curveTransferOwnershipEventDTOVid = Nothing
  }

-- ** CurveUnderlyingCoinDTO
-- | CurveUnderlyingCoinDTO
data CurveUnderlyingCoinDTO = CurveUnderlyingCoinDTO
  { curveUnderlyingCoinDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveUnderlyingCoinDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveUnderlyingCoinDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveUnderlyingCoinDTOId :: !(Maybe Text) -- ^ "id" - Equals to: (pool_id)-(coin_index).
  , curveUnderlyingCoinDTOIndex :: !(Maybe Int) -- ^ "index" - Coin index.
  , curveUnderlyingCoinDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveUnderlyingCoinDTOToken :: !(Maybe Text) -- ^ "token" - 
  , curveUnderlyingCoinDTOCoin :: !(Maybe Text) -- ^ "coin" - 
  , curveUnderlyingCoinDTOBalance :: !(Maybe Text) -- ^ "balance" - 
  , curveUnderlyingCoinDTOUpdated :: !(Maybe Text) -- ^ "updated" - 
  , curveUnderlyingCoinDTOUpdatedAtBlock :: !(Maybe Text) -- ^ "updated_at_block" - 
  , curveUnderlyingCoinDTOUpdatedAtTransaction :: !(Maybe Text) -- ^ "updated_at_transaction" - 
  , curveUnderlyingCoinDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveUnderlyingCoinDTO
instance A.FromJSON CurveUnderlyingCoinDTO where
  parseJSON = A.withObject "CurveUnderlyingCoinDTO" $ \o ->
    CurveUnderlyingCoinDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "index")
      <*> (o .:? "pool")
      <*> (o .:? "token")
      <*> (o .:? "coin")
      <*> (o .:? "balance")
      <*> (o .:? "updated")
      <*> (o .:? "updated_at_block")
      <*> (o .:? "updated_at_transaction")
      <*> (o .:? "vid")

-- | ToJSON CurveUnderlyingCoinDTO
instance A.ToJSON CurveUnderlyingCoinDTO where
  toJSON CurveUnderlyingCoinDTO {..} =
   _omitNulls
      [ "entry_time" .= curveUnderlyingCoinDTOEntryTime
      , "recv_time" .= curveUnderlyingCoinDTORecvTime
      , "block_number" .= curveUnderlyingCoinDTOBlockNumber
      , "id" .= curveUnderlyingCoinDTOId
      , "index" .= curveUnderlyingCoinDTOIndex
      , "pool" .= curveUnderlyingCoinDTOPool
      , "token" .= curveUnderlyingCoinDTOToken
      , "coin" .= curveUnderlyingCoinDTOCoin
      , "balance" .= curveUnderlyingCoinDTOBalance
      , "updated" .= curveUnderlyingCoinDTOUpdated
      , "updated_at_block" .= curveUnderlyingCoinDTOUpdatedAtBlock
      , "updated_at_transaction" .= curveUnderlyingCoinDTOUpdatedAtTransaction
      , "vid" .= curveUnderlyingCoinDTOVid
      ]


-- | Construct a value of type 'CurveUnderlyingCoinDTO' (by applying it's required fields, if any)
mkCurveUnderlyingCoinDTO
  :: CurveUnderlyingCoinDTO
mkCurveUnderlyingCoinDTO =
  CurveUnderlyingCoinDTO
  { curveUnderlyingCoinDTOEntryTime = Nothing
  , curveUnderlyingCoinDTORecvTime = Nothing
  , curveUnderlyingCoinDTOBlockNumber = Nothing
  , curveUnderlyingCoinDTOId = Nothing
  , curveUnderlyingCoinDTOIndex = Nothing
  , curveUnderlyingCoinDTOPool = Nothing
  , curveUnderlyingCoinDTOToken = Nothing
  , curveUnderlyingCoinDTOCoin = Nothing
  , curveUnderlyingCoinDTOBalance = Nothing
  , curveUnderlyingCoinDTOUpdated = Nothing
  , curveUnderlyingCoinDTOUpdatedAtBlock = Nothing
  , curveUnderlyingCoinDTOUpdatedAtTransaction = Nothing
  , curveUnderlyingCoinDTOVid = Nothing
  }

-- ** CurveVotingAppDTO
-- | CurveVotingAppDTO
data CurveVotingAppDTO = CurveVotingAppDTO
  { curveVotingAppDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveVotingAppDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveVotingAppDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveVotingAppDTOId :: !(Maybe Text) -- ^ "id" - App address.
  , curveVotingAppDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , curveVotingAppDTOCodename :: !(Maybe Text) -- ^ "codename" - 
  , curveVotingAppDTOMinimumBalance :: !(Maybe Text) -- ^ "minimum_balance" - Minimum balance needed to create a proposal.
  , curveVotingAppDTOMinimumQuorum :: !(Maybe Text) -- ^ "minimum_quorum" - Percentage of positive votes in total possible votes for a proposal to be accepted.
  , curveVotingAppDTOMinimumTime :: !(Maybe Text) -- ^ "minimum_time" - Minimum time needed to pass between user&#39;s previous proposal and a user creating a new proposal.
  , curveVotingAppDTORequiredSupport :: !(Maybe Text) -- ^ "required_support" - Percentage of positive votes needed for a proposal to be accepted.
  , curveVotingAppDTOVoteTime :: !(Maybe Text) -- ^ "vote_time" - Seconds that a proposal will be open for vote (unless enough votes have been cast to make an early decision).
  , curveVotingAppDTOProposalCount :: !(Maybe Text) -- ^ "proposal_count" - Number of proposals created with this app.
  , curveVotingAppDTOVoteCount :: !(Maybe Text) -- ^ "vote_count" - Number of votes received by all the proposals created with this app.
  , curveVotingAppDTOToken :: !(Maybe Text) -- ^ "token" - Address of the token used for voting.
  , curveVotingAppDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveVotingAppDTO
instance A.FromJSON CurveVotingAppDTO where
  parseJSON = A.withObject "CurveVotingAppDTO" $ \o ->
    CurveVotingAppDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "codename")
      <*> (o .:? "minimum_balance")
      <*> (o .:? "minimum_quorum")
      <*> (o .:? "minimum_time")
      <*> (o .:? "required_support")
      <*> (o .:? "vote_time")
      <*> (o .:? "proposal_count")
      <*> (o .:? "vote_count")
      <*> (o .:? "token")
      <*> (o .:? "vid")

-- | ToJSON CurveVotingAppDTO
instance A.ToJSON CurveVotingAppDTO where
  toJSON CurveVotingAppDTO {..} =
   _omitNulls
      [ "entry_time" .= curveVotingAppDTOEntryTime
      , "recv_time" .= curveVotingAppDTORecvTime
      , "block_number" .= curveVotingAppDTOBlockNumber
      , "id" .= curveVotingAppDTOId
      , "address" .= curveVotingAppDTOAddress
      , "codename" .= curveVotingAppDTOCodename
      , "minimum_balance" .= curveVotingAppDTOMinimumBalance
      , "minimum_quorum" .= curveVotingAppDTOMinimumQuorum
      , "minimum_time" .= curveVotingAppDTOMinimumTime
      , "required_support" .= curveVotingAppDTORequiredSupport
      , "vote_time" .= curveVotingAppDTOVoteTime
      , "proposal_count" .= curveVotingAppDTOProposalCount
      , "vote_count" .= curveVotingAppDTOVoteCount
      , "token" .= curveVotingAppDTOToken
      , "vid" .= curveVotingAppDTOVid
      ]


-- | Construct a value of type 'CurveVotingAppDTO' (by applying it's required fields, if any)
mkCurveVotingAppDTO
  :: CurveVotingAppDTO
mkCurveVotingAppDTO =
  CurveVotingAppDTO
  { curveVotingAppDTOEntryTime = Nothing
  , curveVotingAppDTORecvTime = Nothing
  , curveVotingAppDTOBlockNumber = Nothing
  , curveVotingAppDTOId = Nothing
  , curveVotingAppDTOAddress = Nothing
  , curveVotingAppDTOCodename = Nothing
  , curveVotingAppDTOMinimumBalance = Nothing
  , curveVotingAppDTOMinimumQuorum = Nothing
  , curveVotingAppDTOMinimumTime = Nothing
  , curveVotingAppDTORequiredSupport = Nothing
  , curveVotingAppDTOVoteTime = Nothing
  , curveVotingAppDTOProposalCount = Nothing
  , curveVotingAppDTOVoteCount = Nothing
  , curveVotingAppDTOToken = Nothing
  , curveVotingAppDTOVid = Nothing
  }

-- ** CurveWeeklyVolumeDTO
-- | CurveWeeklyVolumeDTO
data CurveWeeklyVolumeDTO = CurveWeeklyVolumeDTO
  { curveWeeklyVolumeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , curveWeeklyVolumeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , curveWeeklyVolumeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , curveWeeklyVolumeDTOId :: !(Maybe Text) -- ^ "id" - 
  , curveWeeklyVolumeDTOPool :: !(Maybe Text) -- ^ "pool" - 
  , curveWeeklyVolumeDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - 
  , curveWeeklyVolumeDTOVolume :: !(Maybe Text) -- ^ "volume" - 
  , curveWeeklyVolumeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CurveWeeklyVolumeDTO
instance A.FromJSON CurveWeeklyVolumeDTO where
  parseJSON = A.withObject "CurveWeeklyVolumeDTO" $ \o ->
    CurveWeeklyVolumeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool")
      <*> (o .:? "timestamp")
      <*> (o .:? "volume")
      <*> (o .:? "vid")

-- | ToJSON CurveWeeklyVolumeDTO
instance A.ToJSON CurveWeeklyVolumeDTO where
  toJSON CurveWeeklyVolumeDTO {..} =
   _omitNulls
      [ "entry_time" .= curveWeeklyVolumeDTOEntryTime
      , "recv_time" .= curveWeeklyVolumeDTORecvTime
      , "block_number" .= curveWeeklyVolumeDTOBlockNumber
      , "id" .= curveWeeklyVolumeDTOId
      , "pool" .= curveWeeklyVolumeDTOPool
      , "timestamp" .= curveWeeklyVolumeDTOTimestamp
      , "volume" .= curveWeeklyVolumeDTOVolume
      , "vid" .= curveWeeklyVolumeDTOVid
      ]


-- | Construct a value of type 'CurveWeeklyVolumeDTO' (by applying it's required fields, if any)
mkCurveWeeklyVolumeDTO
  :: CurveWeeklyVolumeDTO
mkCurveWeeklyVolumeDTO =
  CurveWeeklyVolumeDTO
  { curveWeeklyVolumeDTOEntryTime = Nothing
  , curveWeeklyVolumeDTORecvTime = Nothing
  , curveWeeklyVolumeDTOBlockNumber = Nothing
  , curveWeeklyVolumeDTOId = Nothing
  , curveWeeklyVolumeDTOPool = Nothing
  , curveWeeklyVolumeDTOTimestamp = Nothing
  , curveWeeklyVolumeDTOVolume = Nothing
  , curveWeeklyVolumeDTOVid = Nothing
  }

-- ** DexBatchDTO
-- | DexBatchDTO
-- Batch executed. Every batch will contain at least solution with the a set of trades that are executed in it
data DexBatchDTO = DexBatchDTO
  { dexBatchDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexBatchDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexBatchDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexBatchDTOId :: !(Maybe Text) -- ^ "id" - Identifier.
  , dexBatchDTOStartEpoch :: !(Maybe Text) -- ^ "start_epoch" - Start epoch.
  , dexBatchDTOEndEpoch :: !(Maybe Text) -- ^ "end_epoch" - End epoch.
  , dexBatchDTOSolution :: !(Maybe Text) -- ^ "solution" - Reference to solution.
  , dexBatchDTOFirstSolutionEpoch :: !(Maybe Text) -- ^ "first_solution_epoch" - First solution epoch.
  , dexBatchDTOLastRevertEpoch :: !(Maybe Text) -- ^ "last_revert_epoch" - Last revert epoch.
  , dexBatchDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Transaction hash.
  , dexBatchDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexBatchDTO
instance A.FromJSON DexBatchDTO where
  parseJSON = A.withObject "DexBatchDTO" $ \o ->
    DexBatchDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "start_epoch")
      <*> (o .:? "end_epoch")
      <*> (o .:? "solution")
      <*> (o .:? "first_solution_epoch")
      <*> (o .:? "last_revert_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexBatchDTO
instance A.ToJSON DexBatchDTO where
  toJSON DexBatchDTO {..} =
   _omitNulls
      [ "entry_time" .= dexBatchDTOEntryTime
      , "recv_time" .= dexBatchDTORecvTime
      , "block_number" .= dexBatchDTOBlockNumber
      , "id" .= dexBatchDTOId
      , "start_epoch" .= dexBatchDTOStartEpoch
      , "end_epoch" .= dexBatchDTOEndEpoch
      , "solution" .= dexBatchDTOSolution
      , "first_solution_epoch" .= dexBatchDTOFirstSolutionEpoch
      , "last_revert_epoch" .= dexBatchDTOLastRevertEpoch
      , "tx_hash" .= dexBatchDTOTxHash
      , "vid" .= dexBatchDTOVid
      ]


-- | Construct a value of type 'DexBatchDTO' (by applying it's required fields, if any)
mkDexBatchDTO
  :: DexBatchDTO
mkDexBatchDTO =
  DexBatchDTO
  { dexBatchDTOEntryTime = Nothing
  , dexBatchDTORecvTime = Nothing
  , dexBatchDTOBlockNumber = Nothing
  , dexBatchDTOId = Nothing
  , dexBatchDTOStartEpoch = Nothing
  , dexBatchDTOEndEpoch = Nothing
  , dexBatchDTOSolution = Nothing
  , dexBatchDTOFirstSolutionEpoch = Nothing
  , dexBatchDTOLastRevertEpoch = Nothing
  , dexBatchDTOTxHash = Nothing
  , dexBatchDTOVid = Nothing
  }

-- ** DexDepositDTO
-- | DexDepositDTO
-- Deposit of an user.
data DexDepositDTO = DexDepositDTO
  { dexDepositDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexDepositDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexDepositDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexDepositDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (transaction hash)-(token id).
  , dexDepositDTOUser :: !(Maybe Text) -- ^ "user" - User address.
  , dexDepositDTOTokenAddress :: !(Maybe Text) -- ^ "token_address" - Token address.
  , dexDepositDTOAmount :: !(Maybe Text) -- ^ "amount" - Amount of deposit.
  , dexDepositDTOBatchId :: !(Maybe Text) -- ^ "batch_id" - Identifier (numerical).
  , dexDepositDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - Create epoch.
  , dexDepositDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Transaction hash.
  , dexDepositDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexDepositDTO
instance A.FromJSON DexDepositDTO where
  parseJSON = A.withObject "DexDepositDTO" $ \o ->
    DexDepositDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "token_address")
      <*> (o .:? "amount")
      <*> (o .:? "batch_id")
      <*> (o .:? "create_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexDepositDTO
instance A.ToJSON DexDepositDTO where
  toJSON DexDepositDTO {..} =
   _omitNulls
      [ "entry_time" .= dexDepositDTOEntryTime
      , "recv_time" .= dexDepositDTORecvTime
      , "block_number" .= dexDepositDTOBlockNumber
      , "id" .= dexDepositDTOId
      , "user" .= dexDepositDTOUser
      , "token_address" .= dexDepositDTOTokenAddress
      , "amount" .= dexDepositDTOAmount
      , "batch_id" .= dexDepositDTOBatchId
      , "create_epoch" .= dexDepositDTOCreateEpoch
      , "tx_hash" .= dexDepositDTOTxHash
      , "vid" .= dexDepositDTOVid
      ]


-- | Construct a value of type 'DexDepositDTO' (by applying it's required fields, if any)
mkDexDepositDTO
  :: DexDepositDTO
mkDexDepositDTO =
  DexDepositDTO
  { dexDepositDTOEntryTime = Nothing
  , dexDepositDTORecvTime = Nothing
  , dexDepositDTOBlockNumber = Nothing
  , dexDepositDTOId = Nothing
  , dexDepositDTOUser = Nothing
  , dexDepositDTOTokenAddress = Nothing
  , dexDepositDTOAmount = Nothing
  , dexDepositDTOBatchId = Nothing
  , dexDepositDTOCreateEpoch = Nothing
  , dexDepositDTOTxHash = Nothing
  , dexDepositDTOVid = Nothing
  }

-- ** DexOrderDTO
-- | DexOrderDTO
-- Order submitted by an user. It has a validity (dates) so they can only be executed from/until some given batches. Partial executions of this trades must respect the limit price.
data DexOrderDTO = DexOrderDTO
  { dexOrderDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexOrderDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexOrderDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexOrderDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (owner address)-(order id)
  , dexOrderDTOOwner :: !(Maybe Text) -- ^ "owner" - Reference to owner.
  , dexOrderDTOOrderId :: !(Maybe Int) -- ^ "order_id" - Order id.
  , dexOrderDTOFromBatchId :: !(Maybe Text) -- ^ "from_batch_id" - Batch id from which order became valid.
  , dexOrderDTOFromEpoch :: !(Maybe Text) -- ^ "from_epoch" - Start of epoch in which order was placed and became valid.
  , dexOrderDTOUntilBatchId :: !(Maybe Text) -- ^ "until_batch_id" - Batch id until which trade was still valid.
  , dexOrderDTOUntilEpoch :: !(Maybe Text) -- ^ "until_epoch" - End of epoch in which order was placed.
  , dexOrderDTOBuyToken :: !(Maybe Text) -- ^ "buy_token" - Identifier of token that was bought.
  , dexOrderDTOSellToken :: !(Maybe Text) -- ^ "sell_token" - Identifier of token that was sold.
  , dexOrderDTOPriceNumerator :: !(Maybe Text) -- ^ "price_numerator" - Price enumerator.
  , dexOrderDTOPriceDenominator :: !(Maybe Text) -- ^ "price_denominator" - Price denominator.
  , dexOrderDTOMaxSellAmount :: !(Maybe Text) -- ^ "max_sell_amount" - Maximum sell amount.
  , dexOrderDTOMinReceiveAmount :: !(Maybe Text) -- ^ "min_receive_amount" - Minimum receive amount.
  , dexOrderDTOSoldVolume :: !(Maybe Text) -- ^ "sold_volume" - Sold volume.
  , dexOrderDTOBoughtVolume :: !(Maybe Text) -- ^ "bought_volume" - Bought volume.
  , dexOrderDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - Epoch in which order was created.
  , dexOrderDTOCancelEpoch :: !(Maybe Text) -- ^ "cancel_epoch" - Epoch in which order was cancelled.
  , dexOrderDTODeleteEpoch :: !(Maybe Text) -- ^ "delete_epoch" - Epoch in which order was deleted.
  , dexOrderDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Transaction hash.
  , dexOrderDTOTxLogIndex :: !(Maybe Text) -- ^ "tx_log_index" - Event index within transaction.
  , dexOrderDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexOrderDTO
instance A.FromJSON DexOrderDTO where
  parseJSON = A.withObject "DexOrderDTO" $ \o ->
    DexOrderDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "owner")
      <*> (o .:? "order_id")
      <*> (o .:? "from_batch_id")
      <*> (o .:? "from_epoch")
      <*> (o .:? "until_batch_id")
      <*> (o .:? "until_epoch")
      <*> (o .:? "buy_token")
      <*> (o .:? "sell_token")
      <*> (o .:? "price_numerator")
      <*> (o .:? "price_denominator")
      <*> (o .:? "max_sell_amount")
      <*> (o .:? "min_receive_amount")
      <*> (o .:? "sold_volume")
      <*> (o .:? "bought_volume")
      <*> (o .:? "create_epoch")
      <*> (o .:? "cancel_epoch")
      <*> (o .:? "delete_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "tx_log_index")
      <*> (o .:? "vid")

-- | ToJSON DexOrderDTO
instance A.ToJSON DexOrderDTO where
  toJSON DexOrderDTO {..} =
   _omitNulls
      [ "entry_time" .= dexOrderDTOEntryTime
      , "recv_time" .= dexOrderDTORecvTime
      , "block_number" .= dexOrderDTOBlockNumber
      , "id" .= dexOrderDTOId
      , "owner" .= dexOrderDTOOwner
      , "order_id" .= dexOrderDTOOrderId
      , "from_batch_id" .= dexOrderDTOFromBatchId
      , "from_epoch" .= dexOrderDTOFromEpoch
      , "until_batch_id" .= dexOrderDTOUntilBatchId
      , "until_epoch" .= dexOrderDTOUntilEpoch
      , "buy_token" .= dexOrderDTOBuyToken
      , "sell_token" .= dexOrderDTOSellToken
      , "price_numerator" .= dexOrderDTOPriceNumerator
      , "price_denominator" .= dexOrderDTOPriceDenominator
      , "max_sell_amount" .= dexOrderDTOMaxSellAmount
      , "min_receive_amount" .= dexOrderDTOMinReceiveAmount
      , "sold_volume" .= dexOrderDTOSoldVolume
      , "bought_volume" .= dexOrderDTOBoughtVolume
      , "create_epoch" .= dexOrderDTOCreateEpoch
      , "cancel_epoch" .= dexOrderDTOCancelEpoch
      , "delete_epoch" .= dexOrderDTODeleteEpoch
      , "tx_hash" .= dexOrderDTOTxHash
      , "tx_log_index" .= dexOrderDTOTxLogIndex
      , "vid" .= dexOrderDTOVid
      ]


-- | Construct a value of type 'DexOrderDTO' (by applying it's required fields, if any)
mkDexOrderDTO
  :: DexOrderDTO
mkDexOrderDTO =
  DexOrderDTO
  { dexOrderDTOEntryTime = Nothing
  , dexOrderDTORecvTime = Nothing
  , dexOrderDTOBlockNumber = Nothing
  , dexOrderDTOId = Nothing
  , dexOrderDTOOwner = Nothing
  , dexOrderDTOOrderId = Nothing
  , dexOrderDTOFromBatchId = Nothing
  , dexOrderDTOFromEpoch = Nothing
  , dexOrderDTOUntilBatchId = Nothing
  , dexOrderDTOUntilEpoch = Nothing
  , dexOrderDTOBuyToken = Nothing
  , dexOrderDTOSellToken = Nothing
  , dexOrderDTOPriceNumerator = Nothing
  , dexOrderDTOPriceDenominator = Nothing
  , dexOrderDTOMaxSellAmount = Nothing
  , dexOrderDTOMinReceiveAmount = Nothing
  , dexOrderDTOSoldVolume = Nothing
  , dexOrderDTOBoughtVolume = Nothing
  , dexOrderDTOCreateEpoch = Nothing
  , dexOrderDTOCancelEpoch = Nothing
  , dexOrderDTODeleteEpoch = Nothing
  , dexOrderDTOTxHash = Nothing
  , dexOrderDTOTxLogIndex = Nothing
  , dexOrderDTOVid = Nothing
  }

-- ** DexPriceDTO
-- | DexPriceDTO
-- Token price in conjuction with batch id.
data DexPriceDTO = DexPriceDTO
  { dexPriceDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexPriceDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexPriceDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexPriceDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (token id)-(batch id).
  , dexPriceDTOToken :: !(Maybe Text) -- ^ "token" - Token identifier.
  , dexPriceDTOBatchId :: !(Maybe Text) -- ^ "batch_id" - Batch identifier.
  , dexPriceDTOPriceInOwlNumerator :: !(Maybe Text) -- ^ "price_in_owl_numerator" - Price enumerator in OWL (derivative of the GNO token).
  , dexPriceDTOPriceInOwlDenominator :: !(Maybe Text) -- ^ "price_in_owl_denominator" - Price denominator in OWL (derivative of the GNO token).
  , dexPriceDTOVolume :: !(Maybe Text) -- ^ "volume" - Volume.
  , dexPriceDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - Create epoch.
  , dexPriceDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - Transaction hash.
  , dexPriceDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexPriceDTO
instance A.FromJSON DexPriceDTO where
  parseJSON = A.withObject "DexPriceDTO" $ \o ->
    DexPriceDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "token")
      <*> (o .:? "batch_id")
      <*> (o .:? "price_in_owl_numerator")
      <*> (o .:? "price_in_owl_denominator")
      <*> (o .:? "volume")
      <*> (o .:? "create_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexPriceDTO
instance A.ToJSON DexPriceDTO where
  toJSON DexPriceDTO {..} =
   _omitNulls
      [ "entry_time" .= dexPriceDTOEntryTime
      , "recv_time" .= dexPriceDTORecvTime
      , "block_number" .= dexPriceDTOBlockNumber
      , "id" .= dexPriceDTOId
      , "token" .= dexPriceDTOToken
      , "batch_id" .= dexPriceDTOBatchId
      , "price_in_owl_numerator" .= dexPriceDTOPriceInOwlNumerator
      , "price_in_owl_denominator" .= dexPriceDTOPriceInOwlDenominator
      , "volume" .= dexPriceDTOVolume
      , "create_epoch" .= dexPriceDTOCreateEpoch
      , "tx_hash" .= dexPriceDTOTxHash
      , "vid" .= dexPriceDTOVid
      ]


-- | Construct a value of type 'DexPriceDTO' (by applying it's required fields, if any)
mkDexPriceDTO
  :: DexPriceDTO
mkDexPriceDTO =
  DexPriceDTO
  { dexPriceDTOEntryTime = Nothing
  , dexPriceDTORecvTime = Nothing
  , dexPriceDTOBlockNumber = Nothing
  , dexPriceDTOId = Nothing
  , dexPriceDTOToken = Nothing
  , dexPriceDTOBatchId = Nothing
  , dexPriceDTOPriceInOwlNumerator = Nothing
  , dexPriceDTOPriceInOwlDenominator = Nothing
  , dexPriceDTOVolume = Nothing
  , dexPriceDTOCreateEpoch = Nothing
  , dexPriceDTOTxHash = Nothing
  , dexPriceDTOVid = Nothing
  }

-- ** DexSolutionDTO
-- | DexSolutionDTO
data DexSolutionDTO = DexSolutionDTO
  { dexSolutionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexSolutionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexSolutionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexSolutionDTOId :: !(Maybe Text) -- ^ "id" - 
  , dexSolutionDTOBatch :: !(Maybe Text) -- ^ "batch" - 
  , dexSolutionDTOSolver :: !(Maybe Text) -- ^ "solver" - 
  , dexSolutionDTOFeeReward :: !(Maybe Text) -- ^ "fee_reward" - 
  , dexSolutionDTOObjectiveValue :: !(Maybe Text) -- ^ "objective_value" - 
  , dexSolutionDTOUtility :: !(Maybe Text) -- ^ "utility" - 
  , dexSolutionDTOTrades :: !(Maybe [Text]) -- ^ "trades" - 
  , dexSolutionDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - 
  , dexSolutionDTORevertEpoch :: !(Maybe Text) -- ^ "revert_epoch" - 
  , dexSolutionDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexSolutionDTOTxLogIndex :: !(Maybe Text) -- ^ "tx_log_index" - 
  , dexSolutionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexSolutionDTO
instance A.FromJSON DexSolutionDTO where
  parseJSON = A.withObject "DexSolutionDTO" $ \o ->
    DexSolutionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "batch")
      <*> (o .:? "solver")
      <*> (o .:? "fee_reward")
      <*> (o .:? "objective_value")
      <*> (o .:? "utility")
      <*> (o .:? "trades")
      <*> (o .:? "create_epoch")
      <*> (o .:? "revert_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "tx_log_index")
      <*> (o .:? "vid")

-- | ToJSON DexSolutionDTO
instance A.ToJSON DexSolutionDTO where
  toJSON DexSolutionDTO {..} =
   _omitNulls
      [ "entry_time" .= dexSolutionDTOEntryTime
      , "recv_time" .= dexSolutionDTORecvTime
      , "block_number" .= dexSolutionDTOBlockNumber
      , "id" .= dexSolutionDTOId
      , "batch" .= dexSolutionDTOBatch
      , "solver" .= dexSolutionDTOSolver
      , "fee_reward" .= dexSolutionDTOFeeReward
      , "objective_value" .= dexSolutionDTOObjectiveValue
      , "utility" .= dexSolutionDTOUtility
      , "trades" .= dexSolutionDTOTrades
      , "create_epoch" .= dexSolutionDTOCreateEpoch
      , "revert_epoch" .= dexSolutionDTORevertEpoch
      , "tx_hash" .= dexSolutionDTOTxHash
      , "tx_log_index" .= dexSolutionDTOTxLogIndex
      , "vid" .= dexSolutionDTOVid
      ]


-- | Construct a value of type 'DexSolutionDTO' (by applying it's required fields, if any)
mkDexSolutionDTO
  :: DexSolutionDTO
mkDexSolutionDTO =
  DexSolutionDTO
  { dexSolutionDTOEntryTime = Nothing
  , dexSolutionDTORecvTime = Nothing
  , dexSolutionDTOBlockNumber = Nothing
  , dexSolutionDTOId = Nothing
  , dexSolutionDTOBatch = Nothing
  , dexSolutionDTOSolver = Nothing
  , dexSolutionDTOFeeReward = Nothing
  , dexSolutionDTOObjectiveValue = Nothing
  , dexSolutionDTOUtility = Nothing
  , dexSolutionDTOTrades = Nothing
  , dexSolutionDTOCreateEpoch = Nothing
  , dexSolutionDTORevertEpoch = Nothing
  , dexSolutionDTOTxHash = Nothing
  , dexSolutionDTOTxLogIndex = Nothing
  , dexSolutionDTOVid = Nothing
  }

-- ** DexStatsDTO
-- | DexStatsDTO
-- A type collecting global stats about this instance of Gnosis Protocol.
data DexStatsDTO = DexStatsDTO
  { dexStatsDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexStatsDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexStatsDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexStatsDTOId :: !(Maybe Text) -- ^ "id" - 
  , dexStatsDTOVolumeInOwl :: !(Maybe Text) -- ^ "volume_in_owl" - The total volume denominated in OWL (all sell amounts combined).
  , dexStatsDTOUtilityInOwl :: !(Maybe Text) -- ^ "utility_in_owl" - The total trader surplus in OWL.
  , dexStatsDTOOwlBurnt :: !(Maybe Text) -- ^ "owl_burnt" - The total amount of OWL burnt (equivalent to fees rewarded to solvers).
  , dexStatsDTOSettledBatchCount :: !(Maybe Int) -- ^ "settled_batch_count" - The total number of settled batches.
  , dexStatsDTOSettledTradeCount :: !(Maybe Int) -- ^ "settled_trade_count" - The total number of settled trades.
  , dexStatsDTOListedTokens :: !(Maybe Int) -- ^ "listed_tokens" - The number of listed tokens.
  , dexStatsDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexStatsDTO
instance A.FromJSON DexStatsDTO where
  parseJSON = A.withObject "DexStatsDTO" $ \o ->
    DexStatsDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "volume_in_owl")
      <*> (o .:? "utility_in_owl")
      <*> (o .:? "owl_burnt")
      <*> (o .:? "settled_batch_count")
      <*> (o .:? "settled_trade_count")
      <*> (o .:? "listed_tokens")
      <*> (o .:? "vid")

-- | ToJSON DexStatsDTO
instance A.ToJSON DexStatsDTO where
  toJSON DexStatsDTO {..} =
   _omitNulls
      [ "entry_time" .= dexStatsDTOEntryTime
      , "recv_time" .= dexStatsDTORecvTime
      , "block_number" .= dexStatsDTOBlockNumber
      , "id" .= dexStatsDTOId
      , "volume_in_owl" .= dexStatsDTOVolumeInOwl
      , "utility_in_owl" .= dexStatsDTOUtilityInOwl
      , "owl_burnt" .= dexStatsDTOOwlBurnt
      , "settled_batch_count" .= dexStatsDTOSettledBatchCount
      , "settled_trade_count" .= dexStatsDTOSettledTradeCount
      , "listed_tokens" .= dexStatsDTOListedTokens
      , "vid" .= dexStatsDTOVid
      ]


-- | Construct a value of type 'DexStatsDTO' (by applying it's required fields, if any)
mkDexStatsDTO
  :: DexStatsDTO
mkDexStatsDTO =
  DexStatsDTO
  { dexStatsDTOEntryTime = Nothing
  , dexStatsDTORecvTime = Nothing
  , dexStatsDTOBlockNumber = Nothing
  , dexStatsDTOId = Nothing
  , dexStatsDTOVolumeInOwl = Nothing
  , dexStatsDTOUtilityInOwl = Nothing
  , dexStatsDTOOwlBurnt = Nothing
  , dexStatsDTOSettledBatchCount = Nothing
  , dexStatsDTOSettledTradeCount = Nothing
  , dexStatsDTOListedTokens = Nothing
  , dexStatsDTOVid = Nothing
  }

-- ** DexTokenDTO
-- | DexTokenDTO
-- Registered token.
data DexTokenDTO = DexTokenDTO
  { dexTokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexTokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexTokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexTokenDTOId :: !(Maybe Text) -- ^ "id" - 
  , dexTokenDTOAddress :: !(Maybe Text) -- ^ "address" - 
  , dexTokenDTOFromBatchId :: !(Maybe Text) -- ^ "from_batch_id" - 
  , dexTokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - 
  , dexTokenDTODecimals :: !(Maybe Text) -- ^ "decimals" - 
  , dexTokenDTOName :: !(Maybe Text) -- ^ "name" - 
  , dexTokenDTOSellVolume :: !(Maybe Text) -- ^ "sell_volume" - Cumulative sell volume.
  , dexTokenDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - 
  , dexTokenDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexTokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , dexTokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexTokenDTO
instance A.FromJSON DexTokenDTO where
  parseJSON = A.withObject "DexTokenDTO" $ \o ->
    DexTokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "address")
      <*> (o .:? "from_batch_id")
      <*> (o .:? "symbol")
      <*> (o .:? "decimals")
      <*> (o .:? "name")
      <*> (o .:? "sell_volume")
      <*> (o .:? "create_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")
      <*> (o .:? "token_symbol")

-- | ToJSON DexTokenDTO
instance A.ToJSON DexTokenDTO where
  toJSON DexTokenDTO {..} =
   _omitNulls
      [ "entry_time" .= dexTokenDTOEntryTime
      , "recv_time" .= dexTokenDTORecvTime
      , "block_number" .= dexTokenDTOBlockNumber
      , "id" .= dexTokenDTOId
      , "address" .= dexTokenDTOAddress
      , "from_batch_id" .= dexTokenDTOFromBatchId
      , "symbol" .= dexTokenDTOSymbol
      , "decimals" .= dexTokenDTODecimals
      , "name" .= dexTokenDTOName
      , "sell_volume" .= dexTokenDTOSellVolume
      , "create_epoch" .= dexTokenDTOCreateEpoch
      , "tx_hash" .= dexTokenDTOTxHash
      , "vid" .= dexTokenDTOVid
      , "token_symbol" .= dexTokenDTOTokenSymbol
      ]


-- | Construct a value of type 'DexTokenDTO' (by applying it's required fields, if any)
mkDexTokenDTO
  :: DexTokenDTO
mkDexTokenDTO =
  DexTokenDTO
  { dexTokenDTOEntryTime = Nothing
  , dexTokenDTORecvTime = Nothing
  , dexTokenDTOBlockNumber = Nothing
  , dexTokenDTOId = Nothing
  , dexTokenDTOAddress = Nothing
  , dexTokenDTOFromBatchId = Nothing
  , dexTokenDTOSymbol = Nothing
  , dexTokenDTODecimals = Nothing
  , dexTokenDTOName = Nothing
  , dexTokenDTOSellVolume = Nothing
  , dexTokenDTOCreateEpoch = Nothing
  , dexTokenDTOTxHash = Nothing
  , dexTokenDTOVid = Nothing
  , dexTokenDTOTokenSymbol = Nothing
  }

-- ** DexTradeDTO
-- | DexTradeDTO
-- Trade for a single user, as part of a ring trade. It's part of the solution submitted by a solver for a given batch.
data DexTradeDTO = DexTradeDTO
  { dexTradeDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexTradeDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexTradeDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexTradeDTOId :: !(Maybe Text) -- ^ "id" - 
  , dexTradeDTOOrder :: !(Maybe Text) -- ^ "order" - 
  , dexTradeDTOOwner :: !(Maybe Text) -- ^ "owner" - 
  , dexTradeDTOSellVolume :: !(Maybe Text) -- ^ "sell_volume" - 
  , dexTradeDTOBuyVolume :: !(Maybe Text) -- ^ "buy_volume" - 
  , dexTradeDTOTradeBatchId :: !(Maybe Text) -- ^ "trade_batch_id" - 
  , dexTradeDTOTradeEpoch :: !(Maybe Text) -- ^ "trade_epoch" - The date of the end of the batch.
  , dexTradeDTOBuyToken :: !(Maybe Text) -- ^ "buy_token" - 
  , dexTradeDTOSellToken :: !(Maybe Text) -- ^ "sell_token" - 
  , dexTradeDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - The date where the transaction was mined.
  , dexTradeDTORevertEpoch :: !(Maybe Text) -- ^ "revert_epoch" - 
  , dexTradeDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexTradeDTOTxLogIndex :: !(Maybe Text) -- ^ "tx_log_index" - 
  , dexTradeDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , dexTradeDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , dexTradeDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  , dexTradeDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , dexTradeDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , dexTradeDTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexTradeDTO
instance A.FromJSON DexTradeDTO where
  parseJSON = A.withObject "DexTradeDTO" $ \o ->
    DexTradeDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "order")
      <*> (o .:? "owner")
      <*> (o .:? "sell_volume")
      <*> (o .:? "buy_volume")
      <*> (o .:? "trade_batch_id")
      <*> (o .:? "trade_epoch")
      <*> (o .:? "buy_token")
      <*> (o .:? "sell_token")
      <*> (o .:? "create_epoch")
      <*> (o .:? "revert_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "tx_log_index")
      <*> (o .:? "vid")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")

-- | ToJSON DexTradeDTO
instance A.ToJSON DexTradeDTO where
  toJSON DexTradeDTO {..} =
   _omitNulls
      [ "entry_time" .= dexTradeDTOEntryTime
      , "recv_time" .= dexTradeDTORecvTime
      , "block_number" .= dexTradeDTOBlockNumber
      , "id" .= dexTradeDTOId
      , "order" .= dexTradeDTOOrder
      , "owner" .= dexTradeDTOOwner
      , "sell_volume" .= dexTradeDTOSellVolume
      , "buy_volume" .= dexTradeDTOBuyVolume
      , "trade_batch_id" .= dexTradeDTOTradeBatchId
      , "trade_epoch" .= dexTradeDTOTradeEpoch
      , "buy_token" .= dexTradeDTOBuyToken
      , "sell_token" .= dexTradeDTOSellToken
      , "create_epoch" .= dexTradeDTOCreateEpoch
      , "revert_epoch" .= dexTradeDTORevertEpoch
      , "tx_hash" .= dexTradeDTOTxHash
      , "tx_log_index" .= dexTradeDTOTxLogIndex
      , "vid" .= dexTradeDTOVid
      , "pool_id" .= dexTradeDTOPoolId
      , "transaction_id" .= dexTradeDTOTransactionId
      , "evaluated_price" .= dexTradeDTOEvaluatedPrice
      , "evaluated_amount" .= dexTradeDTOEvaluatedAmount
      , "evaluated_aggressor" .= dexTradeDTOEvaluatedAggressor
      ]


-- | Construct a value of type 'DexTradeDTO' (by applying it's required fields, if any)
mkDexTradeDTO
  :: DexTradeDTO
mkDexTradeDTO =
  DexTradeDTO
  { dexTradeDTOEntryTime = Nothing
  , dexTradeDTORecvTime = Nothing
  , dexTradeDTOBlockNumber = Nothing
  , dexTradeDTOId = Nothing
  , dexTradeDTOOrder = Nothing
  , dexTradeDTOOwner = Nothing
  , dexTradeDTOSellVolume = Nothing
  , dexTradeDTOBuyVolume = Nothing
  , dexTradeDTOTradeBatchId = Nothing
  , dexTradeDTOTradeEpoch = Nothing
  , dexTradeDTOBuyToken = Nothing
  , dexTradeDTOSellToken = Nothing
  , dexTradeDTOCreateEpoch = Nothing
  , dexTradeDTORevertEpoch = Nothing
  , dexTradeDTOTxHash = Nothing
  , dexTradeDTOTxLogIndex = Nothing
  , dexTradeDTOVid = Nothing
  , dexTradeDTOPoolId = Nothing
  , dexTradeDTOTransactionId = Nothing
  , dexTradeDTOEvaluatedPrice = Nothing
  , dexTradeDTOEvaluatedAmount = Nothing
  , dexTradeDTOEvaluatedAggressor = Nothing
  }

-- ** DexUserDTO
-- | DexUserDTO
-- User of the protocol. Any ethereum account that deposited tokens or traded.
data DexUserDTO = DexUserDTO
  { dexUserDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexUserDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexUserDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexUserDTOId :: !(Maybe Text) -- ^ "id" - 
  , dexUserDTOFromBatchId :: !(Maybe Text) -- ^ "from_batch_id" - 
  , dexUserDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - 
  , dexUserDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexUserDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexUserDTO
instance A.FromJSON DexUserDTO where
  parseJSON = A.withObject "DexUserDTO" $ \o ->
    DexUserDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "from_batch_id")
      <*> (o .:? "create_epoch")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexUserDTO
instance A.ToJSON DexUserDTO where
  toJSON DexUserDTO {..} =
   _omitNulls
      [ "entry_time" .= dexUserDTOEntryTime
      , "recv_time" .= dexUserDTORecvTime
      , "block_number" .= dexUserDTOBlockNumber
      , "id" .= dexUserDTOId
      , "from_batch_id" .= dexUserDTOFromBatchId
      , "create_epoch" .= dexUserDTOCreateEpoch
      , "tx_hash" .= dexUserDTOTxHash
      , "vid" .= dexUserDTOVid
      ]


-- | Construct a value of type 'DexUserDTO' (by applying it's required fields, if any)
mkDexUserDTO
  :: DexUserDTO
mkDexUserDTO =
  DexUserDTO
  { dexUserDTOEntryTime = Nothing
  , dexUserDTORecvTime = Nothing
  , dexUserDTOBlockNumber = Nothing
  , dexUserDTOId = Nothing
  , dexUserDTOFromBatchId = Nothing
  , dexUserDTOCreateEpoch = Nothing
  , dexUserDTOTxHash = Nothing
  , dexUserDTOVid = Nothing
  }

-- ** DexWithdrawDTO
-- | DexWithdrawDTO
-- Withdraw of an user.
data DexWithdrawDTO = DexWithdrawDTO
  { dexWithdrawDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexWithdrawDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexWithdrawDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexWithdrawDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (transaction hash)-(id).
  , dexWithdrawDTOUser :: !(Maybe Text) -- ^ "user" - 
  , dexWithdrawDTOTokenAddress :: !(Maybe Text) -- ^ "token_address" - 
  , dexWithdrawDTOAmount :: !(Maybe Text) -- ^ "amount" - 
  , dexWithdrawDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - 
  , dexWithdrawDTOCreateBatchId :: !(Maybe Text) -- ^ "create_batch_id" - 
  , dexWithdrawDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexWithdrawDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexWithdrawDTO
instance A.FromJSON DexWithdrawDTO where
  parseJSON = A.withObject "DexWithdrawDTO" $ \o ->
    DexWithdrawDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "token_address")
      <*> (o .:? "amount")
      <*> (o .:? "create_epoch")
      <*> (o .:? "create_batch_id")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexWithdrawDTO
instance A.ToJSON DexWithdrawDTO where
  toJSON DexWithdrawDTO {..} =
   _omitNulls
      [ "entry_time" .= dexWithdrawDTOEntryTime
      , "recv_time" .= dexWithdrawDTORecvTime
      , "block_number" .= dexWithdrawDTOBlockNumber
      , "id" .= dexWithdrawDTOId
      , "user" .= dexWithdrawDTOUser
      , "token_address" .= dexWithdrawDTOTokenAddress
      , "amount" .= dexWithdrawDTOAmount
      , "create_epoch" .= dexWithdrawDTOCreateEpoch
      , "create_batch_id" .= dexWithdrawDTOCreateBatchId
      , "tx_hash" .= dexWithdrawDTOTxHash
      , "vid" .= dexWithdrawDTOVid
      ]


-- | Construct a value of type 'DexWithdrawDTO' (by applying it's required fields, if any)
mkDexWithdrawDTO
  :: DexWithdrawDTO
mkDexWithdrawDTO =
  DexWithdrawDTO
  { dexWithdrawDTOEntryTime = Nothing
  , dexWithdrawDTORecvTime = Nothing
  , dexWithdrawDTOBlockNumber = Nothing
  , dexWithdrawDTOId = Nothing
  , dexWithdrawDTOUser = Nothing
  , dexWithdrawDTOTokenAddress = Nothing
  , dexWithdrawDTOAmount = Nothing
  , dexWithdrawDTOCreateEpoch = Nothing
  , dexWithdrawDTOCreateBatchId = Nothing
  , dexWithdrawDTOTxHash = Nothing
  , dexWithdrawDTOVid = Nothing
  }

-- ** DexWithdrawRequestDTO
-- | DexWithdrawRequestDTO
-- Withdraw request of an user
data DexWithdrawRequestDTO = DexWithdrawRequestDTO
  { dexWithdrawRequestDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , dexWithdrawRequestDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , dexWithdrawRequestDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , dexWithdrawRequestDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (transaction hash)-(id).
  , dexWithdrawRequestDTOUser :: !(Maybe Text) -- ^ "user" - 
  , dexWithdrawRequestDTOTokenAddress :: !(Maybe Text) -- ^ "token_address" - 
  , dexWithdrawRequestDTOAmount :: !(Maybe Text) -- ^ "amount" - 
  , dexWithdrawRequestDTOWithdrawableFromBatchId :: !(Maybe Text) -- ^ "withdrawable_from_batch_id" - 
  , dexWithdrawRequestDTOCreateEpoch :: !(Maybe Text) -- ^ "create_epoch" - 
  , dexWithdrawRequestDTOCreateBatchId :: !(Maybe Text) -- ^ "create_batch_id" - 
  , dexWithdrawRequestDTOTxHash :: !(Maybe Text) -- ^ "tx_hash" - 
  , dexWithdrawRequestDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DexWithdrawRequestDTO
instance A.FromJSON DexWithdrawRequestDTO where
  parseJSON = A.withObject "DexWithdrawRequestDTO" $ \o ->
    DexWithdrawRequestDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "token_address")
      <*> (o .:? "amount")
      <*> (o .:? "withdrawable_from_batch_id")
      <*> (o .:? "create_epoch")
      <*> (o .:? "create_batch_id")
      <*> (o .:? "tx_hash")
      <*> (o .:? "vid")

-- | ToJSON DexWithdrawRequestDTO
instance A.ToJSON DexWithdrawRequestDTO where
  toJSON DexWithdrawRequestDTO {..} =
   _omitNulls
      [ "entry_time" .= dexWithdrawRequestDTOEntryTime
      , "recv_time" .= dexWithdrawRequestDTORecvTime
      , "block_number" .= dexWithdrawRequestDTOBlockNumber
      , "id" .= dexWithdrawRequestDTOId
      , "user" .= dexWithdrawRequestDTOUser
      , "token_address" .= dexWithdrawRequestDTOTokenAddress
      , "amount" .= dexWithdrawRequestDTOAmount
      , "withdrawable_from_batch_id" .= dexWithdrawRequestDTOWithdrawableFromBatchId
      , "create_epoch" .= dexWithdrawRequestDTOCreateEpoch
      , "create_batch_id" .= dexWithdrawRequestDTOCreateBatchId
      , "tx_hash" .= dexWithdrawRequestDTOTxHash
      , "vid" .= dexWithdrawRequestDTOVid
      ]


-- | Construct a value of type 'DexWithdrawRequestDTO' (by applying it's required fields, if any)
mkDexWithdrawRequestDTO
  :: DexWithdrawRequestDTO
mkDexWithdrawRequestDTO =
  DexWithdrawRequestDTO
  { dexWithdrawRequestDTOEntryTime = Nothing
  , dexWithdrawRequestDTORecvTime = Nothing
  , dexWithdrawRequestDTOBlockNumber = Nothing
  , dexWithdrawRequestDTOId = Nothing
  , dexWithdrawRequestDTOUser = Nothing
  , dexWithdrawRequestDTOTokenAddress = Nothing
  , dexWithdrawRequestDTOAmount = Nothing
  , dexWithdrawRequestDTOWithdrawableFromBatchId = Nothing
  , dexWithdrawRequestDTOCreateEpoch = Nothing
  , dexWithdrawRequestDTOCreateBatchId = Nothing
  , dexWithdrawRequestDTOTxHash = Nothing
  , dexWithdrawRequestDTOVid = Nothing
  }

-- ** NumericsBigInteger
-- | NumericsBigInteger
data NumericsBigInteger = NumericsBigInteger
  { numericsBigIntegerIsPowerOfTwo :: !(Maybe Bool) -- ^ /ReadOnly/ "is_power_of_two"
  , numericsBigIntegerIsZero :: !(Maybe Bool) -- ^ /ReadOnly/ "is_zero"
  , numericsBigIntegerIsOne :: !(Maybe Bool) -- ^ /ReadOnly/ "is_one"
  , numericsBigIntegerIsEven :: !(Maybe Bool) -- ^ /ReadOnly/ "is_even"
  , numericsBigIntegerSign :: !(Maybe Int) -- ^ /ReadOnly/ "sign"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NumericsBigInteger
instance A.FromJSON NumericsBigInteger where
  parseJSON = A.withObject "NumericsBigInteger" $ \o ->
    NumericsBigInteger
      <$> (o .:? "is_power_of_two")
      <*> (o .:? "is_zero")
      <*> (o .:? "is_one")
      <*> (o .:? "is_even")
      <*> (o .:? "sign")

-- | ToJSON NumericsBigInteger
instance A.ToJSON NumericsBigInteger where
  toJSON NumericsBigInteger {..} =
   _omitNulls
      [ "is_power_of_two" .= numericsBigIntegerIsPowerOfTwo
      , "is_zero" .= numericsBigIntegerIsZero
      , "is_one" .= numericsBigIntegerIsOne
      , "is_even" .= numericsBigIntegerIsEven
      , "sign" .= numericsBigIntegerSign
      ]


-- | Construct a value of type 'NumericsBigInteger' (by applying it's required fields, if any)
mkNumericsBigInteger
  :: NumericsBigInteger
mkNumericsBigInteger =
  NumericsBigInteger
  { numericsBigIntegerIsPowerOfTwo = Nothing
  , numericsBigIntegerIsZero = Nothing
  , numericsBigIntegerIsOne = Nothing
  , numericsBigIntegerIsEven = Nothing
  , numericsBigIntegerSign = Nothing
  }

-- ** SushiswapBundleDTO
-- | SushiswapBundleDTO
-- The Bundle is used as a global store of derived ETH price in USD.
data SushiswapBundleDTO = SushiswapBundleDTO
  { sushiswapBundleDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapBundleDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapBundleDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapBundleDTOId :: !(Maybe Text) -- ^ "id" - Hardcoded to &#39;1&#39;.
  , sushiswapBundleDTOEthPrice :: !(Maybe Text) -- ^ "eth_price" - Price of native.
  , sushiswapBundleDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapBundleDTO
instance A.FromJSON SushiswapBundleDTO where
  parseJSON = A.withObject "SushiswapBundleDTO" $ \o ->
    SushiswapBundleDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "eth_price")
      <*> (o .:? "vid")

-- | ToJSON SushiswapBundleDTO
instance A.ToJSON SushiswapBundleDTO where
  toJSON SushiswapBundleDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapBundleDTOEntryTime
      , "recv_time" .= sushiswapBundleDTORecvTime
      , "block_number" .= sushiswapBundleDTOBlockNumber
      , "id" .= sushiswapBundleDTOId
      , "eth_price" .= sushiswapBundleDTOEthPrice
      , "vid" .= sushiswapBundleDTOVid
      ]


-- | Construct a value of type 'SushiswapBundleDTO' (by applying it's required fields, if any)
mkSushiswapBundleDTO
  :: SushiswapBundleDTO
mkSushiswapBundleDTO =
  SushiswapBundleDTO
  { sushiswapBundleDTOEntryTime = Nothing
  , sushiswapBundleDTORecvTime = Nothing
  , sushiswapBundleDTOBlockNumber = Nothing
  , sushiswapBundleDTOId = Nothing
  , sushiswapBundleDTOEthPrice = Nothing
  , sushiswapBundleDTOVid = Nothing
  }

-- ** SushiswapBurnDTO
-- | SushiswapBurnDTO
-- Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
data SushiswapBurnDTO = SushiswapBurnDTO
  { sushiswapBurnDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapBurnDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapBurnDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapBurnDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (transaction id):(transaction.burns.length).
  , sushiswapBurnDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to the transaction Burn was included in.
  , sushiswapBurnDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of Burn, used to sort recent liquidity removals.
  , sushiswapBurnDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , sushiswapBurnDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Amount of liquidity tokens burned.
  , sushiswapBurnDTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the liquidity removal.
  , sushiswapBurnDTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token0 removed.
  , sushiswapBurnDTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token1 removed.
  , sushiswapBurnDTOTo :: !(Maybe Text) -- ^ "to" - Recipient of tokens.
  , sushiswapBurnDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Index in the transaction event was emitted.
  , sushiswapBurnDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount based on available prices of tokens.
  , sushiswapBurnDTOComplete :: !(Maybe Bool) -- ^ "complete" - 
  , sushiswapBurnDTOFeeTo :: !(Maybe Text) -- ^ "fee_to" - Address of fee recipient (if fee is on).
  , sushiswapBurnDTOFeeLiquidity :: !(Maybe Text) -- ^ "fee_liquidity" - Amount of tokens sent to fee recipient (if fee is on).
  , sushiswapBurnDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapBurnDTO
instance A.FromJSON SushiswapBurnDTO where
  parseJSON = A.withObject "SushiswapBurnDTO" $ \o ->
    SushiswapBurnDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "liquidity")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "to")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "complete")
      <*> (o .:? "fee_to")
      <*> (o .:? "fee_liquidity")
      <*> (o .:? "vid")

-- | ToJSON SushiswapBurnDTO
instance A.ToJSON SushiswapBurnDTO where
  toJSON SushiswapBurnDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapBurnDTOEntryTime
      , "recv_time" .= sushiswapBurnDTORecvTime
      , "block_number" .= sushiswapBurnDTOBlockNumber
      , "id" .= sushiswapBurnDTOId
      , "transaction" .= sushiswapBurnDTOTransaction
      , "timestamp" .= sushiswapBurnDTOTimestamp
      , "pair" .= sushiswapBurnDTOPair
      , "liquidity" .= sushiswapBurnDTOLiquidity
      , "sender" .= sushiswapBurnDTOSender
      , "amount_0" .= sushiswapBurnDTOAmount0
      , "amount_1" .= sushiswapBurnDTOAmount1
      , "to" .= sushiswapBurnDTOTo
      , "log_index" .= sushiswapBurnDTOLogIndex
      , "amount_usd" .= sushiswapBurnDTOAmountUsd
      , "complete" .= sushiswapBurnDTOComplete
      , "fee_to" .= sushiswapBurnDTOFeeTo
      , "fee_liquidity" .= sushiswapBurnDTOFeeLiquidity
      , "vid" .= sushiswapBurnDTOVid
      ]


-- | Construct a value of type 'SushiswapBurnDTO' (by applying it's required fields, if any)
mkSushiswapBurnDTO
  :: SushiswapBurnDTO
mkSushiswapBurnDTO =
  SushiswapBurnDTO
  { sushiswapBurnDTOEntryTime = Nothing
  , sushiswapBurnDTORecvTime = Nothing
  , sushiswapBurnDTOBlockNumber = Nothing
  , sushiswapBurnDTOId = Nothing
  , sushiswapBurnDTOTransaction = Nothing
  , sushiswapBurnDTOTimestamp = Nothing
  , sushiswapBurnDTOPair = Nothing
  , sushiswapBurnDTOLiquidity = Nothing
  , sushiswapBurnDTOSender = Nothing
  , sushiswapBurnDTOAmount0 = Nothing
  , sushiswapBurnDTOAmount1 = Nothing
  , sushiswapBurnDTOTo = Nothing
  , sushiswapBurnDTOLogIndex = Nothing
  , sushiswapBurnDTOAmountUsd = Nothing
  , sushiswapBurnDTOComplete = Nothing
  , sushiswapBurnDTOFeeTo = Nothing
  , sushiswapBurnDTOFeeLiquidity = Nothing
  , sushiswapBurnDTOVid = Nothing
  }

-- ** SushiswapDayDataDTO
-- | SushiswapDayDataDTO
-- Tracks data across all pairs aggregated into a daily bucket.
data SushiswapDayDataDTO = SushiswapDayDataDTO
  { sushiswapDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapDayDataDTOId :: !(Maybe Text) -- ^ "id" - Unix timestamp for start of day / 86400 giving a unique day index.
  , sushiswapDayDataDTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , sushiswapDayDataDTOFactory :: !(Maybe Text) -- ^ "factory" - Factory address.
  , sushiswapDayDataDTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - Total volume across all pairs on this day, stored as a derived amount of ETH.
  , sushiswapDayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total volume across all pairs on this day, stored as a derived amount of USD.
  , sushiswapDayDataDTOUntrackedVolume :: !(Maybe Text) -- ^ "untracked_volume" - Total volume across all pairs on this day, untracked
  , sushiswapDayDataDTOLiquidityEth :: !(Maybe Text) -- ^ "liquidity_eth" - Total liquidity across all pairs in ETH up to and including this day.
  , sushiswapDayDataDTOLiquidityUsd :: !(Maybe Text) -- ^ "liquidity_usd" - Total liquidity across all pairs in USD up to and including this day.
  , sushiswapDayDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Number of transactions throughout this day.
  , sushiswapDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapDayDataDTO
instance A.FromJSON SushiswapDayDataDTO where
  parseJSON = A.withObject "SushiswapDayDataDTO" $ \o ->
    SushiswapDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "factory")
      <*> (o .:? "volume_eth")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume")
      <*> (o .:? "liquidity_eth")
      <*> (o .:? "liquidity_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON SushiswapDayDataDTO
instance A.ToJSON SushiswapDayDataDTO where
  toJSON SushiswapDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapDayDataDTOEntryTime
      , "recv_time" .= sushiswapDayDataDTORecvTime
      , "block_number" .= sushiswapDayDataDTOBlockNumber
      , "id" .= sushiswapDayDataDTOId
      , "date" .= sushiswapDayDataDTODate
      , "factory" .= sushiswapDayDataDTOFactory
      , "volume_eth" .= sushiswapDayDataDTOVolumeEth
      , "volume_usd" .= sushiswapDayDataDTOVolumeUsd
      , "untracked_volume" .= sushiswapDayDataDTOUntrackedVolume
      , "liquidity_eth" .= sushiswapDayDataDTOLiquidityEth
      , "liquidity_usd" .= sushiswapDayDataDTOLiquidityUsd
      , "tx_count" .= sushiswapDayDataDTOTxCount
      , "vid" .= sushiswapDayDataDTOVid
      ]


-- | Construct a value of type 'SushiswapDayDataDTO' (by applying it's required fields, if any)
mkSushiswapDayDataDTO
  :: SushiswapDayDataDTO
mkSushiswapDayDataDTO =
  SushiswapDayDataDTO
  { sushiswapDayDataDTOEntryTime = Nothing
  , sushiswapDayDataDTORecvTime = Nothing
  , sushiswapDayDataDTOBlockNumber = Nothing
  , sushiswapDayDataDTOId = Nothing
  , sushiswapDayDataDTODate = Nothing
  , sushiswapDayDataDTOFactory = Nothing
  , sushiswapDayDataDTOVolumeEth = Nothing
  , sushiswapDayDataDTOVolumeUsd = Nothing
  , sushiswapDayDataDTOUntrackedVolume = Nothing
  , sushiswapDayDataDTOLiquidityEth = Nothing
  , sushiswapDayDataDTOLiquidityUsd = Nothing
  , sushiswapDayDataDTOTxCount = Nothing
  , sushiswapDayDataDTOVid = Nothing
  }

-- ** SushiswapFactoryDTO
-- | SushiswapFactoryDTO
-- The Sushiswap Factory entity is responsible for storing aggregate information across all Sushiswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
data SushiswapFactoryDTO = SushiswapFactoryDTO
  { sushiswapFactoryDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapFactoryDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapFactoryDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapFactoryDTOId :: !(Maybe Text) -- ^ "id" - Factory address.
  , sushiswapFactoryDTOPairCount :: !(Maybe Text) -- ^ "pair_count" - Amount of pairs created by the Sushiswap factory.
  , sushiswapFactoryDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - All time USD volume across all pairs (USD is derived).
  , sushiswapFactoryDTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - All time volume in ETH across all pairs (ETH is derived).
  , sushiswapFactoryDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Untracked volume USD.
  , sushiswapFactoryDTOLiquidityUsd :: !(Maybe Text) -- ^ "liquidity_usd" - Total liquidity across all pairs stored as a derived USD amount.
  , sushiswapFactoryDTOLiquidityEth :: !(Maybe Text) -- ^ "liquidity_eth" - Total liquidity across all pairs stored as a derived ETH amount.
  , sushiswapFactoryDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - All time amount of transactions across all pairs.
  , sushiswapFactoryDTOTokenCount :: !(Maybe Text) -- ^ "token_count" - Total count of tokens.
  , sushiswapFactoryDTOUserCount :: !(Maybe Text) -- ^ "user_count" - Users count.
  , sushiswapFactoryDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapFactoryDTO
instance A.FromJSON SushiswapFactoryDTO where
  parseJSON = A.withObject "SushiswapFactoryDTO" $ \o ->
    SushiswapFactoryDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pair_count")
      <*> (o .:? "volume_usd")
      <*> (o .:? "volume_eth")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "liquidity_usd")
      <*> (o .:? "liquidity_eth")
      <*> (o .:? "tx_count")
      <*> (o .:? "token_count")
      <*> (o .:? "user_count")
      <*> (o .:? "vid")

-- | ToJSON SushiswapFactoryDTO
instance A.ToJSON SushiswapFactoryDTO where
  toJSON SushiswapFactoryDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapFactoryDTOEntryTime
      , "recv_time" .= sushiswapFactoryDTORecvTime
      , "block_number" .= sushiswapFactoryDTOBlockNumber
      , "id" .= sushiswapFactoryDTOId
      , "pair_count" .= sushiswapFactoryDTOPairCount
      , "volume_usd" .= sushiswapFactoryDTOVolumeUsd
      , "volume_eth" .= sushiswapFactoryDTOVolumeEth
      , "untracked_volume_usd" .= sushiswapFactoryDTOUntrackedVolumeUsd
      , "liquidity_usd" .= sushiswapFactoryDTOLiquidityUsd
      , "liquidity_eth" .= sushiswapFactoryDTOLiquidityEth
      , "tx_count" .= sushiswapFactoryDTOTxCount
      , "token_count" .= sushiswapFactoryDTOTokenCount
      , "user_count" .= sushiswapFactoryDTOUserCount
      , "vid" .= sushiswapFactoryDTOVid
      ]


-- | Construct a value of type 'SushiswapFactoryDTO' (by applying it's required fields, if any)
mkSushiswapFactoryDTO
  :: SushiswapFactoryDTO
mkSushiswapFactoryDTO =
  SushiswapFactoryDTO
  { sushiswapFactoryDTOEntryTime = Nothing
  , sushiswapFactoryDTORecvTime = Nothing
  , sushiswapFactoryDTOBlockNumber = Nothing
  , sushiswapFactoryDTOId = Nothing
  , sushiswapFactoryDTOPairCount = Nothing
  , sushiswapFactoryDTOVolumeUsd = Nothing
  , sushiswapFactoryDTOVolumeEth = Nothing
  , sushiswapFactoryDTOUntrackedVolumeUsd = Nothing
  , sushiswapFactoryDTOLiquidityUsd = Nothing
  , sushiswapFactoryDTOLiquidityEth = Nothing
  , sushiswapFactoryDTOTxCount = Nothing
  , sushiswapFactoryDTOTokenCount = Nothing
  , sushiswapFactoryDTOUserCount = Nothing
  , sushiswapFactoryDTOVid = Nothing
  }

-- ** SushiswapHourDataDTO
-- | SushiswapHourDataDTO
data SushiswapHourDataDTO = SushiswapHourDataDTO
  { sushiswapHourDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapHourDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapHourDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapHourDataDTOId :: !(Maybe Text) -- ^ "id" - Start of hour timestamp.
  , sushiswapHourDataDTODate :: !(Maybe Int) -- ^ "date" - 
  , sushiswapHourDataDTOFactory :: !(Maybe Text) -- ^ "factory" - 
  , sushiswapHourDataDTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - 
  , sushiswapHourDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - 
  , sushiswapHourDataDTOUntrackedVolume :: !(Maybe Text) -- ^ "untracked_volume" - 
  , sushiswapHourDataDTOLiquidityEth :: !(Maybe Text) -- ^ "liquidity_eth" - 
  , sushiswapHourDataDTOLiquidityUsd :: !(Maybe Text) -- ^ "liquidity_usd" - 
  , sushiswapHourDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - 
  , sushiswapHourDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapHourDataDTO
instance A.FromJSON SushiswapHourDataDTO where
  parseJSON = A.withObject "SushiswapHourDataDTO" $ \o ->
    SushiswapHourDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "factory")
      <*> (o .:? "volume_eth")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume")
      <*> (o .:? "liquidity_eth")
      <*> (o .:? "liquidity_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON SushiswapHourDataDTO
instance A.ToJSON SushiswapHourDataDTO where
  toJSON SushiswapHourDataDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapHourDataDTOEntryTime
      , "recv_time" .= sushiswapHourDataDTORecvTime
      , "block_number" .= sushiswapHourDataDTOBlockNumber
      , "id" .= sushiswapHourDataDTOId
      , "date" .= sushiswapHourDataDTODate
      , "factory" .= sushiswapHourDataDTOFactory
      , "volume_eth" .= sushiswapHourDataDTOVolumeEth
      , "volume_usd" .= sushiswapHourDataDTOVolumeUsd
      , "untracked_volume" .= sushiswapHourDataDTOUntrackedVolume
      , "liquidity_eth" .= sushiswapHourDataDTOLiquidityEth
      , "liquidity_usd" .= sushiswapHourDataDTOLiquidityUsd
      , "tx_count" .= sushiswapHourDataDTOTxCount
      , "vid" .= sushiswapHourDataDTOVid
      ]


-- | Construct a value of type 'SushiswapHourDataDTO' (by applying it's required fields, if any)
mkSushiswapHourDataDTO
  :: SushiswapHourDataDTO
mkSushiswapHourDataDTO =
  SushiswapHourDataDTO
  { sushiswapHourDataDTOEntryTime = Nothing
  , sushiswapHourDataDTORecvTime = Nothing
  , sushiswapHourDataDTOBlockNumber = Nothing
  , sushiswapHourDataDTOId = Nothing
  , sushiswapHourDataDTODate = Nothing
  , sushiswapHourDataDTOFactory = Nothing
  , sushiswapHourDataDTOVolumeEth = Nothing
  , sushiswapHourDataDTOVolumeUsd = Nothing
  , sushiswapHourDataDTOUntrackedVolume = Nothing
  , sushiswapHourDataDTOLiquidityEth = Nothing
  , sushiswapHourDataDTOLiquidityUsd = Nothing
  , sushiswapHourDataDTOTxCount = Nothing
  , sushiswapHourDataDTOVid = Nothing
  }

-- ** SushiswapLiquidityPositionDTO
-- | SushiswapLiquidityPositionDTO
data SushiswapLiquidityPositionDTO = SushiswapLiquidityPositionDTO
  { sushiswapLiquidityPositionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapLiquidityPositionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapLiquidityPositionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapLiquidityPositionDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (pair address)-(user address)
  , sushiswapLiquidityPositionDTOUser :: !(Maybe Text) -- ^ "user" - User address.
  , sushiswapLiquidityPositionDTOPair :: !(Maybe Text) -- ^ "pair" - Pair address.
  , sushiswapLiquidityPositionDTOLiquidityTokenBalance :: !(Maybe Text) -- ^ "liquidity_token_balance" - Amount of LP tokens minted for this position.
  , sushiswapLiquidityPositionDTOBlock :: !(Maybe Int) -- ^ "block" - Block number at which position was created.
  , sushiswapLiquidityPositionDTOTimestamp :: !(Maybe Int) -- ^ "timestamp" - Creation time.
  , sushiswapLiquidityPositionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapLiquidityPositionDTO
instance A.FromJSON SushiswapLiquidityPositionDTO where
  parseJSON = A.withObject "SushiswapLiquidityPositionDTO" $ \o ->
    SushiswapLiquidityPositionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "pair")
      <*> (o .:? "liquidity_token_balance")
      <*> (o .:? "block")
      <*> (o .:? "timestamp")
      <*> (o .:? "vid")

-- | ToJSON SushiswapLiquidityPositionDTO
instance A.ToJSON SushiswapLiquidityPositionDTO where
  toJSON SushiswapLiquidityPositionDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapLiquidityPositionDTOEntryTime
      , "recv_time" .= sushiswapLiquidityPositionDTORecvTime
      , "block_number" .= sushiswapLiquidityPositionDTOBlockNumber
      , "id" .= sushiswapLiquidityPositionDTOId
      , "user" .= sushiswapLiquidityPositionDTOUser
      , "pair" .= sushiswapLiquidityPositionDTOPair
      , "liquidity_token_balance" .= sushiswapLiquidityPositionDTOLiquidityTokenBalance
      , "block" .= sushiswapLiquidityPositionDTOBlock
      , "timestamp" .= sushiswapLiquidityPositionDTOTimestamp
      , "vid" .= sushiswapLiquidityPositionDTOVid
      ]


-- | Construct a value of type 'SushiswapLiquidityPositionDTO' (by applying it's required fields, if any)
mkSushiswapLiquidityPositionDTO
  :: SushiswapLiquidityPositionDTO
mkSushiswapLiquidityPositionDTO =
  SushiswapLiquidityPositionDTO
  { sushiswapLiquidityPositionDTOEntryTime = Nothing
  , sushiswapLiquidityPositionDTORecvTime = Nothing
  , sushiswapLiquidityPositionDTOBlockNumber = Nothing
  , sushiswapLiquidityPositionDTOId = Nothing
  , sushiswapLiquidityPositionDTOUser = Nothing
  , sushiswapLiquidityPositionDTOPair = Nothing
  , sushiswapLiquidityPositionDTOLiquidityTokenBalance = Nothing
  , sushiswapLiquidityPositionDTOBlock = Nothing
  , sushiswapLiquidityPositionDTOTimestamp = Nothing
  , sushiswapLiquidityPositionDTOVid = Nothing
  }

-- ** SushiswapLiquidityPositionSnapshotDTO
-- | SushiswapLiquidityPositionSnapshotDTO
-- This entity is used to store data about a user's liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
data SushiswapLiquidityPositionSnapshotDTO = SushiswapLiquidityPositionSnapshotDTO
  { sushiswapLiquidityPositionSnapshotDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapLiquidityPositionSnapshotDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapLiquidityPositionSnapshotDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapLiquidityPositionSnapshotDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (pair address)-(user address)-(timestamp)
  , sushiswapLiquidityPositionSnapshotDTOLiquidityPosition :: !(Maybe Text) -- ^ "liquidity_position" - Reference to LP identifier.
  , sushiswapLiquidityPositionSnapshotDTOTimestamp :: !(Maybe Int) -- ^ "timestamp" - Creation time.
  , sushiswapLiquidityPositionSnapshotDTOBlock :: !(Maybe Int) -- ^ "block" - Block in which snapshot has been created.
  , sushiswapLiquidityPositionSnapshotDTOUser :: !(Maybe Text) -- ^ "user" - Reference to user.
  , sushiswapLiquidityPositionSnapshotDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to the pair liquidity is being provided on.
  , sushiswapLiquidityPositionSnapshotDTOToken0PriceUsd :: !(Maybe Text) -- ^ "token_0_price_usd" - Snapshot of token0 price in USD.
  , sushiswapLiquidityPositionSnapshotDTOToken1PriceUsd :: !(Maybe Text) -- ^ "token_1_price_usd" - Snapshot of token0 price in USD.
  , sushiswapLiquidityPositionSnapshotDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Snapshot of pair token0 reserves.
  , sushiswapLiquidityPositionSnapshotDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Snapshot of pair token1 reserves.
  , sushiswapLiquidityPositionSnapshotDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Snapshot of pair reserves in USD.
  , sushiswapLiquidityPositionSnapshotDTOLiquidityTokenTotalSupply :: !(Maybe Text) -- ^ "liquidity_token_total_supply" - Snapshot of pool token supply.
  , sushiswapLiquidityPositionSnapshotDTOLiquidityTokenBalance :: !(Maybe Text) -- ^ "liquidity_token_balance" - Snapshot of users pool token balance.
  , sushiswapLiquidityPositionSnapshotDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapLiquidityPositionSnapshotDTO
instance A.FromJSON SushiswapLiquidityPositionSnapshotDTO where
  parseJSON = A.withObject "SushiswapLiquidityPositionSnapshotDTO" $ \o ->
    SushiswapLiquidityPositionSnapshotDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "liquidity_position")
      <*> (o .:? "timestamp")
      <*> (o .:? "block")
      <*> (o .:? "user")
      <*> (o .:? "pair")
      <*> (o .:? "token_0_price_usd")
      <*> (o .:? "token_1_price_usd")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "liquidity_token_total_supply")
      <*> (o .:? "liquidity_token_balance")
      <*> (o .:? "vid")

-- | ToJSON SushiswapLiquidityPositionSnapshotDTO
instance A.ToJSON SushiswapLiquidityPositionSnapshotDTO where
  toJSON SushiswapLiquidityPositionSnapshotDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapLiquidityPositionSnapshotDTOEntryTime
      , "recv_time" .= sushiswapLiquidityPositionSnapshotDTORecvTime
      , "block_number" .= sushiswapLiquidityPositionSnapshotDTOBlockNumber
      , "id" .= sushiswapLiquidityPositionSnapshotDTOId
      , "liquidity_position" .= sushiswapLiquidityPositionSnapshotDTOLiquidityPosition
      , "timestamp" .= sushiswapLiquidityPositionSnapshotDTOTimestamp
      , "block" .= sushiswapLiquidityPositionSnapshotDTOBlock
      , "user" .= sushiswapLiquidityPositionSnapshotDTOUser
      , "pair" .= sushiswapLiquidityPositionSnapshotDTOPair
      , "token_0_price_usd" .= sushiswapLiquidityPositionSnapshotDTOToken0PriceUsd
      , "token_1_price_usd" .= sushiswapLiquidityPositionSnapshotDTOToken1PriceUsd
      , "reserve_0" .= sushiswapLiquidityPositionSnapshotDTOReserve0
      , "reserve_1" .= sushiswapLiquidityPositionSnapshotDTOReserve1
      , "reserve_usd" .= sushiswapLiquidityPositionSnapshotDTOReserveUsd
      , "liquidity_token_total_supply" .= sushiswapLiquidityPositionSnapshotDTOLiquidityTokenTotalSupply
      , "liquidity_token_balance" .= sushiswapLiquidityPositionSnapshotDTOLiquidityTokenBalance
      , "vid" .= sushiswapLiquidityPositionSnapshotDTOVid
      ]


-- | Construct a value of type 'SushiswapLiquidityPositionSnapshotDTO' (by applying it's required fields, if any)
mkSushiswapLiquidityPositionSnapshotDTO
  :: SushiswapLiquidityPositionSnapshotDTO
mkSushiswapLiquidityPositionSnapshotDTO =
  SushiswapLiquidityPositionSnapshotDTO
  { sushiswapLiquidityPositionSnapshotDTOEntryTime = Nothing
  , sushiswapLiquidityPositionSnapshotDTORecvTime = Nothing
  , sushiswapLiquidityPositionSnapshotDTOBlockNumber = Nothing
  , sushiswapLiquidityPositionSnapshotDTOId = Nothing
  , sushiswapLiquidityPositionSnapshotDTOLiquidityPosition = Nothing
  , sushiswapLiquidityPositionSnapshotDTOTimestamp = Nothing
  , sushiswapLiquidityPositionSnapshotDTOBlock = Nothing
  , sushiswapLiquidityPositionSnapshotDTOUser = Nothing
  , sushiswapLiquidityPositionSnapshotDTOPair = Nothing
  , sushiswapLiquidityPositionSnapshotDTOToken0PriceUsd = Nothing
  , sushiswapLiquidityPositionSnapshotDTOToken1PriceUsd = Nothing
  , sushiswapLiquidityPositionSnapshotDTOReserve0 = Nothing
  , sushiswapLiquidityPositionSnapshotDTOReserve1 = Nothing
  , sushiswapLiquidityPositionSnapshotDTOReserveUsd = Nothing
  , sushiswapLiquidityPositionSnapshotDTOLiquidityTokenTotalSupply = Nothing
  , sushiswapLiquidityPositionSnapshotDTOLiquidityTokenBalance = Nothing
  , sushiswapLiquidityPositionSnapshotDTOVid = Nothing
  }

-- ** SushiswapMintDTO
-- | SushiswapMintDTO
-- Mint entities are created for every emitted Mint event on the Sushiswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
data SushiswapMintDTO = SushiswapMintDTO
  { sushiswapMintDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapMintDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapMintDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapMintDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (transaction hash)-(index in the transaction mint array).
  , sushiswapMintDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to the transaction Mint was included in.
  , sushiswapMintDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of Mint, used to sort recent liquidity provisions.
  , sushiswapMintDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , sushiswapMintDTOTo :: !(Maybe Text) -- ^ "to" - Recipient of liquidity tokens.
  , sushiswapMintDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Amount of liquidity tokens minted.
  , sushiswapMintDTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the liquidity provision.
  , sushiswapMintDTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token0 provided.
  , sushiswapMintDTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token1 provided.
  , sushiswapMintDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Index in the transaction event was emitted.
  , sushiswapMintDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived USD value of token0 amount plus token1 amount.
  , sushiswapMintDTOFeeTo :: !(Maybe Text) -- ^ "fee_to" - Address of fee recipient (if fee is on).
  , sushiswapMintDTOFeeLiquidity :: !(Maybe Text) -- ^ "fee_liquidity" - Amount of liquidity sent to fee recipient (if fee is on).
  , sushiswapMintDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapMintDTO
instance A.FromJSON SushiswapMintDTO where
  parseJSON = A.withObject "SushiswapMintDTO" $ \o ->
    SushiswapMintDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "to")
      <*> (o .:? "liquidity")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "fee_to")
      <*> (o .:? "fee_liquidity")
      <*> (o .:? "vid")

-- | ToJSON SushiswapMintDTO
instance A.ToJSON SushiswapMintDTO where
  toJSON SushiswapMintDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapMintDTOEntryTime
      , "recv_time" .= sushiswapMintDTORecvTime
      , "block_number" .= sushiswapMintDTOBlockNumber
      , "id" .= sushiswapMintDTOId
      , "transaction" .= sushiswapMintDTOTransaction
      , "timestamp" .= sushiswapMintDTOTimestamp
      , "pair" .= sushiswapMintDTOPair
      , "to" .= sushiswapMintDTOTo
      , "liquidity" .= sushiswapMintDTOLiquidity
      , "sender" .= sushiswapMintDTOSender
      , "amount_0" .= sushiswapMintDTOAmount0
      , "amount_1" .= sushiswapMintDTOAmount1
      , "log_index" .= sushiswapMintDTOLogIndex
      , "amount_usd" .= sushiswapMintDTOAmountUsd
      , "fee_to" .= sushiswapMintDTOFeeTo
      , "fee_liquidity" .= sushiswapMintDTOFeeLiquidity
      , "vid" .= sushiswapMintDTOVid
      ]


-- | Construct a value of type 'SushiswapMintDTO' (by applying it's required fields, if any)
mkSushiswapMintDTO
  :: SushiswapMintDTO
mkSushiswapMintDTO =
  SushiswapMintDTO
  { sushiswapMintDTOEntryTime = Nothing
  , sushiswapMintDTORecvTime = Nothing
  , sushiswapMintDTOBlockNumber = Nothing
  , sushiswapMintDTOId = Nothing
  , sushiswapMintDTOTransaction = Nothing
  , sushiswapMintDTOTimestamp = Nothing
  , sushiswapMintDTOPair = Nothing
  , sushiswapMintDTOTo = Nothing
  , sushiswapMintDTOLiquidity = Nothing
  , sushiswapMintDTOSender = Nothing
  , sushiswapMintDTOAmount0 = Nothing
  , sushiswapMintDTOAmount1 = Nothing
  , sushiswapMintDTOLogIndex = Nothing
  , sushiswapMintDTOAmountUsd = Nothing
  , sushiswapMintDTOFeeTo = Nothing
  , sushiswapMintDTOFeeLiquidity = Nothing
  , sushiswapMintDTOVid = Nothing
  }

-- ** SushiswapPairDTO
-- | SushiswapPairDTO
-- Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
data SushiswapPairDTO = SushiswapPairDTO
  { sushiswapPairDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapPairDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapPairDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapPairDTOId :: !(Maybe Text) -- ^ "id" - Pair contract address.
  , sushiswapPairDTOFactory :: !(Maybe Text) -- ^ "factory" - Factory contract address.
  , sushiswapPairDTOName :: !(Maybe Text) -- ^ "name" - Friendly name, format: (token0 name)-(token1 name)
  , sushiswapPairDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pair contract.
  , sushiswapPairDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token0 as stored in pair contract.
  , sushiswapPairDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0.
  , sushiswapPairDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1.
  , sushiswapPairDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token distributed to LPs.
  , sushiswapPairDTOReserveEth :: !(Maybe Text) -- ^ "reserve_eth" - Total liquidity in pair stored as an amount of ETH.
  , sushiswapPairDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Total liquidity amount in pair stored as an amount of USD.
  , sushiswapPairDTOTrackedReserveEth :: !(Maybe Text) -- ^ "tracked_reserve_eth" - Total liquidity with only tracked amount.
  , sushiswapPairDTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - Token0 per token1.
  , sushiswapPairDTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - Token1 per token0.
  , sushiswapPairDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Amount of token0 swapped on this pair.
  , sushiswapPairDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Amount of token1 swapped on this pair.
  , sushiswapPairDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
  , sushiswapPairDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
  , sushiswapPairDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - All time amount of transactions on this pair.
  , sushiswapPairDTOLiquidityProviderCount :: !(Maybe Text) -- ^ "liquidity_provider_count" - Total number of LPs.
  , sushiswapPairDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp.
  , sushiswapPairDTOBlock :: !(Maybe Text) -- ^ "block" - Block number in which pair information was created in.
  , sushiswapPairDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , sushiswapPairDTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapPairDTO
instance A.FromJSON SushiswapPairDTO where
  parseJSON = A.withObject "SushiswapPairDTO" $ \o ->
    SushiswapPairDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "factory")
      <*> (o .:? "name")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_eth")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "tracked_reserve_eth")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "timestamp")
      <*> (o .:? "block")
      <*> (o .:? "vid")
      <*> (o .:? "evaluated_ask")

-- | ToJSON SushiswapPairDTO
instance A.ToJSON SushiswapPairDTO where
  toJSON SushiswapPairDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapPairDTOEntryTime
      , "recv_time" .= sushiswapPairDTORecvTime
      , "block_number" .= sushiswapPairDTOBlockNumber
      , "id" .= sushiswapPairDTOId
      , "factory" .= sushiswapPairDTOFactory
      , "name" .= sushiswapPairDTOName
      , "token_0" .= sushiswapPairDTOToken0
      , "token_1" .= sushiswapPairDTOToken1
      , "reserve_0" .= sushiswapPairDTOReserve0
      , "reserve_1" .= sushiswapPairDTOReserve1
      , "total_supply" .= sushiswapPairDTOTotalSupply
      , "reserve_eth" .= sushiswapPairDTOReserveEth
      , "reserve_usd" .= sushiswapPairDTOReserveUsd
      , "tracked_reserve_eth" .= sushiswapPairDTOTrackedReserveEth
      , "token_0_price" .= sushiswapPairDTOToken0Price
      , "token_1_price" .= sushiswapPairDTOToken1Price
      , "volume_token_0" .= sushiswapPairDTOVolumeToken0
      , "volume_token_1" .= sushiswapPairDTOVolumeToken1
      , "volume_usd" .= sushiswapPairDTOVolumeUsd
      , "untracked_volume_usd" .= sushiswapPairDTOUntrackedVolumeUsd
      , "tx_count" .= sushiswapPairDTOTxCount
      , "liquidity_provider_count" .= sushiswapPairDTOLiquidityProviderCount
      , "timestamp" .= sushiswapPairDTOTimestamp
      , "block" .= sushiswapPairDTOBlock
      , "vid" .= sushiswapPairDTOVid
      , "evaluated_ask" .= sushiswapPairDTOEvaluatedAsk
      ]


-- | Construct a value of type 'SushiswapPairDTO' (by applying it's required fields, if any)
mkSushiswapPairDTO
  :: SushiswapPairDTO
mkSushiswapPairDTO =
  SushiswapPairDTO
  { sushiswapPairDTOEntryTime = Nothing
  , sushiswapPairDTORecvTime = Nothing
  , sushiswapPairDTOBlockNumber = Nothing
  , sushiswapPairDTOId = Nothing
  , sushiswapPairDTOFactory = Nothing
  , sushiswapPairDTOName = Nothing
  , sushiswapPairDTOToken0 = Nothing
  , sushiswapPairDTOToken1 = Nothing
  , sushiswapPairDTOReserve0 = Nothing
  , sushiswapPairDTOReserve1 = Nothing
  , sushiswapPairDTOTotalSupply = Nothing
  , sushiswapPairDTOReserveEth = Nothing
  , sushiswapPairDTOReserveUsd = Nothing
  , sushiswapPairDTOTrackedReserveEth = Nothing
  , sushiswapPairDTOToken0Price = Nothing
  , sushiswapPairDTOToken1Price = Nothing
  , sushiswapPairDTOVolumeToken0 = Nothing
  , sushiswapPairDTOVolumeToken1 = Nothing
  , sushiswapPairDTOVolumeUsd = Nothing
  , sushiswapPairDTOUntrackedVolumeUsd = Nothing
  , sushiswapPairDTOTxCount = Nothing
  , sushiswapPairDTOLiquidityProviderCount = Nothing
  , sushiswapPairDTOTimestamp = Nothing
  , sushiswapPairDTOBlock = Nothing
  , sushiswapPairDTOVid = Nothing
  , sushiswapPairDTOEvaluatedAsk = Nothing
  }

-- ** SushiswapPairDayDataDTO
-- | SushiswapPairDayDataDTO
-- Tracks pair data across each day.
data SushiswapPairDayDataDTO = SushiswapPairDayDataDTO
  { sushiswapPairDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapPairDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapPairDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapPairDayDataDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (pair id)-(day start timestamp).
  , sushiswapPairDayDataDTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , sushiswapPairDayDataDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , sushiswapPairDayDataDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0.
  , sushiswapPairDayDataDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1.
  , sushiswapPairDayDataDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0 (updated during each transaction on pair).
  , sushiswapPairDayDataDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1 (updated during each transaction on pair).
  , sushiswapPairDayDataDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token distributed to LPs.
  , sushiswapPairDayDataDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Reserve of token0 plus token1 stored as a derived USD amount.
  , sushiswapPairDayDataDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Total amount of token0 swapped throughout day.
  , sushiswapPairDayDataDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Total amount of token1 swapped throughout day.
  , sushiswapPairDayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total volume within pair throughout day.
  , sushiswapPairDayDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Amount of transactions on pair throughout day.
  , sushiswapPairDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapPairDayDataDTO
instance A.FromJSON SushiswapPairDayDataDTO where
  parseJSON = A.withObject "SushiswapPairDayDataDTO" $ \o ->
    SushiswapPairDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pair")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON SushiswapPairDayDataDTO
instance A.ToJSON SushiswapPairDayDataDTO where
  toJSON SushiswapPairDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapPairDayDataDTOEntryTime
      , "recv_time" .= sushiswapPairDayDataDTORecvTime
      , "block_number" .= sushiswapPairDayDataDTOBlockNumber
      , "id" .= sushiswapPairDayDataDTOId
      , "date" .= sushiswapPairDayDataDTODate
      , "pair" .= sushiswapPairDayDataDTOPair
      , "token_0" .= sushiswapPairDayDataDTOToken0
      , "token_1" .= sushiswapPairDayDataDTOToken1
      , "reserve_0" .= sushiswapPairDayDataDTOReserve0
      , "reserve_1" .= sushiswapPairDayDataDTOReserve1
      , "total_supply" .= sushiswapPairDayDataDTOTotalSupply
      , "reserve_usd" .= sushiswapPairDayDataDTOReserveUsd
      , "volume_token_0" .= sushiswapPairDayDataDTOVolumeToken0
      , "volume_token_1" .= sushiswapPairDayDataDTOVolumeToken1
      , "volume_usd" .= sushiswapPairDayDataDTOVolumeUsd
      , "tx_count" .= sushiswapPairDayDataDTOTxCount
      , "vid" .= sushiswapPairDayDataDTOVid
      ]


-- | Construct a value of type 'SushiswapPairDayDataDTO' (by applying it's required fields, if any)
mkSushiswapPairDayDataDTO
  :: SushiswapPairDayDataDTO
mkSushiswapPairDayDataDTO =
  SushiswapPairDayDataDTO
  { sushiswapPairDayDataDTOEntryTime = Nothing
  , sushiswapPairDayDataDTORecvTime = Nothing
  , sushiswapPairDayDataDTOBlockNumber = Nothing
  , sushiswapPairDayDataDTOId = Nothing
  , sushiswapPairDayDataDTODate = Nothing
  , sushiswapPairDayDataDTOPair = Nothing
  , sushiswapPairDayDataDTOToken0 = Nothing
  , sushiswapPairDayDataDTOToken1 = Nothing
  , sushiswapPairDayDataDTOReserve0 = Nothing
  , sushiswapPairDayDataDTOReserve1 = Nothing
  , sushiswapPairDayDataDTOTotalSupply = Nothing
  , sushiswapPairDayDataDTOReserveUsd = Nothing
  , sushiswapPairDayDataDTOVolumeToken0 = Nothing
  , sushiswapPairDayDataDTOVolumeToken1 = Nothing
  , sushiswapPairDayDataDTOVolumeUsd = Nothing
  , sushiswapPairDayDataDTOTxCount = Nothing
  , sushiswapPairDayDataDTOVid = Nothing
  }

-- ** SushiswapPairHourDataDTO
-- | SushiswapPairHourDataDTO
-- Tracks pair data across each hour.
data SushiswapPairHourDataDTO = SushiswapPairHourDataDTO
  { sushiswapPairHourDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapPairHourDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapPairHourDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapPairHourDataDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (pair id)-(hour start timestamp).
  , sushiswapPairHourDataDTODate :: !(Maybe Int) -- ^ "date" - Hour start timestamp.
  , sushiswapPairHourDataDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , sushiswapPairHourDataDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0 (updated during each transaction on pair).
  , sushiswapPairHourDataDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1 (updated during each transaction on pair).
  , sushiswapPairHourDataDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Reserve of token0 plus token1 stored as a derived USD amount.
  , sushiswapPairHourDataDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Total amount of token0 swapped throughout hour.
  , sushiswapPairHourDataDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Total amount of token1 swapped throughout hour.
  , sushiswapPairHourDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total volume within pair throughout hour.
  , sushiswapPairHourDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Amount of transactions on pair throughout hour.
  , sushiswapPairHourDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapPairHourDataDTO
instance A.FromJSON SushiswapPairHourDataDTO where
  parseJSON = A.withObject "SushiswapPairHourDataDTO" $ \o ->
    SushiswapPairHourDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pair")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON SushiswapPairHourDataDTO
instance A.ToJSON SushiswapPairHourDataDTO where
  toJSON SushiswapPairHourDataDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapPairHourDataDTOEntryTime
      , "recv_time" .= sushiswapPairHourDataDTORecvTime
      , "block_number" .= sushiswapPairHourDataDTOBlockNumber
      , "id" .= sushiswapPairHourDataDTOId
      , "date" .= sushiswapPairHourDataDTODate
      , "pair" .= sushiswapPairHourDataDTOPair
      , "reserve_0" .= sushiswapPairHourDataDTOReserve0
      , "reserve_1" .= sushiswapPairHourDataDTOReserve1
      , "reserve_usd" .= sushiswapPairHourDataDTOReserveUsd
      , "volume_token_0" .= sushiswapPairHourDataDTOVolumeToken0
      , "volume_token_1" .= sushiswapPairHourDataDTOVolumeToken1
      , "volume_usd" .= sushiswapPairHourDataDTOVolumeUsd
      , "tx_count" .= sushiswapPairHourDataDTOTxCount
      , "vid" .= sushiswapPairHourDataDTOVid
      ]


-- | Construct a value of type 'SushiswapPairHourDataDTO' (by applying it's required fields, if any)
mkSushiswapPairHourDataDTO
  :: SushiswapPairHourDataDTO
mkSushiswapPairHourDataDTO =
  SushiswapPairHourDataDTO
  { sushiswapPairHourDataDTOEntryTime = Nothing
  , sushiswapPairHourDataDTORecvTime = Nothing
  , sushiswapPairHourDataDTOBlockNumber = Nothing
  , sushiswapPairHourDataDTOId = Nothing
  , sushiswapPairHourDataDTODate = Nothing
  , sushiswapPairHourDataDTOPair = Nothing
  , sushiswapPairHourDataDTOReserve0 = Nothing
  , sushiswapPairHourDataDTOReserve1 = Nothing
  , sushiswapPairHourDataDTOReserveUsd = Nothing
  , sushiswapPairHourDataDTOVolumeToken0 = Nothing
  , sushiswapPairHourDataDTOVolumeToken1 = Nothing
  , sushiswapPairHourDataDTOVolumeUsd = Nothing
  , sushiswapPairHourDataDTOTxCount = Nothing
  , sushiswapPairHourDataDTOVid = Nothing
  }

-- ** SushiswapSwapDTO
-- | SushiswapSwapDTO
-- Swap are created for each token swap within a pair.
data SushiswapSwapDTO = SushiswapSwapDTO
  { sushiswapSwapDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapSwapDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapSwapDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapSwapDTOId :: !(Maybe Text) -- ^ "id" - Transaction hash plus index in Transaction swap array.
  , sushiswapSwapDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to transaction swap was included in.
  , sushiswapSwapDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of swap, used for sorted lookups.
  , sushiswapSwapDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , sushiswapSwapDTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the swap.
  , sushiswapSwapDTOAmount0In :: !(Maybe Text) -- ^ "amount_0_in" - Amount of token0 sold.
  , sushiswapSwapDTOAmount1In :: !(Maybe Text) -- ^ "amount_1_in" - Amount of token1 sold.
  , sushiswapSwapDTOAmount0Out :: !(Maybe Text) -- ^ "amount_0_out" - Amount of token0 received.
  , sushiswapSwapDTOAmount1Out :: !(Maybe Text) -- ^ "amount_1_out" - Amount of token1 received.
  , sushiswapSwapDTOTo :: !(Maybe Text) -- ^ "to" - Recipient of output tokens.
  , sushiswapSwapDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Event index within transaction.
  , sushiswapSwapDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount of tokens sold in USD.
  , sushiswapSwapDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , sushiswapSwapDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , sushiswapSwapDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  , sushiswapSwapDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , sushiswapSwapDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , sushiswapSwapDTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapSwapDTO
instance A.FromJSON SushiswapSwapDTO where
  parseJSON = A.withObject "SushiswapSwapDTO" $ \o ->
    SushiswapSwapDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0_in")
      <*> (o .:? "amount_1_in")
      <*> (o .:? "amount_0_out")
      <*> (o .:? "amount_1_out")
      <*> (o .:? "to")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "vid")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")

-- | ToJSON SushiswapSwapDTO
instance A.ToJSON SushiswapSwapDTO where
  toJSON SushiswapSwapDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapSwapDTOEntryTime
      , "recv_time" .= sushiswapSwapDTORecvTime
      , "block_number" .= sushiswapSwapDTOBlockNumber
      , "id" .= sushiswapSwapDTOId
      , "transaction" .= sushiswapSwapDTOTransaction
      , "timestamp" .= sushiswapSwapDTOTimestamp
      , "pair" .= sushiswapSwapDTOPair
      , "sender" .= sushiswapSwapDTOSender
      , "amount_0_in" .= sushiswapSwapDTOAmount0In
      , "amount_1_in" .= sushiswapSwapDTOAmount1In
      , "amount_0_out" .= sushiswapSwapDTOAmount0Out
      , "amount_1_out" .= sushiswapSwapDTOAmount1Out
      , "to" .= sushiswapSwapDTOTo
      , "log_index" .= sushiswapSwapDTOLogIndex
      , "amount_usd" .= sushiswapSwapDTOAmountUsd
      , "vid" .= sushiswapSwapDTOVid
      , "pool_id" .= sushiswapSwapDTOPoolId
      , "transaction_id" .= sushiswapSwapDTOTransactionId
      , "evaluated_price" .= sushiswapSwapDTOEvaluatedPrice
      , "evaluated_amount" .= sushiswapSwapDTOEvaluatedAmount
      , "evaluated_aggressor" .= sushiswapSwapDTOEvaluatedAggressor
      ]


-- | Construct a value of type 'SushiswapSwapDTO' (by applying it's required fields, if any)
mkSushiswapSwapDTO
  :: SushiswapSwapDTO
mkSushiswapSwapDTO =
  SushiswapSwapDTO
  { sushiswapSwapDTOEntryTime = Nothing
  , sushiswapSwapDTORecvTime = Nothing
  , sushiswapSwapDTOBlockNumber = Nothing
  , sushiswapSwapDTOId = Nothing
  , sushiswapSwapDTOTransaction = Nothing
  , sushiswapSwapDTOTimestamp = Nothing
  , sushiswapSwapDTOPair = Nothing
  , sushiswapSwapDTOSender = Nothing
  , sushiswapSwapDTOAmount0In = Nothing
  , sushiswapSwapDTOAmount1In = Nothing
  , sushiswapSwapDTOAmount0Out = Nothing
  , sushiswapSwapDTOAmount1Out = Nothing
  , sushiswapSwapDTOTo = Nothing
  , sushiswapSwapDTOLogIndex = Nothing
  , sushiswapSwapDTOAmountUsd = Nothing
  , sushiswapSwapDTOVid = Nothing
  , sushiswapSwapDTOPoolId = Nothing
  , sushiswapSwapDTOTransactionId = Nothing
  , sushiswapSwapDTOEvaluatedPrice = Nothing
  , sushiswapSwapDTOEvaluatedAmount = Nothing
  , sushiswapSwapDTOEvaluatedAggressor = Nothing
  }

-- ** SushiswapTokenDTO
-- | SushiswapTokenDTO
-- Stores aggregated information for a specific token across all pairs that token is included in.
data SushiswapTokenDTO = SushiswapTokenDTO
  { sushiswapTokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapTokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapTokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapTokenDTOId :: !(Maybe Text) -- ^ "id" - Token address.
  , sushiswapTokenDTOFactory :: !(Maybe Text) -- ^ "factory" - Factory address.
  , sushiswapTokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - Token symbol.
  , sushiswapTokenDTOName :: !(Maybe Text) -- ^ "name" - Token name.
  , sushiswapTokenDTODecimals :: !(Maybe Text) -- ^ "decimals" - Token decimals.
  , sushiswapTokenDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token.
  , sushiswapTokenDTOVolume :: !(Maybe Text) -- ^ "volume" - Amount of token traded all time across all pairs.
  , sushiswapTokenDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
  , sushiswapTokenDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
  , sushiswapTokenDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Amount of transactions all time in pairs including token.
  , sushiswapTokenDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Total amount of token provided as liquidity across all pairs.
  , sushiswapTokenDTODerivedEth :: !(Maybe Text) -- ^ "derived_eth" - ETH per token.
  , sushiswapTokenDTOWhitelistPairs :: !(Maybe [Text]) -- ^ "whitelist_pairs" - Array of whitelisted pairs.
  , sushiswapTokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , sushiswapTokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapTokenDTO
instance A.FromJSON SushiswapTokenDTO where
  parseJSON = A.withObject "SushiswapTokenDTO" $ \o ->
    SushiswapTokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "factory")
      <*> (o .:? "symbol")
      <*> (o .:? "name")
      <*> (o .:? "decimals")
      <*> (o .:? "total_supply")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "liquidity")
      <*> (o .:? "derived_eth")
      <*> (o .:? "whitelist_pairs")
      <*> (o .:? "vid")
      <*> (o .:? "token_symbol")

-- | ToJSON SushiswapTokenDTO
instance A.ToJSON SushiswapTokenDTO where
  toJSON SushiswapTokenDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapTokenDTOEntryTime
      , "recv_time" .= sushiswapTokenDTORecvTime
      , "block_number" .= sushiswapTokenDTOBlockNumber
      , "id" .= sushiswapTokenDTOId
      , "factory" .= sushiswapTokenDTOFactory
      , "symbol" .= sushiswapTokenDTOSymbol
      , "name" .= sushiswapTokenDTOName
      , "decimals" .= sushiswapTokenDTODecimals
      , "total_supply" .= sushiswapTokenDTOTotalSupply
      , "volume" .= sushiswapTokenDTOVolume
      , "volume_usd" .= sushiswapTokenDTOVolumeUsd
      , "untracked_volume_usd" .= sushiswapTokenDTOUntrackedVolumeUsd
      , "tx_count" .= sushiswapTokenDTOTxCount
      , "liquidity" .= sushiswapTokenDTOLiquidity
      , "derived_eth" .= sushiswapTokenDTODerivedEth
      , "whitelist_pairs" .= sushiswapTokenDTOWhitelistPairs
      , "vid" .= sushiswapTokenDTOVid
      , "token_symbol" .= sushiswapTokenDTOTokenSymbol
      ]


-- | Construct a value of type 'SushiswapTokenDTO' (by applying it's required fields, if any)
mkSushiswapTokenDTO
  :: SushiswapTokenDTO
mkSushiswapTokenDTO =
  SushiswapTokenDTO
  { sushiswapTokenDTOEntryTime = Nothing
  , sushiswapTokenDTORecvTime = Nothing
  , sushiswapTokenDTOBlockNumber = Nothing
  , sushiswapTokenDTOId = Nothing
  , sushiswapTokenDTOFactory = Nothing
  , sushiswapTokenDTOSymbol = Nothing
  , sushiswapTokenDTOName = Nothing
  , sushiswapTokenDTODecimals = Nothing
  , sushiswapTokenDTOTotalSupply = Nothing
  , sushiswapTokenDTOVolume = Nothing
  , sushiswapTokenDTOVolumeUsd = Nothing
  , sushiswapTokenDTOUntrackedVolumeUsd = Nothing
  , sushiswapTokenDTOTxCount = Nothing
  , sushiswapTokenDTOLiquidity = Nothing
  , sushiswapTokenDTODerivedEth = Nothing
  , sushiswapTokenDTOWhitelistPairs = Nothing
  , sushiswapTokenDTOVid = Nothing
  , sushiswapTokenDTOTokenSymbol = Nothing
  }

-- ** SushiswapTokenDayDataDTO
-- | SushiswapTokenDayDataDTO
-- Token data aggregated across all pairs that include token.
data SushiswapTokenDayDataDTO = SushiswapTokenDayDataDTO
  { sushiswapTokenDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapTokenDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapTokenDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapTokenDayDataDTOId :: !(Maybe Text) -- ^ "id" - Identifier, day start timestamp in unix / 86400.
  , sushiswapTokenDayDataDTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , sushiswapTokenDayDataDTOToken :: !(Maybe Text) -- ^ "token" - Reference to token entity.
  , sushiswapTokenDayDataDTOVolume :: !(Maybe Text) -- ^ "volume" - Amount of token swapped across all pairs throughout day.
  , sushiswapTokenDayDataDTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
  , sushiswapTokenDayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
  , sushiswapTokenDayDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Amount of transactions with this token across all pairs.
  , sushiswapTokenDayDataDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Token amount of token deposited across all pairs.
  , sushiswapTokenDayDataDTOLiquidityEth :: !(Maybe Text) -- ^ "liquidity_eth" - Token amount of token deposited across all pairs stored as amount of ETH.
  , sushiswapTokenDayDataDTOLiquidityUsd :: !(Maybe Text) -- ^ "liquidity_usd" - Token amount of token deposited across all pairs stored as amount of USD.
  , sushiswapTokenDayDataDTOPriceUsd :: !(Maybe Text) -- ^ "price_usd" - Price of token in derived USD.
  , sushiswapTokenDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapTokenDayDataDTO
instance A.FromJSON SushiswapTokenDayDataDTO where
  parseJSON = A.withObject "SushiswapTokenDayDataDTO" $ \o ->
    SushiswapTokenDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "token")
      <*> (o .:? "volume")
      <*> (o .:? "volume_eth")
      <*> (o .:? "volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "liquidity")
      <*> (o .:? "liquidity_eth")
      <*> (o .:? "liquidity_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "vid")

-- | ToJSON SushiswapTokenDayDataDTO
instance A.ToJSON SushiswapTokenDayDataDTO where
  toJSON SushiswapTokenDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapTokenDayDataDTOEntryTime
      , "recv_time" .= sushiswapTokenDayDataDTORecvTime
      , "block_number" .= sushiswapTokenDayDataDTOBlockNumber
      , "id" .= sushiswapTokenDayDataDTOId
      , "date" .= sushiswapTokenDayDataDTODate
      , "token" .= sushiswapTokenDayDataDTOToken
      , "volume" .= sushiswapTokenDayDataDTOVolume
      , "volume_eth" .= sushiswapTokenDayDataDTOVolumeEth
      , "volume_usd" .= sushiswapTokenDayDataDTOVolumeUsd
      , "tx_count" .= sushiswapTokenDayDataDTOTxCount
      , "liquidity" .= sushiswapTokenDayDataDTOLiquidity
      , "liquidity_eth" .= sushiswapTokenDayDataDTOLiquidityEth
      , "liquidity_usd" .= sushiswapTokenDayDataDTOLiquidityUsd
      , "price_usd" .= sushiswapTokenDayDataDTOPriceUsd
      , "vid" .= sushiswapTokenDayDataDTOVid
      ]


-- | Construct a value of type 'SushiswapTokenDayDataDTO' (by applying it's required fields, if any)
mkSushiswapTokenDayDataDTO
  :: SushiswapTokenDayDataDTO
mkSushiswapTokenDayDataDTO =
  SushiswapTokenDayDataDTO
  { sushiswapTokenDayDataDTOEntryTime = Nothing
  , sushiswapTokenDayDataDTORecvTime = Nothing
  , sushiswapTokenDayDataDTOBlockNumber = Nothing
  , sushiswapTokenDayDataDTOId = Nothing
  , sushiswapTokenDayDataDTODate = Nothing
  , sushiswapTokenDayDataDTOToken = Nothing
  , sushiswapTokenDayDataDTOVolume = Nothing
  , sushiswapTokenDayDataDTOVolumeEth = Nothing
  , sushiswapTokenDayDataDTOVolumeUsd = Nothing
  , sushiswapTokenDayDataDTOTxCount = Nothing
  , sushiswapTokenDayDataDTOLiquidity = Nothing
  , sushiswapTokenDayDataDTOLiquidityEth = Nothing
  , sushiswapTokenDayDataDTOLiquidityUsd = Nothing
  , sushiswapTokenDayDataDTOPriceUsd = Nothing
  , sushiswapTokenDayDataDTOVid = Nothing
  }

-- ** SushiswapTransactionDTO
-- | SushiswapTransactionDTO
-- Transaction entities are created for each Ethereum transaction that contains an interaction within Sushiswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
data SushiswapTransactionDTO = SushiswapTransactionDTO
  { sushiswapTransactionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapTransactionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapTransactionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapTransactionDTOId :: !(Maybe Text) -- ^ "id" - Ethereum transaction hash.
  , sushiswapTransactionDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp.
  , sushiswapTransactionDTOMints :: !(Maybe [Text]) -- ^ "mints" - Array of Mint events within the transaction, 0 or greater.
  , sushiswapTransactionDTOBurns :: !(Maybe [Text]) -- ^ "burns" - Array of Burn events within transaction, 0 or greater.
  , sushiswapTransactionDTOSwaps :: !(Maybe [Text]) -- ^ "swaps" - Array of Swap events within transaction, 0 or greater.
  , sushiswapTransactionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapTransactionDTO
instance A.FromJSON SushiswapTransactionDTO where
  parseJSON = A.withObject "SushiswapTransactionDTO" $ \o ->
    SushiswapTransactionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "timestamp")
      <*> (o .:? "mints")
      <*> (o .:? "burns")
      <*> (o .:? "swaps")
      <*> (o .:? "vid")

-- | ToJSON SushiswapTransactionDTO
instance A.ToJSON SushiswapTransactionDTO where
  toJSON SushiswapTransactionDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapTransactionDTOEntryTime
      , "recv_time" .= sushiswapTransactionDTORecvTime
      , "block_number" .= sushiswapTransactionDTOBlockNumber
      , "id" .= sushiswapTransactionDTOId
      , "timestamp" .= sushiswapTransactionDTOTimestamp
      , "mints" .= sushiswapTransactionDTOMints
      , "burns" .= sushiswapTransactionDTOBurns
      , "swaps" .= sushiswapTransactionDTOSwaps
      , "vid" .= sushiswapTransactionDTOVid
      ]


-- | Construct a value of type 'SushiswapTransactionDTO' (by applying it's required fields, if any)
mkSushiswapTransactionDTO
  :: SushiswapTransactionDTO
mkSushiswapTransactionDTO =
  SushiswapTransactionDTO
  { sushiswapTransactionDTOEntryTime = Nothing
  , sushiswapTransactionDTORecvTime = Nothing
  , sushiswapTransactionDTOBlockNumber = Nothing
  , sushiswapTransactionDTOId = Nothing
  , sushiswapTransactionDTOTimestamp = Nothing
  , sushiswapTransactionDTOMints = Nothing
  , sushiswapTransactionDTOBurns = Nothing
  , sushiswapTransactionDTOSwaps = Nothing
  , sushiswapTransactionDTOVid = Nothing
  }

-- ** SushiswapUserDTO
-- | SushiswapUserDTO
data SushiswapUserDTO = SushiswapUserDTO
  { sushiswapUserDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , sushiswapUserDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , sushiswapUserDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , sushiswapUserDTOId :: !(Maybe Text) -- ^ "id" - User address.
  , sushiswapUserDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SushiswapUserDTO
instance A.FromJSON SushiswapUserDTO where
  parseJSON = A.withObject "SushiswapUserDTO" $ \o ->
    SushiswapUserDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "vid")

-- | ToJSON SushiswapUserDTO
instance A.ToJSON SushiswapUserDTO where
  toJSON SushiswapUserDTO {..} =
   _omitNulls
      [ "entry_time" .= sushiswapUserDTOEntryTime
      , "recv_time" .= sushiswapUserDTORecvTime
      , "block_number" .= sushiswapUserDTOBlockNumber
      , "id" .= sushiswapUserDTOId
      , "vid" .= sushiswapUserDTOVid
      ]


-- | Construct a value of type 'SushiswapUserDTO' (by applying it's required fields, if any)
mkSushiswapUserDTO
  :: SushiswapUserDTO
mkSushiswapUserDTO =
  SushiswapUserDTO
  { sushiswapUserDTOEntryTime = Nothing
  , sushiswapUserDTORecvTime = Nothing
  , sushiswapUserDTOBlockNumber = Nothing
  , sushiswapUserDTOId = Nothing
  , sushiswapUserDTOVid = Nothing
  }

-- ** UniswapV2BundleDTO
-- | UniswapV2BundleDTO
-- The Bundle is used as a global store of derived ETH price in USD. Because there is no guaranteed common base token across pairs, a global reference of USD price is useful for deriving other USD values. The Bundle entity stores an updated weighted average of ETH<->Stablecoin pair prices. This provides a strong estimate for the USD price of ETH.
data UniswapV2BundleDTO = UniswapV2BundleDTO
  { uniswapV2BundleDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2BundleDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2BundleDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2BundleDTOId :: !(Maybe Text) -- ^ "id" - Constant 1.
  , uniswapV2BundleDTOEthPrice :: !(Maybe Text) -- ^ "eth_price" - Derived price of ETH in USD based on stablecoin pairs.
  , uniswapV2BundleDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2BundleDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2BundleDTO
instance A.FromJSON UniswapV2BundleDTO where
  parseJSON = A.withObject "UniswapV2BundleDTO" $ \o ->
    UniswapV2BundleDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "eth_price")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON UniswapV2BundleDTO
instance A.ToJSON UniswapV2BundleDTO where
  toJSON UniswapV2BundleDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2BundleDTOEntryTime
      , "recv_time" .= uniswapV2BundleDTORecvTime
      , "block_number" .= uniswapV2BundleDTOBlockNumber
      , "id" .= uniswapV2BundleDTOId
      , "eth_price" .= uniswapV2BundleDTOEthPrice
      , "vid" .= uniswapV2BundleDTOVid
      , "block_range" .= uniswapV2BundleDTOBlockRange
      ]


-- | Construct a value of type 'UniswapV2BundleDTO' (by applying it's required fields, if any)
mkUniswapV2BundleDTO
  :: UniswapV2BundleDTO
mkUniswapV2BundleDTO =
  UniswapV2BundleDTO
  { uniswapV2BundleDTOEntryTime = Nothing
  , uniswapV2BundleDTORecvTime = Nothing
  , uniswapV2BundleDTOBlockNumber = Nothing
  , uniswapV2BundleDTOId = Nothing
  , uniswapV2BundleDTOEthPrice = Nothing
  , uniswapV2BundleDTOVid = Nothing
  , uniswapV2BundleDTOBlockRange = Nothing
  }

-- ** UniswapV2BurnDTO
-- | UniswapV2BurnDTO
-- Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
data UniswapV2BurnDTO = UniswapV2BurnDTO
  { uniswapV2BurnDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2BurnDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2BurnDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2BurnDTOId :: !(Maybe Text) -- ^ "id" - Transaction hash plus index in the transaction burn array
  , uniswapV2BurnDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to the transaction Burn was included in.
  , uniswapV2BurnDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of Burn, used to sort recent liquidity removals.
  , uniswapV2BurnDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , uniswapV2BurnDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Amount of liquidity tokens burned.
  , uniswapV2BurnDTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the liquidity removal.
  , uniswapV2BurnDTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token0 removed.
  , uniswapV2BurnDTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token1 removed.
  , uniswapV2BurnDTOTo :: !(Maybe Text) -- ^ "to" - Recipient of tokens.
  , uniswapV2BurnDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Index in the transaction event was emitted.
  , uniswapV2BurnDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived USD value of token0 amount plus token1 amount.
  , uniswapV2BurnDTONeedsComplete :: !(Maybe Bool) -- ^ "needs_complete" - 
  , uniswapV2BurnDTOFeeTo :: !(Maybe Text) -- ^ "fee_to" - Address of fee recipient (if fee is on).
  , uniswapV2BurnDTOFeeLiquidity :: !(Maybe Text) -- ^ "fee_liquidity" - Amount of tokens sent to fee recipient (if fee is on).
  , uniswapV2BurnDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2BurnDTO
instance A.FromJSON UniswapV2BurnDTO where
  parseJSON = A.withObject "UniswapV2BurnDTO" $ \o ->
    UniswapV2BurnDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "liquidity")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "to")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "needs_complete")
      <*> (o .:? "fee_to")
      <*> (o .:? "fee_liquidity")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2BurnDTO
instance A.ToJSON UniswapV2BurnDTO where
  toJSON UniswapV2BurnDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2BurnDTOEntryTime
      , "recv_time" .= uniswapV2BurnDTORecvTime
      , "block_number" .= uniswapV2BurnDTOBlockNumber
      , "id" .= uniswapV2BurnDTOId
      , "transaction" .= uniswapV2BurnDTOTransaction
      , "timestamp" .= uniswapV2BurnDTOTimestamp
      , "pair" .= uniswapV2BurnDTOPair
      , "liquidity" .= uniswapV2BurnDTOLiquidity
      , "sender" .= uniswapV2BurnDTOSender
      , "amount_0" .= uniswapV2BurnDTOAmount0
      , "amount_1" .= uniswapV2BurnDTOAmount1
      , "to" .= uniswapV2BurnDTOTo
      , "log_index" .= uniswapV2BurnDTOLogIndex
      , "amount_usd" .= uniswapV2BurnDTOAmountUsd
      , "needs_complete" .= uniswapV2BurnDTONeedsComplete
      , "fee_to" .= uniswapV2BurnDTOFeeTo
      , "fee_liquidity" .= uniswapV2BurnDTOFeeLiquidity
      , "vid" .= uniswapV2BurnDTOVid
      ]


-- | Construct a value of type 'UniswapV2BurnDTO' (by applying it's required fields, if any)
mkUniswapV2BurnDTO
  :: UniswapV2BurnDTO
mkUniswapV2BurnDTO =
  UniswapV2BurnDTO
  { uniswapV2BurnDTOEntryTime = Nothing
  , uniswapV2BurnDTORecvTime = Nothing
  , uniswapV2BurnDTOBlockNumber = Nothing
  , uniswapV2BurnDTOId = Nothing
  , uniswapV2BurnDTOTransaction = Nothing
  , uniswapV2BurnDTOTimestamp = Nothing
  , uniswapV2BurnDTOPair = Nothing
  , uniswapV2BurnDTOLiquidity = Nothing
  , uniswapV2BurnDTOSender = Nothing
  , uniswapV2BurnDTOAmount0 = Nothing
  , uniswapV2BurnDTOAmount1 = Nothing
  , uniswapV2BurnDTOTo = Nothing
  , uniswapV2BurnDTOLogIndex = Nothing
  , uniswapV2BurnDTOAmountUsd = Nothing
  , uniswapV2BurnDTONeedsComplete = Nothing
  , uniswapV2BurnDTOFeeTo = Nothing
  , uniswapV2BurnDTOFeeLiquidity = Nothing
  , uniswapV2BurnDTOVid = Nothing
  }

-- ** UniswapV2LiquidityPositionDTO
-- | UniswapV2LiquidityPositionDTO
-- This entity is used to store data about a user's liquidity position. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more.
data UniswapV2LiquidityPositionDTO = UniswapV2LiquidityPositionDTO
  { uniswapV2LiquidityPositionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2LiquidityPositionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2LiquidityPositionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2LiquidityPositionDTOId :: !(Maybe Text) -- ^ "id" - User address and pair address concatenated with a dash.
  , uniswapV2LiquidityPositionDTOUser :: !(Maybe Text) -- ^ "user" - Reference to user.
  , uniswapV2LiquidityPositionDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to the pair liquidity is being provided on.
  , uniswapV2LiquidityPositionDTOLiquidityTokenBalance :: !(Maybe Text) -- ^ "liquidity_token_balance" - Amount of LP tokens minted for this position.
  , uniswapV2LiquidityPositionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2LiquidityPositionDTO
instance A.FromJSON UniswapV2LiquidityPositionDTO where
  parseJSON = A.withObject "UniswapV2LiquidityPositionDTO" $ \o ->
    UniswapV2LiquidityPositionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "user")
      <*> (o .:? "pair")
      <*> (o .:? "liquidity_token_balance")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2LiquidityPositionDTO
instance A.ToJSON UniswapV2LiquidityPositionDTO where
  toJSON UniswapV2LiquidityPositionDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2LiquidityPositionDTOEntryTime
      , "recv_time" .= uniswapV2LiquidityPositionDTORecvTime
      , "block_number" .= uniswapV2LiquidityPositionDTOBlockNumber
      , "id" .= uniswapV2LiquidityPositionDTOId
      , "user" .= uniswapV2LiquidityPositionDTOUser
      , "pair" .= uniswapV2LiquidityPositionDTOPair
      , "liquidity_token_balance" .= uniswapV2LiquidityPositionDTOLiquidityTokenBalance
      , "vid" .= uniswapV2LiquidityPositionDTOVid
      ]


-- | Construct a value of type 'UniswapV2LiquidityPositionDTO' (by applying it's required fields, if any)
mkUniswapV2LiquidityPositionDTO
  :: UniswapV2LiquidityPositionDTO
mkUniswapV2LiquidityPositionDTO =
  UniswapV2LiquidityPositionDTO
  { uniswapV2LiquidityPositionDTOEntryTime = Nothing
  , uniswapV2LiquidityPositionDTORecvTime = Nothing
  , uniswapV2LiquidityPositionDTOBlockNumber = Nothing
  , uniswapV2LiquidityPositionDTOId = Nothing
  , uniswapV2LiquidityPositionDTOUser = Nothing
  , uniswapV2LiquidityPositionDTOPair = Nothing
  , uniswapV2LiquidityPositionDTOLiquidityTokenBalance = Nothing
  , uniswapV2LiquidityPositionDTOVid = Nothing
  }

-- ** UniswapV2LiquidityPositionSnapshotDTO
-- | UniswapV2LiquidityPositionSnapshotDTO
-- This entity is used to store data about a user's liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
data UniswapV2LiquidityPositionSnapshotDTO = UniswapV2LiquidityPositionSnapshotDTO
  { uniswapV2LiquidityPositionSnapshotDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2LiquidityPositionSnapshotDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2LiquidityPositionSnapshotDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2LiquidityPositionSnapshotDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (pair address)-(user address)
  , uniswapV2LiquidityPositionSnapshotDTOLiquidityPosition :: !(Maybe Text) -- ^ "liquidity_position" - Reference to LP identifier.
  , uniswapV2LiquidityPositionSnapshotDTOTimestamp :: !(Maybe Int) -- ^ "timestamp" - Creation time.
  , uniswapV2LiquidityPositionSnapshotDTOBlock :: !(Maybe Int) -- ^ "block" - Number of block in which LP snapshot was recorded.
  , uniswapV2LiquidityPositionSnapshotDTOUser :: !(Maybe Text) -- ^ "user" - Reference to user.
  , uniswapV2LiquidityPositionSnapshotDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to the pair liquidity is being provided on.
  , uniswapV2LiquidityPositionSnapshotDTOToken0PriceUsd :: !(Maybe Text) -- ^ "token_0_price_usd" - Snapshot of token0 price.
  , uniswapV2LiquidityPositionSnapshotDTOToken1PriceUsd :: !(Maybe Text) -- ^ "token_1_price_usd" - Snapshot of token0 price.
  , uniswapV2LiquidityPositionSnapshotDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Snapshot of pair token0 reserves.
  , uniswapV2LiquidityPositionSnapshotDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Snapshot of pair token1 reserves.
  , uniswapV2LiquidityPositionSnapshotDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Snapshot of pair reserves in USD.
  , uniswapV2LiquidityPositionSnapshotDTOLiquidityTokenTotalSupply :: !(Maybe Text) -- ^ "liquidity_token_total_supply" - Snapshot of pool token supply.
  , uniswapV2LiquidityPositionSnapshotDTOLiquidityTokenBalance :: !(Maybe Text) -- ^ "liquidity_token_balance" - Snapshot of users pool token balance.
  , uniswapV2LiquidityPositionSnapshotDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2LiquidityPositionSnapshotDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2LiquidityPositionSnapshotDTO
instance A.FromJSON UniswapV2LiquidityPositionSnapshotDTO where
  parseJSON = A.withObject "UniswapV2LiquidityPositionSnapshotDTO" $ \o ->
    UniswapV2LiquidityPositionSnapshotDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "liquidity_position")
      <*> (o .:? "timestamp")
      <*> (o .:? "block")
      <*> (o .:? "user")
      <*> (o .:? "pair")
      <*> (o .:? "token_0_price_usd")
      <*> (o .:? "token_1_price_usd")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "liquidity_token_total_supply")
      <*> (o .:? "liquidity_token_balance")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON UniswapV2LiquidityPositionSnapshotDTO
instance A.ToJSON UniswapV2LiquidityPositionSnapshotDTO where
  toJSON UniswapV2LiquidityPositionSnapshotDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2LiquidityPositionSnapshotDTOEntryTime
      , "recv_time" .= uniswapV2LiquidityPositionSnapshotDTORecvTime
      , "block_number" .= uniswapV2LiquidityPositionSnapshotDTOBlockNumber
      , "id" .= uniswapV2LiquidityPositionSnapshotDTOId
      , "liquidity_position" .= uniswapV2LiquidityPositionSnapshotDTOLiquidityPosition
      , "timestamp" .= uniswapV2LiquidityPositionSnapshotDTOTimestamp
      , "block" .= uniswapV2LiquidityPositionSnapshotDTOBlock
      , "user" .= uniswapV2LiquidityPositionSnapshotDTOUser
      , "pair" .= uniswapV2LiquidityPositionSnapshotDTOPair
      , "token_0_price_usd" .= uniswapV2LiquidityPositionSnapshotDTOToken0PriceUsd
      , "token_1_price_usd" .= uniswapV2LiquidityPositionSnapshotDTOToken1PriceUsd
      , "reserve_0" .= uniswapV2LiquidityPositionSnapshotDTOReserve0
      , "reserve_1" .= uniswapV2LiquidityPositionSnapshotDTOReserve1
      , "reserve_usd" .= uniswapV2LiquidityPositionSnapshotDTOReserveUsd
      , "liquidity_token_total_supply" .= uniswapV2LiquidityPositionSnapshotDTOLiquidityTokenTotalSupply
      , "liquidity_token_balance" .= uniswapV2LiquidityPositionSnapshotDTOLiquidityTokenBalance
      , "vid" .= uniswapV2LiquidityPositionSnapshotDTOVid
      , "block_range" .= uniswapV2LiquidityPositionSnapshotDTOBlockRange
      ]


-- | Construct a value of type 'UniswapV2LiquidityPositionSnapshotDTO' (by applying it's required fields, if any)
mkUniswapV2LiquidityPositionSnapshotDTO
  :: UniswapV2LiquidityPositionSnapshotDTO
mkUniswapV2LiquidityPositionSnapshotDTO =
  UniswapV2LiquidityPositionSnapshotDTO
  { uniswapV2LiquidityPositionSnapshotDTOEntryTime = Nothing
  , uniswapV2LiquidityPositionSnapshotDTORecvTime = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOBlockNumber = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOId = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOLiquidityPosition = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOTimestamp = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOBlock = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOUser = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOPair = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOToken0PriceUsd = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOToken1PriceUsd = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOReserve0 = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOReserve1 = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOReserveUsd = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOLiquidityTokenTotalSupply = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOLiquidityTokenBalance = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOVid = Nothing
  , uniswapV2LiquidityPositionSnapshotDTOBlockRange = Nothing
  }

-- ** UniswapV2MintDTO
-- | UniswapV2MintDTO
-- Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
data UniswapV2MintDTO = UniswapV2MintDTO
  { uniswapV2MintDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2MintDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2MintDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2MintDTOId :: !(Maybe Text) -- ^ "id" - Transaction hash plus index in the transaction mint array.
  , uniswapV2MintDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to the transaction Mint was included in.
  , uniswapV2MintDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of Mint, used to sort recent liquidity provisions.
  , uniswapV2MintDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , uniswapV2MintDTOTo :: !(Maybe Text) -- ^ "to" - Recipient of liquidity tokens.
  , uniswapV2MintDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Amount of liquidity tokens minted.
  , uniswapV2MintDTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the liquidity provision.
  , uniswapV2MintDTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token0 provided.
  , uniswapV2MintDTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token1 provided.
  , uniswapV2MintDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Index in the transaction event was emitted.
  , uniswapV2MintDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived USD value of token0 amount plus token1 amount.
  , uniswapV2MintDTOFeeTo :: !(Maybe Text) -- ^ "fee_to" - Address of fee recipient (if fee is on).
  , uniswapV2MintDTOFeeLiquidity :: !(Maybe Text) -- ^ "fee_liquidity" - Amount of liquidity sent to fee recipient (if fee is on).
  , uniswapV2MintDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2MintDTOBlockRange :: !(Maybe Text) -- ^ "block_range" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2MintDTO
instance A.FromJSON UniswapV2MintDTO where
  parseJSON = A.withObject "UniswapV2MintDTO" $ \o ->
    UniswapV2MintDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "to")
      <*> (o .:? "liquidity")
      <*> (o .:? "sender")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "fee_to")
      <*> (o .:? "fee_liquidity")
      <*> (o .:? "vid")
      <*> (o .:? "block_range")

-- | ToJSON UniswapV2MintDTO
instance A.ToJSON UniswapV2MintDTO where
  toJSON UniswapV2MintDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2MintDTOEntryTime
      , "recv_time" .= uniswapV2MintDTORecvTime
      , "block_number" .= uniswapV2MintDTOBlockNumber
      , "id" .= uniswapV2MintDTOId
      , "transaction" .= uniswapV2MintDTOTransaction
      , "timestamp" .= uniswapV2MintDTOTimestamp
      , "pair" .= uniswapV2MintDTOPair
      , "to" .= uniswapV2MintDTOTo
      , "liquidity" .= uniswapV2MintDTOLiquidity
      , "sender" .= uniswapV2MintDTOSender
      , "amount_0" .= uniswapV2MintDTOAmount0
      , "amount_1" .= uniswapV2MintDTOAmount1
      , "log_index" .= uniswapV2MintDTOLogIndex
      , "amount_usd" .= uniswapV2MintDTOAmountUsd
      , "fee_to" .= uniswapV2MintDTOFeeTo
      , "fee_liquidity" .= uniswapV2MintDTOFeeLiquidity
      , "vid" .= uniswapV2MintDTOVid
      , "block_range" .= uniswapV2MintDTOBlockRange
      ]


-- | Construct a value of type 'UniswapV2MintDTO' (by applying it's required fields, if any)
mkUniswapV2MintDTO
  :: UniswapV2MintDTO
mkUniswapV2MintDTO =
  UniswapV2MintDTO
  { uniswapV2MintDTOEntryTime = Nothing
  , uniswapV2MintDTORecvTime = Nothing
  , uniswapV2MintDTOBlockNumber = Nothing
  , uniswapV2MintDTOId = Nothing
  , uniswapV2MintDTOTransaction = Nothing
  , uniswapV2MintDTOTimestamp = Nothing
  , uniswapV2MintDTOPair = Nothing
  , uniswapV2MintDTOTo = Nothing
  , uniswapV2MintDTOLiquidity = Nothing
  , uniswapV2MintDTOSender = Nothing
  , uniswapV2MintDTOAmount0 = Nothing
  , uniswapV2MintDTOAmount1 = Nothing
  , uniswapV2MintDTOLogIndex = Nothing
  , uniswapV2MintDTOAmountUsd = Nothing
  , uniswapV2MintDTOFeeTo = Nothing
  , uniswapV2MintDTOFeeLiquidity = Nothing
  , uniswapV2MintDTOVid = Nothing
  , uniswapV2MintDTOBlockRange = Nothing
  }

-- ** UniswapV2PairDTO
-- | UniswapV2PairDTO
-- Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
data UniswapV2PairDTO = UniswapV2PairDTO
  { uniswapV2PairDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2PairDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2PairDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2PairDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2PairDTOId :: !(Maybe Text) -- ^ "id" - Pair contract address.
  , uniswapV2PairDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pair contract.
  , uniswapV2PairDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pair contract.
  , uniswapV2PairDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0.
  , uniswapV2PairDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1.
  , uniswapV2PairDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token distributed to LPs.
  , uniswapV2PairDTOReserveEth :: !(Maybe Text) -- ^ "reserve_eth" - Total liquidity in pair stored as an amount of ETH.
  , uniswapV2PairDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Total liquidity amount in pair stored as an amount of USD.
  , uniswapV2PairDTOTrackedReserveEth :: !(Maybe Text) -- ^ "tracked_reserve_eth" - Total liquidity with only tracked amount.
  , uniswapV2PairDTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - Token0 per token1.
  , uniswapV2PairDTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - Token1 per token0.
  , uniswapV2PairDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Amount of token0 swapped on this pair.
  , uniswapV2PairDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Amount of token1 swapped on this pair.
  , uniswapV2PairDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
  , uniswapV2PairDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
  , uniswapV2PairDTOTxCount :: !(Maybe NumericsBigInteger) -- ^ "tx_count"
  , uniswapV2PairDTOCreatedAtTimestamp :: !(Maybe DateTime) -- ^ "created_at_timestamp" - Timestamp contract was created.
  , uniswapV2PairDTOLiquidityProviderCount :: !(Maybe Text) -- ^ "liquidity_provider_count" - Total number of LPs.
  , uniswapV2PairDTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2PairDTO
instance A.FromJSON UniswapV2PairDTO where
  parseJSON = A.withObject "UniswapV2PairDTO" $ \o ->
    UniswapV2PairDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_eth")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "tracked_reserve_eth")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "created_at_timestamp")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "evaluated_ask")

-- | ToJSON UniswapV2PairDTO
instance A.ToJSON UniswapV2PairDTO where
  toJSON UniswapV2PairDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2PairDTOEntryTime
      , "recv_time" .= uniswapV2PairDTORecvTime
      , "block_number" .= uniswapV2PairDTOBlockNumber
      , "vid" .= uniswapV2PairDTOVid
      , "id" .= uniswapV2PairDTOId
      , "token_0" .= uniswapV2PairDTOToken0
      , "token_1" .= uniswapV2PairDTOToken1
      , "reserve_0" .= uniswapV2PairDTOReserve0
      , "reserve_1" .= uniswapV2PairDTOReserve1
      , "total_supply" .= uniswapV2PairDTOTotalSupply
      , "reserve_eth" .= uniswapV2PairDTOReserveEth
      , "reserve_usd" .= uniswapV2PairDTOReserveUsd
      , "tracked_reserve_eth" .= uniswapV2PairDTOTrackedReserveEth
      , "token_0_price" .= uniswapV2PairDTOToken0Price
      , "token_1_price" .= uniswapV2PairDTOToken1Price
      , "volume_token_0" .= uniswapV2PairDTOVolumeToken0
      , "volume_token_1" .= uniswapV2PairDTOVolumeToken1
      , "volume_usd" .= uniswapV2PairDTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV2PairDTOUntrackedVolumeUsd
      , "tx_count" .= uniswapV2PairDTOTxCount
      , "created_at_timestamp" .= uniswapV2PairDTOCreatedAtTimestamp
      , "liquidity_provider_count" .= uniswapV2PairDTOLiquidityProviderCount
      , "evaluated_ask" .= uniswapV2PairDTOEvaluatedAsk
      ]


-- | Construct a value of type 'UniswapV2PairDTO' (by applying it's required fields, if any)
mkUniswapV2PairDTO
  :: UniswapV2PairDTO
mkUniswapV2PairDTO =
  UniswapV2PairDTO
  { uniswapV2PairDTOEntryTime = Nothing
  , uniswapV2PairDTORecvTime = Nothing
  , uniswapV2PairDTOBlockNumber = Nothing
  , uniswapV2PairDTOVid = Nothing
  , uniswapV2PairDTOId = Nothing
  , uniswapV2PairDTOToken0 = Nothing
  , uniswapV2PairDTOToken1 = Nothing
  , uniswapV2PairDTOReserve0 = Nothing
  , uniswapV2PairDTOReserve1 = Nothing
  , uniswapV2PairDTOTotalSupply = Nothing
  , uniswapV2PairDTOReserveEth = Nothing
  , uniswapV2PairDTOReserveUsd = Nothing
  , uniswapV2PairDTOTrackedReserveEth = Nothing
  , uniswapV2PairDTOToken0Price = Nothing
  , uniswapV2PairDTOToken1Price = Nothing
  , uniswapV2PairDTOVolumeToken0 = Nothing
  , uniswapV2PairDTOVolumeToken1 = Nothing
  , uniswapV2PairDTOVolumeUsd = Nothing
  , uniswapV2PairDTOUntrackedVolumeUsd = Nothing
  , uniswapV2PairDTOTxCount = Nothing
  , uniswapV2PairDTOCreatedAtTimestamp = Nothing
  , uniswapV2PairDTOLiquidityProviderCount = Nothing
  , uniswapV2PairDTOEvaluatedAsk = Nothing
  }

-- ** UniswapV2PairDayDataDTO
-- | UniswapV2PairDayDataDTO
-- Tracks pair data across each day.
data UniswapV2PairDayDataDTO = UniswapV2PairDayDataDTO
  { uniswapV2PairDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2PairDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2PairDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2PairDayDataDTOId :: !(Maybe Text) -- ^ "id" - 
  , uniswapV2PairDayDataDTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , uniswapV2PairDayDataDTOPairAddress :: !(Maybe Text) -- ^ "pair_address" - Address for pair contract.
  , uniswapV2PairDayDataDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0.
  , uniswapV2PairDayDataDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1.
  , uniswapV2PairDayDataDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0 (updated during each transaction on pair).
  , uniswapV2PairDayDataDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1 (updated during each transaction on pair).
  , uniswapV2PairDayDataDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token distributed to LPs.
  , uniswapV2PairDayDataDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Reserve of token0 plus token1 stored as a derived USD amount.
  , uniswapV2PairDayDataDTODailyVolumeToken0 :: !(Maybe Text) -- ^ "daily_volume_token_0" - Total amount of token0 swapped throughout day.
  , uniswapV2PairDayDataDTODailyVolumeToken1 :: !(Maybe Text) -- ^ "daily_volume_token_1" - Total amount of token1 swapped throughout day.
  , uniswapV2PairDayDataDTODailyVolumeUsd :: !(Maybe Text) -- ^ "daily_volume_usd" - Total volume within pair throughout day.
  , uniswapV2PairDayDataDTODailyTxns :: !(Maybe Text) -- ^ "daily_txns" - Amount of transactions on pair throughout day.
  , uniswapV2PairDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2PairDayDataDTO
instance A.FromJSON UniswapV2PairDayDataDTO where
  parseJSON = A.withObject "UniswapV2PairDayDataDTO" $ \o ->
    UniswapV2PairDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pair_address")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "daily_volume_token_0")
      <*> (o .:? "daily_volume_token_1")
      <*> (o .:? "daily_volume_usd")
      <*> (o .:? "daily_txns")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2PairDayDataDTO
instance A.ToJSON UniswapV2PairDayDataDTO where
  toJSON UniswapV2PairDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2PairDayDataDTOEntryTime
      , "recv_time" .= uniswapV2PairDayDataDTORecvTime
      , "block_number" .= uniswapV2PairDayDataDTOBlockNumber
      , "id" .= uniswapV2PairDayDataDTOId
      , "date" .= uniswapV2PairDayDataDTODate
      , "pair_address" .= uniswapV2PairDayDataDTOPairAddress
      , "token_0" .= uniswapV2PairDayDataDTOToken0
      , "token_1" .= uniswapV2PairDayDataDTOToken1
      , "reserve_0" .= uniswapV2PairDayDataDTOReserve0
      , "reserve_1" .= uniswapV2PairDayDataDTOReserve1
      , "total_supply" .= uniswapV2PairDayDataDTOTotalSupply
      , "reserve_usd" .= uniswapV2PairDayDataDTOReserveUsd
      , "daily_volume_token_0" .= uniswapV2PairDayDataDTODailyVolumeToken0
      , "daily_volume_token_1" .= uniswapV2PairDayDataDTODailyVolumeToken1
      , "daily_volume_usd" .= uniswapV2PairDayDataDTODailyVolumeUsd
      , "daily_txns" .= uniswapV2PairDayDataDTODailyTxns
      , "vid" .= uniswapV2PairDayDataDTOVid
      ]


-- | Construct a value of type 'UniswapV2PairDayDataDTO' (by applying it's required fields, if any)
mkUniswapV2PairDayDataDTO
  :: UniswapV2PairDayDataDTO
mkUniswapV2PairDayDataDTO =
  UniswapV2PairDayDataDTO
  { uniswapV2PairDayDataDTOEntryTime = Nothing
  , uniswapV2PairDayDataDTORecvTime = Nothing
  , uniswapV2PairDayDataDTOBlockNumber = Nothing
  , uniswapV2PairDayDataDTOId = Nothing
  , uniswapV2PairDayDataDTODate = Nothing
  , uniswapV2PairDayDataDTOPairAddress = Nothing
  , uniswapV2PairDayDataDTOToken0 = Nothing
  , uniswapV2PairDayDataDTOToken1 = Nothing
  , uniswapV2PairDayDataDTOReserve0 = Nothing
  , uniswapV2PairDayDataDTOReserve1 = Nothing
  , uniswapV2PairDayDataDTOTotalSupply = Nothing
  , uniswapV2PairDayDataDTOReserveUsd = Nothing
  , uniswapV2PairDayDataDTODailyVolumeToken0 = Nothing
  , uniswapV2PairDayDataDTODailyVolumeToken1 = Nothing
  , uniswapV2PairDayDataDTODailyVolumeUsd = Nothing
  , uniswapV2PairDayDataDTODailyTxns = Nothing
  , uniswapV2PairDayDataDTOVid = Nothing
  }

-- ** UniswapV2PairHourDataDTO
-- | UniswapV2PairHourDataDTO
-- Tracks pair data across each hour.
data UniswapV2PairHourDataDTO = UniswapV2PairHourDataDTO
  { uniswapV2PairHourDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2PairHourDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2PairHourDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2PairHourDataDTOId :: !(Maybe Text) -- ^ "id" - 
  , uniswapV2PairHourDataDTOHourStartUnix :: !(Maybe Int) -- ^ "hour_start_unix" - Unix timestamp for start of hour.
  , uniswapV2PairHourDataDTOPair :: !(Maybe Text) -- ^ "pair" - Address for pair contract.
  , uniswapV2PairHourDataDTOReserve0 :: !(Maybe Text) -- ^ "reserve_0" - Reserve of token0 (updated during each transaction on pair).
  , uniswapV2PairHourDataDTOReserve1 :: !(Maybe Text) -- ^ "reserve_1" - Reserve of token1 (updated during each transaction on pair).
  , uniswapV2PairHourDataDTOTotalSupply :: !(Maybe Text) -- ^ "total_supply" - Total supply of liquidity token distributed to LPs.
  , uniswapV2PairHourDataDTOReserveUsd :: !(Maybe Text) -- ^ "reserve_usd" - Reserve of token0 plus token1 stored as a derived USD amount.
  , uniswapV2PairHourDataDTOHourlyVolumeToken0 :: !(Maybe Text) -- ^ "hourly_volume_token_0" - Total amount of token0 swapped throughout hour.
  , uniswapV2PairHourDataDTOHourlyVolumeToken1 :: !(Maybe Text) -- ^ "hourly_volume_token_1" - Total amount of token1 swapped throughout hour.
  , uniswapV2PairHourDataDTOHourlyVolumeUsd :: !(Maybe Text) -- ^ "hourly_volume_usd" - Total volume within pair throughout hour.
  , uniswapV2PairHourDataDTOHourlyTxns :: !(Maybe Text) -- ^ "hourly_txns" - Amount of transactions on pair throughout hour.
  , uniswapV2PairHourDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2PairHourDataDTO
instance A.FromJSON UniswapV2PairHourDataDTO where
  parseJSON = A.withObject "UniswapV2PairHourDataDTO" $ \o ->
    UniswapV2PairHourDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "hour_start_unix")
      <*> (o .:? "pair")
      <*> (o .:? "reserve_0")
      <*> (o .:? "reserve_1")
      <*> (o .:? "total_supply")
      <*> (o .:? "reserve_usd")
      <*> (o .:? "hourly_volume_token_0")
      <*> (o .:? "hourly_volume_token_1")
      <*> (o .:? "hourly_volume_usd")
      <*> (o .:? "hourly_txns")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2PairHourDataDTO
instance A.ToJSON UniswapV2PairHourDataDTO where
  toJSON UniswapV2PairHourDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2PairHourDataDTOEntryTime
      , "recv_time" .= uniswapV2PairHourDataDTORecvTime
      , "block_number" .= uniswapV2PairHourDataDTOBlockNumber
      , "id" .= uniswapV2PairHourDataDTOId
      , "hour_start_unix" .= uniswapV2PairHourDataDTOHourStartUnix
      , "pair" .= uniswapV2PairHourDataDTOPair
      , "reserve_0" .= uniswapV2PairHourDataDTOReserve0
      , "reserve_1" .= uniswapV2PairHourDataDTOReserve1
      , "total_supply" .= uniswapV2PairHourDataDTOTotalSupply
      , "reserve_usd" .= uniswapV2PairHourDataDTOReserveUsd
      , "hourly_volume_token_0" .= uniswapV2PairHourDataDTOHourlyVolumeToken0
      , "hourly_volume_token_1" .= uniswapV2PairHourDataDTOHourlyVolumeToken1
      , "hourly_volume_usd" .= uniswapV2PairHourDataDTOHourlyVolumeUsd
      , "hourly_txns" .= uniswapV2PairHourDataDTOHourlyTxns
      , "vid" .= uniswapV2PairHourDataDTOVid
      ]


-- | Construct a value of type 'UniswapV2PairHourDataDTO' (by applying it's required fields, if any)
mkUniswapV2PairHourDataDTO
  :: UniswapV2PairHourDataDTO
mkUniswapV2PairHourDataDTO =
  UniswapV2PairHourDataDTO
  { uniswapV2PairHourDataDTOEntryTime = Nothing
  , uniswapV2PairHourDataDTORecvTime = Nothing
  , uniswapV2PairHourDataDTOBlockNumber = Nothing
  , uniswapV2PairHourDataDTOId = Nothing
  , uniswapV2PairHourDataDTOHourStartUnix = Nothing
  , uniswapV2PairHourDataDTOPair = Nothing
  , uniswapV2PairHourDataDTOReserve0 = Nothing
  , uniswapV2PairHourDataDTOReserve1 = Nothing
  , uniswapV2PairHourDataDTOTotalSupply = Nothing
  , uniswapV2PairHourDataDTOReserveUsd = Nothing
  , uniswapV2PairHourDataDTOHourlyVolumeToken0 = Nothing
  , uniswapV2PairHourDataDTOHourlyVolumeToken1 = Nothing
  , uniswapV2PairHourDataDTOHourlyVolumeUsd = Nothing
  , uniswapV2PairHourDataDTOHourlyTxns = Nothing
  , uniswapV2PairHourDataDTOVid = Nothing
  }

-- ** UniswapV2SwapDTO
-- | UniswapV2SwapDTO
-- Swap are created for each token swap within a pair.
data UniswapV2SwapDTO = UniswapV2SwapDTO
  { uniswapV2SwapDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2SwapDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2SwapDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2SwapDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2SwapDTOId :: !(Maybe Text) -- ^ "id" - Transaction hash plus index in Transaction swap array.
  , uniswapV2SwapDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Reference to transaction swap was included in.
  , uniswapV2SwapDTOTimestamp :: !(Maybe DateTime) -- ^ "timestamp" - Timestamp of swap, used for sorted lookups.
  , uniswapV2SwapDTOPair :: !(Maybe Text) -- ^ "pair" - Reference to pair.
  , uniswapV2SwapDTOSender :: !(Maybe Text) -- ^ "sender" - Address that initiated the swap.
  , uniswapV2SwapDTOFrom :: !(Maybe Text) -- ^ "from" - The EOA (Externally Owned Account) that initiated the transaction.
  , uniswapV2SwapDTOAmount0In :: !(Maybe Text) -- ^ "amount_0_in" - Amount of token0 sold.
  , uniswapV2SwapDTOAmount1In :: !(Maybe Text) -- ^ "amount_1_in" - Amount of token1 sold.
  , uniswapV2SwapDTOAmount0Out :: !(Maybe Text) -- ^ "amount_0_out" - Amount of token0 received.
  , uniswapV2SwapDTOAmount1Out :: !(Maybe Text) -- ^ "amount_1_out" - Amount of token1 received.
  , uniswapV2SwapDTOTo :: !(Maybe Text) -- ^ "to" - Recipient of output tokens.
  , uniswapV2SwapDTOLogIndex :: !(Maybe NumericsBigInteger) -- ^ "log_index"
  , uniswapV2SwapDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount of tokens sold in USD.
  , uniswapV2SwapDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , uniswapV2SwapDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , uniswapV2SwapDTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  , uniswapV2SwapDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , uniswapV2SwapDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2SwapDTO
instance A.FromJSON UniswapV2SwapDTO where
  parseJSON = A.withObject "UniswapV2SwapDTO" $ \o ->
    UniswapV2SwapDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pair")
      <*> (o .:? "sender")
      <*> (o .:? "from")
      <*> (o .:? "amount_0_in")
      <*> (o .:? "amount_1_in")
      <*> (o .:? "amount_0_out")
      <*> (o .:? "amount_1_out")
      <*> (o .:? "to")
      <*> (o .:? "log_index")
      <*> (o .:? "amount_usd")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")

-- | ToJSON UniswapV2SwapDTO
instance A.ToJSON UniswapV2SwapDTO where
  toJSON UniswapV2SwapDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2SwapDTOEntryTime
      , "recv_time" .= uniswapV2SwapDTORecvTime
      , "block_number" .= uniswapV2SwapDTOBlockNumber
      , "vid" .= uniswapV2SwapDTOVid
      , "id" .= uniswapV2SwapDTOId
      , "transaction" .= uniswapV2SwapDTOTransaction
      , "timestamp" .= uniswapV2SwapDTOTimestamp
      , "pair" .= uniswapV2SwapDTOPair
      , "sender" .= uniswapV2SwapDTOSender
      , "from" .= uniswapV2SwapDTOFrom
      , "amount_0_in" .= uniswapV2SwapDTOAmount0In
      , "amount_1_in" .= uniswapV2SwapDTOAmount1In
      , "amount_0_out" .= uniswapV2SwapDTOAmount0Out
      , "amount_1_out" .= uniswapV2SwapDTOAmount1Out
      , "to" .= uniswapV2SwapDTOTo
      , "log_index" .= uniswapV2SwapDTOLogIndex
      , "amount_usd" .= uniswapV2SwapDTOAmountUsd
      , "evaluated_price" .= uniswapV2SwapDTOEvaluatedPrice
      , "evaluated_amount" .= uniswapV2SwapDTOEvaluatedAmount
      , "evaluated_aggressor" .= uniswapV2SwapDTOEvaluatedAggressor
      , "pool_id" .= uniswapV2SwapDTOPoolId
      , "transaction_id" .= uniswapV2SwapDTOTransactionId
      ]


-- | Construct a value of type 'UniswapV2SwapDTO' (by applying it's required fields, if any)
mkUniswapV2SwapDTO
  :: UniswapV2SwapDTO
mkUniswapV2SwapDTO =
  UniswapV2SwapDTO
  { uniswapV2SwapDTOEntryTime = Nothing
  , uniswapV2SwapDTORecvTime = Nothing
  , uniswapV2SwapDTOBlockNumber = Nothing
  , uniswapV2SwapDTOVid = Nothing
  , uniswapV2SwapDTOId = Nothing
  , uniswapV2SwapDTOTransaction = Nothing
  , uniswapV2SwapDTOTimestamp = Nothing
  , uniswapV2SwapDTOPair = Nothing
  , uniswapV2SwapDTOSender = Nothing
  , uniswapV2SwapDTOFrom = Nothing
  , uniswapV2SwapDTOAmount0In = Nothing
  , uniswapV2SwapDTOAmount1In = Nothing
  , uniswapV2SwapDTOAmount0Out = Nothing
  , uniswapV2SwapDTOAmount1Out = Nothing
  , uniswapV2SwapDTOTo = Nothing
  , uniswapV2SwapDTOLogIndex = Nothing
  , uniswapV2SwapDTOAmountUsd = Nothing
  , uniswapV2SwapDTOEvaluatedPrice = Nothing
  , uniswapV2SwapDTOEvaluatedAmount = Nothing
  , uniswapV2SwapDTOEvaluatedAggressor = Nothing
  , uniswapV2SwapDTOPoolId = Nothing
  , uniswapV2SwapDTOTransactionId = Nothing
  }

-- ** UniswapV2TokenDTO
-- | UniswapV2TokenDTO
-- Stores aggregated information for a specific token across all pairs that token is included in.
data UniswapV2TokenDTO = UniswapV2TokenDTO
  { uniswapV2TokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2TokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2TokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2TokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV2TokenDTOId :: !(Maybe Text) -- ^ "id" - Token address.
  , uniswapV2TokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - Token symbol.
  , uniswapV2TokenDTOName :: !(Maybe Text) -- ^ "name" - Token name.
  , uniswapV2TokenDTODecimals :: !(Maybe Int) -- ^ "decimals" - Token decimals.
  , uniswapV2TokenDTOTotalSupply :: !(Maybe NumericsBigInteger) -- ^ "total_supply"
  , uniswapV2TokenDTOTradeVolume :: !(Maybe Text) -- ^ "trade_volume" - Amount of token traded all time across all pairs.
  , uniswapV2TokenDTOTradeVolumeUsd :: !(Maybe Text) -- ^ "trade_volume_usd" - Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
  , uniswapV2TokenDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
  , uniswapV2TokenDTOTxCount :: !(Maybe NumericsBigInteger) -- ^ "tx_count"
  , uniswapV2TokenDTOTotalLiquidity :: !(Maybe Text) -- ^ "total_liquidity" - Total amount of token provided as liquidity across all pairs.
  , uniswapV2TokenDTODerivedEth :: !(Maybe Text) -- ^ "derived_eth" - ETH per token.
  , uniswapV2TokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2TokenDTO
instance A.FromJSON UniswapV2TokenDTO where
  parseJSON = A.withObject "UniswapV2TokenDTO" $ \o ->
    UniswapV2TokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "symbol")
      <*> (o .:? "name")
      <*> (o .:? "decimals")
      <*> (o .:? "total_supply")
      <*> (o .:? "trade_volume")
      <*> (o .:? "trade_volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "total_liquidity")
      <*> (o .:? "derived_eth")
      <*> (o .:? "token_symbol")

-- | ToJSON UniswapV2TokenDTO
instance A.ToJSON UniswapV2TokenDTO where
  toJSON UniswapV2TokenDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2TokenDTOEntryTime
      , "recv_time" .= uniswapV2TokenDTORecvTime
      , "block_number" .= uniswapV2TokenDTOBlockNumber
      , "vid" .= uniswapV2TokenDTOVid
      , "id" .= uniswapV2TokenDTOId
      , "symbol" .= uniswapV2TokenDTOSymbol
      , "name" .= uniswapV2TokenDTOName
      , "decimals" .= uniswapV2TokenDTODecimals
      , "total_supply" .= uniswapV2TokenDTOTotalSupply
      , "trade_volume" .= uniswapV2TokenDTOTradeVolume
      , "trade_volume_usd" .= uniswapV2TokenDTOTradeVolumeUsd
      , "untracked_volume_usd" .= uniswapV2TokenDTOUntrackedVolumeUsd
      , "tx_count" .= uniswapV2TokenDTOTxCount
      , "total_liquidity" .= uniswapV2TokenDTOTotalLiquidity
      , "derived_eth" .= uniswapV2TokenDTODerivedEth
      , "token_symbol" .= uniswapV2TokenDTOTokenSymbol
      ]


-- | Construct a value of type 'UniswapV2TokenDTO' (by applying it's required fields, if any)
mkUniswapV2TokenDTO
  :: UniswapV2TokenDTO
mkUniswapV2TokenDTO =
  UniswapV2TokenDTO
  { uniswapV2TokenDTOEntryTime = Nothing
  , uniswapV2TokenDTORecvTime = Nothing
  , uniswapV2TokenDTOBlockNumber = Nothing
  , uniswapV2TokenDTOVid = Nothing
  , uniswapV2TokenDTOId = Nothing
  , uniswapV2TokenDTOSymbol = Nothing
  , uniswapV2TokenDTOName = Nothing
  , uniswapV2TokenDTODecimals = Nothing
  , uniswapV2TokenDTOTotalSupply = Nothing
  , uniswapV2TokenDTOTradeVolume = Nothing
  , uniswapV2TokenDTOTradeVolumeUsd = Nothing
  , uniswapV2TokenDTOUntrackedVolumeUsd = Nothing
  , uniswapV2TokenDTOTxCount = Nothing
  , uniswapV2TokenDTOTotalLiquidity = Nothing
  , uniswapV2TokenDTODerivedEth = Nothing
  , uniswapV2TokenDTOTokenSymbol = Nothing
  }

-- ** UniswapV2TokenDayDataDTO
-- | UniswapV2TokenDayDataDTO
-- Token data aggregated across all pairs that include token.
data UniswapV2TokenDayDataDTO = UniswapV2TokenDayDataDTO
  { uniswapV2TokenDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2TokenDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2TokenDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2TokenDayDataDTOId :: !(Maybe Text) -- ^ "id" - Token address and day id (day start timestamp in unix / 86400) concatenated with a dash.
  , uniswapV2TokenDayDataDTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , uniswapV2TokenDayDataDTOToken :: !(Maybe Text) -- ^ "token" - Reference to token entity.
  , uniswapV2TokenDayDataDTODailyVolumeToken :: !(Maybe Text) -- ^ "daily_volume_token" - Amount of token swapped across all pairs throughout day.
  , uniswapV2TokenDayDataDTODailyVolumeEth :: !(Maybe Text) -- ^ "daily_volume_eth" - Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
  , uniswapV2TokenDayDataDTODailyVolumeUsd :: !(Maybe Text) -- ^ "daily_volume_usd" - Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
  , uniswapV2TokenDayDataDTODailyTxns :: !(Maybe Text) -- ^ "daily_txns" - Amount of transactions with this token across all pairs.
  , uniswapV2TokenDayDataDTOTotalLiquidityToken :: !(Maybe Text) -- ^ "total_liquidity_token" - Token amount of token deposited across all pairs.
  , uniswapV2TokenDayDataDTOTotalLiquidityEth :: !(Maybe Text) -- ^ "total_liquidity_eth" - Token amount of token deposited across all pairs stored as amount of ETH.
  , uniswapV2TokenDayDataDTOTotalLiquidityUsd :: !(Maybe Text) -- ^ "total_liquidity_usd" - Token amount of token deposited across all pairs stored as amount of USD.
  , uniswapV2TokenDayDataDTOPriceUsd :: !(Maybe Text) -- ^ "price_usd" - Price of token in derived USD.
  , uniswapV2TokenDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2TokenDayDataDTO
instance A.FromJSON UniswapV2TokenDayDataDTO where
  parseJSON = A.withObject "UniswapV2TokenDayDataDTO" $ \o ->
    UniswapV2TokenDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "token")
      <*> (o .:? "daily_volume_token")
      <*> (o .:? "daily_volume_eth")
      <*> (o .:? "daily_volume_usd")
      <*> (o .:? "daily_txns")
      <*> (o .:? "total_liquidity_token")
      <*> (o .:? "total_liquidity_eth")
      <*> (o .:? "total_liquidity_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2TokenDayDataDTO
instance A.ToJSON UniswapV2TokenDayDataDTO where
  toJSON UniswapV2TokenDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2TokenDayDataDTOEntryTime
      , "recv_time" .= uniswapV2TokenDayDataDTORecvTime
      , "block_number" .= uniswapV2TokenDayDataDTOBlockNumber
      , "id" .= uniswapV2TokenDayDataDTOId
      , "date" .= uniswapV2TokenDayDataDTODate
      , "token" .= uniswapV2TokenDayDataDTOToken
      , "daily_volume_token" .= uniswapV2TokenDayDataDTODailyVolumeToken
      , "daily_volume_eth" .= uniswapV2TokenDayDataDTODailyVolumeEth
      , "daily_volume_usd" .= uniswapV2TokenDayDataDTODailyVolumeUsd
      , "daily_txns" .= uniswapV2TokenDayDataDTODailyTxns
      , "total_liquidity_token" .= uniswapV2TokenDayDataDTOTotalLiquidityToken
      , "total_liquidity_eth" .= uniswapV2TokenDayDataDTOTotalLiquidityEth
      , "total_liquidity_usd" .= uniswapV2TokenDayDataDTOTotalLiquidityUsd
      , "price_usd" .= uniswapV2TokenDayDataDTOPriceUsd
      , "vid" .= uniswapV2TokenDayDataDTOVid
      ]


-- | Construct a value of type 'UniswapV2TokenDayDataDTO' (by applying it's required fields, if any)
mkUniswapV2TokenDayDataDTO
  :: UniswapV2TokenDayDataDTO
mkUniswapV2TokenDayDataDTO =
  UniswapV2TokenDayDataDTO
  { uniswapV2TokenDayDataDTOEntryTime = Nothing
  , uniswapV2TokenDayDataDTORecvTime = Nothing
  , uniswapV2TokenDayDataDTOBlockNumber = Nothing
  , uniswapV2TokenDayDataDTOId = Nothing
  , uniswapV2TokenDayDataDTODate = Nothing
  , uniswapV2TokenDayDataDTOToken = Nothing
  , uniswapV2TokenDayDataDTODailyVolumeToken = Nothing
  , uniswapV2TokenDayDataDTODailyVolumeEth = Nothing
  , uniswapV2TokenDayDataDTODailyVolumeUsd = Nothing
  , uniswapV2TokenDayDataDTODailyTxns = Nothing
  , uniswapV2TokenDayDataDTOTotalLiquidityToken = Nothing
  , uniswapV2TokenDayDataDTOTotalLiquidityEth = Nothing
  , uniswapV2TokenDayDataDTOTotalLiquidityUsd = Nothing
  , uniswapV2TokenDayDataDTOPriceUsd = Nothing
  , uniswapV2TokenDayDataDTOVid = Nothing
  }

-- ** UniswapV2TransactionDTO
-- | UniswapV2TransactionDTO
-- Transaction entities are created for each Ethereum transaction that contains an interaction within Uniswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
data UniswapV2TransactionDTO = UniswapV2TransactionDTO
  { uniswapV2TransactionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2TransactionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2TransactionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2TransactionDTOId :: !(Maybe Text) -- ^ "id" - Ethereum transaction hash.
  , uniswapV2TransactionDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp.
  , uniswapV2TransactionDTOMints :: !(Maybe [Text]) -- ^ "mints" - Array of Mint events within the transaction, 0 or greater.
  , uniswapV2TransactionDTOBurns :: !(Maybe [Text]) -- ^ "burns" - Array of Burn events within transaction, 0 or greater.
  , uniswapV2TransactionDTOSwaps :: !(Maybe [Text]) -- ^ "swaps" - Array of Swap events within transaction, 0 or greater.
  , uniswapV2TransactionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2TransactionDTO
instance A.FromJSON UniswapV2TransactionDTO where
  parseJSON = A.withObject "UniswapV2TransactionDTO" $ \o ->
    UniswapV2TransactionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "timestamp")
      <*> (o .:? "mints")
      <*> (o .:? "burns")
      <*> (o .:? "swaps")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2TransactionDTO
instance A.ToJSON UniswapV2TransactionDTO where
  toJSON UniswapV2TransactionDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2TransactionDTOEntryTime
      , "recv_time" .= uniswapV2TransactionDTORecvTime
      , "block_number" .= uniswapV2TransactionDTOBlockNumber
      , "id" .= uniswapV2TransactionDTOId
      , "timestamp" .= uniswapV2TransactionDTOTimestamp
      , "mints" .= uniswapV2TransactionDTOMints
      , "burns" .= uniswapV2TransactionDTOBurns
      , "swaps" .= uniswapV2TransactionDTOSwaps
      , "vid" .= uniswapV2TransactionDTOVid
      ]


-- | Construct a value of type 'UniswapV2TransactionDTO' (by applying it's required fields, if any)
mkUniswapV2TransactionDTO
  :: UniswapV2TransactionDTO
mkUniswapV2TransactionDTO =
  UniswapV2TransactionDTO
  { uniswapV2TransactionDTOEntryTime = Nothing
  , uniswapV2TransactionDTORecvTime = Nothing
  , uniswapV2TransactionDTOBlockNumber = Nothing
  , uniswapV2TransactionDTOId = Nothing
  , uniswapV2TransactionDTOTimestamp = Nothing
  , uniswapV2TransactionDTOMints = Nothing
  , uniswapV2TransactionDTOBurns = Nothing
  , uniswapV2TransactionDTOSwaps = Nothing
  , uniswapV2TransactionDTOVid = Nothing
  }

-- ** UniswapV2UniswapDayDataDTO
-- | UniswapV2UniswapDayDataDTO
-- Tracks data across all pairs aggregated into a daily bucket.
data UniswapV2UniswapDayDataDTO = UniswapV2UniswapDayDataDTO
  { uniswapV2UniswapDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2UniswapDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2UniswapDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2UniswapDayDataDTOId :: !(Maybe Text) -- ^ "id" - Unix timestamp for start of day / 86400 giving a unique day index.
  , uniswapV2UniswapDayDataDTODate :: !(Maybe Int) -- ^ "date" - Unix timestamp for start of day.
  , uniswapV2UniswapDayDataDTODailyVolumeEth :: !(Maybe Text) -- ^ "daily_volume_eth" - Total volume across all pairs on this day, stored as a derived amount of ETH.
  , uniswapV2UniswapDayDataDTODailyVolumeUsd :: !(Maybe Text) -- ^ "daily_volume_usd" - Total volume across all pairs on this day, stored as a derived amount of USD.
  , uniswapV2UniswapDayDataDTODailyVolumeUntracked :: !(Maybe Text) -- ^ "daily_volume_untracked" - Total volume across all pairs on this day, untracked.
  , uniswapV2UniswapDayDataDTOTotalVolumeEth :: !(Maybe Text) -- ^ "total_volume_eth" - All time volume across all pairs in ETH up to and including this day.
  , uniswapV2UniswapDayDataDTOTotalLiquidityEth :: !(Maybe Text) -- ^ "total_liquidity_eth" - Total liquidity across all pairs in ETH up to and including this day.
  , uniswapV2UniswapDayDataDTOTotalVolumeUsd :: !(Maybe Text) -- ^ "total_volume_usd" - All time volume across all pairs in USD up to and including this day.
  , uniswapV2UniswapDayDataDTOTotalLiquidityUsd :: !(Maybe Text) -- ^ "total_liquidity_usd" - Total liquidity across all pairs in USD up to and including this day.
  , uniswapV2UniswapDayDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Number of transactions throughout this day.
  , uniswapV2UniswapDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2UniswapDayDataDTO
instance A.FromJSON UniswapV2UniswapDayDataDTO where
  parseJSON = A.withObject "UniswapV2UniswapDayDataDTO" $ \o ->
    UniswapV2UniswapDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "daily_volume_eth")
      <*> (o .:? "daily_volume_usd")
      <*> (o .:? "daily_volume_untracked")
      <*> (o .:? "total_volume_eth")
      <*> (o .:? "total_liquidity_eth")
      <*> (o .:? "total_volume_usd")
      <*> (o .:? "total_liquidity_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2UniswapDayDataDTO
instance A.ToJSON UniswapV2UniswapDayDataDTO where
  toJSON UniswapV2UniswapDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2UniswapDayDataDTOEntryTime
      , "recv_time" .= uniswapV2UniswapDayDataDTORecvTime
      , "block_number" .= uniswapV2UniswapDayDataDTOBlockNumber
      , "id" .= uniswapV2UniswapDayDataDTOId
      , "date" .= uniswapV2UniswapDayDataDTODate
      , "daily_volume_eth" .= uniswapV2UniswapDayDataDTODailyVolumeEth
      , "daily_volume_usd" .= uniswapV2UniswapDayDataDTODailyVolumeUsd
      , "daily_volume_untracked" .= uniswapV2UniswapDayDataDTODailyVolumeUntracked
      , "total_volume_eth" .= uniswapV2UniswapDayDataDTOTotalVolumeEth
      , "total_liquidity_eth" .= uniswapV2UniswapDayDataDTOTotalLiquidityEth
      , "total_volume_usd" .= uniswapV2UniswapDayDataDTOTotalVolumeUsd
      , "total_liquidity_usd" .= uniswapV2UniswapDayDataDTOTotalLiquidityUsd
      , "tx_count" .= uniswapV2UniswapDayDataDTOTxCount
      , "vid" .= uniswapV2UniswapDayDataDTOVid
      ]


-- | Construct a value of type 'UniswapV2UniswapDayDataDTO' (by applying it's required fields, if any)
mkUniswapV2UniswapDayDataDTO
  :: UniswapV2UniswapDayDataDTO
mkUniswapV2UniswapDayDataDTO =
  UniswapV2UniswapDayDataDTO
  { uniswapV2UniswapDayDataDTOEntryTime = Nothing
  , uniswapV2UniswapDayDataDTORecvTime = Nothing
  , uniswapV2UniswapDayDataDTOBlockNumber = Nothing
  , uniswapV2UniswapDayDataDTOId = Nothing
  , uniswapV2UniswapDayDataDTODate = Nothing
  , uniswapV2UniswapDayDataDTODailyVolumeEth = Nothing
  , uniswapV2UniswapDayDataDTODailyVolumeUsd = Nothing
  , uniswapV2UniswapDayDataDTODailyVolumeUntracked = Nothing
  , uniswapV2UniswapDayDataDTOTotalVolumeEth = Nothing
  , uniswapV2UniswapDayDataDTOTotalLiquidityEth = Nothing
  , uniswapV2UniswapDayDataDTOTotalVolumeUsd = Nothing
  , uniswapV2UniswapDayDataDTOTotalLiquidityUsd = Nothing
  , uniswapV2UniswapDayDataDTOTxCount = Nothing
  , uniswapV2UniswapDayDataDTOVid = Nothing
  }

-- ** UniswapV2UniswapFactoryDTO
-- | UniswapV2UniswapFactoryDTO
-- The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
data UniswapV2UniswapFactoryDTO = UniswapV2UniswapFactoryDTO
  { uniswapV2UniswapFactoryDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2UniswapFactoryDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2UniswapFactoryDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2UniswapFactoryDTOId :: !(Maybe Text) -- ^ "id" - Factory address.
  , uniswapV2UniswapFactoryDTOPairCount :: !(Maybe Int) -- ^ "pair_count" - Amount of pairs created by the Uniswap factory.
  , uniswapV2UniswapFactoryDTOTotalVolumeUsd :: !(Maybe Text) -- ^ "total_volume_usd" - All time USD volume across all pairs (USD is derived).
  , uniswapV2UniswapFactoryDTOTotalVolumeEth :: !(Maybe Text) -- ^ "total_volume_eth" - All time volume in ETH across all pairs (ETH is derived).
  , uniswapV2UniswapFactoryDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Untracked volume USD.
  , uniswapV2UniswapFactoryDTOTotalLiquidityUsd :: !(Maybe Text) -- ^ "total_liquidity_usd" - Total liquidity across all pairs stored as a derived USD amount.
  , uniswapV2UniswapFactoryDTOTotalLiquidityEth :: !(Maybe Text) -- ^ "total_liquidity_eth" - Total liquidity across all pairs stored as a derived ETH amount.
  , uniswapV2UniswapFactoryDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - All time amount of transactions across all pairs.
  , uniswapV2UniswapFactoryDTOVid :: !(Maybe Integer) -- ^ "vid" - .
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2UniswapFactoryDTO
instance A.FromJSON UniswapV2UniswapFactoryDTO where
  parseJSON = A.withObject "UniswapV2UniswapFactoryDTO" $ \o ->
    UniswapV2UniswapFactoryDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pair_count")
      <*> (o .:? "total_volume_usd")
      <*> (o .:? "total_volume_eth")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_liquidity_usd")
      <*> (o .:? "total_liquidity_eth")
      <*> (o .:? "tx_count")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2UniswapFactoryDTO
instance A.ToJSON UniswapV2UniswapFactoryDTO where
  toJSON UniswapV2UniswapFactoryDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2UniswapFactoryDTOEntryTime
      , "recv_time" .= uniswapV2UniswapFactoryDTORecvTime
      , "block_number" .= uniswapV2UniswapFactoryDTOBlockNumber
      , "id" .= uniswapV2UniswapFactoryDTOId
      , "pair_count" .= uniswapV2UniswapFactoryDTOPairCount
      , "total_volume_usd" .= uniswapV2UniswapFactoryDTOTotalVolumeUsd
      , "total_volume_eth" .= uniswapV2UniswapFactoryDTOTotalVolumeEth
      , "untracked_volume_usd" .= uniswapV2UniswapFactoryDTOUntrackedVolumeUsd
      , "total_liquidity_usd" .= uniswapV2UniswapFactoryDTOTotalLiquidityUsd
      , "total_liquidity_eth" .= uniswapV2UniswapFactoryDTOTotalLiquidityEth
      , "tx_count" .= uniswapV2UniswapFactoryDTOTxCount
      , "vid" .= uniswapV2UniswapFactoryDTOVid
      ]


-- | Construct a value of type 'UniswapV2UniswapFactoryDTO' (by applying it's required fields, if any)
mkUniswapV2UniswapFactoryDTO
  :: UniswapV2UniswapFactoryDTO
mkUniswapV2UniswapFactoryDTO =
  UniswapV2UniswapFactoryDTO
  { uniswapV2UniswapFactoryDTOEntryTime = Nothing
  , uniswapV2UniswapFactoryDTORecvTime = Nothing
  , uniswapV2UniswapFactoryDTOBlockNumber = Nothing
  , uniswapV2UniswapFactoryDTOId = Nothing
  , uniswapV2UniswapFactoryDTOPairCount = Nothing
  , uniswapV2UniswapFactoryDTOTotalVolumeUsd = Nothing
  , uniswapV2UniswapFactoryDTOTotalVolumeEth = Nothing
  , uniswapV2UniswapFactoryDTOUntrackedVolumeUsd = Nothing
  , uniswapV2UniswapFactoryDTOTotalLiquidityUsd = Nothing
  , uniswapV2UniswapFactoryDTOTotalLiquidityEth = Nothing
  , uniswapV2UniswapFactoryDTOTxCount = Nothing
  , uniswapV2UniswapFactoryDTOVid = Nothing
  }

-- ** UniswapV2UserDTO
-- | UniswapV2UserDTO
-- A user entity is created for any address that provides liquidity to a pool on Uniswap. This entity can be used to track open positions for users.
data UniswapV2UserDTO = UniswapV2UserDTO
  { uniswapV2UserDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV2UserDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV2UserDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV2UserDTOId :: !(Maybe Text) -- ^ "id" - User address.
  , uniswapV2UserDTOUsdSwapped :: !(Maybe Text) -- ^ "usd_swapped" - Total USD value swapped.
  , uniswapV2UserDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV2UserDTO
instance A.FromJSON UniswapV2UserDTO where
  parseJSON = A.withObject "UniswapV2UserDTO" $ \o ->
    UniswapV2UserDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "usd_swapped")
      <*> (o .:? "vid")

-- | ToJSON UniswapV2UserDTO
instance A.ToJSON UniswapV2UserDTO where
  toJSON UniswapV2UserDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV2UserDTOEntryTime
      , "recv_time" .= uniswapV2UserDTORecvTime
      , "block_number" .= uniswapV2UserDTOBlockNumber
      , "id" .= uniswapV2UserDTOId
      , "usd_swapped" .= uniswapV2UserDTOUsdSwapped
      , "vid" .= uniswapV2UserDTOVid
      ]


-- | Construct a value of type 'UniswapV2UserDTO' (by applying it's required fields, if any)
mkUniswapV2UserDTO
  :: UniswapV2UserDTO
mkUniswapV2UserDTO =
  UniswapV2UserDTO
  { uniswapV2UserDTOEntryTime = Nothing
  , uniswapV2UserDTORecvTime = Nothing
  , uniswapV2UserDTOBlockNumber = Nothing
  , uniswapV2UserDTOId = Nothing
  , uniswapV2UserDTOUsdSwapped = Nothing
  , uniswapV2UserDTOVid = Nothing
  }

-- ** UniswapV3BundleDTO
-- | UniswapV3BundleDTO
-- The Bundle is used as a global store of derived ETH price in USD. This provides a strong estimate for the USD price of ETH.
data UniswapV3BundleDTO = UniswapV3BundleDTO
  { uniswapV3BundleDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3BundleDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3BundleDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3BundleDTOId :: !(Maybe Text) -- ^ "id" - 
  , uniswapV3BundleDTOEthPriceUsd :: !(Maybe Text) -- ^ "eth_price_usd" - Price of ETH in usd.
  , uniswapV3BundleDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3BundleDTO
instance A.FromJSON UniswapV3BundleDTO where
  parseJSON = A.withObject "UniswapV3BundleDTO" $ \o ->
    UniswapV3BundleDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "eth_price_usd")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3BundleDTO
instance A.ToJSON UniswapV3BundleDTO where
  toJSON UniswapV3BundleDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3BundleDTOEntryTime
      , "recv_time" .= uniswapV3BundleDTORecvTime
      , "block_number" .= uniswapV3BundleDTOBlockNumber
      , "id" .= uniswapV3BundleDTOId
      , "eth_price_usd" .= uniswapV3BundleDTOEthPriceUsd
      , "vid" .= uniswapV3BundleDTOVid
      ]


-- | Construct a value of type 'UniswapV3BundleDTO' (by applying it's required fields, if any)
mkUniswapV3BundleDTO
  :: UniswapV3BundleDTO
mkUniswapV3BundleDTO =
  UniswapV3BundleDTO
  { uniswapV3BundleDTOEntryTime = Nothing
  , uniswapV3BundleDTORecvTime = Nothing
  , uniswapV3BundleDTOBlockNumber = Nothing
  , uniswapV3BundleDTOId = Nothing
  , uniswapV3BundleDTOEthPriceUsd = Nothing
  , uniswapV3BundleDTOVid = Nothing
  }

-- ** UniswapV3BurnDTO
-- | UniswapV3BurnDTO
-- Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
data UniswapV3BurnDTO = UniswapV3BurnDTO
  { uniswapV3BurnDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3BurnDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3BurnDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3BurnDTOId :: !(Maybe Text) -- ^ "id" - Transaction hash + &#39;#&#39; + index in mints Transaction array.
  , uniswapV3BurnDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Transaction burn was included in.
  , uniswapV3BurnDTOPool :: !(Maybe Text) -- ^ "pool" - Pool position is within.
  , uniswapV3BurnDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pool contract.
  , uniswapV3BurnDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pool contract.
  , uniswapV3BurnDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp.
  , uniswapV3BurnDTOOwner :: !(Maybe Text) -- ^ "owner" - Owner of position where liquidity was burned.
  , uniswapV3BurnDTOOrigin :: !(Maybe Text) -- ^ "origin" - Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
  , uniswapV3BurnDTOAmount :: !(Maybe Text) -- ^ "amount" - Amount of liquidity burned.
  , uniswapV3BurnDTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token 0 burned.
  , uniswapV3BurnDTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token 1 burned.
  , uniswapV3BurnDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount based on available prices of tokens.
  , uniswapV3BurnDTOTickLower :: !(Maybe Text) -- ^ "tick_lower" - Lower tick of position.
  , uniswapV3BurnDTOTickUpper :: !(Maybe Text) -- ^ "tick_upper" - Upper tick of position.
  , uniswapV3BurnDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Position within the transactions.
  , uniswapV3BurnDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3BurnDTO
instance A.FromJSON UniswapV3BurnDTO where
  parseJSON = A.withObject "UniswapV3BurnDTO" $ \o ->
    UniswapV3BurnDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "timestamp")
      <*> (o .:? "owner")
      <*> (o .:? "origin")
      <*> (o .:? "amount")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "amount_usd")
      <*> (o .:? "tick_lower")
      <*> (o .:? "tick_upper")
      <*> (o .:? "log_index")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3BurnDTO
instance A.ToJSON UniswapV3BurnDTO where
  toJSON UniswapV3BurnDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3BurnDTOEntryTime
      , "recv_time" .= uniswapV3BurnDTORecvTime
      , "block_number" .= uniswapV3BurnDTOBlockNumber
      , "id" .= uniswapV3BurnDTOId
      , "transaction" .= uniswapV3BurnDTOTransaction
      , "pool" .= uniswapV3BurnDTOPool
      , "token_0" .= uniswapV3BurnDTOToken0
      , "token_1" .= uniswapV3BurnDTOToken1
      , "timestamp" .= uniswapV3BurnDTOTimestamp
      , "owner" .= uniswapV3BurnDTOOwner
      , "origin" .= uniswapV3BurnDTOOrigin
      , "amount" .= uniswapV3BurnDTOAmount
      , "amount_0" .= uniswapV3BurnDTOAmount0
      , "amount_1" .= uniswapV3BurnDTOAmount1
      , "amount_usd" .= uniswapV3BurnDTOAmountUsd
      , "tick_lower" .= uniswapV3BurnDTOTickLower
      , "tick_upper" .= uniswapV3BurnDTOTickUpper
      , "log_index" .= uniswapV3BurnDTOLogIndex
      , "vid" .= uniswapV3BurnDTOVid
      ]


-- | Construct a value of type 'UniswapV3BurnDTO' (by applying it's required fields, if any)
mkUniswapV3BurnDTO
  :: UniswapV3BurnDTO
mkUniswapV3BurnDTO =
  UniswapV3BurnDTO
  { uniswapV3BurnDTOEntryTime = Nothing
  , uniswapV3BurnDTORecvTime = Nothing
  , uniswapV3BurnDTOBlockNumber = Nothing
  , uniswapV3BurnDTOId = Nothing
  , uniswapV3BurnDTOTransaction = Nothing
  , uniswapV3BurnDTOPool = Nothing
  , uniswapV3BurnDTOToken0 = Nothing
  , uniswapV3BurnDTOToken1 = Nothing
  , uniswapV3BurnDTOTimestamp = Nothing
  , uniswapV3BurnDTOOwner = Nothing
  , uniswapV3BurnDTOOrigin = Nothing
  , uniswapV3BurnDTOAmount = Nothing
  , uniswapV3BurnDTOAmount0 = Nothing
  , uniswapV3BurnDTOAmount1 = Nothing
  , uniswapV3BurnDTOAmountUsd = Nothing
  , uniswapV3BurnDTOTickLower = Nothing
  , uniswapV3BurnDTOTickUpper = Nothing
  , uniswapV3BurnDTOLogIndex = Nothing
  , uniswapV3BurnDTOVid = Nothing
  }

-- ** UniswapV3FactoryDTO
-- | UniswapV3FactoryDTO
-- The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
data UniswapV3FactoryDTO = UniswapV3FactoryDTO
  { uniswapV3FactoryDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3FactoryDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3FactoryDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3FactoryDTOId :: !(Maybe Text) -- ^ "id" - Factory address.
  , uniswapV3FactoryDTOPoolCount :: !(Maybe Text) -- ^ "pool_count" - Amount of pools created.
  , uniswapV3FactoryDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Amount of transactions all time.
  , uniswapV3FactoryDTOTotalVolumeUsd :: !(Maybe Text) -- ^ "total_volume_usd" - Total volume all time in derived USD.
  , uniswapV3FactoryDTOTotalVolumeEth :: !(Maybe Text) -- ^ "total_volume_eth" - Total volume all time in derived ETH.
  , uniswapV3FactoryDTOTotalFeesUsd :: !(Maybe Text) -- ^ "total_fees_usd" - Total swap fees all time in USD.
  , uniswapV3FactoryDTOTotalFeesEth :: !(Maybe Text) -- ^ "total_fees_eth" - All volume even through less reliable USD values.
  , uniswapV3FactoryDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - All volume even through less reliable USD values.
  , uniswapV3FactoryDTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - Total value locked derived in USD.
  , uniswapV3FactoryDTOTotalValueLockedEth :: !(Maybe Text) -- ^ "total_value_locked_eth" - Total value locked derived in ETH.
  , uniswapV3FactoryDTOTotalValueLockedUsdUntracked :: !(Maybe Text) -- ^ "total_value_locked_usd_untracked" - Total value locked derived in USD untracked.
  , uniswapV3FactoryDTOTotalValueLockedEthUntracked :: !(Maybe Text) -- ^ "total_value_locked_eth_untracked" - Total value locked derived in ETH untracked.
  , uniswapV3FactoryDTOOwner :: !(Maybe Text) -- ^ "owner" - Current owner of the factory.
  , uniswapV3FactoryDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3FactoryDTO
instance A.FromJSON UniswapV3FactoryDTO where
  parseJSON = A.withObject "UniswapV3FactoryDTO" $ \o ->
    UniswapV3FactoryDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "pool_count")
      <*> (o .:? "tx_count")
      <*> (o .:? "total_volume_usd")
      <*> (o .:? "total_volume_eth")
      <*> (o .:? "total_fees_usd")
      <*> (o .:? "total_fees_eth")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "total_value_locked_eth")
      <*> (o .:? "total_value_locked_usd_untracked")
      <*> (o .:? "total_value_locked_eth_untracked")
      <*> (o .:? "owner")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3FactoryDTO
instance A.ToJSON UniswapV3FactoryDTO where
  toJSON UniswapV3FactoryDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3FactoryDTOEntryTime
      , "recv_time" .= uniswapV3FactoryDTORecvTime
      , "block_number" .= uniswapV3FactoryDTOBlockNumber
      , "id" .= uniswapV3FactoryDTOId
      , "pool_count" .= uniswapV3FactoryDTOPoolCount
      , "tx_count" .= uniswapV3FactoryDTOTxCount
      , "total_volume_usd" .= uniswapV3FactoryDTOTotalVolumeUsd
      , "total_volume_eth" .= uniswapV3FactoryDTOTotalVolumeEth
      , "total_fees_usd" .= uniswapV3FactoryDTOTotalFeesUsd
      , "total_fees_eth" .= uniswapV3FactoryDTOTotalFeesEth
      , "untracked_volume_usd" .= uniswapV3FactoryDTOUntrackedVolumeUsd
      , "total_value_locked_usd" .= uniswapV3FactoryDTOTotalValueLockedUsd
      , "total_value_locked_eth" .= uniswapV3FactoryDTOTotalValueLockedEth
      , "total_value_locked_usd_untracked" .= uniswapV3FactoryDTOTotalValueLockedUsdUntracked
      , "total_value_locked_eth_untracked" .= uniswapV3FactoryDTOTotalValueLockedEthUntracked
      , "owner" .= uniswapV3FactoryDTOOwner
      , "vid" .= uniswapV3FactoryDTOVid
      ]


-- | Construct a value of type 'UniswapV3FactoryDTO' (by applying it's required fields, if any)
mkUniswapV3FactoryDTO
  :: UniswapV3FactoryDTO
mkUniswapV3FactoryDTO =
  UniswapV3FactoryDTO
  { uniswapV3FactoryDTOEntryTime = Nothing
  , uniswapV3FactoryDTORecvTime = Nothing
  , uniswapV3FactoryDTOBlockNumber = Nothing
  , uniswapV3FactoryDTOId = Nothing
  , uniswapV3FactoryDTOPoolCount = Nothing
  , uniswapV3FactoryDTOTxCount = Nothing
  , uniswapV3FactoryDTOTotalVolumeUsd = Nothing
  , uniswapV3FactoryDTOTotalVolumeEth = Nothing
  , uniswapV3FactoryDTOTotalFeesUsd = Nothing
  , uniswapV3FactoryDTOTotalFeesEth = Nothing
  , uniswapV3FactoryDTOUntrackedVolumeUsd = Nothing
  , uniswapV3FactoryDTOTotalValueLockedUsd = Nothing
  , uniswapV3FactoryDTOTotalValueLockedEth = Nothing
  , uniswapV3FactoryDTOTotalValueLockedUsdUntracked = Nothing
  , uniswapV3FactoryDTOTotalValueLockedEthUntracked = Nothing
  , uniswapV3FactoryDTOOwner = Nothing
  , uniswapV3FactoryDTOVid = Nothing
  }

-- ** UniswapV3MintDTO
-- | UniswapV3MintDTO
-- Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, and more.
data UniswapV3MintDTO = UniswapV3MintDTO
  { uniswapV3MintDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3MintDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3MintDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3MintDTOId :: !(Maybe Text) -- ^ "id" - Transaction hash + &#39;#&#39; + index in mints Transaction array.
  , uniswapV3MintDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Which txn the mint was included in.
  , uniswapV3MintDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Time of transaction.
  , uniswapV3MintDTOPool :: !(Maybe Text) -- ^ "pool" - Pool address.
  , uniswapV3MintDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pool contract.
  , uniswapV3MintDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pool contract.
  , uniswapV3MintDTOOwner :: !(Maybe Text) -- ^ "owner" - Owner of position where liquidity minted to.
  , uniswapV3MintDTOSender :: !(Maybe Text) -- ^ "sender" - The address that minted the liquidity.
  , uniswapV3MintDTOOrigin :: !(Maybe Text) -- ^ "origin" - Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
  , uniswapV3MintDTOAmount :: !(Maybe Text) -- ^ "amount" - Amount of liquidity minted.
  , uniswapV3MintDTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Amount of token 0 minted.
  , uniswapV3MintDTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Amount of token 1 minted.
  , uniswapV3MintDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount based on available prices of tokens.
  , uniswapV3MintDTOTickLower :: !(Maybe Text) -- ^ "tick_lower" - Lower tick of the position.
  , uniswapV3MintDTOTickUpper :: !(Maybe Text) -- ^ "tick_upper" - Upper tick of the position.
  , uniswapV3MintDTOLogIndex :: !(Maybe Text) -- ^ "log_index" - Order within the transaction.
  , uniswapV3MintDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3MintDTO
instance A.FromJSON UniswapV3MintDTO where
  parseJSON = A.withObject "UniswapV3MintDTO" $ \o ->
    UniswapV3MintDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "owner")
      <*> (o .:? "sender")
      <*> (o .:? "origin")
      <*> (o .:? "amount")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "amount_usd")
      <*> (o .:? "tick_lower")
      <*> (o .:? "tick_upper")
      <*> (o .:? "log_index")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3MintDTO
instance A.ToJSON UniswapV3MintDTO where
  toJSON UniswapV3MintDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3MintDTOEntryTime
      , "recv_time" .= uniswapV3MintDTORecvTime
      , "block_number" .= uniswapV3MintDTOBlockNumber
      , "id" .= uniswapV3MintDTOId
      , "transaction" .= uniswapV3MintDTOTransaction
      , "timestamp" .= uniswapV3MintDTOTimestamp
      , "pool" .= uniswapV3MintDTOPool
      , "token_0" .= uniswapV3MintDTOToken0
      , "token_1" .= uniswapV3MintDTOToken1
      , "owner" .= uniswapV3MintDTOOwner
      , "sender" .= uniswapV3MintDTOSender
      , "origin" .= uniswapV3MintDTOOrigin
      , "amount" .= uniswapV3MintDTOAmount
      , "amount_0" .= uniswapV3MintDTOAmount0
      , "amount_1" .= uniswapV3MintDTOAmount1
      , "amount_usd" .= uniswapV3MintDTOAmountUsd
      , "tick_lower" .= uniswapV3MintDTOTickLower
      , "tick_upper" .= uniswapV3MintDTOTickUpper
      , "log_index" .= uniswapV3MintDTOLogIndex
      , "vid" .= uniswapV3MintDTOVid
      ]


-- | Construct a value of type 'UniswapV3MintDTO' (by applying it's required fields, if any)
mkUniswapV3MintDTO
  :: UniswapV3MintDTO
mkUniswapV3MintDTO =
  UniswapV3MintDTO
  { uniswapV3MintDTOEntryTime = Nothing
  , uniswapV3MintDTORecvTime = Nothing
  , uniswapV3MintDTOBlockNumber = Nothing
  , uniswapV3MintDTOId = Nothing
  , uniswapV3MintDTOTransaction = Nothing
  , uniswapV3MintDTOTimestamp = Nothing
  , uniswapV3MintDTOPool = Nothing
  , uniswapV3MintDTOToken0 = Nothing
  , uniswapV3MintDTOToken1 = Nothing
  , uniswapV3MintDTOOwner = Nothing
  , uniswapV3MintDTOSender = Nothing
  , uniswapV3MintDTOOrigin = Nothing
  , uniswapV3MintDTOAmount = Nothing
  , uniswapV3MintDTOAmount0 = Nothing
  , uniswapV3MintDTOAmount1 = Nothing
  , uniswapV3MintDTOAmountUsd = Nothing
  , uniswapV3MintDTOTickLower = Nothing
  , uniswapV3MintDTOTickUpper = Nothing
  , uniswapV3MintDTOLogIndex = Nothing
  , uniswapV3MintDTOVid = Nothing
  }

-- ** UniswapV3PoolDTO
-- | UniswapV3PoolDTO
-- Information about a pool. Includes references to each token within the pool, volume information, liquidity information, and more. The pool entity mirrors the pool smart contract, and also contains aggregated information about use.
data UniswapV3PoolDTO = UniswapV3PoolDTO
  { uniswapV3PoolDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3PoolDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3PoolDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3PoolDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3PoolDTOId :: !(Maybe Text) -- ^ "id" - Pool address.
  , uniswapV3PoolDTOCreatedAtTimestamp :: !(Maybe DateTime) -- ^ "created_at_timestamp" - Creation time.
  , uniswapV3PoolDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pool contract.
  , uniswapV3PoolDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pool contract.
  , uniswapV3PoolDTOFeeTier :: !(Maybe NumericsBigInteger) -- ^ "fee_tier"
  , uniswapV3PoolDTOLiquidity :: !(Maybe NumericsBigInteger) -- ^ "liquidity"
  , uniswapV3PoolDTOSqrtPrice :: !(Maybe NumericsBigInteger) -- ^ "sqrt_price"
  , uniswapV3PoolDTOFeeGrowthGlobal0x128 :: !(Maybe NumericsBigInteger) -- ^ "fee_growth_global_0x128"
  , uniswapV3PoolDTOFeeGrowthGlobal1x128 :: !(Maybe NumericsBigInteger) -- ^ "fee_growth_global_1x128"
  , uniswapV3PoolDTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - Token0 per token1.
  , uniswapV3PoolDTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - Token1 per token0.
  , uniswapV3PoolDTOTick :: !(Maybe NumericsBigInteger) -- ^ "tick"
  , uniswapV3PoolDTOObservationIndex :: !(Maybe NumericsBigInteger) -- ^ "observation_index"
  , uniswapV3PoolDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - All time token0 swapped.
  , uniswapV3PoolDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - All time token1 swapped.
  , uniswapV3PoolDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - All time USD swapped.
  , uniswapV3PoolDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - All time USD swapped, unfiltered for unreliable USD pools.
  , uniswapV3PoolDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3PoolDTOTxCount :: !(Maybe NumericsBigInteger) -- ^ "tx_count"
  , uniswapV3PoolDTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - All time fees collected token0.
  , uniswapV3PoolDTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - All time fees collected token1.
  , uniswapV3PoolDTOCollectedFeesUsd :: !(Maybe Text) -- ^ "collected_fees_usd" - All time fees collected derived USD.
  , uniswapV3PoolDTOTotalValueLockedToken0 :: !(Maybe Text) -- ^ "total_value_locked_token_0" - Total token 0 across all ticks.
  , uniswapV3PoolDTOTotalValueLockedToken1 :: !(Maybe Text) -- ^ "total_value_locked_token_1" - 
  , uniswapV3PoolDTOTotalValueLockedEth :: !(Maybe Text) -- ^ "total_value_locked_eth" - Total token 1 across all ticks.
  , uniswapV3PoolDTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - Total value locked USD.
  , uniswapV3PoolDTOTotalValueLockedUsdUntracked :: !(Maybe Text) -- ^ "total_value_locked_usd_untracked" - Total value locked derived ETH.
  , uniswapV3PoolDTOLiquidityProviderCount :: !(Maybe Text) -- ^ "liquidity_provider_count" - Liquidity providers count, used to detect new exchanges.
  , uniswapV3PoolDTOEvaluatedAsk :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_ask"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3PoolDTO
instance A.FromJSON UniswapV3PoolDTO where
  parseJSON = A.withObject "UniswapV3PoolDTO" $ \o ->
    UniswapV3PoolDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "created_at_timestamp")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "fee_tier")
      <*> (o .:? "liquidity")
      <*> (o .:? "sqrt_price")
      <*> (o .:? "fee_growth_global_0x128")
      <*> (o .:? "fee_growth_global_1x128")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "tick")
      <*> (o .:? "observation_index")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "collected_fees_usd")
      <*> (o .:? "total_value_locked_token_0")
      <*> (o .:? "total_value_locked_token_1")
      <*> (o .:? "total_value_locked_eth")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "total_value_locked_usd_untracked")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "evaluated_ask")

-- | ToJSON UniswapV3PoolDTO
instance A.ToJSON UniswapV3PoolDTO where
  toJSON UniswapV3PoolDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3PoolDTOEntryTime
      , "recv_time" .= uniswapV3PoolDTORecvTime
      , "block_number" .= uniswapV3PoolDTOBlockNumber
      , "vid" .= uniswapV3PoolDTOVid
      , "id" .= uniswapV3PoolDTOId
      , "created_at_timestamp" .= uniswapV3PoolDTOCreatedAtTimestamp
      , "token_0" .= uniswapV3PoolDTOToken0
      , "token_1" .= uniswapV3PoolDTOToken1
      , "fee_tier" .= uniswapV3PoolDTOFeeTier
      , "liquidity" .= uniswapV3PoolDTOLiquidity
      , "sqrt_price" .= uniswapV3PoolDTOSqrtPrice
      , "fee_growth_global_0x128" .= uniswapV3PoolDTOFeeGrowthGlobal0x128
      , "fee_growth_global_1x128" .= uniswapV3PoolDTOFeeGrowthGlobal1x128
      , "token_0_price" .= uniswapV3PoolDTOToken0Price
      , "token_1_price" .= uniswapV3PoolDTOToken1Price
      , "tick" .= uniswapV3PoolDTOTick
      , "observation_index" .= uniswapV3PoolDTOObservationIndex
      , "volume_token_0" .= uniswapV3PoolDTOVolumeToken0
      , "volume_token_1" .= uniswapV3PoolDTOVolumeToken1
      , "volume_usd" .= uniswapV3PoolDTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV3PoolDTOUntrackedVolumeUsd
      , "fees_usd" .= uniswapV3PoolDTOFeesUsd
      , "tx_count" .= uniswapV3PoolDTOTxCount
      , "collected_fees_token_0" .= uniswapV3PoolDTOCollectedFeesToken0
      , "collected_fees_token_1" .= uniswapV3PoolDTOCollectedFeesToken1
      , "collected_fees_usd" .= uniswapV3PoolDTOCollectedFeesUsd
      , "total_value_locked_token_0" .= uniswapV3PoolDTOTotalValueLockedToken0
      , "total_value_locked_token_1" .= uniswapV3PoolDTOTotalValueLockedToken1
      , "total_value_locked_eth" .= uniswapV3PoolDTOTotalValueLockedEth
      , "total_value_locked_usd" .= uniswapV3PoolDTOTotalValueLockedUsd
      , "total_value_locked_usd_untracked" .= uniswapV3PoolDTOTotalValueLockedUsdUntracked
      , "liquidity_provider_count" .= uniswapV3PoolDTOLiquidityProviderCount
      , "evaluated_ask" .= uniswapV3PoolDTOEvaluatedAsk
      ]


-- | Construct a value of type 'UniswapV3PoolDTO' (by applying it's required fields, if any)
mkUniswapV3PoolDTO
  :: UniswapV3PoolDTO
mkUniswapV3PoolDTO =
  UniswapV3PoolDTO
  { uniswapV3PoolDTOEntryTime = Nothing
  , uniswapV3PoolDTORecvTime = Nothing
  , uniswapV3PoolDTOBlockNumber = Nothing
  , uniswapV3PoolDTOVid = Nothing
  , uniswapV3PoolDTOId = Nothing
  , uniswapV3PoolDTOCreatedAtTimestamp = Nothing
  , uniswapV3PoolDTOToken0 = Nothing
  , uniswapV3PoolDTOToken1 = Nothing
  , uniswapV3PoolDTOFeeTier = Nothing
  , uniswapV3PoolDTOLiquidity = Nothing
  , uniswapV3PoolDTOSqrtPrice = Nothing
  , uniswapV3PoolDTOFeeGrowthGlobal0x128 = Nothing
  , uniswapV3PoolDTOFeeGrowthGlobal1x128 = Nothing
  , uniswapV3PoolDTOToken0Price = Nothing
  , uniswapV3PoolDTOToken1Price = Nothing
  , uniswapV3PoolDTOTick = Nothing
  , uniswapV3PoolDTOObservationIndex = Nothing
  , uniswapV3PoolDTOVolumeToken0 = Nothing
  , uniswapV3PoolDTOVolumeToken1 = Nothing
  , uniswapV3PoolDTOVolumeUsd = Nothing
  , uniswapV3PoolDTOUntrackedVolumeUsd = Nothing
  , uniswapV3PoolDTOFeesUsd = Nothing
  , uniswapV3PoolDTOTxCount = Nothing
  , uniswapV3PoolDTOCollectedFeesToken0 = Nothing
  , uniswapV3PoolDTOCollectedFeesToken1 = Nothing
  , uniswapV3PoolDTOCollectedFeesUsd = Nothing
  , uniswapV3PoolDTOTotalValueLockedToken0 = Nothing
  , uniswapV3PoolDTOTotalValueLockedToken1 = Nothing
  , uniswapV3PoolDTOTotalValueLockedEth = Nothing
  , uniswapV3PoolDTOTotalValueLockedUsd = Nothing
  , uniswapV3PoolDTOTotalValueLockedUsdUntracked = Nothing
  , uniswapV3PoolDTOLiquidityProviderCount = Nothing
  , uniswapV3PoolDTOEvaluatedAsk = Nothing
  }

-- ** UniswapV3PoolDayDataDTO
-- | UniswapV3PoolDayDataDTO
-- Data accumulated and condensed into day stats for each pool.
data UniswapV3PoolDayDataDTO = UniswapV3PoolDayDataDTO
  { uniswapV3PoolDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3PoolDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3PoolDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3PoolDayDataDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (pool address)-(day id).
  , uniswapV3PoolDayDataDTODate :: !(Maybe Int) -- ^ "date" - Timestamp rounded to current day by dividing by 86400
  , uniswapV3PoolDayDataDTOPool :: !(Maybe Text) -- ^ "pool" - Pointer to pool.
  , uniswapV3PoolDayDataDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - In range liquidity at end of period.
  , uniswapV3PoolDayDataDTOSqrtPrice :: !(Maybe Text) -- ^ "sqrt_price" - Current price tracker at end of period.
  , uniswapV3PoolDayDataDTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - Price of token0 - derived from sqrtPrice.
  , uniswapV3PoolDayDataDTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - Price of token1 - derived from sqrtPrice.
  , uniswapV3PoolDayDataDTOTick :: !(Maybe Text) -- ^ "tick" - Current tick at end of period.
  , uniswapV3PoolDayDataDTOFeeGrowthGlobal0x128 :: !(Maybe Text) -- ^ "fee_growth_global_0x128" - Tracker for global fee growth.
  , uniswapV3PoolDayDataDTOFeeGrowthGlobal1x128 :: !(Maybe Text) -- ^ "fee_growth_global_1x128" - Tracker for global fee growth.
  , uniswapV3PoolDayDataDTOTvlUsd :: !(Maybe Text) -- ^ "tvl_usd" - Total value locked derived in USD at end of period.
  , uniswapV3PoolDayDataDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Volume in token0.
  , uniswapV3PoolDayDataDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Volume in token1.
  , uniswapV3PoolDayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Volume in USD.
  , uniswapV3PoolDayDataDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3PoolDayDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Number of transactions during period.
  , uniswapV3PoolDayDataDTOOpen :: !(Maybe Text) -- ^ "open" - Opening price of token0.
  , uniswapV3PoolDayDataDTOHigh :: !(Maybe Text) -- ^ "high" - High price of token0.
  , uniswapV3PoolDayDataDTOLow :: !(Maybe Text) -- ^ "low" - Low price of token0.
  , uniswapV3PoolDayDataDTOClose :: !(Maybe Text) -- ^ "close" - Close price of token0.
  , uniswapV3PoolDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3PoolDayDataDTO
instance A.FromJSON UniswapV3PoolDayDataDTO where
  parseJSON = A.withObject "UniswapV3PoolDayDataDTO" $ \o ->
    UniswapV3PoolDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pool")
      <*> (o .:? "liquidity")
      <*> (o .:? "sqrt_price")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "tick")
      <*> (o .:? "fee_growth_global_0x128")
      <*> (o .:? "fee_growth_global_1x128")
      <*> (o .:? "tvl_usd")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3PoolDayDataDTO
instance A.ToJSON UniswapV3PoolDayDataDTO where
  toJSON UniswapV3PoolDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3PoolDayDataDTOEntryTime
      , "recv_time" .= uniswapV3PoolDayDataDTORecvTime
      , "block_number" .= uniswapV3PoolDayDataDTOBlockNumber
      , "id" .= uniswapV3PoolDayDataDTOId
      , "date" .= uniswapV3PoolDayDataDTODate
      , "pool" .= uniswapV3PoolDayDataDTOPool
      , "liquidity" .= uniswapV3PoolDayDataDTOLiquidity
      , "sqrt_price" .= uniswapV3PoolDayDataDTOSqrtPrice
      , "token_0_price" .= uniswapV3PoolDayDataDTOToken0Price
      , "token_1_price" .= uniswapV3PoolDayDataDTOToken1Price
      , "tick" .= uniswapV3PoolDayDataDTOTick
      , "fee_growth_global_0x128" .= uniswapV3PoolDayDataDTOFeeGrowthGlobal0x128
      , "fee_growth_global_1x128" .= uniswapV3PoolDayDataDTOFeeGrowthGlobal1x128
      , "tvl_usd" .= uniswapV3PoolDayDataDTOTvlUsd
      , "volume_token_0" .= uniswapV3PoolDayDataDTOVolumeToken0
      , "volume_token_1" .= uniswapV3PoolDayDataDTOVolumeToken1
      , "volume_usd" .= uniswapV3PoolDayDataDTOVolumeUsd
      , "fees_usd" .= uniswapV3PoolDayDataDTOFeesUsd
      , "tx_count" .= uniswapV3PoolDayDataDTOTxCount
      , "open" .= uniswapV3PoolDayDataDTOOpen
      , "high" .= uniswapV3PoolDayDataDTOHigh
      , "low" .= uniswapV3PoolDayDataDTOLow
      , "close" .= uniswapV3PoolDayDataDTOClose
      , "vid" .= uniswapV3PoolDayDataDTOVid
      ]


-- | Construct a value of type 'UniswapV3PoolDayDataDTO' (by applying it's required fields, if any)
mkUniswapV3PoolDayDataDTO
  :: UniswapV3PoolDayDataDTO
mkUniswapV3PoolDayDataDTO =
  UniswapV3PoolDayDataDTO
  { uniswapV3PoolDayDataDTOEntryTime = Nothing
  , uniswapV3PoolDayDataDTORecvTime = Nothing
  , uniswapV3PoolDayDataDTOBlockNumber = Nothing
  , uniswapV3PoolDayDataDTOId = Nothing
  , uniswapV3PoolDayDataDTODate = Nothing
  , uniswapV3PoolDayDataDTOPool = Nothing
  , uniswapV3PoolDayDataDTOLiquidity = Nothing
  , uniswapV3PoolDayDataDTOSqrtPrice = Nothing
  , uniswapV3PoolDayDataDTOToken0Price = Nothing
  , uniswapV3PoolDayDataDTOToken1Price = Nothing
  , uniswapV3PoolDayDataDTOTick = Nothing
  , uniswapV3PoolDayDataDTOFeeGrowthGlobal0x128 = Nothing
  , uniswapV3PoolDayDataDTOFeeGrowthGlobal1x128 = Nothing
  , uniswapV3PoolDayDataDTOTvlUsd = Nothing
  , uniswapV3PoolDayDataDTOVolumeToken0 = Nothing
  , uniswapV3PoolDayDataDTOVolumeToken1 = Nothing
  , uniswapV3PoolDayDataDTOVolumeUsd = Nothing
  , uniswapV3PoolDayDataDTOFeesUsd = Nothing
  , uniswapV3PoolDayDataDTOTxCount = Nothing
  , uniswapV3PoolDayDataDTOOpen = Nothing
  , uniswapV3PoolDayDataDTOHigh = Nothing
  , uniswapV3PoolDayDataDTOLow = Nothing
  , uniswapV3PoolDayDataDTOClose = Nothing
  , uniswapV3PoolDayDataDTOVid = Nothing
  }

-- ** UniswapV3PoolHourDataDTO
-- | UniswapV3PoolHourDataDTO
-- Hourly stats tracker for pool.
data UniswapV3PoolHourDataDTO = UniswapV3PoolHourDataDTO
  { uniswapV3PoolHourDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3PoolHourDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3PoolHourDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3PoolHourDataDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (pool address)-(day id)
  , uniswapV3PoolHourDataDTOPeriodStartUnix :: !(Maybe Int) -- ^ "period_start_unix" - Unix timestamp for start of hour.
  , uniswapV3PoolHourDataDTOPool :: !(Maybe Text) -- ^ "pool" - Pointer to pool.
  , uniswapV3PoolHourDataDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - In range liquidity at end of period.
  , uniswapV3PoolHourDataDTOSqrtPrice :: !(Maybe Text) -- ^ "sqrt_price" - Current price tracker at end of period.
  , uniswapV3PoolHourDataDTOToken0Price :: !(Maybe Text) -- ^ "token_0_price" - Price of token0 - derived from sqrtPrice.
  , uniswapV3PoolHourDataDTOToken1Price :: !(Maybe Text) -- ^ "token_1_price" - Price of token1 - derived from sqrtPrice.
  , uniswapV3PoolHourDataDTOTick :: !(Maybe Text) -- ^ "tick" - Current tick at end of period.
  , uniswapV3PoolHourDataDTOFeeGrowthGlobal0x128 :: !(Maybe Text) -- ^ "fee_growth_global_0x128" - Tracker for global fee growth.
  , uniswapV3PoolHourDataDTOFeeGrowthGlobal1x128 :: !(Maybe Text) -- ^ "fee_growth_global_1x128" - Tracker for global fee growth.
  , uniswapV3PoolHourDataDTOTvlUsd :: !(Maybe Text) -- ^ "tvl_usd" - Total value locked derived in USD at end of period.
  , uniswapV3PoolHourDataDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Volume in token0.
  , uniswapV3PoolHourDataDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Volume in token1.
  , uniswapV3PoolHourDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Volume in USD.
  , uniswapV3PoolHourDataDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3PoolHourDataDTOTxCount :: !(Maybe Text) -- ^ "tx_count" - Number of transactions during period.
  , uniswapV3PoolHourDataDTOOpen :: !(Maybe Text) -- ^ "open" - Opening price of token0.
  , uniswapV3PoolHourDataDTOHigh :: !(Maybe Text) -- ^ "high" - High price of token0.
  , uniswapV3PoolHourDataDTOLow :: !(Maybe Text) -- ^ "low" - Low price of token0.
  , uniswapV3PoolHourDataDTOClose :: !(Maybe Text) -- ^ "close" - Close price of token0.
  , uniswapV3PoolHourDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3PoolHourDataDTO
instance A.FromJSON UniswapV3PoolHourDataDTO where
  parseJSON = A.withObject "UniswapV3PoolHourDataDTO" $ \o ->
    UniswapV3PoolHourDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "period_start_unix")
      <*> (o .:? "pool")
      <*> (o .:? "liquidity")
      <*> (o .:? "sqrt_price")
      <*> (o .:? "token_0_price")
      <*> (o .:? "token_1_price")
      <*> (o .:? "tick")
      <*> (o .:? "fee_growth_global_0x128")
      <*> (o .:? "fee_growth_global_1x128")
      <*> (o .:? "tvl_usd")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3PoolHourDataDTO
instance A.ToJSON UniswapV3PoolHourDataDTO where
  toJSON UniswapV3PoolHourDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3PoolHourDataDTOEntryTime
      , "recv_time" .= uniswapV3PoolHourDataDTORecvTime
      , "block_number" .= uniswapV3PoolHourDataDTOBlockNumber
      , "id" .= uniswapV3PoolHourDataDTOId
      , "period_start_unix" .= uniswapV3PoolHourDataDTOPeriodStartUnix
      , "pool" .= uniswapV3PoolHourDataDTOPool
      , "liquidity" .= uniswapV3PoolHourDataDTOLiquidity
      , "sqrt_price" .= uniswapV3PoolHourDataDTOSqrtPrice
      , "token_0_price" .= uniswapV3PoolHourDataDTOToken0Price
      , "token_1_price" .= uniswapV3PoolHourDataDTOToken1Price
      , "tick" .= uniswapV3PoolHourDataDTOTick
      , "fee_growth_global_0x128" .= uniswapV3PoolHourDataDTOFeeGrowthGlobal0x128
      , "fee_growth_global_1x128" .= uniswapV3PoolHourDataDTOFeeGrowthGlobal1x128
      , "tvl_usd" .= uniswapV3PoolHourDataDTOTvlUsd
      , "volume_token_0" .= uniswapV3PoolHourDataDTOVolumeToken0
      , "volume_token_1" .= uniswapV3PoolHourDataDTOVolumeToken1
      , "volume_usd" .= uniswapV3PoolHourDataDTOVolumeUsd
      , "fees_usd" .= uniswapV3PoolHourDataDTOFeesUsd
      , "tx_count" .= uniswapV3PoolHourDataDTOTxCount
      , "open" .= uniswapV3PoolHourDataDTOOpen
      , "high" .= uniswapV3PoolHourDataDTOHigh
      , "low" .= uniswapV3PoolHourDataDTOLow
      , "close" .= uniswapV3PoolHourDataDTOClose
      , "vid" .= uniswapV3PoolHourDataDTOVid
      ]


-- | Construct a value of type 'UniswapV3PoolHourDataDTO' (by applying it's required fields, if any)
mkUniswapV3PoolHourDataDTO
  :: UniswapV3PoolHourDataDTO
mkUniswapV3PoolHourDataDTO =
  UniswapV3PoolHourDataDTO
  { uniswapV3PoolHourDataDTOEntryTime = Nothing
  , uniswapV3PoolHourDataDTORecvTime = Nothing
  , uniswapV3PoolHourDataDTOBlockNumber = Nothing
  , uniswapV3PoolHourDataDTOId = Nothing
  , uniswapV3PoolHourDataDTOPeriodStartUnix = Nothing
  , uniswapV3PoolHourDataDTOPool = Nothing
  , uniswapV3PoolHourDataDTOLiquidity = Nothing
  , uniswapV3PoolHourDataDTOSqrtPrice = Nothing
  , uniswapV3PoolHourDataDTOToken0Price = Nothing
  , uniswapV3PoolHourDataDTOToken1Price = Nothing
  , uniswapV3PoolHourDataDTOTick = Nothing
  , uniswapV3PoolHourDataDTOFeeGrowthGlobal0x128 = Nothing
  , uniswapV3PoolHourDataDTOFeeGrowthGlobal1x128 = Nothing
  , uniswapV3PoolHourDataDTOTvlUsd = Nothing
  , uniswapV3PoolHourDataDTOVolumeToken0 = Nothing
  , uniswapV3PoolHourDataDTOVolumeToken1 = Nothing
  , uniswapV3PoolHourDataDTOVolumeUsd = Nothing
  , uniswapV3PoolHourDataDTOFeesUsd = Nothing
  , uniswapV3PoolHourDataDTOTxCount = Nothing
  , uniswapV3PoolHourDataDTOOpen = Nothing
  , uniswapV3PoolHourDataDTOHigh = Nothing
  , uniswapV3PoolHourDataDTOLow = Nothing
  , uniswapV3PoolHourDataDTOClose = Nothing
  , uniswapV3PoolHourDataDTOVid = Nothing
  }

-- ** UniswapV3PositionDTO
-- | UniswapV3PositionDTO
-- Positions created through NonfungiblePositionManager. Positions are represented as NFTs (ERC-721 tokens) as opposed to the fungible ERC-20 tokens on Uniswap V1 and V2.
data UniswapV3PositionDTO = UniswapV3PositionDTO
  { uniswapV3PositionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3PositionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3PositionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3PositionDTOId :: !(Maybe Text) -- ^ "id" - NFT token identifier.
  , uniswapV3PositionDTOOwner :: !(Maybe Text) -- ^ "owner" - Owner of the NFT.
  , uniswapV3PositionDTOPool :: !(Maybe Text) -- ^ "pool" - Pool position is within.
  , uniswapV3PositionDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pair contract.
  , uniswapV3PositionDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pair contract.
  , uniswapV3PositionDTOTickLower :: !(Maybe Text) -- ^ "tick_lower" - Lower tick of the position.
  , uniswapV3PositionDTOTickUpper :: !(Maybe Text) -- ^ "tick_upper" - Upper tick of the position.
  , uniswapV3PositionDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Total position liquidity.
  , uniswapV3PositionDTODepositedToken0 :: !(Maybe Text) -- ^ "deposited_token_0" - Amount of token 0 ever deposited to position.
  , uniswapV3PositionDTODepositedToken1 :: !(Maybe Text) -- ^ "deposited_token_1" - Amount of token 1 ever deposited to position.
  , uniswapV3PositionDTOWithdrawnToken0 :: !(Maybe Text) -- ^ "withdrawn_token_0" - Amount of token 0 ever withdrawn from position (without fees).
  , uniswapV3PositionDTOWithdrawnToken1 :: !(Maybe Text) -- ^ "withdrawn_token_1" - Amount of token 1 ever withdrawn from position (without fees).
  , uniswapV3PositionDTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - All time collected fees in token0.
  , uniswapV3PositionDTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - All time collected fees in token1.
  , uniswapV3PositionDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Transaction in which the position was initialized.
  , uniswapV3PositionDTOFeeGrowthInside0LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_0_last_x128" - Variable needed for fee computation.
  , uniswapV3PositionDTOFeeGrowthInside1LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_1_last_x128" - Variable needed for fee computation.
  , uniswapV3PositionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3PositionDTO
instance A.FromJSON UniswapV3PositionDTO where
  parseJSON = A.withObject "UniswapV3PositionDTO" $ \o ->
    UniswapV3PositionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "owner")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "tick_lower")
      <*> (o .:? "tick_upper")
      <*> (o .:? "liquidity")
      <*> (o .:? "deposited_token_0")
      <*> (o .:? "deposited_token_1")
      <*> (o .:? "withdrawn_token_0")
      <*> (o .:? "withdrawn_token_1")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "transaction")
      <*> (o .:? "fee_growth_inside_0_last_x128")
      <*> (o .:? "fee_growth_inside_1_last_x128")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3PositionDTO
instance A.ToJSON UniswapV3PositionDTO where
  toJSON UniswapV3PositionDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3PositionDTOEntryTime
      , "recv_time" .= uniswapV3PositionDTORecvTime
      , "block_number" .= uniswapV3PositionDTOBlockNumber
      , "id" .= uniswapV3PositionDTOId
      , "owner" .= uniswapV3PositionDTOOwner
      , "pool" .= uniswapV3PositionDTOPool
      , "token_0" .= uniswapV3PositionDTOToken0
      , "token_1" .= uniswapV3PositionDTOToken1
      , "tick_lower" .= uniswapV3PositionDTOTickLower
      , "tick_upper" .= uniswapV3PositionDTOTickUpper
      , "liquidity" .= uniswapV3PositionDTOLiquidity
      , "deposited_token_0" .= uniswapV3PositionDTODepositedToken0
      , "deposited_token_1" .= uniswapV3PositionDTODepositedToken1
      , "withdrawn_token_0" .= uniswapV3PositionDTOWithdrawnToken0
      , "withdrawn_token_1" .= uniswapV3PositionDTOWithdrawnToken1
      , "collected_fees_token_0" .= uniswapV3PositionDTOCollectedFeesToken0
      , "collected_fees_token_1" .= uniswapV3PositionDTOCollectedFeesToken1
      , "transaction" .= uniswapV3PositionDTOTransaction
      , "fee_growth_inside_0_last_x128" .= uniswapV3PositionDTOFeeGrowthInside0LastX128
      , "fee_growth_inside_1_last_x128" .= uniswapV3PositionDTOFeeGrowthInside1LastX128
      , "vid" .= uniswapV3PositionDTOVid
      ]


-- | Construct a value of type 'UniswapV3PositionDTO' (by applying it's required fields, if any)
mkUniswapV3PositionDTO
  :: UniswapV3PositionDTO
mkUniswapV3PositionDTO =
  UniswapV3PositionDTO
  { uniswapV3PositionDTOEntryTime = Nothing
  , uniswapV3PositionDTORecvTime = Nothing
  , uniswapV3PositionDTOBlockNumber = Nothing
  , uniswapV3PositionDTOId = Nothing
  , uniswapV3PositionDTOOwner = Nothing
  , uniswapV3PositionDTOPool = Nothing
  , uniswapV3PositionDTOToken0 = Nothing
  , uniswapV3PositionDTOToken1 = Nothing
  , uniswapV3PositionDTOTickLower = Nothing
  , uniswapV3PositionDTOTickUpper = Nothing
  , uniswapV3PositionDTOLiquidity = Nothing
  , uniswapV3PositionDTODepositedToken0 = Nothing
  , uniswapV3PositionDTODepositedToken1 = Nothing
  , uniswapV3PositionDTOWithdrawnToken0 = Nothing
  , uniswapV3PositionDTOWithdrawnToken1 = Nothing
  , uniswapV3PositionDTOCollectedFeesToken0 = Nothing
  , uniswapV3PositionDTOCollectedFeesToken1 = Nothing
  , uniswapV3PositionDTOTransaction = Nothing
  , uniswapV3PositionDTOFeeGrowthInside0LastX128 = Nothing
  , uniswapV3PositionDTOFeeGrowthInside1LastX128 = Nothing
  , uniswapV3PositionDTOVid = Nothing
  }

-- ** UniswapV3PositionSnapshotDTO
-- | UniswapV3PositionSnapshotDTO
data UniswapV3PositionSnapshotDTO = UniswapV3PositionSnapshotDTO
  { uniswapV3PositionSnapshotDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3PositionSnapshotDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3PositionSnapshotDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3PositionSnapshotDTOId :: !(Maybe Text) -- ^ "id" - NFT token identifier, format: (NFT token id)#(block number).
  , uniswapV3PositionSnapshotDTOOwner :: !(Maybe Text) -- ^ "owner" - Owner of the NFT.
  , uniswapV3PositionSnapshotDTOPool :: !(Maybe Text) -- ^ "pool" - Pool the position is within.
  , uniswapV3PositionSnapshotDTOPosition :: !(Maybe Text) -- ^ "position" - Position of which the snap was taken of.
  , uniswapV3PositionSnapshotDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp of block in which the snap was created.
  , uniswapV3PositionSnapshotDTOLiquidity :: !(Maybe Text) -- ^ "liquidity" - Total position liquidity.
  , uniswapV3PositionSnapshotDTODepositedToken0 :: !(Maybe Text) -- ^ "deposited_token_0" - Amount of token 0 ever deposited to position.
  , uniswapV3PositionSnapshotDTODepositedToken1 :: !(Maybe Text) -- ^ "deposited_token_1" - Amount of token 1 ever deposited to position.
  , uniswapV3PositionSnapshotDTOWithdrawnToken0 :: !(Maybe Text) -- ^ "withdrawn_token_0" - Amount of token 0 ever withdrawn from position (without fees).
  , uniswapV3PositionSnapshotDTOWithdrawnToken1 :: !(Maybe Text) -- ^ "withdrawn_token_1" - Amount of token 1 ever withdrawn from position (without fees).
  , uniswapV3PositionSnapshotDTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - All time collected fees in token0.
  , uniswapV3PositionSnapshotDTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - All time collected fees in token1.
  , uniswapV3PositionSnapshotDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Transaction in which the snapshot was initialized.
  , uniswapV3PositionSnapshotDTOFeeGrowthInside0LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_0_last_x128" - Variable needed for fee computation.
  , uniswapV3PositionSnapshotDTOFeeGrowthInside1LastX128 :: !(Maybe Text) -- ^ "fee_growth_inside_1_last_x128" - Variable needed for fee computation.
  , uniswapV3PositionSnapshotDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3PositionSnapshotDTO
instance A.FromJSON UniswapV3PositionSnapshotDTO where
  parseJSON = A.withObject "UniswapV3PositionSnapshotDTO" $ \o ->
    UniswapV3PositionSnapshotDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "owner")
      <*> (o .:? "pool")
      <*> (o .:? "position")
      <*> (o .:? "timestamp")
      <*> (o .:? "liquidity")
      <*> (o .:? "deposited_token_0")
      <*> (o .:? "deposited_token_1")
      <*> (o .:? "withdrawn_token_0")
      <*> (o .:? "withdrawn_token_1")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "transaction")
      <*> (o .:? "fee_growth_inside_0_last_x128")
      <*> (o .:? "fee_growth_inside_1_last_x128")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3PositionSnapshotDTO
instance A.ToJSON UniswapV3PositionSnapshotDTO where
  toJSON UniswapV3PositionSnapshotDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3PositionSnapshotDTOEntryTime
      , "recv_time" .= uniswapV3PositionSnapshotDTORecvTime
      , "block_number" .= uniswapV3PositionSnapshotDTOBlockNumber
      , "id" .= uniswapV3PositionSnapshotDTOId
      , "owner" .= uniswapV3PositionSnapshotDTOOwner
      , "pool" .= uniswapV3PositionSnapshotDTOPool
      , "position" .= uniswapV3PositionSnapshotDTOPosition
      , "timestamp" .= uniswapV3PositionSnapshotDTOTimestamp
      , "liquidity" .= uniswapV3PositionSnapshotDTOLiquidity
      , "deposited_token_0" .= uniswapV3PositionSnapshotDTODepositedToken0
      , "deposited_token_1" .= uniswapV3PositionSnapshotDTODepositedToken1
      , "withdrawn_token_0" .= uniswapV3PositionSnapshotDTOWithdrawnToken0
      , "withdrawn_token_1" .= uniswapV3PositionSnapshotDTOWithdrawnToken1
      , "collected_fees_token_0" .= uniswapV3PositionSnapshotDTOCollectedFeesToken0
      , "collected_fees_token_1" .= uniswapV3PositionSnapshotDTOCollectedFeesToken1
      , "transaction" .= uniswapV3PositionSnapshotDTOTransaction
      , "fee_growth_inside_0_last_x128" .= uniswapV3PositionSnapshotDTOFeeGrowthInside0LastX128
      , "fee_growth_inside_1_last_x128" .= uniswapV3PositionSnapshotDTOFeeGrowthInside1LastX128
      , "vid" .= uniswapV3PositionSnapshotDTOVid
      ]


-- | Construct a value of type 'UniswapV3PositionSnapshotDTO' (by applying it's required fields, if any)
mkUniswapV3PositionSnapshotDTO
  :: UniswapV3PositionSnapshotDTO
mkUniswapV3PositionSnapshotDTO =
  UniswapV3PositionSnapshotDTO
  { uniswapV3PositionSnapshotDTOEntryTime = Nothing
  , uniswapV3PositionSnapshotDTORecvTime = Nothing
  , uniswapV3PositionSnapshotDTOBlockNumber = Nothing
  , uniswapV3PositionSnapshotDTOId = Nothing
  , uniswapV3PositionSnapshotDTOOwner = Nothing
  , uniswapV3PositionSnapshotDTOPool = Nothing
  , uniswapV3PositionSnapshotDTOPosition = Nothing
  , uniswapV3PositionSnapshotDTOTimestamp = Nothing
  , uniswapV3PositionSnapshotDTOLiquidity = Nothing
  , uniswapV3PositionSnapshotDTODepositedToken0 = Nothing
  , uniswapV3PositionSnapshotDTODepositedToken1 = Nothing
  , uniswapV3PositionSnapshotDTOWithdrawnToken0 = Nothing
  , uniswapV3PositionSnapshotDTOWithdrawnToken1 = Nothing
  , uniswapV3PositionSnapshotDTOCollectedFeesToken0 = Nothing
  , uniswapV3PositionSnapshotDTOCollectedFeesToken1 = Nothing
  , uniswapV3PositionSnapshotDTOTransaction = Nothing
  , uniswapV3PositionSnapshotDTOFeeGrowthInside0LastX128 = Nothing
  , uniswapV3PositionSnapshotDTOFeeGrowthInside1LastX128 = Nothing
  , uniswapV3PositionSnapshotDTOVid = Nothing
  }

-- ** UniswapV3SwapDTO
-- | UniswapV3SwapDTO
-- Swap are created for each token swap within a pair.
data UniswapV3SwapDTO = UniswapV3SwapDTO
  { uniswapV3SwapDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3SwapDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3SwapDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3SwapDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3SwapDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (transaction hash) + # + (index in swaps Transaction array).
  , uniswapV3SwapDTOTransaction :: !(Maybe Text) -- ^ "transaction" - Pointer to transaction.
  , uniswapV3SwapDTOTimestamp :: !(Maybe DateTime) -- ^ "timestamp" - Timestamp of transaction.
  , uniswapV3SwapDTOPool :: !(Maybe Text) -- ^ "pool" - Pool swap occured within.
  , uniswapV3SwapDTOToken0 :: !(Maybe Text) -- ^ "token_0" - Reference to token0 as stored in pair contract.
  , uniswapV3SwapDTOToken1 :: !(Maybe Text) -- ^ "token_1" - Reference to token1 as stored in pair contract.
  , uniswapV3SwapDTOSender :: !(Maybe Text) -- ^ "sender" - Sender of the swap.
  , uniswapV3SwapDTORecipient :: !(Maybe Text) -- ^ "recipient" - Recipient of the swap.
  , uniswapV3SwapDTOOrigin :: !(Maybe Text) -- ^ "origin" - Transaction origin: the EOA (Externally Owned Account) that initiated the transaction
  , uniswapV3SwapDTOAmount0 :: !(Maybe Text) -- ^ "amount_0" - Delta of token0 swapped.
  , uniswapV3SwapDTOAmount1 :: !(Maybe Text) -- ^ "amount_1" - Delta of token1 swapped.
  , uniswapV3SwapDTOAmountUsd :: !(Maybe Text) -- ^ "amount_usd" - Derived amount of tokens sold in USD.
  , uniswapV3SwapDTOSqrtPriceX96 :: !(Maybe NumericsBigInteger) -- ^ "sqrt_price_x96"
  , uniswapV3SwapDTOTick :: !(Maybe NumericsBigInteger) -- ^ "tick"
  , uniswapV3SwapDTOLogIndex :: !(Maybe NumericsBigInteger) -- ^ "log_index"
  , uniswapV3SwapDTOEvaluatedPrice :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_price"
  , uniswapV3SwapDTOEvaluatedAmount :: !(Maybe Double) -- ^ /ReadOnly/ "evaluated_amount"
  , uniswapV3SwapDTOEvaluatedAggressor :: !(Maybe TransactionsETradeAggressiveSide) -- ^ "evaluated_aggressor"
  , uniswapV3SwapDTOPoolId :: !(Maybe Text) -- ^ /ReadOnly/ "pool_id"
  , uniswapV3SwapDTOTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "transaction_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3SwapDTO
instance A.FromJSON UniswapV3SwapDTO where
  parseJSON = A.withObject "UniswapV3SwapDTO" $ \o ->
    UniswapV3SwapDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "pool")
      <*> (o .:? "token_0")
      <*> (o .:? "token_1")
      <*> (o .:? "sender")
      <*> (o .:? "recipient")
      <*> (o .:? "origin")
      <*> (o .:? "amount_0")
      <*> (o .:? "amount_1")
      <*> (o .:? "amount_usd")
      <*> (o .:? "sqrt_price_x96")
      <*> (o .:? "tick")
      <*> (o .:? "log_index")
      <*> (o .:? "evaluated_price")
      <*> (o .:? "evaluated_amount")
      <*> (o .:? "evaluated_aggressor")
      <*> (o .:? "pool_id")
      <*> (o .:? "transaction_id")

-- | ToJSON UniswapV3SwapDTO
instance A.ToJSON UniswapV3SwapDTO where
  toJSON UniswapV3SwapDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3SwapDTOEntryTime
      , "recv_time" .= uniswapV3SwapDTORecvTime
      , "block_number" .= uniswapV3SwapDTOBlockNumber
      , "vid" .= uniswapV3SwapDTOVid
      , "id" .= uniswapV3SwapDTOId
      , "transaction" .= uniswapV3SwapDTOTransaction
      , "timestamp" .= uniswapV3SwapDTOTimestamp
      , "pool" .= uniswapV3SwapDTOPool
      , "token_0" .= uniswapV3SwapDTOToken0
      , "token_1" .= uniswapV3SwapDTOToken1
      , "sender" .= uniswapV3SwapDTOSender
      , "recipient" .= uniswapV3SwapDTORecipient
      , "origin" .= uniswapV3SwapDTOOrigin
      , "amount_0" .= uniswapV3SwapDTOAmount0
      , "amount_1" .= uniswapV3SwapDTOAmount1
      , "amount_usd" .= uniswapV3SwapDTOAmountUsd
      , "sqrt_price_x96" .= uniswapV3SwapDTOSqrtPriceX96
      , "tick" .= uniswapV3SwapDTOTick
      , "log_index" .= uniswapV3SwapDTOLogIndex
      , "evaluated_price" .= uniswapV3SwapDTOEvaluatedPrice
      , "evaluated_amount" .= uniswapV3SwapDTOEvaluatedAmount
      , "evaluated_aggressor" .= uniswapV3SwapDTOEvaluatedAggressor
      , "pool_id" .= uniswapV3SwapDTOPoolId
      , "transaction_id" .= uniswapV3SwapDTOTransactionId
      ]


-- | Construct a value of type 'UniswapV3SwapDTO' (by applying it's required fields, if any)
mkUniswapV3SwapDTO
  :: UniswapV3SwapDTO
mkUniswapV3SwapDTO =
  UniswapV3SwapDTO
  { uniswapV3SwapDTOEntryTime = Nothing
  , uniswapV3SwapDTORecvTime = Nothing
  , uniswapV3SwapDTOBlockNumber = Nothing
  , uniswapV3SwapDTOVid = Nothing
  , uniswapV3SwapDTOId = Nothing
  , uniswapV3SwapDTOTransaction = Nothing
  , uniswapV3SwapDTOTimestamp = Nothing
  , uniswapV3SwapDTOPool = Nothing
  , uniswapV3SwapDTOToken0 = Nothing
  , uniswapV3SwapDTOToken1 = Nothing
  , uniswapV3SwapDTOSender = Nothing
  , uniswapV3SwapDTORecipient = Nothing
  , uniswapV3SwapDTOOrigin = Nothing
  , uniswapV3SwapDTOAmount0 = Nothing
  , uniswapV3SwapDTOAmount1 = Nothing
  , uniswapV3SwapDTOAmountUsd = Nothing
  , uniswapV3SwapDTOSqrtPriceX96 = Nothing
  , uniswapV3SwapDTOTick = Nothing
  , uniswapV3SwapDTOLogIndex = Nothing
  , uniswapV3SwapDTOEvaluatedPrice = Nothing
  , uniswapV3SwapDTOEvaluatedAmount = Nothing
  , uniswapV3SwapDTOEvaluatedAggressor = Nothing
  , uniswapV3SwapDTOPoolId = Nothing
  , uniswapV3SwapDTOTransactionId = Nothing
  }

-- ** UniswapV3TickDTO
-- | UniswapV3TickDTO
-- Ticks are the boundaries between discrete areas in price space.
data UniswapV3TickDTO = UniswapV3TickDTO
  { uniswapV3TickDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TickDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TickDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TickDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3TickDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (pool address)#(tick index)
  , uniswapV3TickDTOPoolAddress :: !(Maybe Text) -- ^ "pool_address" - Pool address.
  , uniswapV3TickDTOTickIdx :: !(Maybe NumericsBigInteger) -- ^ "tick_idx"
  , uniswapV3TickDTOPool :: !(Maybe Text) -- ^ "pool" - Pool address.
  , uniswapV3TickDTOLiquidityGross :: !(Maybe NumericsBigInteger) -- ^ "liquidity_gross"
  , uniswapV3TickDTOLiquidityNet :: !(Maybe NumericsBigInteger) -- ^ "liquidity_net"
  , uniswapV3TickDTOPrice0 :: !(Maybe Text) -- ^ "price_0" - Calculated price of token0 of tick within this pool - constant.
  , uniswapV3TickDTOPrice1 :: !(Maybe Text) -- ^ "price_1" - Calculated price of token1 of tick within this pool - constant.
  , uniswapV3TickDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Lifetime volume of token0 with this tick in range.
  , uniswapV3TickDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Lifetime volume of token1 with this tick in range.
  , uniswapV3TickDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Lifetime volume in derived USD with this tick in range.
  , uniswapV3TickDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Lifetime volume in untracked USD with this tick in range.
  , uniswapV3TickDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3TickDTOCollectedFeesToken0 :: !(Maybe Text) -- ^ "collected_fees_token_0" - All time collected fees in token0.
  , uniswapV3TickDTOCollectedFeesToken1 :: !(Maybe Text) -- ^ "collected_fees_token_1" - All time collected fees in token1.
  , uniswapV3TickDTOCollectedFeesUsd :: !(Maybe Text) -- ^ "collected_fees_usd" - All time collected fees in USD.
  , uniswapV3TickDTOCreatedAtTimestamp :: !(Maybe DateTime) -- ^ "created_at_timestamp" - Created time.
  , uniswapV3TickDTOLiquidityProviderCount :: !(Maybe NumericsBigInteger) -- ^ "liquidity_provider_count"
  , uniswapV3TickDTOFeeGrowthOutside0x128 :: !(Maybe NumericsBigInteger) -- ^ "fee_growth_outside_0x128"
  , uniswapV3TickDTOFeeGrowthOutside1x128 :: !(Maybe NumericsBigInteger) -- ^ "fee_growth_outside_1x128"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TickDTO
instance A.FromJSON UniswapV3TickDTO where
  parseJSON = A.withObject "UniswapV3TickDTO" $ \o ->
    UniswapV3TickDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "pool_address")
      <*> (o .:? "tick_idx")
      <*> (o .:? "pool")
      <*> (o .:? "liquidity_gross")
      <*> (o .:? "liquidity_net")
      <*> (o .:? "price_0")
      <*> (o .:? "price_1")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "collected_fees_token_0")
      <*> (o .:? "collected_fees_token_1")
      <*> (o .:? "collected_fees_usd")
      <*> (o .:? "created_at_timestamp")
      <*> (o .:? "liquidity_provider_count")
      <*> (o .:? "fee_growth_outside_0x128")
      <*> (o .:? "fee_growth_outside_1x128")

-- | ToJSON UniswapV3TickDTO
instance A.ToJSON UniswapV3TickDTO where
  toJSON UniswapV3TickDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TickDTOEntryTime
      , "recv_time" .= uniswapV3TickDTORecvTime
      , "block_number" .= uniswapV3TickDTOBlockNumber
      , "vid" .= uniswapV3TickDTOVid
      , "id" .= uniswapV3TickDTOId
      , "pool_address" .= uniswapV3TickDTOPoolAddress
      , "tick_idx" .= uniswapV3TickDTOTickIdx
      , "pool" .= uniswapV3TickDTOPool
      , "liquidity_gross" .= uniswapV3TickDTOLiquidityGross
      , "liquidity_net" .= uniswapV3TickDTOLiquidityNet
      , "price_0" .= uniswapV3TickDTOPrice0
      , "price_1" .= uniswapV3TickDTOPrice1
      , "volume_token_0" .= uniswapV3TickDTOVolumeToken0
      , "volume_token_1" .= uniswapV3TickDTOVolumeToken1
      , "volume_usd" .= uniswapV3TickDTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV3TickDTOUntrackedVolumeUsd
      , "fees_usd" .= uniswapV3TickDTOFeesUsd
      , "collected_fees_token_0" .= uniswapV3TickDTOCollectedFeesToken0
      , "collected_fees_token_1" .= uniswapV3TickDTOCollectedFeesToken1
      , "collected_fees_usd" .= uniswapV3TickDTOCollectedFeesUsd
      , "created_at_timestamp" .= uniswapV3TickDTOCreatedAtTimestamp
      , "liquidity_provider_count" .= uniswapV3TickDTOLiquidityProviderCount
      , "fee_growth_outside_0x128" .= uniswapV3TickDTOFeeGrowthOutside0x128
      , "fee_growth_outside_1x128" .= uniswapV3TickDTOFeeGrowthOutside1x128
      ]


-- | Construct a value of type 'UniswapV3TickDTO' (by applying it's required fields, if any)
mkUniswapV3TickDTO
  :: UniswapV3TickDTO
mkUniswapV3TickDTO =
  UniswapV3TickDTO
  { uniswapV3TickDTOEntryTime = Nothing
  , uniswapV3TickDTORecvTime = Nothing
  , uniswapV3TickDTOBlockNumber = Nothing
  , uniswapV3TickDTOVid = Nothing
  , uniswapV3TickDTOId = Nothing
  , uniswapV3TickDTOPoolAddress = Nothing
  , uniswapV3TickDTOTickIdx = Nothing
  , uniswapV3TickDTOPool = Nothing
  , uniswapV3TickDTOLiquidityGross = Nothing
  , uniswapV3TickDTOLiquidityNet = Nothing
  , uniswapV3TickDTOPrice0 = Nothing
  , uniswapV3TickDTOPrice1 = Nothing
  , uniswapV3TickDTOVolumeToken0 = Nothing
  , uniswapV3TickDTOVolumeToken1 = Nothing
  , uniswapV3TickDTOVolumeUsd = Nothing
  , uniswapV3TickDTOUntrackedVolumeUsd = Nothing
  , uniswapV3TickDTOFeesUsd = Nothing
  , uniswapV3TickDTOCollectedFeesToken0 = Nothing
  , uniswapV3TickDTOCollectedFeesToken1 = Nothing
  , uniswapV3TickDTOCollectedFeesUsd = Nothing
  , uniswapV3TickDTOCreatedAtTimestamp = Nothing
  , uniswapV3TickDTOLiquidityProviderCount = Nothing
  , uniswapV3TickDTOFeeGrowthOutside0x128 = Nothing
  , uniswapV3TickDTOFeeGrowthOutside1x128 = Nothing
  }

-- ** UniswapV3TickDayDataDTO
-- | UniswapV3TickDayDataDTO
-- Data accumulated and condensed into day stats for each exchange. Entity gets saved only if there is a change during the day
data UniswapV3TickDayDataDTO = UniswapV3TickDayDataDTO
  { uniswapV3TickDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TickDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TickDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TickDayDataDTOId :: !(Maybe Text) -- ^ "id" - Identifier, format: (pool address)-(tick index)-(timestamp).
  , uniswapV3TickDayDataDTODate :: !(Maybe Int) -- ^ "date" - Timestamp rounded to current day by dividing by 86400.
  , uniswapV3TickDayDataDTOPool :: !(Maybe Text) -- ^ "pool" - Pointer to pool.
  , uniswapV3TickDayDataDTOTick :: !(Maybe Text) -- ^ "tick" - Pointer to tick.
  , uniswapV3TickDayDataDTOLiquidityGross :: !(Maybe Text) -- ^ "liquidity_gross" - Total liquidity pool has as tick lower or upper at end of period.
  , uniswapV3TickDayDataDTOLiquidityNet :: !(Maybe Text) -- ^ "liquidity_net" - How much liquidity changes when tick crossed at end of period.
  , uniswapV3TickDayDataDTOVolumeToken0 :: !(Maybe Text) -- ^ "volume_token_0" - Hourly volume of token0 with this tick in range.
  , uniswapV3TickDayDataDTOVolumeToken1 :: !(Maybe Text) -- ^ "volume_token_1" - Hourly volume of token1 with this tick in range.
  , uniswapV3TickDayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Hourly volume in derived USD with this tick in range.
  , uniswapV3TickDayDataDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3TickDayDataDTOFeeGrowthOutside0x128 :: !(Maybe Text) -- ^ "fee_growth_outside_0x128" - Variable needed for fee computation.
  , uniswapV3TickDayDataDTOFeeGrowthOutside1x128 :: !(Maybe Text) -- ^ "fee_growth_outside_1x128" - Variable needed for fee computation.
  , uniswapV3TickDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TickDayDataDTO
instance A.FromJSON UniswapV3TickDayDataDTO where
  parseJSON = A.withObject "UniswapV3TickDayDataDTO" $ \o ->
    UniswapV3TickDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "pool")
      <*> (o .:? "tick")
      <*> (o .:? "liquidity_gross")
      <*> (o .:? "liquidity_net")
      <*> (o .:? "volume_token_0")
      <*> (o .:? "volume_token_1")
      <*> (o .:? "volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "fee_growth_outside_0x128")
      <*> (o .:? "fee_growth_outside_1x128")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3TickDayDataDTO
instance A.ToJSON UniswapV3TickDayDataDTO where
  toJSON UniswapV3TickDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TickDayDataDTOEntryTime
      , "recv_time" .= uniswapV3TickDayDataDTORecvTime
      , "block_number" .= uniswapV3TickDayDataDTOBlockNumber
      , "id" .= uniswapV3TickDayDataDTOId
      , "date" .= uniswapV3TickDayDataDTODate
      , "pool" .= uniswapV3TickDayDataDTOPool
      , "tick" .= uniswapV3TickDayDataDTOTick
      , "liquidity_gross" .= uniswapV3TickDayDataDTOLiquidityGross
      , "liquidity_net" .= uniswapV3TickDayDataDTOLiquidityNet
      , "volume_token_0" .= uniswapV3TickDayDataDTOVolumeToken0
      , "volume_token_1" .= uniswapV3TickDayDataDTOVolumeToken1
      , "volume_usd" .= uniswapV3TickDayDataDTOVolumeUsd
      , "fees_usd" .= uniswapV3TickDayDataDTOFeesUsd
      , "fee_growth_outside_0x128" .= uniswapV3TickDayDataDTOFeeGrowthOutside0x128
      , "fee_growth_outside_1x128" .= uniswapV3TickDayDataDTOFeeGrowthOutside1x128
      , "vid" .= uniswapV3TickDayDataDTOVid
      ]


-- | Construct a value of type 'UniswapV3TickDayDataDTO' (by applying it's required fields, if any)
mkUniswapV3TickDayDataDTO
  :: UniswapV3TickDayDataDTO
mkUniswapV3TickDayDataDTO =
  UniswapV3TickDayDataDTO
  { uniswapV3TickDayDataDTOEntryTime = Nothing
  , uniswapV3TickDayDataDTORecvTime = Nothing
  , uniswapV3TickDayDataDTOBlockNumber = Nothing
  , uniswapV3TickDayDataDTOId = Nothing
  , uniswapV3TickDayDataDTODate = Nothing
  , uniswapV3TickDayDataDTOPool = Nothing
  , uniswapV3TickDayDataDTOTick = Nothing
  , uniswapV3TickDayDataDTOLiquidityGross = Nothing
  , uniswapV3TickDayDataDTOLiquidityNet = Nothing
  , uniswapV3TickDayDataDTOVolumeToken0 = Nothing
  , uniswapV3TickDayDataDTOVolumeToken1 = Nothing
  , uniswapV3TickDayDataDTOVolumeUsd = Nothing
  , uniswapV3TickDayDataDTOFeesUsd = Nothing
  , uniswapV3TickDayDataDTOFeeGrowthOutside0x128 = Nothing
  , uniswapV3TickDayDataDTOFeeGrowthOutside1x128 = Nothing
  , uniswapV3TickDayDataDTOVid = Nothing
  }

-- ** UniswapV3TokenDTO
-- | UniswapV3TokenDTO
-- Stores aggregated information for a specific token across all pairs that token is included in.
data UniswapV3TokenDTO = UniswapV3TokenDTO
  { uniswapV3TokenDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TokenDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TokenDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TokenDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3TokenDTOId :: !(Maybe Text) -- ^ "id" - Token address.
  , uniswapV3TokenDTOSymbol :: !(Maybe Text) -- ^ "symbol" - Token symbol.
  , uniswapV3TokenDTOName :: !(Maybe Text) -- ^ "name" - Token name.
  , uniswapV3TokenDTODecimals :: !(Maybe Int) -- ^ "decimals" - Token decimals.
  , uniswapV3TokenDTOTotalSupply :: !(Maybe NumericsBigInteger) -- ^ "total_supply"
  , uniswapV3TokenDTOVolume :: !(Maybe Text) -- ^ "volume" - Volume in token units.
  , uniswapV3TokenDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Volume in derived USD.
  , uniswapV3TokenDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Volume in USD even on pools with less reliable USD values.
  , uniswapV3TokenDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3TokenDTOTxCount :: !(Maybe NumericsBigInteger) -- ^ "tx_count"
  , uniswapV3TokenDTOPoolCount :: !(Maybe NumericsBigInteger) -- ^ "pool_count"
  , uniswapV3TokenDTOTotalValueLocked :: !(Maybe Text) -- ^ "total_value_locked" - Liquidity across all pools in token units.
  , uniswapV3TokenDTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - Liquidity across all pools in derived USD.
  , uniswapV3TokenDTOTotalValueLockedUsdUntracked :: !(Maybe Text) -- ^ "total_value_locked_usd_untracked" - TVL derived in USD untracked.
  , uniswapV3TokenDTODerivedEth :: !(Maybe Text) -- ^ "derived_eth" - Derived price in ETH.
  , uniswapV3TokenDTOWhitelistPools :: !(Maybe [Text]) -- ^ "whitelist_pools" - Pools token is in that are white listed for USD pricing.
  , uniswapV3TokenDTOTokenSymbol :: !(Maybe Text) -- ^ /ReadOnly/ "token_symbol"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TokenDTO
instance A.FromJSON UniswapV3TokenDTO where
  parseJSON = A.withObject "UniswapV3TokenDTO" $ \o ->
    UniswapV3TokenDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "symbol")
      <*> (o .:? "name")
      <*> (o .:? "decimals")
      <*> (o .:? "total_supply")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "pool_count")
      <*> (o .:? "total_value_locked")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "total_value_locked_usd_untracked")
      <*> (o .:? "derived_eth")
      <*> (o .:? "whitelist_pools")
      <*> (o .:? "token_symbol")

-- | ToJSON UniswapV3TokenDTO
instance A.ToJSON UniswapV3TokenDTO where
  toJSON UniswapV3TokenDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TokenDTOEntryTime
      , "recv_time" .= uniswapV3TokenDTORecvTime
      , "block_number" .= uniswapV3TokenDTOBlockNumber
      , "vid" .= uniswapV3TokenDTOVid
      , "id" .= uniswapV3TokenDTOId
      , "symbol" .= uniswapV3TokenDTOSymbol
      , "name" .= uniswapV3TokenDTOName
      , "decimals" .= uniswapV3TokenDTODecimals
      , "total_supply" .= uniswapV3TokenDTOTotalSupply
      , "volume" .= uniswapV3TokenDTOVolume
      , "volume_usd" .= uniswapV3TokenDTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV3TokenDTOUntrackedVolumeUsd
      , "fees_usd" .= uniswapV3TokenDTOFeesUsd
      , "tx_count" .= uniswapV3TokenDTOTxCount
      , "pool_count" .= uniswapV3TokenDTOPoolCount
      , "total_value_locked" .= uniswapV3TokenDTOTotalValueLocked
      , "total_value_locked_usd" .= uniswapV3TokenDTOTotalValueLockedUsd
      , "total_value_locked_usd_untracked" .= uniswapV3TokenDTOTotalValueLockedUsdUntracked
      , "derived_eth" .= uniswapV3TokenDTODerivedEth
      , "whitelist_pools" .= uniswapV3TokenDTOWhitelistPools
      , "token_symbol" .= uniswapV3TokenDTOTokenSymbol
      ]


-- | Construct a value of type 'UniswapV3TokenDTO' (by applying it's required fields, if any)
mkUniswapV3TokenDTO
  :: UniswapV3TokenDTO
mkUniswapV3TokenDTO =
  UniswapV3TokenDTO
  { uniswapV3TokenDTOEntryTime = Nothing
  , uniswapV3TokenDTORecvTime = Nothing
  , uniswapV3TokenDTOBlockNumber = Nothing
  , uniswapV3TokenDTOVid = Nothing
  , uniswapV3TokenDTOId = Nothing
  , uniswapV3TokenDTOSymbol = Nothing
  , uniswapV3TokenDTOName = Nothing
  , uniswapV3TokenDTODecimals = Nothing
  , uniswapV3TokenDTOTotalSupply = Nothing
  , uniswapV3TokenDTOVolume = Nothing
  , uniswapV3TokenDTOVolumeUsd = Nothing
  , uniswapV3TokenDTOUntrackedVolumeUsd = Nothing
  , uniswapV3TokenDTOFeesUsd = Nothing
  , uniswapV3TokenDTOTxCount = Nothing
  , uniswapV3TokenDTOPoolCount = Nothing
  , uniswapV3TokenDTOTotalValueLocked = Nothing
  , uniswapV3TokenDTOTotalValueLockedUsd = Nothing
  , uniswapV3TokenDTOTotalValueLockedUsdUntracked = Nothing
  , uniswapV3TokenDTODerivedEth = Nothing
  , uniswapV3TokenDTOWhitelistPools = Nothing
  , uniswapV3TokenDTOTokenSymbol = Nothing
  }

-- ** UniswapV3TokenHourDataDTO
-- | UniswapV3TokenHourDataDTO
-- Token data aggregated across all pairs that include token.
data UniswapV3TokenHourDataDTO = UniswapV3TokenHourDataDTO
  { uniswapV3TokenHourDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TokenHourDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TokenHourDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TokenHourDataDTOId :: !(Maybe Text) -- ^ "id" - Token address concatendated with date.
  , uniswapV3TokenHourDataDTOPeriodStartUnix :: !(Maybe Int) -- ^ "period_start_unix" - Unix timestamp for start of hour.
  , uniswapV3TokenHourDataDTOToken :: !(Maybe Text) -- ^ "token" - Pointer to token.
  , uniswapV3TokenHourDataDTOVolume :: !(Maybe Text) -- ^ "volume" - Volume in token units.
  , uniswapV3TokenHourDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Volume in derived USD.
  , uniswapV3TokenHourDataDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Volume in USD even on pools with less reliable USD values.
  , uniswapV3TokenHourDataDTOTotalValueLocked :: !(Maybe Text) -- ^ "total_value_locked" - Liquidity across all pools in token units.
  , uniswapV3TokenHourDataDTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - Liquidity across all pools in derived USD.
  , uniswapV3TokenHourDataDTOPriceUsd :: !(Maybe Text) -- ^ "price_usd" - Price at end of period in USD.
  , uniswapV3TokenHourDataDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3TokenHourDataDTOOpen :: !(Maybe Text) -- ^ "open" - Opening price USD.
  , uniswapV3TokenHourDataDTOHigh :: !(Maybe Text) -- ^ "high" - High price USD.
  , uniswapV3TokenHourDataDTOLow :: !(Maybe Text) -- ^ "low" - Low price USD.
  , uniswapV3TokenHourDataDTOClose :: !(Maybe Text) -- ^ "close" - Close price USD.
  , uniswapV3TokenHourDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TokenHourDataDTO
instance A.FromJSON UniswapV3TokenHourDataDTO where
  parseJSON = A.withObject "UniswapV3TokenHourDataDTO" $ \o ->
    UniswapV3TokenHourDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "period_start_unix")
      <*> (o .:? "token")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_value_locked")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3TokenHourDataDTO
instance A.ToJSON UniswapV3TokenHourDataDTO where
  toJSON UniswapV3TokenHourDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TokenHourDataDTOEntryTime
      , "recv_time" .= uniswapV3TokenHourDataDTORecvTime
      , "block_number" .= uniswapV3TokenHourDataDTOBlockNumber
      , "id" .= uniswapV3TokenHourDataDTOId
      , "period_start_unix" .= uniswapV3TokenHourDataDTOPeriodStartUnix
      , "token" .= uniswapV3TokenHourDataDTOToken
      , "volume" .= uniswapV3TokenHourDataDTOVolume
      , "volume_usd" .= uniswapV3TokenHourDataDTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV3TokenHourDataDTOUntrackedVolumeUsd
      , "total_value_locked" .= uniswapV3TokenHourDataDTOTotalValueLocked
      , "total_value_locked_usd" .= uniswapV3TokenHourDataDTOTotalValueLockedUsd
      , "price_usd" .= uniswapV3TokenHourDataDTOPriceUsd
      , "fees_usd" .= uniswapV3TokenHourDataDTOFeesUsd
      , "open" .= uniswapV3TokenHourDataDTOOpen
      , "high" .= uniswapV3TokenHourDataDTOHigh
      , "low" .= uniswapV3TokenHourDataDTOLow
      , "close" .= uniswapV3TokenHourDataDTOClose
      , "vid" .= uniswapV3TokenHourDataDTOVid
      ]


-- | Construct a value of type 'UniswapV3TokenHourDataDTO' (by applying it's required fields, if any)
mkUniswapV3TokenHourDataDTO
  :: UniswapV3TokenHourDataDTO
mkUniswapV3TokenHourDataDTO =
  UniswapV3TokenHourDataDTO
  { uniswapV3TokenHourDataDTOEntryTime = Nothing
  , uniswapV3TokenHourDataDTORecvTime = Nothing
  , uniswapV3TokenHourDataDTOBlockNumber = Nothing
  , uniswapV3TokenHourDataDTOId = Nothing
  , uniswapV3TokenHourDataDTOPeriodStartUnix = Nothing
  , uniswapV3TokenHourDataDTOToken = Nothing
  , uniswapV3TokenHourDataDTOVolume = Nothing
  , uniswapV3TokenHourDataDTOVolumeUsd = Nothing
  , uniswapV3TokenHourDataDTOUntrackedVolumeUsd = Nothing
  , uniswapV3TokenHourDataDTOTotalValueLocked = Nothing
  , uniswapV3TokenHourDataDTOTotalValueLockedUsd = Nothing
  , uniswapV3TokenHourDataDTOPriceUsd = Nothing
  , uniswapV3TokenHourDataDTOFeesUsd = Nothing
  , uniswapV3TokenHourDataDTOOpen = Nothing
  , uniswapV3TokenHourDataDTOHigh = Nothing
  , uniswapV3TokenHourDataDTOLow = Nothing
  , uniswapV3TokenHourDataDTOClose = Nothing
  , uniswapV3TokenHourDataDTOVid = Nothing
  }

-- ** UniswapV3TokenV3DayDataDTO
-- | UniswapV3TokenV3DayDataDTO
-- Token data aggregated across all pairs that include token.
data UniswapV3TokenV3DayDataDTO = UniswapV3TokenV3DayDataDTO
  { uniswapV3TokenV3DayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TokenV3DayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TokenV3DayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TokenV3DayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3TokenV3DayDataDTOId :: !(Maybe Text) -- ^ "id" - Token address concatendated with date.
  , uniswapV3TokenV3DayDataDTODate :: !(Maybe Int) -- ^ "date" - Timestamp rounded to current day by dividing by 86400.
  , uniswapV3TokenV3DayDataDTOToken :: !(Maybe Text) -- ^ "token" - Pointer to token.
  , uniswapV3TokenV3DayDataDTOVolume :: !(Maybe Text) -- ^ "volume" - Volume in token units.
  , uniswapV3TokenV3DayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Volume in derived USD.
  , uniswapV3TokenV3DayDataDTOUntrackedVolumeUsd :: !(Maybe Text) -- ^ "untracked_volume_usd" - Volume in USD even on pools with less reliable USD values.
  , uniswapV3TokenV3DayDataDTOTotalValueLocked :: !(Maybe Text) -- ^ "total_value_locked" - Liquidity across all pools in token units.
  , uniswapV3TokenV3DayDataDTOTotalValueLockedUsd :: !(Maybe Text) -- ^ "total_value_locked_usd" - Liquidity across all pools in derived USD.
  , uniswapV3TokenV3DayDataDTOPriceUsd :: !(Maybe Text) -- ^ "price_usd" - Price at end of period in USD.
  , uniswapV3TokenV3DayDataDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD.
  , uniswapV3TokenV3DayDataDTOOpen :: !(Maybe Text) -- ^ "open" - Opening price USD.
  , uniswapV3TokenV3DayDataDTOHigh :: !(Maybe Text) -- ^ "high" - High price USD.
  , uniswapV3TokenV3DayDataDTOLow :: !(Maybe Text) -- ^ "low" - Low price USD.
  , uniswapV3TokenV3DayDataDTOClose :: !(Maybe Text) -- ^ "close" - Close price USD.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TokenV3DayDataDTO
instance A.FromJSON UniswapV3TokenV3DayDataDTO where
  parseJSON = A.withObject "UniswapV3TokenV3DayDataDTO" $ \o ->
    UniswapV3TokenV3DayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "token")
      <*> (o .:? "volume")
      <*> (o .:? "volume_usd")
      <*> (o .:? "untracked_volume_usd")
      <*> (o .:? "total_value_locked")
      <*> (o .:? "total_value_locked_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "fees_usd")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")

-- | ToJSON UniswapV3TokenV3DayDataDTO
instance A.ToJSON UniswapV3TokenV3DayDataDTO where
  toJSON UniswapV3TokenV3DayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TokenV3DayDataDTOEntryTime
      , "recv_time" .= uniswapV3TokenV3DayDataDTORecvTime
      , "block_number" .= uniswapV3TokenV3DayDataDTOBlockNumber
      , "vid" .= uniswapV3TokenV3DayDataDTOVid
      , "id" .= uniswapV3TokenV3DayDataDTOId
      , "date" .= uniswapV3TokenV3DayDataDTODate
      , "token" .= uniswapV3TokenV3DayDataDTOToken
      , "volume" .= uniswapV3TokenV3DayDataDTOVolume
      , "volume_usd" .= uniswapV3TokenV3DayDataDTOVolumeUsd
      , "untracked_volume_usd" .= uniswapV3TokenV3DayDataDTOUntrackedVolumeUsd
      , "total_value_locked" .= uniswapV3TokenV3DayDataDTOTotalValueLocked
      , "total_value_locked_usd" .= uniswapV3TokenV3DayDataDTOTotalValueLockedUsd
      , "price_usd" .= uniswapV3TokenV3DayDataDTOPriceUsd
      , "fees_usd" .= uniswapV3TokenV3DayDataDTOFeesUsd
      , "open" .= uniswapV3TokenV3DayDataDTOOpen
      , "high" .= uniswapV3TokenV3DayDataDTOHigh
      , "low" .= uniswapV3TokenV3DayDataDTOLow
      , "close" .= uniswapV3TokenV3DayDataDTOClose
      ]


-- | Construct a value of type 'UniswapV3TokenV3DayDataDTO' (by applying it's required fields, if any)
mkUniswapV3TokenV3DayDataDTO
  :: UniswapV3TokenV3DayDataDTO
mkUniswapV3TokenV3DayDataDTO =
  UniswapV3TokenV3DayDataDTO
  { uniswapV3TokenV3DayDataDTOEntryTime = Nothing
  , uniswapV3TokenV3DayDataDTORecvTime = Nothing
  , uniswapV3TokenV3DayDataDTOBlockNumber = Nothing
  , uniswapV3TokenV3DayDataDTOVid = Nothing
  , uniswapV3TokenV3DayDataDTOId = Nothing
  , uniswapV3TokenV3DayDataDTODate = Nothing
  , uniswapV3TokenV3DayDataDTOToken = Nothing
  , uniswapV3TokenV3DayDataDTOVolume = Nothing
  , uniswapV3TokenV3DayDataDTOVolumeUsd = Nothing
  , uniswapV3TokenV3DayDataDTOUntrackedVolumeUsd = Nothing
  , uniswapV3TokenV3DayDataDTOTotalValueLocked = Nothing
  , uniswapV3TokenV3DayDataDTOTotalValueLockedUsd = Nothing
  , uniswapV3TokenV3DayDataDTOPriceUsd = Nothing
  , uniswapV3TokenV3DayDataDTOFeesUsd = Nothing
  , uniswapV3TokenV3DayDataDTOOpen = Nothing
  , uniswapV3TokenV3DayDataDTOHigh = Nothing
  , uniswapV3TokenV3DayDataDTOLow = Nothing
  , uniswapV3TokenV3DayDataDTOClose = Nothing
  }

-- ** UniswapV3TransactionDTO
-- | UniswapV3TransactionDTO
data UniswapV3TransactionDTO = UniswapV3TransactionDTO
  { uniswapV3TransactionDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3TransactionDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3TransactionDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3TransactionDTOId :: !(Maybe Text) -- ^ "id" - Transaction hash.
  , uniswapV3TransactionDTOTimestamp :: !(Maybe Text) -- ^ "timestamp" - Timestamp txn was confirmed.
  , uniswapV3TransactionDTOGasUsed :: !(Maybe Text) -- ^ "gas_used" - Gas used during txn execution.
  , uniswapV3TransactionDTOGasPrice :: !(Maybe Text) -- ^ "gas_price" - 
  , uniswapV3TransactionDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3TransactionDTO
instance A.FromJSON UniswapV3TransactionDTO where
  parseJSON = A.withObject "UniswapV3TransactionDTO" $ \o ->
    UniswapV3TransactionDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "id")
      <*> (o .:? "timestamp")
      <*> (o .:? "gas_used")
      <*> (o .:? "gas_price")
      <*> (o .:? "vid")

-- | ToJSON UniswapV3TransactionDTO
instance A.ToJSON UniswapV3TransactionDTO where
  toJSON UniswapV3TransactionDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3TransactionDTOEntryTime
      , "recv_time" .= uniswapV3TransactionDTORecvTime
      , "block_number" .= uniswapV3TransactionDTOBlockNumber
      , "id" .= uniswapV3TransactionDTOId
      , "timestamp" .= uniswapV3TransactionDTOTimestamp
      , "gas_used" .= uniswapV3TransactionDTOGasUsed
      , "gas_price" .= uniswapV3TransactionDTOGasPrice
      , "vid" .= uniswapV3TransactionDTOVid
      ]


-- | Construct a value of type 'UniswapV3TransactionDTO' (by applying it's required fields, if any)
mkUniswapV3TransactionDTO
  :: UniswapV3TransactionDTO
mkUniswapV3TransactionDTO =
  UniswapV3TransactionDTO
  { uniswapV3TransactionDTOEntryTime = Nothing
  , uniswapV3TransactionDTORecvTime = Nothing
  , uniswapV3TransactionDTOBlockNumber = Nothing
  , uniswapV3TransactionDTOId = Nothing
  , uniswapV3TransactionDTOTimestamp = Nothing
  , uniswapV3TransactionDTOGasUsed = Nothing
  , uniswapV3TransactionDTOGasPrice = Nothing
  , uniswapV3TransactionDTOVid = Nothing
  }

-- ** UniswapV3UniswapDayDataDTO
-- | UniswapV3UniswapDayDataDTO
-- Data accumulated and condensed into day stats for all of Uniswap.
data UniswapV3UniswapDayDataDTO = UniswapV3UniswapDayDataDTO
  { uniswapV3UniswapDayDataDTOEntryTime :: !(Maybe DateTime) -- ^ "entry_time"
  , uniswapV3UniswapDayDataDTORecvTime :: !(Maybe DateTime) -- ^ "recv_time"
  , uniswapV3UniswapDayDataDTOBlockNumber :: !(Maybe Integer) -- ^ "block_number" - Number of block in which entity was recorded.
  , uniswapV3UniswapDayDataDTOVid :: !(Maybe Integer) -- ^ "vid" - 
  , uniswapV3UniswapDayDataDTOId :: !(Maybe Text) -- ^ "id" - Timestamp rounded to current day by dividing by 86400.
  , uniswapV3UniswapDayDataDTODate :: !(Maybe Int) -- ^ "date" - Timestamp rounded to current day by dividing by 86400.
  , uniswapV3UniswapDayDataDTOVolumeEth :: !(Maybe Text) -- ^ "volume_eth" - Total volume across all pairs on this day, stored as a derived amount of ETH.
  , uniswapV3UniswapDayDataDTOVolumeUsd :: !(Maybe Text) -- ^ "volume_usd" - Total volume across all pairs on this day, stored as a derived amount of USD.
  , uniswapV3UniswapDayDataDTOVolumeUsdUntracked :: !(Maybe Text) -- ^ "volume_usd_untracked" - Total daily volume in Uniswap derived in terms of USD untracked.
  , uniswapV3UniswapDayDataDTOFeesUsd :: !(Maybe Text) -- ^ "fees_usd" - Fees in USD
  , uniswapV3UniswapDayDataDTOTxCount :: !(Maybe NumericsBigInteger) -- ^ "tx_count"
  , uniswapV3UniswapDayDataDTOTvlUsd :: !(Maybe Text) -- ^ "tvl_usd" - Tvl in terms of USD.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UniswapV3UniswapDayDataDTO
instance A.FromJSON UniswapV3UniswapDayDataDTO where
  parseJSON = A.withObject "UniswapV3UniswapDayDataDTO" $ \o ->
    UniswapV3UniswapDayDataDTO
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "block_number")
      <*> (o .:? "vid")
      <*> (o .:? "id")
      <*> (o .:? "date")
      <*> (o .:? "volume_eth")
      <*> (o .:? "volume_usd")
      <*> (o .:? "volume_usd_untracked")
      <*> (o .:? "fees_usd")
      <*> (o .:? "tx_count")
      <*> (o .:? "tvl_usd")

-- | ToJSON UniswapV3UniswapDayDataDTO
instance A.ToJSON UniswapV3UniswapDayDataDTO where
  toJSON UniswapV3UniswapDayDataDTO {..} =
   _omitNulls
      [ "entry_time" .= uniswapV3UniswapDayDataDTOEntryTime
      , "recv_time" .= uniswapV3UniswapDayDataDTORecvTime
      , "block_number" .= uniswapV3UniswapDayDataDTOBlockNumber
      , "vid" .= uniswapV3UniswapDayDataDTOVid
      , "id" .= uniswapV3UniswapDayDataDTOId
      , "date" .= uniswapV3UniswapDayDataDTODate
      , "volume_eth" .= uniswapV3UniswapDayDataDTOVolumeEth
      , "volume_usd" .= uniswapV3UniswapDayDataDTOVolumeUsd
      , "volume_usd_untracked" .= uniswapV3UniswapDayDataDTOVolumeUsdUntracked
      , "fees_usd" .= uniswapV3UniswapDayDataDTOFeesUsd
      , "tx_count" .= uniswapV3UniswapDayDataDTOTxCount
      , "tvl_usd" .= uniswapV3UniswapDayDataDTOTvlUsd
      ]


-- | Construct a value of type 'UniswapV3UniswapDayDataDTO' (by applying it's required fields, if any)
mkUniswapV3UniswapDayDataDTO
  :: UniswapV3UniswapDayDataDTO
mkUniswapV3UniswapDayDataDTO =
  UniswapV3UniswapDayDataDTO
  { uniswapV3UniswapDayDataDTOEntryTime = Nothing
  , uniswapV3UniswapDayDataDTORecvTime = Nothing
  , uniswapV3UniswapDayDataDTOBlockNumber = Nothing
  , uniswapV3UniswapDayDataDTOVid = Nothing
  , uniswapV3UniswapDayDataDTOId = Nothing
  , uniswapV3UniswapDayDataDTODate = Nothing
  , uniswapV3UniswapDayDataDTOVolumeEth = Nothing
  , uniswapV3UniswapDayDataDTOVolumeUsd = Nothing
  , uniswapV3UniswapDayDataDTOVolumeUsdUntracked = Nothing
  , uniswapV3UniswapDayDataDTOFeesUsd = Nothing
  , uniswapV3UniswapDayDataDTOTxCount = Nothing
  , uniswapV3UniswapDayDataDTOTvlUsd = Nothing
  }


-- * Enums


-- ** TransactionsETradeAggressiveSide

-- | Enum of 'Text'
data TransactionsETradeAggressiveSide
  = TransactionsETradeAggressiveSide'Buy -- ^ @"Buy"@
  | TransactionsETradeAggressiveSide'Sell -- ^ @"Sell"@
  | TransactionsETradeAggressiveSide'EstimatedBuy -- ^ @"EstimatedBuy"@
  | TransactionsETradeAggressiveSide'EstimatedSell -- ^ @"EstimatedSell"@
  | TransactionsETradeAggressiveSide'Unknown -- ^ @"Unknown"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TransactionsETradeAggressiveSide where toJSON = A.toJSON . fromTransactionsETradeAggressiveSide
instance A.FromJSON TransactionsETradeAggressiveSide where parseJSON o = P.either P.fail (pure . P.id) . toTransactionsETradeAggressiveSide =<< A.parseJSON o
instance WH.ToHttpApiData TransactionsETradeAggressiveSide where toQueryParam = WH.toQueryParam . fromTransactionsETradeAggressiveSide
instance WH.FromHttpApiData TransactionsETradeAggressiveSide where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTransactionsETradeAggressiveSide
instance MimeRender MimeMultipartFormData TransactionsETradeAggressiveSide where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TransactionsETradeAggressiveSide' enum
fromTransactionsETradeAggressiveSide :: TransactionsETradeAggressiveSide -> Text
fromTransactionsETradeAggressiveSide = \case
  TransactionsETradeAggressiveSide'Buy -> "Buy"
  TransactionsETradeAggressiveSide'Sell -> "Sell"
  TransactionsETradeAggressiveSide'EstimatedBuy -> "EstimatedBuy"
  TransactionsETradeAggressiveSide'EstimatedSell -> "EstimatedSell"
  TransactionsETradeAggressiveSide'Unknown -> "Unknown"

-- | parse 'TransactionsETradeAggressiveSide' enum
toTransactionsETradeAggressiveSide :: Text -> P.Either String TransactionsETradeAggressiveSide
toTransactionsETradeAggressiveSide = \case
  "Buy" -> P.Right TransactionsETradeAggressiveSide'Buy
  "Sell" -> P.Right TransactionsETradeAggressiveSide'Sell
  "EstimatedBuy" -> P.Right TransactionsETradeAggressiveSide'EstimatedBuy
  "EstimatedSell" -> P.Right TransactionsETradeAggressiveSide'EstimatedSell
  "Unknown" -> P.Right TransactionsETradeAggressiveSide'Unknown
  s -> P.Left $ "toTransactionsETradeAggressiveSide: enum parse failure: " P.++ P.show s



