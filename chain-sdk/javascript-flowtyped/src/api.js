// @flow
/* eslint-disable no-use-before-define */
/**
 * OnChain API
 *  This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://onchain.coinapi.io".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type NumericsBigInteger = {
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_power_of_two?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_zero?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_one?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_even?: boolean;
    /**
     * 
     * @type {number}
     * @memberof NumericsBigInteger
     */
    sign?: number;
}

/**
 * The Bundle is used as a global store of derived ETH price in USD.
 * @export
 */
export type SushiswapBundleDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBundleDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBundleDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapBundleDTO
     */
    block_number?: number;
    /**
     * Hardcoded to \'1\'.
     * @type {string}
     * @memberof SushiswapBundleDTO
     */
    id?: string;
    /**
     * Price of native.
     * @type {string}
     * @memberof SushiswapBundleDTO
     */
    eth_price?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapBundleDTO
     */
    vid?: number;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type SushiswapBurnDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBurnDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBurnDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapBurnDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <transaction id>:<transaction.burns.length>.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    id?: string;
    /**
     * Reference to the transaction Burn was included in.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    transaction?: string;
    /**
     * Timestamp of Burn, used to sort recent liquidity removals.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    pair?: string;
    /**
     * Amount of liquidity tokens burned.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity removal.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    sender?: string;
    /**
     * Amount of token0 removed.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 removed.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_1?: string;
    /**
     * Recipient of tokens.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    to?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    log_index?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SushiswapBurnDTO
     */
    complete?: boolean;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    fee_to?: string;
    /**
     * Amount of tokens sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapBurnDTO
     */
    vid?: number;
}

/**
 * Tracks data across all pairs aggregated into a daily bucket.
 * @export
 */
export type SushiswapDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    block_number?: number;
    /**
     * Unix timestamp for start of day / 86400 giving a unique day index.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    _date?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    factory?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    volume_usd?: string;
    /**
     * Total volume across all pairs on this day, untracked
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    untracked_volume?: string;
    /**
     * Total liquidity across all pairs in ETH up to and including this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    liquidity_eth?: string;
    /**
     * Total liquidity across all pairs in USD up to and including this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    liquidity_usd?: string;
    /**
     * Number of transactions throughout this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    vid?: number;
}

/**
 * The Sushiswap Factory entity is responsible for storing aggregate information across all Sushiswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type SushiswapFactoryDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapFactoryDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapFactoryDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapFactoryDTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    id?: string;
    /**
     * Amount of pairs created by the Sushiswap factory.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    pair_count?: string;
    /**
     * All time USD volume across all pairs (USD is derived).
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    volume_usd?: string;
    /**
     * All time volume in ETH across all pairs (ETH is derived).
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    volume_eth?: string;
    /**
     * Untracked volume USD.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    untracked_volume_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    liquidity_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived ETH amount.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    liquidity_eth?: string;
    /**
     * All time amount of transactions across all pairs.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    tx_count?: string;
    /**
     * Total count of tokens.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    token_count?: string;
    /**
     * Users count.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    user_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapFactoryDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    block_number?: number;
    /**
     * Start of hour timestamp.
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    _date?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    factory?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    volume_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    untracked_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    liquidity_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    liquidity_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapLiquidityPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pair address>-<user address>
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    id?: string;
    /**
     * User address.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    user?: string;
    /**
     * Pair address.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    pair?: string;
    /**
     * Amount of LP tokens minted for this position.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    liquidity_token_balance?: string;
    /**
     * Block number at which position was created.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    block?: number;
    /**
     * Creation time.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    vid?: number;
}

/**
 * This entity is used to store data about a user\'s liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
 * @export
 */
export type SushiswapLiquidityPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pair address>-<user address>-<timestamp>
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    id?: string;
    /**
     * Reference to LP identifier.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_position?: string;
    /**
     * Creation time.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    timestamp?: number;
    /**
     * Block in which snapshot has been created.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    block?: number;
    /**
     * Reference to user.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    user?: string;
    /**
     * Reference to the pair liquidity is being provided on.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    pair?: string;
    /**
     * Snapshot of token0 price in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    token_0_price_usd?: string;
    /**
     * Snapshot of token0 price in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    token_1_price_usd?: string;
    /**
     * Snapshot of pair token0 reserves.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_0?: string;
    /**
     * Snapshot of pair token1 reserves.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_1?: string;
    /**
     * Snapshot of pair reserves in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_usd?: string;
    /**
     * Snapshot of pool token supply.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_token_total_supply?: string;
    /**
     * Snapshot of users pool token balance.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_token_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    vid?: number;
}

/**
 * Mint entities are created for every emitted Mint event on the Sushiswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
 * @export
 */
export type SushiswapMintDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapMintDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapMintDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapMintDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <transaction hash>-<index in the transaction mint array>.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    id?: string;
    /**
     * Reference to the transaction Mint was included in.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    transaction?: string;
    /**
     * Timestamp of Mint, used to sort recent liquidity provisions.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    pair?: string;
    /**
     * Recipient of liquidity tokens.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    to?: string;
    /**
     * Amount of liquidity tokens minted.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity provision.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    sender?: string;
    /**
     * Amount of token0 provided.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 provided.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_1?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    log_index?: string;
    /**
     * Derived USD value of token0 amount plus token1 amount.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_usd?: string;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    fee_to?: string;
    /**
     * Amount of liquidity sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapMintDTO
     */
    vid?: number;
}

/**
 * Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
 * @export
 */
export type SushiswapPairDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    block_number?: number;
    /**
     * Pair contract address.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    id?: string;
    /**
     * Factory contract address.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    factory?: string;
    /**
     * Friendly name, format: <token0 name>-<token1 name>
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    name?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_0?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_1?: string;
    /**
     * Reserve of token0.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    total_supply?: string;
    /**
     * Total liquidity in pair stored as an amount of ETH.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_eth?: string;
    /**
     * Total liquidity amount in pair stored as an amount of USD.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_usd?: string;
    /**
     * Total liquidity with only tracked amount.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    tracked_reserve_eth?: string;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_1_price?: string;
    /**
     * Amount of token0 swapped on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_token_0?: string;
    /**
     * Amount of token1 swapped on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_token_1?: string;
    /**
     * Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_usd?: string;
    /**
     * Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    untracked_volume_usd?: string;
    /**
     * All time amount of transactions on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    tx_count?: string;
    /**
     * Total number of LPs.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    liquidity_provider_count?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    timestamp?: string;
    /**
     * Block number in which pair information was created in.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    block?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    vid?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    evaluated_ask?: number;
}

/**
 * Tracks pair data across each day.
 * @export
 */
export type SushiswapPairDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pair id>-<day start timestamp>.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    _date?: number;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    pair?: string;
    /**
     * Reference to token0.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    token_0?: string;
    /**
     * Reference to token1.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    token_1?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    total_supply?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_token_1?: string;
    /**
     * Total volume within pair throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions on pair throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    vid?: number;
}

/**
 * Tracks pair data across each hour.
 * @export
 */
export type SushiswapPairHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pair id>-<hour start timestamp>.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    id?: string;
    /**
     * Hour start timestamp.
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    _date?: number;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    pair?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_1?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_token_1?: string;
    /**
     * Total volume within pair throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions on pair throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    vid?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type SushiswapSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    block_number?: number;
    /**
     * Transaction hash plus index in Transaction swap array.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    id?: string;
    /**
     * Reference to transaction swap was included in.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    transaction?: string;
    /**
     * Timestamp of swap, used for sorted lookups.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    pair?: string;
    /**
     * Address that initiated the swap.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    sender?: string;
    /**
     * Amount of token0 sold.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_0_in?: string;
    /**
     * Amount of token1 sold.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_1_in?: string;
    /**
     * Amount of token0 received.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_0_out?: string;
    /**
     * Amount of token1 received.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_1_out?: string;
    /**
     * Recipient of output tokens.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    to?: string;
    /**
     * Event index within transaction.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    log_index?: string;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof SushiswapSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type SushiswapTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTokenDTO
     */
    block_number?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    id?: string;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    factory?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    decimals?: string;
    /**
     * Total supply of liquidity token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    total_supply?: string;
    /**
     * Amount of token traded all time across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    volume?: string;
    /**
     * Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    volume_usd?: string;
    /**
     * Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    untracked_volume_usd?: string;
    /**
     * Amount of transactions all time in pairs including token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    tx_count?: string;
    /**
     * Total amount of token provided as liquidity across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    liquidity?: string;
    /**
     * ETH per token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    derived_eth?: string;
    /**
     * Array of whitelisted pairs.
     * @type {Array<string>}
     * @memberof SushiswapTokenDTO
     */
    whitelist_pairs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    token_symbol?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type SushiswapTokenDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, day start timestamp in unix / 86400.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    _date?: number;
    /**
     * Reference to token entity.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    token?: string;
    /**
     * Amount of token swapped across all pairs throughout day.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume_eth?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions with this token across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    tx_count?: string;
    /**
     * Token amount of token deposited across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of ETH.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity_eth?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity_usd?: string;
    /**
     * Price of token in derived USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    vid?: number;
}

/**
 * Transaction entities are created for each Ethereum transaction that contains an interaction within Sushiswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
 * @export
 */
export type SushiswapTransactionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTransactionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTransactionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTransactionDTO
     */
    block_number?: number;
    /**
     * Ethereum transaction hash.
     * @type {string}
     * @memberof SushiswapTransactionDTO
     */
    id?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof SushiswapTransactionDTO
     */
    timestamp?: string;
    /**
     * Array of Mint events within the transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    mints?: Array<string>;
    /**
     * Array of Burn events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    burns?: Array<string>;
    /**
     * Array of Swap events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    swaps?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTransactionDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapUserDTO
     */
    block_number?: number;
    /**
     * User address.
     * @type {string}
     * @memberof SushiswapUserDTO
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapUserDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export type TransactionsETradeAggressiveSide = 'Buy' | 'Sell' | 'EstimatedBuy' | 'EstimatedSell' | 'Unknown';

/**
 * Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
 * @export
 */
export type UniswapV2PairV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2PairV2DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairV2DTO
     */
    vid?: number;
    /**
     * Pair contract address.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    id?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    token_1?: string;
    /**
     * Reserve of token0.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    total_supply?: string;
    /**
     * Total liquidity in pair stored as an amount of ETH.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    reserve_eth?: string;
    /**
     * Total liquidity amount in pair stored as an amount of USD.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    reserve_usd?: string;
    /**
     * Total liquidity with only tracked amount.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    tracked_reserve_eth?: string;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    token_1_price?: string;
    /**
     * Amount of token0 swapped on this pair.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    volume_token_0?: string;
    /**
     * Amount of token1 swapped on this pair.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    volume_token_1?: string;
    /**
     * Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    volume_usd?: string;
    /**
     * Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    untracked_volume_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2PairV2DTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Timestamp contract was created.
     * @type {Date}
     * @memberof UniswapV2PairV2DTO
     */
    created_at_timestamp?: Date;
    /**
     * Total number of LPs.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    liquidity_provider_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairV2DTO
     */
    evaluated_ask?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type UniswapV2SwapV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2SwapV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2SwapV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2SwapV2DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapV2DTO
     */
    vid?: number;
    /**
     * Transaction hash plus index in Transaction swap array.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    id?: string;
    /**
     * Reference to transaction swap was included in.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    transaction?: string;
    /**
     * Timestamp of swap, used for sorted lookups.
     * @type {Date}
     * @memberof UniswapV2SwapV2DTO
     */
    timestamp?: Date;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    pair?: string;
    /**
     * Address that initiated the swap.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    sender?: string;
    /**
     * The EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    from?: string;
    /**
     * Amount of token0 sold.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    amount_0_in?: string;
    /**
     * Amount of token1 sold.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    amount_1_in?: string;
    /**
     * Amount of token0 received.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    amount_0_out?: string;
    /**
     * Amount of token1 received.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    amount_1_out?: string;
    /**
     * Recipient of output tokens.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    to?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2SwapV2DTO
     */
    log_index?: NumericsBigInteger;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapV2DTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapV2DTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UniswapV2SwapV2DTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    transaction_id?: string;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UniswapV2TokenV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2TokenV2DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2TokenV2DTO
     */
    vid?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    id?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {number}
     * @memberof UniswapV2TokenV2DTO
     */
    decimals?: number;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2TokenV2DTO
     */
    total_supply?: NumericsBigInteger;
    /**
     * Amount of token traded all time across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    trade_volume?: string;
    /**
     * Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    trade_volume_usd?: string;
    /**
     * Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    untracked_volume_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2TokenV2DTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Total amount of token provided as liquidity across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    total_liquidity?: string;
    /**
     * ETH per token.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    derived_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    token_symbol?: string;
}

/**
 * The Bundle is used as a global store of derived ETH price in USD. This provides a strong estimate for the USD price of ETH.
 * @export
 */
export type UniswapV3BundleV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BundleV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BundleV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3BundleV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3BundleV3DTO
     */
    id?: string;
    /**
     * Price of ETH in usd.
     * @type {string}
     * @memberof UniswapV3BundleV3DTO
     */
    eth_price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3BundleV3DTO
     */
    vid?: number;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type UniswapV3BurnV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BurnV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BurnV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3BurnV3DTO
     */
    block_number?: number;
    /**
     * Transaction hash + \'#\' + index in mints Transaction array.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    id?: string;
    /**
     * Transaction burn was included in.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    transaction?: string;
    /**
     * Pool position is within.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    token_1?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    timestamp?: string;
    /**
     * Owner of position where liquidity was burned.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    owner?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    origin?: string;
    /**
     * Amount of liquidity burned.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    amount?: string;
    /**
     * Amount of token 0 burned.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    amount_0?: string;
    /**
     * Amount of token 1 burned.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    amount_1?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    amount_usd?: string;
    /**
     * Lower tick of position.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    tick_lower?: string;
    /**
     * Upper tick of position.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    tick_upper?: string;
    /**
     * Position within the transactions.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3BurnV3DTO
     */
    vid?: number;
}

/**
 * The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type UniswapV3FactoryV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3FactoryV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3FactoryV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3FactoryV3DTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    id?: string;
    /**
     * Amount of pools created.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    pool_count?: string;
    /**
     * Amount of transactions all time.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    tx_count?: string;
    /**
     * Total volume all time in derived USD.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_volume_usd?: string;
    /**
     * Total volume all time in derived ETH.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_volume_eth?: string;
    /**
     * Total swap fees all time in USD.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_fees_usd?: string;
    /**
     * All volume even through less reliable USD values.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_fees_eth?: string;
    /**
     * All volume even through less reliable USD values.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    untracked_volume_usd?: string;
    /**
     * Total value locked derived in USD.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_value_locked_usd?: string;
    /**
     * Total value locked derived in ETH.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_value_locked_eth?: string;
    /**
     * Total value locked derived in USD untracked.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Total value locked derived in ETH untracked.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_value_locked_eth_untracked?: string;
    /**
     * Current owner of the factory.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    owner?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3FactoryV3DTO
     */
    vid?: number;
}

/**
 * Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, and more.
 * @export
 */
export type UniswapV3MintV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3MintV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3MintV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3MintV3DTO
     */
    block_number?: number;
    /**
     * Transaction hash + \'#\' + index in mints Transaction array.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    id?: string;
    /**
     * Which txn the mint was included in.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    transaction?: string;
    /**
     * Time of transaction.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    timestamp?: string;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    token_1?: string;
    /**
     * Owner of position where liquidity minted to.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    owner?: string;
    /**
     * The address that minted the liquidity.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    sender?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    origin?: string;
    /**
     * Amount of liquidity minted.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    amount?: string;
    /**
     * Amount of token 0 minted.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    amount_0?: string;
    /**
     * Amount of token 1 minted.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    amount_1?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    amount_usd?: string;
    /**
     * Lower tick of the position.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    tick_lower?: string;
    /**
     * Upper tick of the position.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    tick_upper?: string;
    /**
     * Order within the transaction.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3MintV3DTO
     */
    vid?: number;
}

/**
 * Data accumulated and condensed into day stats for each pool.
 * @export
 */
export type UniswapV3PoolDayDataV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pool address>-<day id>.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400
     * @type {number}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    _date?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    pool?: string;
    /**
     * In range liquidity at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    liquidity?: string;
    /**
     * Current price tracker at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    sqrt_price?: string;
    /**
     * Price of token0 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    token_0_price?: string;
    /**
     * Price of token1 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    token_1_price?: string;
    /**
     * Current tick at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    tick?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    fee_growth_global_0x128?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    fee_growth_global_1x128?: string;
    /**
     * Total value locked derived in USD at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    tvl_usd?: string;
    /**
     * Volume in token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    volume_token_0?: string;
    /**
     * Volume in token1.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    volume_token_1?: string;
    /**
     * Volume in USD.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    fees_usd?: string;
    /**
     * Number of transactions during period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    tx_count?: string;
    /**
     * Opening price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    open?: string;
    /**
     * High price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    high?: string;
    /**
     * Low price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    low?: string;
    /**
     * Close price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    vid?: number;
}

/**
 * Hourly stats tracker for pool.
 * @export
 */
export type UniswapV3PoolHourDataV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pool address>-<day id>
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    period_start_unix?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    pool?: string;
    /**
     * In range liquidity at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    liquidity?: string;
    /**
     * Current price tracker at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    sqrt_price?: string;
    /**
     * Price of token0 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    token_0_price?: string;
    /**
     * Price of token1 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    token_1_price?: string;
    /**
     * Current tick at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    tick?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    fee_growth_global_0x128?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    fee_growth_global_1x128?: string;
    /**
     * Total value locked derived in USD at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    tvl_usd?: string;
    /**
     * Volume in token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    volume_token_0?: string;
    /**
     * Volume in token1.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    volume_token_1?: string;
    /**
     * Volume in USD.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    fees_usd?: string;
    /**
     * Number of transactions during period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    tx_count?: string;
    /**
     * Opening price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    open?: string;
    /**
     * High price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    high?: string;
    /**
     * Low price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    low?: string;
    /**
     * Close price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    vid?: number;
}

/**
 * Information about a pool. Includes references to each token within the pool, volume information, liquidity information, and more. The pool entity mirrors the pool smart contract, and also contains aggregated information about use.
 * @export
 */
export type UniswapV3PoolV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolV3DTO
     */
    vid?: number;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    id?: string;
    /**
     * Creation time.
     * @type {Date}
     * @memberof UniswapV3PoolV3DTO
     */
    created_at_timestamp?: Date;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    token_1?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    fee_tier?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    liquidity?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    sqrt_price?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    fee_growth_global_0x128?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    fee_growth_global_1x128?: NumericsBigInteger;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    token_1_price?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    tick?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    observation_index?: NumericsBigInteger;
    /**
     * All time token0 swapped.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    volume_token_0?: string;
    /**
     * All time token1 swapped.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    volume_token_1?: string;
    /**
     * All time USD swapped.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    volume_usd?: string;
    /**
     * All time USD swapped, unfiltered for unreliable USD pools.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * All time fees collected token0.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    collected_fees_token_0?: string;
    /**
     * All time fees collected token1.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    collected_fees_token_1?: string;
    /**
     * All time fees collected derived USD.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    collected_fees_usd?: string;
    /**
     * Total token 0 across all ticks.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    total_value_locked_token_0?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    total_value_locked_token_1?: string;
    /**
     * Total token 1 across all ticks.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    total_value_locked_eth?: string;
    /**
     * Total value locked USD.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    total_value_locked_usd?: string;
    /**
     * Total value locked derived ETH.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Liquidity providers count, used to detect new exchanges.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    liquidity_provider_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolV3DTO
     */
    evaluated_ask?: number;
}

/**
 * 
 * @export
 */
export type UniswapV3PositionSnapshotV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    block_number?: number;
    /**
     * NFT token identifier, format: <NFT token id>#<block number>
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    id?: string;
    /**
     * Owner of the NFT.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    owner?: string;
    /**
     * Pool the position is within.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    pool?: string;
    /**
     * Position of which the snap was taken of.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    position?: string;
    /**
     * Timestamp of block in which the snap was created.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    timestamp?: string;
    /**
     * Total position liquidity.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    liquidity?: string;
    /**
     * Amount of token 0 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    deposited_token_0?: string;
    /**
     * Amount of token 1 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    deposited_token_1?: string;
    /**
     * Amount of token 0 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    withdrawn_token_0?: string;
    /**
     * Amount of token 1 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    withdrawn_token_1?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    collected_fees_token_1?: string;
    /**
     * Transaction in which the snapshot was initialized.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    transaction?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    fee_growth_inside_0_last_x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    fee_growth_inside_1_last_x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    vid?: number;
}

/**
 * Positions created through NonfungiblePositionManager. Positions are represented as NFTs (ERC-721 tokens) as opposed to the fungible ERC-20 tokens on Uniswap V1 and V2.
 * @export
 */
export type UniswapV3PositionV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PositionV3DTO
     */
    block_number?: number;
    /**
     * NFT token identifier.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    id?: string;
    /**
     * Owner of the NFT.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    owner?: string;
    /**
     * Pool position is within.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    token_1?: string;
    /**
     * Lower tick of the position.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    tick_lower?: string;
    /**
     * Upper tick of the position.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    tick_upper?: string;
    /**
     * Total position liquidity.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    liquidity?: string;
    /**
     * Amount of token 0 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    deposited_token_0?: string;
    /**
     * Amount of token 1 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    deposited_token_1?: string;
    /**
     * Amount of token 0 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    withdrawn_token_0?: string;
    /**
     * Amount of token 1 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    withdrawn_token_1?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    collected_fees_token_1?: string;
    /**
     * Transaction in which the position was initialized.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    transaction?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    fee_growth_inside_0_last_x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    fee_growth_inside_1_last_x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PositionV3DTO
     */
    vid?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type UniswapV3SwapV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3SwapV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3SwapV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3SwapV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapV3DTO
     */
    vid?: number;
    /**
     * Identifier, format: transaction hash + \"#\" + index in swaps Transaction array.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    id?: string;
    /**
     * Pointer to transaction.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    transaction?: string;
    /**
     * Timestamp of transaction.
     * @type {Date}
     * @memberof UniswapV3SwapV3DTO
     */
    timestamp?: Date;
    /**
     * Pool swap occured within.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    token_1?: string;
    /**
     * Sender of the swap.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    sender?: string;
    /**
     * Recipient of the swap.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    recipient?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    origin?: string;
    /**
     * Delta of token0 swapped.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    amount_0?: string;
    /**
     * Delta of token1 swapped.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    amount_1?: string;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapV3DTO
     */
    sqrt_price_x96?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapV3DTO
     */
    tick?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapV3DTO
     */
    log_index?: NumericsBigInteger;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapV3DTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapV3DTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UniswapV3SwapV3DTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    transaction_id?: string;
}

/**
 * Data accumulated and condensed into day stats for each exchange. Entity gets saved only if there is a change during the day
 * @export
 */
export type UniswapV3TickDayDataV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pool address>-<tick index>-<timestamp>.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    _date?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    pool?: string;
    /**
     * Pointer to tick.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    tick?: string;
    /**
     * Total liquidity pool has as tick lower or upper at end of period.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    liquidity_gross?: string;
    /**
     * How much liquidity changes when tick crossed at end of period.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    liquidity_net?: string;
    /**
     * Hourly volume of token0 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    volume_token_0?: string;
    /**
     * Hourly volume of token1 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    volume_token_1?: string;
    /**
     * Hourly volume in derived USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    fees_usd?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    fee_growth_outside_0x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    fee_growth_outside_1x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    vid?: number;
}

/**
 * Ticks are the boundaries between discrete areas in price space.
 * @export
 */
export type UniswapV3TickV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TickV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TickV3DTO
     */
    vid?: number;
    /**
     * Identifier, format: <pool address>#<tick index>
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    id?: string;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    pool_address?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    tick_idx?: NumericsBigInteger;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    pool?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    liquidity_gross?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    liquidity_net?: NumericsBigInteger;
    /**
     * Calculated price of token0 of tick within this pool - constant.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    price_0?: string;
    /**
     * Calculated price of token1 of tick within this pool - constant.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    price_1?: string;
    /**
     * Lifetime volume of token0 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    volume_token_0?: string;
    /**
     * Lifetime volume of token1 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    volume_token_1?: string;
    /**
     * Lifetime volume in derived USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    volume_usd?: string;
    /**
     * Lifetime volume in untracked USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    fees_usd?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    collected_fees_token_1?: string;
    /**
     * All time collected fees in USD.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    collected_fees_usd?: string;
    /**
     * Created time.
     * @type {Date}
     * @memberof UniswapV3TickV3DTO
     */
    created_at_timestamp?: Date;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    liquidity_provider_count?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    fee_growth_outside_0x128?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    fee_growth_outside_1x128?: NumericsBigInteger;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV3TokenHourDataV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    block_number?: number;
    /**
     * Token address concatendated with date.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    period_start_unix?: number;
    /**
     * Pointer to token.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    token?: string;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    untracked_volume_usd?: string;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    total_value_locked_usd?: string;
    /**
     * Price at end of period in USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    price_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    fees_usd?: string;
    /**
     * Opening price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    open?: string;
    /**
     * High price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    high?: string;
    /**
     * Low price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    low?: string;
    /**
     * Close price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    vid?: number;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UniswapV3TokenV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenV3DTO
     */
    vid?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    id?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {number}
     * @memberof UniswapV3TokenV3DTO
     */
    decimals?: number;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenV3DTO
     */
    total_supply?: NumericsBigInteger;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenV3DTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenV3DTO
     */
    pool_count?: NumericsBigInteger;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    total_value_locked_usd?: string;
    /**
     * TVL derived in USD untracked.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Derived price in ETH.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    derived_eth?: string;
    /**
     * Pools token is in that are white listed for USD pricing.
     * @type {Array<string>}
     * @memberof UniswapV3TokenV3DTO
     */
    whitelist_pools?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    token_symbol?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV3TokenV3DayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    vid?: number;
    /**
     * Token address concatendated with date.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    _date?: number;
    /**
     * Pointer to token.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    token?: string;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    untracked_volume_usd?: string;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    total_value_locked_usd?: string;
    /**
     * Price at end of period in USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    price_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    fees_usd?: string;
    /**
     * Opening price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    open?: string;
    /**
     * High price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    high?: string;
    /**
     * Low price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    low?: string;
    /**
     * Close price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    close?: string;
}

/**
 * Data accumulated and condensed into day stats for all of Uniswap.
 * @export
 */
export type UniswapV3UniswapDayDataV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    vid?: number;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    _date?: number;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    volume_usd?: string;
    /**
     * Total daily volume in Uniswap derived in terms of USD untracked.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    volume_usd_untracked?: string;
    /**
     * Fees in USD
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Tvl in terms of USD.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    tvl_usd?: string;
}



/**
 * CowApi - fetch parameter creator
 * @export
 */
export const CowApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCowOrdersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/orders/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCowSettlementHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/settlement/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCowTokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCowTradesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/trades/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCowUsersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/users/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CowApiType = { 
    dappsCowOrdersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCowSettlementHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCowTokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsCowTradesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCowUsersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,
}

/**
 * CowApi - factory function to inject configuration 
 * @export
 */
export const CowApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CowApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCowOrdersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).dappsCowOrdersHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCowSettlementHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).dappsCowSettlementHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCowTokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).dappsCowTokensHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCowTradesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).dappsCowTradesHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCowUsersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).dappsCowUsersHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CurveApi - fetch parameter creator
 * @export
 */
export const CurveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveAccountsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/accounts/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveAddLiquidityEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/addLiquidityEvent/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveAdminFeeChangeLogHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/adminFeeChangeLog/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveAmplificationCoeffChangeLogHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/amplificationCoeffChangeLog/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveCoinsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/coins/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveContractsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/contracts/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveContractsVersionHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/contractsVersion/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveDailyVolumeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/dailyVolume/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveFeeChangeLogHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/feeChangeLog/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeDepositHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeDeposit/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gauge/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeLiquidityHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeLiquidity/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeTotalWeightHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTotalWeight/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeTypeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeType/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeTypeWeightHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTypeWeight/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeWeightHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWeight/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeWeightVoteHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWeightVote/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeWithdrawHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWithdraw/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveHourlyVolumeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/hourlyVolume/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveLpTokenHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/lpToken/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurvePoolsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/pools/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveProposalsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/proposals/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveProposalsVoteHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/proposalsVote/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveRemoveLiquidityEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/removeLiquidityEvent/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveRemoveLiquidityOneEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/removeLiquidityOneEvent/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveSwapsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/swaps/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveSystemStateHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/systemState/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveTokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveTransferOwnershipEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/transferOwnershipEvent/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveUnderlyingCoinHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/underlyingCoin/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveVotingAppHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/votingApp/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveWeeklyVolumeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/weeklyVolume/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CurveApiType = { 
    dappsCurveAccountsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveAddLiquidityEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveAdminFeeChangeLogHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveAmplificationCoeffChangeLogHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveCoinsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveContractsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveContractsVersionHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveDailyVolumeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveFeeChangeLogHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveGaugeDepositHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveGaugeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveGaugeLiquidityHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveGaugeTotalWeightHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveGaugeTypeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveGaugeTypeWeightHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveGaugeWeightHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveGaugeWeightVoteHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveGaugeWithdrawHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveHourlyVolumeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveLpTokenHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurvePoolsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveProposalsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveProposalsVoteHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveRemoveLiquidityEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveRemoveLiquidityOneEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveSwapsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveSystemStateHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveTokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveTransferOwnershipEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveUnderlyingCoinHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsCurveVotingAppHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsCurveWeeklyVolumeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,
}

/**
 * CurveApi - factory function to inject configuration 
 * @export
 */
export const CurveApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CurveApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveAccountsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveAccountsHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveAddLiquidityEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveAddLiquidityEventHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveAdminFeeChangeLogHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveAdminFeeChangeLogHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveAmplificationCoeffChangeLogHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveAmplificationCoeffChangeLogHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveCoinsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveCoinsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveContractsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveContractsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveContractsVersionHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveContractsVersionHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveDailyVolumeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveDailyVolumeHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveFeeChangeLogHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveFeeChangeLogHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeDepositHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveGaugeDepositHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveGaugeHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeLiquidityHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveGaugeLiquidityHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeTotalWeightHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveGaugeTotalWeightHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeTypeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveGaugeTypeHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeTypeWeightHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveGaugeTypeWeightHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeWeightHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveGaugeWeightHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeWeightVoteHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveGaugeWeightVoteHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveGaugeWithdrawHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveGaugeWithdrawHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveHourlyVolumeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveHourlyVolumeHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveLpTokenHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveLpTokenHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurvePoolsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurvePoolsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveProposalsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveProposalsHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveProposalsVoteHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveProposalsVoteHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveRemoveLiquidityEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveRemoveLiquidityEventHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveRemoveLiquidityOneEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveRemoveLiquidityOneEventHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveSwapsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveSwapsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveSystemStateHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveSystemStateHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveTokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveTokensHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveTransferOwnershipEventHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveTransferOwnershipEventHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveUnderlyingCoinHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveUnderlyingCoinHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveVotingAppHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveVotingAppHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsCurveWeeklyVolumeHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).dappsCurveWeeklyVolumeHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * DexApi - fetch parameter creator
 * @export
 */
export const DexApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexBatchHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/batch/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexOrdersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/orders/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexPricesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/prices/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexSolutionHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/solution/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexStatsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/stats/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexTokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexTradesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/trades/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexUsersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/users/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexWithdrawHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/withdraw/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexWithdrawRequestHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/withdrawRequest/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type DexApiType = { 
    dappsDexBatchHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsDexOrdersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsDexPricesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsDexSolutionHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsDexStatsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsDexTokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsDexTradesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsDexUsersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsDexWithdrawHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsDexWithdrawRequestHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,
}

/**
 * DexApi - factory function to inject configuration 
 * @export
 */
export const DexApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): DexApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexBatchHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dappsDexBatchHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexOrdersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dappsDexOrdersHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexPricesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dappsDexPricesHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexSolutionHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dappsDexSolutionHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexStatsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dappsDexStatsHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexTokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dappsDexTokensHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexTradesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dappsDexTradesHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexUsersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dappsDexUsersHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexWithdrawHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dappsDexWithdrawHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsDexWithdrawRequestHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dappsDexWithdrawRequestHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * SushiswapApi - fetch parameter creator
 * @export
 */
export const SushiswapApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bundles.
         * @summary GetBundles (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/bundles/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary GetBurns (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/burns/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets day data.
         * @summary GetDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/dayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factory.
         * @summary GetFactory (historical)
         * @throws {RequiredError}
         */
        sushiswapGetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/factory/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets hour data.
         * @summary GetHourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/hourData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidity position.
         * @summary GetLiquidityPosition (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/liquidityPosition/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidity position snapshot.
         * @summary GetLiquidityPositionSnapshot (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionSnapshotHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/liquidityPositionSnapshots/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary GetMints (historical)
         * @throws {RequiredError}
         */
        sushiswapGetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/mints/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary GetPools (current)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools day data.
         * @summary GetPoolsDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/poolsDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets list of pools for given filters.
         * @summary GetPools (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pools/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools tracked each our.
         * @summary GetPoolsHourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/poolsHourData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary GetSwaps (current)
         * @throws {RequiredError}
         */
        sushiswapGetSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets list of swaps for given filters.
         * @summary GetSwaps (historical)
         * @throws {RequiredError}
         */
        sushiswapGetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/swaps/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary GetTokens (current)
         * @throws {RequiredError}
         */
        sushiswapGetTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens day data.
         * @summary GetTokensDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokensDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets list of tokens for given filters.
         * @summary GetTokens (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary GetTransactions (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/transactions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary GetUsers (historical)
         * @throws {RequiredError}
         */
        sushiswapGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/users/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SushiswapApiType = { 
    sushiswapGetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapBundleDTO>>,

    sushiswapGetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapBurnDTO>>,

    sushiswapGetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapDayDataDTO>>,

    sushiswapGetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapFactoryDTO>>,

    sushiswapGetHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapHourDataDTO>>,

    sushiswapGetLiquidityPositionHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapLiquidityPositionDTO>>,

    sushiswapGetLiquidityPositionSnapshotHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapLiquidityPositionSnapshotDTO>>,

    sushiswapGetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapMintDTO>>,

    sushiswapGetPoolsCurrent(options?: RequestOptions): Promise<Array<SushiswapPairDTO>>,

    sushiswapGetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapPairDayDataDTO>>,

    sushiswapGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapPairDTO>>,

    sushiswapGetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapPairHourDataDTO>>,

    sushiswapGetSwapsCurrent(options?: RequestOptions): Promise<Array<SushiswapSwapDTO>>,

    sushiswapGetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapSwapDTO>>,

    sushiswapGetTokensCurrent(options?: RequestOptions): Promise<Array<SushiswapTokenDTO>>,

    sushiswapGetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<SushiswapTokenDayDataDTO>>,

    sushiswapGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<SushiswapTokenDTO>>,

    sushiswapGetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapTransactionDTO>>,

    sushiswapGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapUserDTO>>,
}

/**
 * SushiswapApi - factory function to inject configuration 
 * @export
 */
export const SushiswapApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SushiswapApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bundles.
         * @summary GetBundles (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapBundleDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetBundlesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary GetBurns (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapBurnDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetBurnsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets day data.
         * @summary GetDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetDayDataHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factory.
         * @summary GetFactory (historical)
         * @throws {RequiredError}
         */
        sushiswapGetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapFactoryDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetFactoryHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets hour data.
         * @summary GetHourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapHourDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetHourDataHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidity position.
         * @summary GetLiquidityPosition (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapLiquidityPositionDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetLiquidityPositionHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidity position snapshot.
         * @summary GetLiquidityPositionSnapshot (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionSnapshotHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapLiquidityPositionSnapshotDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetLiquidityPositionSnapshotHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary GetMints (historical)
         * @throws {RequiredError}
         */
        sushiswapGetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapMintDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetMintsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary GetPools (current)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapPairDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPoolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools day data.
         * @summary GetPoolsDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPoolsDayDataHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets list of pools for given filters.
         * @summary GetPools (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPoolsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools tracked each our.
         * @summary GetPoolsHourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairHourDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPoolsHourDataHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary GetSwaps (current)
         * @throws {RequiredError}
         */
        sushiswapGetSwapsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapSwapDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets list of swaps for given filters.
         * @summary GetSwaps (historical)
         * @throws {RequiredError}
         */
        sushiswapGetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapSwapDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetSwapsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary GetTokens (current)
         * @throws {RequiredError}
         */
        sushiswapGetTokensCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapTokenDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens day data.
         * @summary GetTokensDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapTokenDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTokensDayDataHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets list of tokens for given filters.
         * @summary GetTokens (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapTokenDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTokensHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary GetTransactions (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapTransactionDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTransactionsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary GetUsers (historical)
         * @throws {RequiredError}
         */
        sushiswapGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapUserDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetUsersHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UniswapV2Api - fetch parameter creator
 * @export
 */
export const UniswapV2ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2BundlesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/bundles/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2BurnsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/burns/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2DayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/dayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2FactoryHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/factory/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2LiquidityPositionHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/liquidityPosition/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2LiquidityPositionSnapshotsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/liquidityPositionSnapshots/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2MintsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/mints/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2PoolDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/poolDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2PoolHourDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/poolHourData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetPools
         * @throws {RequiredError}
         */
        dappsUniswapv2PoolsCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2PoolsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pools/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetSwaps
         * @throws {RequiredError}
         */
        dappsUniswapv2SwapsCurrentGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2SwapsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/swaps/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2TokenDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokenDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetTokens
         * @throws {RequiredError}
         */
        dappsUniswapv2TokensCurrentGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2TokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2TransactionsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/transactions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2UsersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/users/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UniswapV2ApiType = { 
    dappsUniswapv2BundlesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2BurnsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2DayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2FactoryHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2LiquidityPositionHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2LiquidityPositionSnapshotsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2MintsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2PoolDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2PoolHourDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2PoolsCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV2PairV2DTO>>,

    dappsUniswapv2PoolsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2SwapsCurrentGet(options?: RequestOptions): Promise<Array<UniswapV2SwapV2DTO>>,

    dappsUniswapv2SwapsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2TokenDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2TokensCurrentGet(options?: RequestOptions): Promise<Array<UniswapV2TokenV2DTO>>,

    dappsUniswapv2TokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2TransactionsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsUniswapv2UsersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,
}

/**
 * UniswapV2Api - factory function to inject configuration 
 * @export
 */
export const UniswapV2Api = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UniswapV2ApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2BundlesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2BundlesHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2BurnsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2BurnsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2DayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2DayDataHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2FactoryHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2FactoryHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2LiquidityPositionHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2LiquidityPositionHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2LiquidityPositionSnapshotsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2LiquidityPositionSnapshotsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2MintsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2MintsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2PoolDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2PoolDayDataHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2PoolHourDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2PoolHourDataHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetPools
         * @throws {RequiredError}
         */
        dappsUniswapv2PoolsCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2PairV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2PoolsCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2PoolsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2PoolsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetSwaps
         * @throws {RequiredError}
         */
        dappsUniswapv2SwapsCurrentGet(options?: RequestOptions = {}): Promise<Array<UniswapV2SwapV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2SwapsCurrentGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2SwapsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2SwapsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2TokenDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2TokenDayDataHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetTokens
         * @throws {RequiredError}
         */
        dappsUniswapv2TokensCurrentGet(options?: RequestOptions = {}): Promise<Array<UniswapV2TokenV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2TokensCurrentGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2TokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2TokensHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2TransactionsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2TransactionsHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv2UsersHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).dappsUniswapv2UsersHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UniswapV3Api - fetch parameter creator
 * @export
 */
export const UniswapV3ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary GetBundles
         * @throws {RequiredError}
         */
        dappsUniswapv3BundleCurrentGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/bundle/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3BundlesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/bundles/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetBurns
         * @throws {RequiredError}
         */
        dappsUniswapv3BurnsCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/burns/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3BurnsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/burns/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3DayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/dayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetFactory
         * @throws {RequiredError}
         */
        dappsUniswapv3FactoryCurrentGet(chainId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'chainId' is not null or undefined
            if (chainId === null || chainId === undefined) {
                throw new RequiredError('chainId','Required parameter chainId was null or undefined when calling dappsUniswapv3FactoryCurrentGet.');
            }
            const localVarPath = `/dapps/uniswapv3/factory/current`
                .replace(`{${"chain_id"}}`, encodeURIComponent(String(chainId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3FactoryHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/factory/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetMints
         * @throws {RequiredError}
         */
        dappsUniswapv3MintsCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/mints/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3MintsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/mints/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolHourDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolHourData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetPools
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolsCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/pools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetPoolsDayData
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolsDayDataCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolsDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/pools/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetPoolsHourData
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolsHourDataCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolsHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3PositionSnapshotHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positionSnapshot/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetPositionSnapshot
         * @throws {RequiredError}
         */
        dappsUniswapv3PositionSnapshotsCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetPositions
         * @throws {RequiredError}
         */
        dappsUniswapv3PositionsCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3PositionsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetSwaps
         * @throws {RequiredError}
         */
        dappsUniswapv3SwapsCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3SwapsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/swaps/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TickDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tickDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetTicks
         * @throws {RequiredError}
         */
        dappsUniswapv3TicksCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/ticks/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetTicksDayData
         * @throws {RequiredError}
         */
        dappsUniswapv3TicksDayDataCurrentGet(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/ticksDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TicksHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/ticks/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TokenDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokenDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TokenHourDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokenHourData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetTokens
         * @throws {RequiredError}
         */
        dappsUniswapv3TokensCurrentGet(filterTokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterTokenId !== undefined) {
                localVarQueryParameter['filter_token_id'] = ((filterTokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetTokensDayData
         * @throws {RequiredError}
         */
        dappsUniswapv3TokensDayDataCurrentGet(filterTokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokensDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterTokenId !== undefined) {
                localVarQueryParameter['filter_token_id'] = ((filterTokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetTokensHourData
         * @throws {RequiredError}
         */
        dappsUniswapv3TokensHourDataCurrentGet(filterTokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokensHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterTokenId !== undefined) {
                localVarQueryParameter['filter_token_id'] = ((filterTokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TransactionsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/transactions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetUniswapDayData
         * @throws {RequiredError}
         */
        dappsUniswapv3UniswapDayDataCurrentGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/uniswapDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UniswapV3ApiType = { 
    dappsUniswapv3BundleCurrentGet(options?: RequestOptions): Promise<Array<UniswapV3BundleV3DTO>>,

    dappsUniswapv3BundlesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3BurnsCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3BurnV3DTO>>,

    dappsUniswapv3BurnsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3DayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3FactoryCurrentGet(chainId: string, options?: RequestOptions): Promise<Array<UniswapV3FactoryV3DTO>>,

    dappsUniswapv3FactoryHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3MintsCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3MintV3DTO>>,

    dappsUniswapv3MintsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3PoolDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3PoolHourDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3PoolsCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolV3DTO>>,

    dappsUniswapv3PoolsDayDataCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolDayDataV3DTO>>,

    dappsUniswapv3PoolsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3PoolsHourDataCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolHourDataV3DTO>>,

    dappsUniswapv3PositionSnapshotHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3PositionSnapshotsCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PositionSnapshotV3DTO>>,

    dappsUniswapv3PositionsCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PositionV3DTO>>,

    dappsUniswapv3PositionsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3SwapsCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3SwapV3DTO>>,

    dappsUniswapv3SwapsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3TickDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3TicksCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3TickV3DTO>>,

    dappsUniswapv3TicksDayDataCurrentGet(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3TickDayDataV3DTO>>,

    dappsUniswapv3TicksHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3TokenDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3TokenHourDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3TokensCurrentGet(filterTokenId?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenV3DTO>>,

    dappsUniswapv3TokensDayDataCurrentGet(filterTokenId?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenV3DayDataDTO>>,

    dappsUniswapv3TokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3TokensHourDataCurrentGet(filterTokenId?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenHourDataV3DTO>>,

    dappsUniswapv3TransactionsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Response>,

    dappsUniswapv3UniswapDayDataCurrentGet(options?: RequestOptions): Promise<Array<UniswapV3UniswapDayDataV3DTO>>,
}

/**
 * UniswapV3Api - factory function to inject configuration 
 * @export
 */
export const UniswapV3Api = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UniswapV3ApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary GetBundles
         * @throws {RequiredError}
         */
        dappsUniswapv3BundleCurrentGet(options?: RequestOptions = {}): Promise<Array<UniswapV3BundleV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3BundleCurrentGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3BundlesHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3BundlesHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetBurns
         * @throws {RequiredError}
         */
        dappsUniswapv3BurnsCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3BurnV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3BurnsCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3BurnsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3BurnsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3DayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3DayDataHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetFactory
         * @throws {RequiredError}
         */
        dappsUniswapv3FactoryCurrentGet(chainId: string, options?: RequestOptions = {}): Promise<Array<UniswapV3FactoryV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3FactoryCurrentGet(chainId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3FactoryHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3FactoryHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetMints
         * @throws {RequiredError}
         */
        dappsUniswapv3MintsCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3MintV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3MintsCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3MintsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3MintsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3PoolDayDataHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolHourDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3PoolHourDataHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetPools
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolsCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3PoolsCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetPoolsDayData
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolsDayDataCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolDayDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3PoolsDayDataCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3PoolsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetPoolsHourData
         * @throws {RequiredError}
         */
        dappsUniswapv3PoolsHourDataCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolHourDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3PoolsHourDataCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3PositionSnapshotHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3PositionSnapshotHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetPositionSnapshot
         * @throws {RequiredError}
         */
        dappsUniswapv3PositionSnapshotsCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PositionSnapshotV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3PositionSnapshotsCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetPositions
         * @throws {RequiredError}
         */
        dappsUniswapv3PositionsCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PositionV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3PositionsCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3PositionsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3PositionsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetSwaps
         * @throws {RequiredError}
         */
        dappsUniswapv3SwapsCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3SwapV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3SwapsCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3SwapsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3SwapsHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TickDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TickDayDataHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetTicks
         * @throws {RequiredError}
         */
        dappsUniswapv3TicksCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TickV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TicksCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetTicksDayData
         * @throws {RequiredError}
         */
        dappsUniswapv3TicksDayDataCurrentGet(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TickDayDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TicksDayDataCurrentGet(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TicksHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TicksHistoricalGet(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TokenDayDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TokenDayDataHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TokenHourDataHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TokenHourDataHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetTokens
         * @throws {RequiredError}
         */
        dappsUniswapv3TokensCurrentGet(filterTokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TokensCurrentGet(filterTokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetTokensDayData
         * @throws {RequiredError}
         */
        dappsUniswapv3TokensDayDataCurrentGet(filterTokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenV3DayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TokensDayDataCurrentGet(filterTokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TokensHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TokensHistoricalGet(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetTokensHourData
         * @throws {RequiredError}
         */
        dappsUniswapv3TokensHourDataCurrentGet(filterTokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenHourDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TokensHourDataCurrentGet(filterTokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        dappsUniswapv3TransactionsHistoricalGet(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3TransactionsHistoricalGet(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary GetUniswapDayData
         * @throws {RequiredError}
         */
        dappsUniswapv3UniswapDayDataCurrentGet(options?: RequestOptions = {}): Promise<Array<UniswapV3UniswapDayDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).dappsUniswapv3UniswapDayDataCurrentGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    CowApi: CowApiType,

    CurveApi: CurveApiType,

    DexApi: DexApiType,

    SushiswapApi: SushiswapApiType,

    UniswapV2Api: UniswapV2ApiType,

    UniswapV3Api: UniswapV3ApiType,
 }
