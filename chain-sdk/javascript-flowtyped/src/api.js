// @flow
/* eslint-disable no-use-before-define */
/**
 * On Chain Dapps - REST API
 *  This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://onchain.coinapi.io".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSBidDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSBidDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSBidDTO
     */
    recv_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSBidDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    tokens_bid?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    token_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    bidder?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSCollectionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    total_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    royalty_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    buyer_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    seller_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSCollectionDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    collection?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    royalty_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_min_sale_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_max_sale_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_traded_item_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSDataSourcesDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    block_range?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    causality_region?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    manifest_idx?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    parent?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    param?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    context?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    done_at?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSItemDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSItemDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSItemDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSItemDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSItemDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSItemDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSItemDTO
     */
    id?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSMarketPlaceDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    schema_version?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    subgraph_version?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    methodology_version?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    collection_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    cumulative_unique_traders?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSMarketplaceDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    marketplace?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    collection_count?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    cumulative_unique_traders?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_active_traders?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_traded_collection_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_traded_item_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSTradeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    recv_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    transaction_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    log_index?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    is_bundle?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    collection?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    token_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    price_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    buyer?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    seller?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSUserDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSUserDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSUserDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSUserDTO
     */
    id?: string;
}

/**
 * 
 * @export
 */
export type CowOrderDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowOrderDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowOrderDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowOrderDTO
     */
    block_number?: number;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowOrderDTO
     */
    id?: string;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowOrderDTO
     */
    owner?: string;
    /**
     * Block\'s timestamp on trade event.
     * @type {string}
     * @memberof CowOrderDTO
     */
    trades_timestamp?: string;
    /**
     * Block\'s timestamp on invalidate event.
     * @type {string}
     * @memberof CowOrderDTO
     */
    invalidate_timestamp?: string;
    /**
     * Block\'s timestamp on presign event.
     * @type {string}
     * @memberof CowOrderDTO
     */
    presign_timestamp?: string;
    /**
     * Determines whether order is signed.
     * @type {boolean}
     * @memberof CowOrderDTO
     */
    is_signed?: boolean;
    /**
     * Determines whether order is valid.
     * @type {boolean}
     * @memberof CowOrderDTO
     */
    is_valid?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CowOrderDTO
     */
    vid?: number;
}

/**
 * A settlement comprises a list of traded tokens with their corresponding price in the batch.
 * @export
 */
export type CowSettlementDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowSettlementDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowSettlementDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowSettlementDTO
     */
    block_number?: number;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    id?: string;
    /**
     * Solver\'s address.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    solver?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    tx_hash?: string;
    /**
     * First trade timestamp.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    first_trade_timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof CowSettlementDTO
     */
    vid?: number;
}

/**
 * Stores information for a specific token across all pairs that token is included in.
 * @export
 */
export type CowTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowTokenDTO
     */
    block_number?: number;
    /**
     * Token\'s address.
     * @type {string}
     * @memberof CowTokenDTO
     */
    id?: string;
    /**
     * Token\'s address.
     * @type {string}
     * @memberof CowTokenDTO
     */
    address?: string;
    /**
     * First token trade block timestamp.
     * @type {string}
     * @memberof CowTokenDTO
     */
    first_trade_timestamp?: string;
    /**
     * Token name fetched by ERC20 contract call.
     * @type {string}
     * @memberof CowTokenDTO
     */
    name?: string;
    /**
     * Token symbol fetched by contract call.
     * @type {string}
     * @memberof CowTokenDTO
     */
    symbol?: string;
    /**
     * Token decimals fetched by contract call.
     * @type {number}
     * @memberof CowTokenDTO
     */
    decimals?: number;
    /**
     * Sum of total amount traded for this token.
     * @type {string}
     * @memberof CowTokenDTO
     */
    total_volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CowTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CowTokenDTO
     */
    token_symbol?: string;
}

/**
 * Trade entity.
 * @export
 */
export type CowTradeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowTradeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowTradeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowTradeDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (order id)|(transaction hash)|(event index).
     * @type {string}
     * @memberof CowTradeDTO
     */
    id?: string;
    /**
     * Block\'s timestamp.
     * @type {string}
     * @memberof CowTradeDTO
     */
    timestamp?: string;
    /**
     * Transaction\'s gas price.
     * @type {string}
     * @memberof CowTradeDTO
     */
    gas_price?: string;
    /**
     * Transaction\'s gas limit.
     * @type {string}
     * @memberof CowTradeDTO
     */
    gas_limit?: string;
    /**
     * Trade\'s fee amount.
     * @type {string}
     * @memberof CowTradeDTO
     */
    fee_amount?: string;
    /**
     * Trade event transaction hash.
     * @type {string}
     * @memberof CowTradeDTO
     */
    tx_hash?: string;
    /**
     * Reference to settlement.
     * @type {string}
     * @memberof CowTradeDTO
     */
    settlement?: string;
    /**
     * Buy amount.
     * @type {string}
     * @memberof CowTradeDTO
     */
    buy_amount?: string;
    /**
     * Sell amount.
     * @type {string}
     * @memberof CowTradeDTO
     */
    sell_amount?: string;
    /**
     * Address of token that is sold.
     * @type {string}
     * @memberof CowTradeDTO
     */
    sell_token?: string;
    /**
     * Address of token that is bought.
     * @type {string}
     * @memberof CowTradeDTO
     */
    buy_token?: string;
    /**
     * Reference to order.
     * @type {string}
     * @memberof CowTradeDTO
     */
    order?: string;
    /**
     * 
     * @type {number}
     * @memberof CowTradeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CowTradeDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CowTradeDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof CowTradeDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof CowTradeDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof CowTradeDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * 
 * @export
 */
export type CowUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowUserDTO
     */
    block_number?: number;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowUserDTO
     */
    id?: string;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowUserDTO
     */
    address?: string;
    /**
     * First trade block timestamp.
     * @type {string}
     * @memberof CowUserDTO
     */
    first_trade_timestamp?: string;
    /**
     * Determines if user has solved a settlement.
     * @type {boolean}
     * @memberof CowUserDTO
     */
    is_solver?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CowUserDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAccountDTO
     */
    address?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAccountDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAddLiquidityEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAddLiquidityEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAddLiquidityEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAddLiquidityEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    provider?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveAddLiquidityEventDTO
     */
    token_amounts?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveAddLiquidityEventDTO
     */
    fees?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    invariant?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    token_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAddLiquidityEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAdminFeeChangeLogDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAmplificationCoeffChangeLogDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveCoinDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveCoinDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveCoinDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveCoinDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool_id)-(coin_index).
     * @type {string}
     * @memberof CurveCoinDTO
     */
    id?: string;
    /**
     * Coin index.
     * @type {number}
     * @memberof CurveCoinDTO
     */
    index?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    underlying?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    balance?: string;
    /**
     * Exchange rate between this coin and the associated underlying coin within the pool.
     * @type {string}
     * @memberof CurveCoinDTO
     */
    rate?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveCoinDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    block_range?: string;
}

/**
 * 
 * @export
 */
export type CurveContractDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveContractDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveContractDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveContractDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    id?: string;
    /**
     * Human-readable description.
     * @type {string}
     * @memberof CurveContractDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    added?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    added_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    added_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    modified?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    modified_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    modified_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveContractDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveContractVersionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveContractVersionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveContractVersionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveContractVersionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    contract?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    added?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    added_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    added_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveContractVersionDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveDailyVolumeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveDailyVolumeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveDailyVolumeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveDailyVolumeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveDailyVolumeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    block_range?: string;
}

/**
 * 
 * @export
 */
export type CurveExchangeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveExchangeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveExchangeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    buyer?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    receiver?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    token_sold?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    token_bought?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    amount_sold?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    amount_bought?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    vid?: number;
    /**
     * 
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof CurveExchangeDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    transaction_id?: string;
}

/**
 * 
 * @export
 */
export type CurveFeeChangeLogDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveFeeChangeLogDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveFeeChangeLogDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveFeeChangeLogDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveFeeChangeLogDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    created_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    created_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeDepositDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeDepositDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    block_range?: string;
}

/**
 * 
 * @export
 */
export type CurveGaugeLiquidityDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeLiquidityDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeLiquidityDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeLiquidityDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    original_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    original_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    working_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    working_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeLiquidityDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeTotalWeightDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTotalWeightDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTotalWeightDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeTotalWeightDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTotalWeightDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTotalWeightDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTotalWeightDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeTotalWeightDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeTypeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeTypeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeDTO
     */
    gauge_count?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeTypeDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeTypeWeightDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeWeightDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeWeightDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeTypeWeightDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeTypeWeightDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeWeightDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeWeightDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeWeightDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeWeightVoteDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightVoteDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightVoteDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeWeightVoteDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeWeightVoteDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeWithdrawDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeWithdrawDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveHourlyVolumeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveHourlyVolumeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveHourlyVolumeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveHourlyVolumeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveHourlyVolumeDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveLpTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveLpTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveLpTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveLpTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    decimals?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    pool?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveLpTokenDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurvePoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurvePoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurvePoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurvePoolDTO
     */
    block_number?: number;
    /**
     * Pool address.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    id?: string;
    /**
     * Pool\'s human-readable name.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    name?: string;
    /**
     * Identify whether pool is a metapool.
     * @type {boolean}
     * @memberof CurvePoolDTO
     */
    is_meta?: boolean;
    /**
     * Registry contract address from where this pool was registered.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    registry_address?: string;
    /**
     * Swap contract address.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    swap_address?: string;
    /**
     * Address of the token representing LP share.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    lp_token?: string;
    /**
     * Number of coins composing the pool.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    coin_count?: string;
    /**
     * Number of underlying coins composing the pool.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    underlying_count?: string;
    /**
     * Amplification coefficient multiplied by n * (n - 1).
     * @type {string}
     * @memberof CurvePoolDTO
     */
    a?: string;
    /**
     * Fee to charge for exchanges.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    fee?: string;
    /**
     * Admin fee is represented as a percentage of the total fee collected on a swap.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    admin_fee?: string;
    /**
     * Admin address.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    owner?: string;
    /**
     * Average dollar value of pool token.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    virtual_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    locked?: string;
    /**
     * 
     * @type {Date}
     * @memberof CurvePoolDTO
     */
    added_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    added_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    added_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    removed_at?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    removed_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    removed_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    exchange_count?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    gauge_count?: string;
    /**
     * 
     * @type {number}
     * @memberof CurvePoolDTO
     */
    vid?: number;
    /**
     * 
     * @type {number}
     * @memberof CurvePoolDTO
     */
    evaluated_ask?: number;
}

/**
 * 
 * @export
 */
export type CurveProposalDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveProposalDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    id?: string;
    /**
     * Sequential number in related to the realted voting app.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    _number?: string;
    /**
     * Voting app instance.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    app?: string;
    /**
     * Proposal creator\'s account.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    creator?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    execution_script?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    expire_date?: string;
    /**
     * Percentage of positive votes in total possible votes for this proposal to be accepted.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    minimum_quorum?: string;
    /**
     * Percentage of positive votes needed for this proposal to be accepted.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    required_support?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    snapshot_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    voting_power?: string;
    /**
     * Link to metadata file.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    metadata?: string;
    /**
     * Proposal description text.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    text?: string;
    /**
     * Number of votes received by the proposal.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    vote_count?: string;
    /**
     * Number of positive votes (yes) received by the proposal.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    positive_vote_count?: string;
    /**
     * Number of negative votes (no) received by the proposal.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    negative_vote_count?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    current_quorum?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    current_support?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    staked_support?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    total_staked?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    created_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    created_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    executed?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    executed_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    executed_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveProposalDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveProposalVoteDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalVoteDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalVoteDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveProposalVoteDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    proposal?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CurveProposalVoteDTO
     */
    supports?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    stake?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    voter?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    created_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    created_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveProposalVoteDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveRemoveLiquidityEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    provider?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    token_amounts?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    fees?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    token_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    invariant?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveRemoveLiquidityOneEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    token_amount?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    coin_amount?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveSystemStateDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveSystemStateDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveSystemStateDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveSystemStateDTO
     */
    block_number?: number;
    /**
     * Singleton ID, equals to \'current\'.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    id?: string;
    /**
     * Current pool registry address.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    registry_contract?: string;
    /**
     * Number of contracts in the AddressProvider registry.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    contract_count?: string;
    /**
     * Number of gauges registered.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    gauge_count?: string;
    /**
     * Number of gauge types registered.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    gauge_type_count?: string;
    /**
     * Number of active pools.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    pool_count?: string;
    /**
     * Number of tokens registered.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    token_count?: string;
    /**
     * Total number of pools (including removed ones).
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    total_pool_count?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveSystemStateDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    decimals?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    symbol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveTokenDTO
     */
    pools?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CurveTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type CurveTransferOwnershipEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveTransferOwnershipEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveTransferOwnershipEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveTransferOwnershipEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    new_admin?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveTransferOwnershipEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveUnderlyingCoinDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveUnderlyingCoinDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveUnderlyingCoinDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveUnderlyingCoinDTO
     */
    block_number?: number;
    /**
     * Equals to: (pool_id)-(coin_index).
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    id?: string;
    /**
     * Coin index.
     * @type {number}
     * @memberof CurveUnderlyingCoinDTO
     */
    index?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    coin?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveUnderlyingCoinDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveVotingAppDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveVotingAppDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveVotingAppDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveVotingAppDTO
     */
    block_number?: number;
    /**
     * App address.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    codename?: string;
    /**
     * Minimum balance needed to create a proposal.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    minimum_balance?: string;
    /**
     * Percentage of positive votes in total possible votes for a proposal to be accepted.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    minimum_quorum?: string;
    /**
     * Minimum time needed to pass between user\'s previous proposal and a user creating a new proposal.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    minimum_time?: string;
    /**
     * Percentage of positive votes needed for a proposal to be accepted.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    required_support?: string;
    /**
     * Seconds that a proposal will be open for vote (unless enough votes have been cast to make an early decision).
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    vote_time?: string;
    /**
     * Number of proposals created with this app.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    proposal_count?: string;
    /**
     * Number of votes received by all the proposals created with this app.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    vote_count?: string;
    /**
     * Address of the token used for voting.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveVotingAppDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveWeeklyVolumeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveWeeklyVolumeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveWeeklyVolumeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveWeeklyVolumeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveWeeklyVolumeDTO
     */
    vid?: number;
}

/**
 * Batch executed. Every batch will contain at least solution with the a set of trades that are executed in it
 * @export
 */
export type DexBatchDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexBatchDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexBatchDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexBatchDTO
     */
    block_number?: number;
    /**
     * Identifier.
     * @type {string}
     * @memberof DexBatchDTO
     */
    id?: string;
    /**
     * Start epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    start_epoch?: string;
    /**
     * End epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    end_epoch?: string;
    /**
     * Reference to solution.
     * @type {string}
     * @memberof DexBatchDTO
     */
    solution?: string;
    /**
     * First solution epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    first_solution_epoch?: string;
    /**
     * Last revert epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    last_revert_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexBatchDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexBatchDTO
     */
    vid?: number;
}

/**
 * Deposit of an user.
 * @export
 */
export type DexDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexDepositDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (transaction hash)-(token id).
     * @type {string}
     * @memberof DexDepositDTO
     */
    id?: string;
    /**
     * User address.
     * @type {string}
     * @memberof DexDepositDTO
     */
    user?: string;
    /**
     * Token address.
     * @type {string}
     * @memberof DexDepositDTO
     */
    token_address?: string;
    /**
     * Amount of deposit.
     * @type {string}
     * @memberof DexDepositDTO
     */
    amount?: string;
    /**
     * Identifier (numerical).
     * @type {string}
     * @memberof DexDepositDTO
     */
    batch_id?: string;
    /**
     * Create epoch.
     * @type {string}
     * @memberof DexDepositDTO
     */
    create_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexDepositDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexDepositDTO
     */
    vid?: number;
}

/**
 * Order submitted by an user. It has a validity (dates) so they can only be executed from/until some given batches. Partial executions of this trades must respect the limit price.
 * @export
 */
export type DexOrderDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexOrderDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexOrderDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexOrderDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (owner address)-(order id)
     * @type {string}
     * @memberof DexOrderDTO
     */
    id?: string;
    /**
     * Reference to owner.
     * @type {string}
     * @memberof DexOrderDTO
     */
    owner?: string;
    /**
     * Order id.
     * @type {number}
     * @memberof DexOrderDTO
     */
    order_id?: number;
    /**
     * Batch id from which order became valid.
     * @type {string}
     * @memberof DexOrderDTO
     */
    from_batch_id?: string;
    /**
     * Start of epoch in which order was placed and became valid.
     * @type {string}
     * @memberof DexOrderDTO
     */
    from_epoch?: string;
    /**
     * Batch id until which trade was still valid.
     * @type {string}
     * @memberof DexOrderDTO
     */
    until_batch_id?: string;
    /**
     * End of epoch in which order was placed.
     * @type {string}
     * @memberof DexOrderDTO
     */
    until_epoch?: string;
    /**
     * Identifier of token that was bought.
     * @type {string}
     * @memberof DexOrderDTO
     */
    buy_token?: string;
    /**
     * Identifier of token that was sold.
     * @type {string}
     * @memberof DexOrderDTO
     */
    sell_token?: string;
    /**
     * Price enumerator.
     * @type {string}
     * @memberof DexOrderDTO
     */
    price_numerator?: string;
    /**
     * Price denominator.
     * @type {string}
     * @memberof DexOrderDTO
     */
    price_denominator?: string;
    /**
     * Maximum sell amount.
     * @type {string}
     * @memberof DexOrderDTO
     */
    max_sell_amount?: string;
    /**
     * Minimum receive amount.
     * @type {string}
     * @memberof DexOrderDTO
     */
    min_receive_amount?: string;
    /**
     * Sold volume.
     * @type {string}
     * @memberof DexOrderDTO
     */
    sold_volume?: string;
    /**
     * Bought volume.
     * @type {string}
     * @memberof DexOrderDTO
     */
    bought_volume?: string;
    /**
     * Epoch in which order was created.
     * @type {string}
     * @memberof DexOrderDTO
     */
    create_epoch?: string;
    /**
     * Epoch in which order was cancelled.
     * @type {string}
     * @memberof DexOrderDTO
     */
    cancel_epoch?: string;
    /**
     * Epoch in which order was deleted.
     * @type {string}
     * @memberof DexOrderDTO
     */
    delete_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexOrderDTO
     */
    tx_hash?: string;
    /**
     * Event index within transaction.
     * @type {string}
     * @memberof DexOrderDTO
     */
    tx_log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof DexOrderDTO
     */
    vid?: number;
}

/**
 * Token price in conjuction with batch id.
 * @export
 */
export type DexPriceDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexPriceDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexPriceDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexPriceDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (token id)-(batch id).
     * @type {string}
     * @memberof DexPriceDTO
     */
    id?: string;
    /**
     * Token identifier.
     * @type {string}
     * @memberof DexPriceDTO
     */
    token?: string;
    /**
     * Batch identifier.
     * @type {string}
     * @memberof DexPriceDTO
     */
    batch_id?: string;
    /**
     * Price enumerator in OWL (derivative of the GNO token).
     * @type {string}
     * @memberof DexPriceDTO
     */
    price_in_owl_numerator?: string;
    /**
     * Price denominator in OWL (derivative of the GNO token).
     * @type {string}
     * @memberof DexPriceDTO
     */
    price_in_owl_denominator?: string;
    /**
     * Volume.
     * @type {string}
     * @memberof DexPriceDTO
     */
    volume?: string;
    /**
     * Create epoch.
     * @type {string}
     * @memberof DexPriceDTO
     */
    create_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexPriceDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexPriceDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type DexSolutionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexSolutionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexSolutionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexSolutionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    batch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    solver?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    fee_reward?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    objective_value?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    utility?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DexSolutionDTO
     */
    trades?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    revert_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    tx_log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof DexSolutionDTO
     */
    vid?: number;
}

/**
 * A type collecting global stats about this instance of Gnosis Protocol.
 * @export
 */
export type DexStatsDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexStatsDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexStatsDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexStatsDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexStatsDTO
     */
    id?: string;
    /**
     * The total volume denominated in OWL (all sell amounts combined).
     * @type {string}
     * @memberof DexStatsDTO
     */
    volume_in_owl?: string;
    /**
     * The total trader surplus in OWL.
     * @type {string}
     * @memberof DexStatsDTO
     */
    utility_in_owl?: string;
    /**
     * The total amount of OWL burnt (equivalent to fees rewarded to solvers).
     * @type {string}
     * @memberof DexStatsDTO
     */
    owl_burnt?: string;
    /**
     * The total number of settled batches.
     * @type {number}
     * @memberof DexStatsDTO
     */
    settled_batch_count?: number;
    /**
     * The total number of settled trades.
     * @type {number}
     * @memberof DexStatsDTO
     */
    settled_trade_count?: number;
    /**
     * The number of listed tokens.
     * @type {number}
     * @memberof DexStatsDTO
     */
    listed_tokens?: number;
    /**
     * 
     * @type {number}
     * @memberof DexStatsDTO
     */
    vid?: number;
}

/**
 * Registered token.
 * @export
 */
export type DexTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    from_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    decimals?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    name?: string;
    /**
     * Cumulative sell volume.
     * @type {string}
     * @memberof DexTokenDTO
     */
    sell_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    token_symbol?: string;
}

/**
 * Trade for a single user, as part of a ring trade. It\'s part of the solution submitted by a solver for a given batch.
 * @export
 */
export type DexTradeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexTradeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexTradeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexTradeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    order?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    sell_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    buy_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    trade_batch_id?: string;
    /**
     * The date of the end of the batch.
     * @type {string}
     * @memberof DexTradeDTO
     */
    trade_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    buy_token?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    sell_token?: string;
    /**
     * The date where the transaction was mined.
     * @type {string}
     * @memberof DexTradeDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    revert_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    tx_log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof DexTradeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof DexTradeDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof DexTradeDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof DexTradeDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * User of the protocol. Any ethereum account that deposited tokens or traded.
 * @export
 */
export type DexUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexUserDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    from_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexUserDTO
     */
    vid?: number;
}

/**
 * Withdraw of an user.
 * @export
 */
export type DexWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexWithdrawDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (transaction hash)-(id).
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    token_address?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    create_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexWithdrawDTO
     */
    vid?: number;
}

/**
 * Withdraw request of an user
 * @export
 */
export type DexWithdrawRequestDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawRequestDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawRequestDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexWithdrawRequestDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (transaction hash)-(id).
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    token_address?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    withdrawable_from_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    create_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexWithdrawRequestDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type NumericsBigInteger = {
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_power_of_two?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_zero?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_one?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_even?: boolean;
    /**
     * 
     * @type {number}
     * @memberof NumericsBigInteger
     */
    sign?: number;
}

/**
 * The Bundle is used as a global store of derived ETH price in USD.
 * @export
 */
export type SushiswapBundleDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBundleDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBundleDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapBundleDTO
     */
    block_number?: number;
    /**
     * Hardcoded to \'1\'.
     * @type {string}
     * @memberof SushiswapBundleDTO
     */
    id?: string;
    /**
     * Price of native.
     * @type {string}
     * @memberof SushiswapBundleDTO
     */
    eth_price?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapBundleDTO
     */
    vid?: number;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type SushiswapBurnDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBurnDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBurnDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapBurnDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (transaction id):(transaction.burns.length).
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    id?: string;
    /**
     * Reference to the transaction Burn was included in.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    transaction?: string;
    /**
     * Timestamp of Burn, used to sort recent liquidity removals.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    pair?: string;
    /**
     * Amount of liquidity tokens burned.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity removal.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    sender?: string;
    /**
     * Amount of token0 removed.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 removed.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_1?: string;
    /**
     * Recipient of tokens.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    to?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    log_index?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SushiswapBurnDTO
     */
    complete?: boolean;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    fee_to?: string;
    /**
     * Amount of tokens sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapBurnDTO
     */
    vid?: number;
}

/**
 * Tracks data across all pairs aggregated into a daily bucket.
 * @export
 */
export type SushiswapDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    block_number?: number;
    /**
     * Unix timestamp for start of day / 86400 giving a unique day index.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    _date?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    factory?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    volume_usd?: string;
    /**
     * Total volume across all pairs on this day, untracked
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    untracked_volume?: string;
    /**
     * Total liquidity across all pairs in ETH up to and including this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    liquidity_eth?: string;
    /**
     * Total liquidity across all pairs in USD up to and including this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    liquidity_usd?: string;
    /**
     * Number of transactions throughout this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    vid?: number;
}

/**
 * The Sushiswap Factory entity is responsible for storing aggregate information across all Sushiswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type SushiswapFactoryDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapFactoryDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapFactoryDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapFactoryDTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    id?: string;
    /**
     * Amount of pairs created by the Sushiswap factory.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    pair_count?: string;
    /**
     * All time USD volume across all pairs (USD is derived).
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    volume_usd?: string;
    /**
     * All time volume in ETH across all pairs (ETH is derived).
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    volume_eth?: string;
    /**
     * Untracked volume USD.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    untracked_volume_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    liquidity_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived ETH amount.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    liquidity_eth?: string;
    /**
     * All time amount of transactions across all pairs.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    tx_count?: string;
    /**
     * Total count of tokens.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    token_count?: string;
    /**
     * Users count.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    user_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapFactoryDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    block_number?: number;
    /**
     * Start of hour timestamp.
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    _date?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    factory?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    volume_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    untracked_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    liquidity_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    liquidity_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapLiquidityPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pair address)-(user address)
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    id?: string;
    /**
     * User address.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    user?: string;
    /**
     * Pair address.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    pair?: string;
    /**
     * Amount of LP tokens minted for this position.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    liquidity_token_balance?: string;
    /**
     * Block number at which position was created.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    block?: number;
    /**
     * Creation time.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    vid?: number;
}

/**
 * This entity is used to store data about a user\'s liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
 * @export
 */
export type SushiswapLiquidityPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pair address)-(user address)-(timestamp)
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    id?: string;
    /**
     * Reference to LP identifier.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_position?: string;
    /**
     * Creation time.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    timestamp?: number;
    /**
     * Block in which snapshot has been created.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    block?: number;
    /**
     * Reference to user.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    user?: string;
    /**
     * Reference to the pair liquidity is being provided on.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    pair?: string;
    /**
     * Snapshot of token0 price in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    token_0_price_usd?: string;
    /**
     * Snapshot of token0 price in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    token_1_price_usd?: string;
    /**
     * Snapshot of pair token0 reserves.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_0?: string;
    /**
     * Snapshot of pair token1 reserves.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_1?: string;
    /**
     * Snapshot of pair reserves in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_usd?: string;
    /**
     * Snapshot of pool token supply.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_token_total_supply?: string;
    /**
     * Snapshot of users pool token balance.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_token_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    vid?: number;
}

/**
 * Mint entities are created for every emitted Mint event on the Sushiswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
 * @export
 */
export type SushiswapMintDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapMintDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapMintDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapMintDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (transaction hash)-(index in the transaction mint array).
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    id?: string;
    /**
     * Reference to the transaction Mint was included in.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    transaction?: string;
    /**
     * Timestamp of Mint, used to sort recent liquidity provisions.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    pair?: string;
    /**
     * Recipient of liquidity tokens.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    to?: string;
    /**
     * Amount of liquidity tokens minted.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity provision.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    sender?: string;
    /**
     * Amount of token0 provided.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 provided.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_1?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    log_index?: string;
    /**
     * Derived USD value of token0 amount plus token1 amount.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_usd?: string;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    fee_to?: string;
    /**
     * Amount of liquidity sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapMintDTO
     */
    vid?: number;
}

/**
 * Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
 * @export
 */
export type SushiswapPairDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    block_number?: number;
    /**
     * Pair contract address.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    id?: string;
    /**
     * Factory contract address.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    factory?: string;
    /**
     * Friendly name, format: (token0 name)-(token1 name)
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    name?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_0?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_1?: string;
    /**
     * Reserve of token0.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    total_supply?: string;
    /**
     * Total liquidity in pair stored as an amount of ETH.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_eth?: string;
    /**
     * Total liquidity amount in pair stored as an amount of USD.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_usd?: string;
    /**
     * Total liquidity with only tracked amount.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    tracked_reserve_eth?: string;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_1_price?: string;
    /**
     * Amount of token0 swapped on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_token_0?: string;
    /**
     * Amount of token1 swapped on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_token_1?: string;
    /**
     * Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_usd?: string;
    /**
     * Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    untracked_volume_usd?: string;
    /**
     * All time amount of transactions on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    tx_count?: string;
    /**
     * Total number of LPs.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    liquidity_provider_count?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    timestamp?: string;
    /**
     * Block number in which pair information was created in.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    block?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    vid?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    evaluated_ask?: number;
}

/**
 * Tracks pair data across each day.
 * @export
 */
export type SushiswapPairDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pair id)-(day start timestamp).
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    _date?: number;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    pair?: string;
    /**
     * Reference to token0.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    token_0?: string;
    /**
     * Reference to token1.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    token_1?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    total_supply?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_token_1?: string;
    /**
     * Total volume within pair throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions on pair throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    vid?: number;
}

/**
 * Tracks pair data across each hour.
 * @export
 */
export type SushiswapPairHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pair id)-(hour start timestamp).
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    id?: string;
    /**
     * Hour start timestamp.
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    _date?: number;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    pair?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_1?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_token_1?: string;
    /**
     * Total volume within pair throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions on pair throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    vid?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type SushiswapSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    block_number?: number;
    /**
     * Transaction hash plus index in Transaction swap array.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    id?: string;
    /**
     * Reference to transaction swap was included in.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    transaction?: string;
    /**
     * Timestamp of swap, used for sorted lookups.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    pair?: string;
    /**
     * Address that initiated the swap.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    sender?: string;
    /**
     * Amount of token0 sold.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_0_in?: string;
    /**
     * Amount of token1 sold.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_1_in?: string;
    /**
     * Amount of token0 received.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_0_out?: string;
    /**
     * Amount of token1 received.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_1_out?: string;
    /**
     * Recipient of output tokens.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    to?: string;
    /**
     * Event index within transaction.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    log_index?: string;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof SushiswapSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type SushiswapTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTokenDTO
     */
    block_number?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    id?: string;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    factory?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    decimals?: string;
    /**
     * Total supply of liquidity token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    total_supply?: string;
    /**
     * Amount of token traded all time across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    volume?: string;
    /**
     * Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    volume_usd?: string;
    /**
     * Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    untracked_volume_usd?: string;
    /**
     * Amount of transactions all time in pairs including token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    tx_count?: string;
    /**
     * Total amount of token provided as liquidity across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    liquidity?: string;
    /**
     * ETH per token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    derived_eth?: string;
    /**
     * Array of whitelisted pairs.
     * @type {Array<string>}
     * @memberof SushiswapTokenDTO
     */
    whitelist_pairs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    token_symbol?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type SushiswapTokenDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, day start timestamp in unix / 86400.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    _date?: number;
    /**
     * Reference to token entity.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    token?: string;
    /**
     * Amount of token swapped across all pairs throughout day.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume_eth?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions with this token across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    tx_count?: string;
    /**
     * Token amount of token deposited across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of ETH.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity_eth?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity_usd?: string;
    /**
     * Price of token in derived USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    vid?: number;
}

/**
 * Transaction entities are created for each Ethereum transaction that contains an interaction within Sushiswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
 * @export
 */
export type SushiswapTransactionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTransactionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTransactionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTransactionDTO
     */
    block_number?: number;
    /**
     * Ethereum transaction hash.
     * @type {string}
     * @memberof SushiswapTransactionDTO
     */
    id?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof SushiswapTransactionDTO
     */
    timestamp?: string;
    /**
     * Array of Mint events within the transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    mints?: Array<string>;
    /**
     * Array of Burn events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    burns?: Array<string>;
    /**
     * Array of Swap events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    swaps?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTransactionDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapUserDTO
     */
    block_number?: number;
    /**
     * User address.
     * @type {string}
     * @memberof SushiswapUserDTO
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapUserDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export type TransactionsETradeAggressiveSide = 'Buy' | 'Sell' | 'EstimatedBuy' | 'EstimatedSell' | 'Unknown';

/**
 * The Bundle is used as a global store of derived ETH price in USD. Because there is no guaranteed common base token across pairs, a global reference of USD price is useful for deriving other USD values. The Bundle entity stores an updated weighted average of ETH<->Stablecoin pair prices. This provides a strong estimate for the USD price of ETH.
 * @export
 */
export type UniswapV2BundleDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BundleDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BundleDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2BundleDTO
     */
    block_number?: number;
    /**
     * Constant 1.
     * @type {string}
     * @memberof UniswapV2BundleDTO
     */
    id?: string;
    /**
     * Derived price of ETH in USD based on stablecoin pairs.
     * @type {string}
     * @memberof UniswapV2BundleDTO
     */
    eth_price?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2BundleDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2BundleDTO
     */
    block_range?: string;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type UniswapV2BurnDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BurnDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BurnDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2BurnDTO
     */
    block_number?: number;
    /**
     * Transaction hash plus index in the transaction burn array
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    id?: string;
    /**
     * Reference to the transaction Burn was included in.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    transaction?: string;
    /**
     * Timestamp of Burn, used to sort recent liquidity removals.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    pair?: string;
    /**
     * Amount of liquidity tokens burned.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity removal.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    sender?: string;
    /**
     * Amount of token0 removed.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 removed.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    amount_1?: string;
    /**
     * Recipient of tokens.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    to?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    log_index?: string;
    /**
     * Derived USD value of token0 amount plus token1 amount.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UniswapV2BurnDTO
     */
    needs_complete?: boolean;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    fee_to?: string;
    /**
     * Amount of tokens sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2BurnDTO
     */
    vid?: number;
}

/**
 * This entity is used to store data about a user\'s liquidity position. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more.
 * @export
 */
export type UniswapV2LiquidityPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    block_number?: number;
    /**
     * User address and pair address concatenated with a dash.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    id?: string;
    /**
     * Reference to user.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    user?: string;
    /**
     * Reference to the pair liquidity is being provided on.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    pair?: string;
    /**
     * Amount of LP tokens minted for this position.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    liquidity_token_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    vid?: number;
}

/**
 * This entity is used to store data about a user\'s liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
 * @export
 */
export type UniswapV2LiquidityPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pair address)-(user address)
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    id?: string;
    /**
     * Reference to LP identifier.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    liquidity_position?: string;
    /**
     * Creation time.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    timestamp?: number;
    /**
     * Number of block in which LP snapshot was recorded.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    block?: number;
    /**
     * Reference to user.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    user?: string;
    /**
     * Reference to the pair liquidity is being provided on.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    pair?: string;
    /**
     * Snapshot of token0 price.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    token_0_price_usd?: string;
    /**
     * Snapshot of token0 price.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    token_1_price_usd?: string;
    /**
     * Snapshot of pair token0 reserves.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    reserve_0?: string;
    /**
     * Snapshot of pair token1 reserves.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    reserve_1?: string;
    /**
     * Snapshot of pair reserves in USD.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    reserve_usd?: string;
    /**
     * Snapshot of pool token supply.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    liquidity_token_total_supply?: string;
    /**
     * Snapshot of users pool token balance.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    liquidity_token_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    block_range?: string;
}

/**
 * Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
 * @export
 */
export type UniswapV2MintDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2MintDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2MintDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2MintDTO
     */
    block_number?: number;
    /**
     * Transaction hash plus index in the transaction mint array.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    id?: string;
    /**
     * Reference to the transaction Mint was included in.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    transaction?: string;
    /**
     * Timestamp of Mint, used to sort recent liquidity provisions.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    pair?: string;
    /**
     * Recipient of liquidity tokens.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    to?: string;
    /**
     * Amount of liquidity tokens minted.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity provision.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    sender?: string;
    /**
     * Amount of token0 provided.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 provided.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    amount_1?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    log_index?: string;
    /**
     * Derived USD value of token0 amount plus token1 amount.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    amount_usd?: string;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    fee_to?: string;
    /**
     * Amount of liquidity sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2MintDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    block_range?: string;
}

/**
 * Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
 * @export
 */
export type UniswapV2PairDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2PairDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairDTO
     */
    vid?: number;
    /**
     * Pair contract address.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    id?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    token_1?: string;
    /**
     * Reserve of token0.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    total_supply?: string;
    /**
     * Total liquidity in pair stored as an amount of ETH.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    reserve_eth?: string;
    /**
     * Total liquidity amount in pair stored as an amount of USD.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    reserve_usd?: string;
    /**
     * Total liquidity with only tracked amount.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    tracked_reserve_eth?: string;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    token_1_price?: string;
    /**
     * Amount of token0 swapped on this pair.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    volume_token_0?: string;
    /**
     * Amount of token1 swapped on this pair.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    volume_token_1?: string;
    /**
     * Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    volume_usd?: string;
    /**
     * Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    untracked_volume_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2PairDTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Timestamp contract was created.
     * @type {Date}
     * @memberof UniswapV2PairDTO
     */
    created_at_timestamp?: Date;
    /**
     * Total number of LPs.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    liquidity_provider_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairDTO
     */
    evaluated_ask?: number;
}

/**
 * Tracks pair data across each day.
 * @export
 */
export type UniswapV2PairDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2PairDayDataDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof UniswapV2PairDayDataDTO
     */
    _date?: number;
    /**
     * Address for pair contract.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    pair_address?: string;
    /**
     * Reference to token0.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    token_0?: string;
    /**
     * Reference to token1.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    token_1?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    total_supply?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    daily_volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    daily_volume_token_1?: string;
    /**
     * Total volume within pair throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    daily_volume_usd?: string;
    /**
     * Amount of transactions on pair throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    daily_txns?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairDayDataDTO
     */
    vid?: number;
}

/**
 * Tracks pair data across each hour.
 * @export
 */
export type UniswapV2PairHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2PairHourDataDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV2PairHourDataDTO
     */
    hour_start_unix?: number;
    /**
     * Address for pair contract.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    pair?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    total_supply?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    hourly_volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    hourly_volume_token_1?: string;
    /**
     * Total volume within pair throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    hourly_volume_usd?: string;
    /**
     * Amount of transactions on pair throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    hourly_txns?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairHourDataDTO
     */
    vid?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type UniswapV2SwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2SwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2SwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2SwapDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapDTO
     */
    vid?: number;
    /**
     * Transaction hash plus index in Transaction swap array.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    id?: string;
    /**
     * Reference to transaction swap was included in.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    transaction?: string;
    /**
     * Timestamp of swap, used for sorted lookups.
     * @type {Date}
     * @memberof UniswapV2SwapDTO
     */
    timestamp?: Date;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    pair?: string;
    /**
     * Address that initiated the swap.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    sender?: string;
    /**
     * The EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    from?: string;
    /**
     * Amount of token0 sold.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    amount_0_in?: string;
    /**
     * Amount of token1 sold.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    amount_1_in?: string;
    /**
     * Amount of token0 received.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    amount_0_out?: string;
    /**
     * Amount of token1 received.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    amount_1_out?: string;
    /**
     * Recipient of output tokens.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    to?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2SwapDTO
     */
    log_index?: NumericsBigInteger;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UniswapV2SwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    transaction_id?: string;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UniswapV2TokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2TokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2TokenDTO
     */
    vid?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    id?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {number}
     * @memberof UniswapV2TokenDTO
     */
    decimals?: number;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2TokenDTO
     */
    total_supply?: NumericsBigInteger;
    /**
     * Amount of token traded all time across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    trade_volume?: string;
    /**
     * Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    trade_volume_usd?: string;
    /**
     * Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    untracked_volume_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2TokenDTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Total amount of token provided as liquidity across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    total_liquidity?: string;
    /**
     * ETH per token.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    derived_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    token_symbol?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV2TokenDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2TokenDayDataDTO
     */
    block_number?: number;
    /**
     * Token address and day id (day start timestamp in unix / 86400) concatenated with a dash.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof UniswapV2TokenDayDataDTO
     */
    _date?: number;
    /**
     * Reference to token entity.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    token?: string;
    /**
     * Amount of token swapped across all pairs throughout day.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    daily_volume_token?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    daily_volume_eth?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    daily_volume_usd?: string;
    /**
     * Amount of transactions with this token across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    daily_txns?: string;
    /**
     * Token amount of token deposited across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    total_liquidity_token?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of ETH.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    total_liquidity_eth?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of USD.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    total_liquidity_usd?: string;
    /**
     * Price of token in derived USD.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2TokenDayDataDTO
     */
    vid?: number;
}

/**
 * Transaction entities are created for each Ethereum transaction that contains an interaction within Uniswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
 * @export
 */
export type UniswapV2TransactionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TransactionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TransactionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2TransactionDTO
     */
    block_number?: number;
    /**
     * Ethereum transaction hash.
     * @type {string}
     * @memberof UniswapV2TransactionDTO
     */
    id?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof UniswapV2TransactionDTO
     */
    timestamp?: string;
    /**
     * Array of Mint events within the transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof UniswapV2TransactionDTO
     */
    mints?: Array<string>;
    /**
     * Array of Burn events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof UniswapV2TransactionDTO
     */
    burns?: Array<string>;
    /**
     * Array of Swap events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof UniswapV2TransactionDTO
     */
    swaps?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2TransactionDTO
     */
    vid?: number;
}

/**
 * Tracks data across all pairs aggregated into a daily bucket.
 * @export
 */
export type UniswapV2UniswapDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    block_number?: number;
    /**
     * Unix timestamp for start of day / 86400 giving a unique day index.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    _date?: number;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    daily_volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    daily_volume_usd?: string;
    /**
     * Total volume across all pairs on this day, untracked.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    daily_volume_untracked?: string;
    /**
     * All time volume across all pairs in ETH up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    total_volume_eth?: string;
    /**
     * Total liquidity across all pairs in ETH up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    total_liquidity_eth?: string;
    /**
     * All time volume across all pairs in USD up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    total_volume_usd?: string;
    /**
     * Total liquidity across all pairs in USD up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    total_liquidity_usd?: string;
    /**
     * Number of transactions throughout this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    vid?: number;
}

/**
 * The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type UniswapV2UniswapFactoryDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    id?: string;
    /**
     * Amount of pairs created by the Uniswap factory.
     * @type {number}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    pair_count?: number;
    /**
     * All time USD volume across all pairs (USD is derived).
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    total_volume_usd?: string;
    /**
     * All time volume in ETH across all pairs (ETH is derived).
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    total_volume_eth?: string;
    /**
     * Untracked volume USD.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    untracked_volume_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived USD amount.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    total_liquidity_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived ETH amount.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    total_liquidity_eth?: string;
    /**
     * All time amount of transactions across all pairs.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    tx_count?: string;
    /**
     * .
     * @type {number}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    vid?: number;
}

/**
 * A user entity is created for any address that provides liquidity to a pool on Uniswap. This entity can be used to track open positions for users.
 * @export
 */
export type UniswapV2UserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2UserDTO
     */
    block_number?: number;
    /**
     * User address.
     * @type {string}
     * @memberof UniswapV2UserDTO
     */
    id?: string;
    /**
     * Total USD value swapped.
     * @type {string}
     * @memberof UniswapV2UserDTO
     */
    usd_swapped?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2UserDTO
     */
    vid?: number;
}

/**
 * The Bundle is used as a global store of derived ETH price in USD. This provides a strong estimate for the USD price of ETH.
 * @export
 */
export type UniswapV3BundleDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BundleDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BundleDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3BundleDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3BundleDTO
     */
    id?: string;
    /**
     * Price of ETH in usd.
     * @type {string}
     * @memberof UniswapV3BundleDTO
     */
    eth_price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3BundleDTO
     */
    vid?: number;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type UniswapV3BurnDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BurnDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BurnDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3BurnDTO
     */
    block_number?: number;
    /**
     * Transaction hash + \'#\' + index in mints Transaction array.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    id?: string;
    /**
     * Transaction burn was included in.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    transaction?: string;
    /**
     * Pool position is within.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    token_1?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    timestamp?: string;
    /**
     * Owner of position where liquidity was burned.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    owner?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    origin?: string;
    /**
     * Amount of liquidity burned.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    amount?: string;
    /**
     * Amount of token 0 burned.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    amount_0?: string;
    /**
     * Amount of token 1 burned.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    amount_1?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    amount_usd?: string;
    /**
     * Lower tick of position.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of position.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    tick_upper?: string;
    /**
     * Position within the transactions.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3BurnDTO
     */
    vid?: number;
}

/**
 * The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type UniswapV3FactoryDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3FactoryDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3FactoryDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3FactoryDTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    id?: string;
    /**
     * Amount of pools created.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    pool_count?: string;
    /**
     * Amount of transactions all time.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    tx_count?: string;
    /**
     * Total volume all time in derived USD.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_volume_usd?: string;
    /**
     * Total volume all time in derived ETH.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_volume_eth?: string;
    /**
     * Total swap fees all time in USD.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_fees_usd?: string;
    /**
     * All volume even through less reliable USD values.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_fees_eth?: string;
    /**
     * All volume even through less reliable USD values.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    untracked_volume_usd?: string;
    /**
     * Total value locked derived in USD.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_value_locked_usd?: string;
    /**
     * Total value locked derived in ETH.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_value_locked_eth?: string;
    /**
     * Total value locked derived in USD untracked.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Total value locked derived in ETH untracked.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_value_locked_eth_untracked?: string;
    /**
     * Current owner of the factory.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    owner?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3FactoryDTO
     */
    vid?: number;
}

/**
 * Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, and more.
 * @export
 */
export type UniswapV3MintDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3MintDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3MintDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3MintDTO
     */
    block_number?: number;
    /**
     * Transaction hash + \'#\' + index in mints Transaction array.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    id?: string;
    /**
     * Which txn the mint was included in.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    transaction?: string;
    /**
     * Time of transaction.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    timestamp?: string;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    token_1?: string;
    /**
     * Owner of position where liquidity minted to.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    owner?: string;
    /**
     * The address that minted the liquidity.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    sender?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    origin?: string;
    /**
     * Amount of liquidity minted.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    amount?: string;
    /**
     * Amount of token 0 minted.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    amount_0?: string;
    /**
     * Amount of token 1 minted.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    amount_1?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    amount_usd?: string;
    /**
     * Lower tick of the position.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of the position.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    tick_upper?: string;
    /**
     * Order within the transaction.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3MintDTO
     */
    vid?: number;
}

/**
 * Information about a pool. Includes references to each token within the pool, volume information, liquidity information, and more. The pool entity mirrors the pool smart contract, and also contains aggregated information about use.
 * @export
 */
export type UniswapV3PoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolDTO
     */
    vid?: number;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    id?: string;
    /**
     * Creation time.
     * @type {Date}
     * @memberof UniswapV3PoolDTO
     */
    created_at_timestamp?: Date;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    token_1?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    fee_tier?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    liquidity?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    sqrt_price?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    fee_growth_global_0x128?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    fee_growth_global_1x128?: NumericsBigInteger;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    token_1_price?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    tick?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    observation_index?: NumericsBigInteger;
    /**
     * All time token0 swapped.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    volume_token_0?: string;
    /**
     * All time token1 swapped.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    volume_token_1?: string;
    /**
     * All time USD swapped.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    volume_usd?: string;
    /**
     * All time USD swapped, unfiltered for unreliable USD pools.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * All time fees collected token0.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    collected_fees_token_0?: string;
    /**
     * All time fees collected token1.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    collected_fees_token_1?: string;
    /**
     * All time fees collected derived USD.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    collected_fees_usd?: string;
    /**
     * Total token 0 across all ticks.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    total_value_locked_token_0?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    total_value_locked_token_1?: string;
    /**
     * Total token 1 across all ticks.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    total_value_locked_eth?: string;
    /**
     * Total value locked USD.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    total_value_locked_usd?: string;
    /**
     * Total value locked derived ETH.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Liquidity providers count, used to detect new exchanges.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    liquidity_provider_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolDTO
     */
    evaluated_ask?: number;
}

/**
 * Data accumulated and condensed into day stats for each pool.
 * @export
 */
export type UniswapV3PoolDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool address)-(day id).
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400
     * @type {number}
     * @memberof UniswapV3PoolDayDataDTO
     */
    _date?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    pool?: string;
    /**
     * In range liquidity at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    liquidity?: string;
    /**
     * Current price tracker at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    sqrt_price?: string;
    /**
     * Price of token0 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    token_0_price?: string;
    /**
     * Price of token1 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    token_1_price?: string;
    /**
     * Current tick at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    tick?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    fee_growth_global_0x128?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    fee_growth_global_1x128?: string;
    /**
     * Total value locked derived in USD at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    tvl_usd?: string;
    /**
     * Volume in token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    volume_token_0?: string;
    /**
     * Volume in token1.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    volume_token_1?: string;
    /**
     * Volume in USD.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    fees_usd?: string;
    /**
     * Number of transactions during period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    tx_count?: string;
    /**
     * Opening price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    open?: string;
    /**
     * High price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    high?: string;
    /**
     * Low price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    low?: string;
    /**
     * Close price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolDayDataDTO
     */
    vid?: number;
}

/**
 * Hourly stats tracker for pool.
 * @export
 */
export type UniswapV3PoolHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolHourDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool address)-(day id)
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV3PoolHourDataDTO
     */
    period_start_unix?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    pool?: string;
    /**
     * In range liquidity at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    liquidity?: string;
    /**
     * Current price tracker at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    sqrt_price?: string;
    /**
     * Price of token0 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    token_0_price?: string;
    /**
     * Price of token1 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    token_1_price?: string;
    /**
     * Current tick at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    tick?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    fee_growth_global_0x128?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    fee_growth_global_1x128?: string;
    /**
     * Total value locked derived in USD at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    tvl_usd?: string;
    /**
     * Volume in token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    volume_token_0?: string;
    /**
     * Volume in token1.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    volume_token_1?: string;
    /**
     * Volume in USD.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    fees_usd?: string;
    /**
     * Number of transactions during period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    tx_count?: string;
    /**
     * Opening price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    open?: string;
    /**
     * High price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    high?: string;
    /**
     * Low price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    low?: string;
    /**
     * Close price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolHourDataDTO
     */
    vid?: number;
}

/**
 * Positions created through NonfungiblePositionManager. Positions are represented as NFTs (ERC-721 tokens) as opposed to the fungible ERC-20 tokens on Uniswap V1 and V2.
 * @export
 */
export type UniswapV3PositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PositionDTO
     */
    block_number?: number;
    /**
     * NFT token identifier.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    id?: string;
    /**
     * Owner of the NFT.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    owner?: string;
    /**
     * Pool position is within.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    token_1?: string;
    /**
     * Lower tick of the position.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of the position.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    tick_upper?: string;
    /**
     * Total position liquidity.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    liquidity?: string;
    /**
     * Amount of token 0 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    deposited_token_0?: string;
    /**
     * Amount of token 1 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    deposited_token_1?: string;
    /**
     * Amount of token 0 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    withdrawn_token_0?: string;
    /**
     * Amount of token 1 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    withdrawn_token_1?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    collected_fees_token_1?: string;
    /**
     * Transaction in which the position was initialized.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    transaction?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    fee_growth_inside_0_last_x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    fee_growth_inside_1_last_x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PositionDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type UniswapV3PositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    block_number?: number;
    /**
     * NFT token identifier, format: (NFT token id)#(block number).
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    id?: string;
    /**
     * Owner of the NFT.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    owner?: string;
    /**
     * Pool the position is within.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    pool?: string;
    /**
     * Position of which the snap was taken of.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    position?: string;
    /**
     * Timestamp of block in which the snap was created.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    timestamp?: string;
    /**
     * Total position liquidity.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    liquidity?: string;
    /**
     * Amount of token 0 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    deposited_token_0?: string;
    /**
     * Amount of token 1 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    deposited_token_1?: string;
    /**
     * Amount of token 0 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    withdrawn_token_0?: string;
    /**
     * Amount of token 1 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    withdrawn_token_1?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    collected_fees_token_1?: string;
    /**
     * Transaction in which the snapshot was initialized.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    transaction?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    fee_growth_inside_0_last_x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    fee_growth_inside_1_last_x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    vid?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type UniswapV3SwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3SwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3SwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3SwapDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapDTO
     */
    vid?: number;
    /**
     * Identifier, format: (transaction hash) + # + (index in swaps Transaction array).
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    id?: string;
    /**
     * Pointer to transaction.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    transaction?: string;
    /**
     * Timestamp of transaction.
     * @type {Date}
     * @memberof UniswapV3SwapDTO
     */
    timestamp?: Date;
    /**
     * Pool swap occured within.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    token_1?: string;
    /**
     * Sender of the swap.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    sender?: string;
    /**
     * Recipient of the swap.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    recipient?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    origin?: string;
    /**
     * Delta of token0 swapped.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    amount_0?: string;
    /**
     * Delta of token1 swapped.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    amount_1?: string;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapDTO
     */
    sqrt_price_x96?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapDTO
     */
    tick?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapDTO
     */
    log_index?: NumericsBigInteger;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UniswapV3SwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    transaction_id?: string;
}

/**
 * Ticks are the boundaries between discrete areas in price space.
 * @export
 */
export type UniswapV3TickDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TickDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TickDTO
     */
    vid?: number;
    /**
     * Identifier, format: (pool address)#(tick index)
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    id?: string;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    pool_address?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    tick_idx?: NumericsBigInteger;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    pool?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    liquidity_gross?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    liquidity_net?: NumericsBigInteger;
    /**
     * Calculated price of token0 of tick within this pool - constant.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    price_0?: string;
    /**
     * Calculated price of token1 of tick within this pool - constant.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    price_1?: string;
    /**
     * Lifetime volume of token0 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    volume_token_0?: string;
    /**
     * Lifetime volume of token1 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    volume_token_1?: string;
    /**
     * Lifetime volume in derived USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    volume_usd?: string;
    /**
     * Lifetime volume in untracked USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    fees_usd?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    collected_fees_token_1?: string;
    /**
     * All time collected fees in USD.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    collected_fees_usd?: string;
    /**
     * Created time.
     * @type {Date}
     * @memberof UniswapV3TickDTO
     */
    created_at_timestamp?: Date;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    liquidity_provider_count?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    fee_growth_outside_0x128?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    fee_growth_outside_1x128?: NumericsBigInteger;
}

/**
 * Data accumulated and condensed into day stats for each exchange. Entity gets saved only if there is a change during the day
 * @export
 */
export type UniswapV3TickDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TickDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool address)-(tick index)-(timestamp).
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3TickDayDataDTO
     */
    _date?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    pool?: string;
    /**
     * Pointer to tick.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    tick?: string;
    /**
     * Total liquidity pool has as tick lower or upper at end of period.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    liquidity_gross?: string;
    /**
     * How much liquidity changes when tick crossed at end of period.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    liquidity_net?: string;
    /**
     * Hourly volume of token0 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    volume_token_0?: string;
    /**
     * Hourly volume of token1 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    volume_token_1?: string;
    /**
     * Hourly volume in derived USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    fees_usd?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    fee_growth_outside_0x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    fee_growth_outside_1x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TickDayDataDTO
     */
    vid?: number;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UniswapV3TokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenDTO
     */
    vid?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    id?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {number}
     * @memberof UniswapV3TokenDTO
     */
    decimals?: number;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenDTO
     */
    total_supply?: NumericsBigInteger;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenDTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenDTO
     */
    pool_count?: NumericsBigInteger;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    total_value_locked_usd?: string;
    /**
     * TVL derived in USD untracked.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Derived price in ETH.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    derived_eth?: string;
    /**
     * Pools token is in that are white listed for USD pricing.
     * @type {Array<string>}
     * @memberof UniswapV3TokenDTO
     */
    whitelist_pools?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    token_symbol?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV3TokenHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenHourDataDTO
     */
    block_number?: number;
    /**
     * Token address concatendated with date.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV3TokenHourDataDTO
     */
    period_start_unix?: number;
    /**
     * Pointer to token.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    token?: string;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    untracked_volume_usd?: string;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    total_value_locked_usd?: string;
    /**
     * Price at end of period in USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    price_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    fees_usd?: string;
    /**
     * Opening price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    open?: string;
    /**
     * High price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    high?: string;
    /**
     * Low price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    low?: string;
    /**
     * Close price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenHourDataDTO
     */
    vid?: number;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV3TokenV3DayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    vid?: number;
    /**
     * Token address concatendated with date.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    _date?: number;
    /**
     * Pointer to token.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    token?: string;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    untracked_volume_usd?: string;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    total_value_locked_usd?: string;
    /**
     * Price at end of period in USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    price_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    fees_usd?: string;
    /**
     * Opening price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    open?: string;
    /**
     * High price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    high?: string;
    /**
     * Low price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    low?: string;
    /**
     * Close price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    close?: string;
}

/**
 * 
 * @export
 */
export type UniswapV3TransactionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TransactionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TransactionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TransactionDTO
     */
    block_number?: number;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof UniswapV3TransactionDTO
     */
    id?: string;
    /**
     * Timestamp txn was confirmed.
     * @type {string}
     * @memberof UniswapV3TransactionDTO
     */
    timestamp?: string;
    /**
     * Gas used during txn execution.
     * @type {string}
     * @memberof UniswapV3TransactionDTO
     */
    gas_used?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3TransactionDTO
     */
    gas_price?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TransactionDTO
     */
    vid?: number;
}

/**
 * Data accumulated and condensed into day stats for all of Uniswap.
 * @export
 */
export type UniswapV3UniswapDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    vid?: number;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    _date?: number;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    volume_usd?: string;
    /**
     * Total daily volume in Uniswap derived in terms of USD untracked.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    volume_usd_untracked?: string;
    /**
     * Fees in USD
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Tvl in terms of USD.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    tvl_usd?: string;
}



/**
 * CRYPTOPUNKSApi - fetch parameter creator
 * @export
 */
export const CRYPTOPUNKSApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bids.
         * @summary Bids (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSBidsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/bids/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets collectionDailySnapshots.
         * @summary CollectionDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/collectionDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets collections.
         * @summary Collections (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/collections/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dataSources.
         * @summary DataSources (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSDataSourcesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/dataSources/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets bids.
         * @summary Bids (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetBidsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/bids/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets collectionDailySnapshots.
         * @summary CollectionDailySnapshots (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetCollectionDailySnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/collectionDailySnapshots/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets collections.
         * @summary Collections (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetCollectionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/collections/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dataSources.
         * @summary DataSources (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetDataSourcesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/dataSources/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets items.
         * @summary Items (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetItemsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/items/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets marketPlaces.
         * @summary MarketPlaces (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetMarketPlacesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/marketPlaces/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets marketplaceDailySnapshots.
         * @summary MarketplaceDailySnapshots (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetMarketplaceDailySnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/marketplaceDailySnapshots/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/trades/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/users/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets items.
         * @summary Items (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSItemsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/items/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets marketPlaces.
         * @summary MarketPlaces (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketPlacesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/marketPlaces/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets marketplaceDailySnapshots.
         * @summary MarketplaceDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/marketplaceDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSTradesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/trades/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSUsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CRYPTOPUNKSApiType = { 
    cRYPTOPUNKSBidsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSBidDTO>>,

    cRYPTOPUNKSCollectionDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSCollectionDailySnapshotDTO>>,

    cRYPTOPUNKSCollectionsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSCollectionDTO>>,

    cRYPTOPUNKSDataSourcesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSDataSourcesDTO>>,

    cRYPTOPUNKSGetBidsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CRYPTOPUNKSBidDTO>>,

    cRYPTOPUNKSGetCollectionDailySnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CRYPTOPUNKSCollectionDailySnapshotDTO>>,

    cRYPTOPUNKSGetCollectionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CRYPTOPUNKSCollectionDTO>>,

    cRYPTOPUNKSGetDataSourcesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CRYPTOPUNKSDataSourcesDTO>>,

    cRYPTOPUNKSGetItemsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CRYPTOPUNKSItemDTO>>,

    cRYPTOPUNKSGetMarketPlacesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CRYPTOPUNKSMarketPlaceDTO>>,

    cRYPTOPUNKSGetMarketplaceDailySnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CRYPTOPUNKSMarketplaceDailySnapshotDTO>>,

    cRYPTOPUNKSGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CRYPTOPUNKSTradeDTO>>,

    cRYPTOPUNKSGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CRYPTOPUNKSUserDTO>>,

    cRYPTOPUNKSItemsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSItemDTO>>,

    cRYPTOPUNKSMarketPlacesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSMarketPlaceDTO>>,

    cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSMarketplaceDailySnapshotDTO>>,

    cRYPTOPUNKSTradesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSTradeDTO>>,

    cRYPTOPUNKSUsersCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSUserDTO>>,
}

/**
 * CRYPTOPUNKSApi - factory function to inject configuration 
 * @export
 */
export const CRYPTOPUNKSApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CRYPTOPUNKSApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bids.
         * @summary Bids (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSBidsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSBidDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSBidsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets collectionDailySnapshots.
         * @summary CollectionDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSCollectionDailySnapshotDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSCollectionDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets collections.
         * @summary Collections (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSCollectionDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSCollectionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dataSources.
         * @summary DataSources (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSDataSourcesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSDataSourcesDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSDataSourcesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets bids.
         * @summary Bids (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetBidsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSBidDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSGetBidsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets collectionDailySnapshots.
         * @summary CollectionDailySnapshots (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetCollectionDailySnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSCollectionDailySnapshotDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSGetCollectionDailySnapshotsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets collections.
         * @summary Collections (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetCollectionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSCollectionDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSGetCollectionsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dataSources.
         * @summary DataSources (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetDataSourcesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSDataSourcesDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSGetDataSourcesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets items.
         * @summary Items (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetItemsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSItemDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSGetItemsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets marketPlaces.
         * @summary MarketPlaces (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetMarketPlacesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSMarketPlaceDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSGetMarketPlacesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets marketplaceDailySnapshots.
         * @summary MarketplaceDailySnapshots (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetMarketplaceDailySnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSMarketplaceDailySnapshotDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSGetMarketplaceDailySnapshotsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSTradeDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSGetTradesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSUserDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSGetUsersHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets items.
         * @summary Items (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSItemsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSItemDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSItemsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets marketPlaces.
         * @summary MarketPlaces (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketPlacesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSMarketPlaceDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSMarketPlacesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets marketplaceDailySnapshots.
         * @summary MarketplaceDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSMarketplaceDailySnapshotDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSTradesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSTradeDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSTradesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSUsersCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSUserDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSUsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CowApi - fetch parameter creator
 * @export
 */
export const CowApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets orders.
         * @summary Orders (historical)
         * @throws {RequiredError}
         */
        cowGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/orders/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets settlements.
         * @summary Settlements (historical)
         * @throws {RequiredError}
         */
        cowGetSettlementsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/settlements/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        cowGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, name?: string, symbol?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = ((address:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = ((symbol:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (historical)
         * @throws {RequiredError}
         */
        cowGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, sellToken?: string, buyToken?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/trades/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (sellToken !== undefined) {
                localVarQueryParameter['sell_token'] = ((sellToken:any):string);
            }

            if (buyToken !== undefined) {
                localVarQueryParameter['buy_token'] = ((buyToken:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        cowGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/users/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = ((address:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets orders.
         * @summary Orders (current)
         * @throws {RequiredError}
         */
        cowOrdersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/orders/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets settlements.
         * @summary Settlements (current)
         * @throws {RequiredError}
         */
        cowSettlementsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/settlements/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        cowTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cowTradesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/trades/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cowUsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CowApiType = { 
    cowGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CowOrderDTO>>,

    cowGetSettlementsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CowSettlementDTO>>,

    cowGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, name?: string, symbol?: string, options?: RequestOptions): Promise<Array<CowTokenDTO>>,

    cowGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, sellToken?: string, buyToken?: string, options?: RequestOptions): Promise<Array<CowTradeDTO>>,

    cowGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options?: RequestOptions): Promise<Array<CowUserDTO>>,

    cowOrdersCurrent(options?: RequestOptions): Promise<Array<CowOrderDTO>>,

    cowSettlementsCurrent(options?: RequestOptions): Promise<Array<CowSettlementDTO>>,

    cowTokensCurrent(options?: RequestOptions): Promise<Array<CowTokenDTO>>,

    cowTradesCurrent(options?: RequestOptions): Promise<Array<CowTradeDTO>>,

    cowUsersCurrent(options?: RequestOptions): Promise<Array<CowUserDTO>>,
}

/**
 * CowApi - factory function to inject configuration 
 * @export
 */
export const CowApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CowApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets orders.
         * @summary Orders (historical)
         * @throws {RequiredError}
         */
        cowGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CowOrderDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowGetOrdersHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets settlements.
         * @summary Settlements (historical)
         * @throws {RequiredError}
         */
        cowGetSettlementsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CowSettlementDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowGetSettlementsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        cowGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, name?: string, symbol?: string, options?: RequestOptions = {}): Promise<Array<CowTokenDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowGetTokensHistorical(startBlock, endBlock, startDate, endDate, id, address, name, symbol, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (historical)
         * @throws {RequiredError}
         */
        cowGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, sellToken?: string, buyToken?: string, options?: RequestOptions = {}): Promise<Array<CowTradeDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowGetTradesHistorical(startBlock, endBlock, startDate, endDate, id, sellToken, buyToken, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        cowGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options?: RequestOptions = {}): Promise<Array<CowUserDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowGetUsersHistorical(startBlock, endBlock, startDate, endDate, id, address, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets orders.
         * @summary Orders (current)
         * @throws {RequiredError}
         */
        cowOrdersCurrent(options?: RequestOptions = {}): Promise<Array<CowOrderDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowOrdersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets settlements.
         * @summary Settlements (current)
         * @throws {RequiredError}
         */
        cowSettlementsCurrent(options?: RequestOptions = {}): Promise<Array<CowSettlementDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowSettlementsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        cowTokensCurrent(options?: RequestOptions = {}): Promise<Array<CowTokenDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cowTradesCurrent(options?: RequestOptions = {}): Promise<Array<CowTradeDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowTradesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cowUsersCurrent(options?: RequestOptions = {}): Promise<Array<CowUserDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowUsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CurveApi - fetch parameter creator
 * @export
 */
export const CurveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        curveAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/accounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets addLiquidityEvents.
         * @summary AddLiquidityEvents (current)
         * @throws {RequiredError}
         */
        curveAddLiquidityEventsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/addLiquidityEvents/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets adminFeeChangeLogs.
         * @summary AdminFeeChangeLogs (current)
         * @throws {RequiredError}
         */
        curveAdminFeeChangeLogsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/adminFeeChangeLogs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets amplificationCoeffChangeLogs.
         * @summary AmplificationCoeffChangeLogs (current)
         * @throws {RequiredError}
         */
        curveAmplificationCoeffChangeLogsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/amplificationCoeffChangeLogs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets coins.
         * @summary Coins (current)
         * @throws {RequiredError}
         */
        curveCoinsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/coins/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets contractVersions.
         * @summary ContractVersions (current)
         * @throws {RequiredError}
         */
        curveContractVersionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/contractVersions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets contracts.
         * @summary Contracts (current)
         * @throws {RequiredError}
         */
        curveContractsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/contracts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dailyVolumes.
         * @summary DailyVolumes (current)
         * @throws {RequiredError}
         */
        curveDailyVolumesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/dailyVolumes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets exchanges.
         * @summary Exchanges (current)
         * @throws {RequiredError}
         */
        curveExchangesCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/exchanges/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets feeChangeLogs.
         * @summary FeeChangeLogs (current)
         * @throws {RequiredError}
         */
        curveFeeChangeLogsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/feeChangeLogs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeDeposits.
         * @summary GaugeDeposits (current)
         * @throws {RequiredError}
         */
        curveGaugeDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeDeposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeLiquidities.
         * @summary GaugeLiquidities (current)
         * @throws {RequiredError}
         */
        curveGaugeLiquiditiesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeLiquidities/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeTotalWeights.
         * @summary GaugeTotalWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeTotalWeightsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTotalWeights/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeTypeWeights.
         * @summary GaugeTypeWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeTypeWeightsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTypeWeights/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeTypes.
         * @summary GaugeTypes (current)
         * @throws {RequiredError}
         */
        curveGaugeTypesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTypes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeWeightVotes.
         * @summary GaugeWeightVotes (current)
         * @throws {RequiredError}
         */
        curveGaugeWeightVotesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWeightVotes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeWeights.
         * @summary GaugeWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeWeightsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWeights/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeWithdraws.
         * @summary GaugeWithdraws (current)
         * @throws {RequiredError}
         */
        curveGaugeWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWithdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges.
         * @summary Gauges (current)
         * @throws {RequiredError}
         */
        curveGaugesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gauges/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets accounts.
         * @summary Accounts (historical)
         * @throws {RequiredError}
         */
        curveGetAccountsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/accounts/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = ((address:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets addLiquidityEvents.
         * @summary AddLiquidityEvents (historical)
         * @throws {RequiredError}
         */
        curveGetAddLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/addLiquidityEvents/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets adminFeeChangeLogs.
         * @summary AdminFeeChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetAdminFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/adminFeeChangeLogs/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets amplificationCoeffChangeLogs.
         * @summary AmplificationCoeffChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetAmplificationCoeffChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/amplificationCoeffChangeLogs/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets coins.
         * @summary Coins (historical)
         * @throws {RequiredError}
         */
        curveGetCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/coins/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets contractVersions.
         * @summary ContractVersions (historical)
         * @throws {RequiredError}
         */
        curveGetContractVersionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/contractVersions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = ((address:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets contracts.
         * @summary Contracts (historical)
         * @throws {RequiredError}
         */
        curveGetContractsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/contracts/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dailyVolumes.
         * @summary DailyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetDailyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/dailyVolumes/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets exchanges.
         * @summary Exchanges (historical)
         * @throws {RequiredError}
         */
        curveGetExchangesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/exchanges/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets feeChangeLogs.
         * @summary FeeChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/feeChangeLogs/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeDeposits.
         * @summary GaugeDeposits (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeDeposits/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeLiquidities.
         * @summary GaugeLiquidities (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeLiquiditiesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeLiquidities/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = ((user:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeTotalWeights.
         * @summary GaugeTotalWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeTotalWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTotalWeights/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeTypeWeights.
         * @summary GaugeTypeWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeTypeWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTypeWeights/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeTypes.
         * @summary GaugeTypes (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeTypesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, name?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTypes/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeWeightVotes.
         * @summary GaugeWeightVotes (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeWeightVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWeightVotes/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = ((user:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeWeights.
         * @summary GaugeWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWeights/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeWithdraws.
         * @summary GaugeWithdraws (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeWithdrawsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWithdraws/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges.
         * @summary Gauges (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gauges/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = ((address:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets hourlyVolumes.
         * @summary HourlyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetHourlyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/hourlyVolumes/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets lpTokens.
         * @summary LpTokens (historical)
         * @throws {RequiredError}
         */
        curveGetLpTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, name?: string, symbol?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/lpTokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = ((address:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = ((symbol:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (historical)
         * @throws {RequiredError}
         */
        curveGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, name?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/pools/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets proposalVotes.
         * @summary ProposalVotes (historical)
         * @throws {RequiredError}
         */
        curveGetProposalVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/proposalVotes/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets proposals.
         * @summary Proposals (historical)
         * @throws {RequiredError}
         */
        curveGetProposalsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/proposals/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets removeLiquidityEvents.
         * @summary RemoveLiquidityEvents (historical)
         * @throws {RequiredError}
         */
        curveGetRemoveLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/removeLiquidityEvents/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets removeLiquidityOneEvents.
         * @summary RemoveLiquidityOneEvents (historical)
         * @throws {RequiredError}
         */
        curveGetRemoveLiquidityOneEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/removeLiquidityOneEvents/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets systemStates.
         * @summary SystemStates (historical)
         * @throws {RequiredError}
         */
        curveGetSystemStatesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/systemStates/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        curveGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, name?: string, symbol?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = ((address:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = ((symbol:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transferOwnershipEvents.
         * @summary TransferOwnershipEvents (historical)
         * @throws {RequiredError}
         */
        curveGetTransferOwnershipEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/transferOwnershipEvents/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets underlyingCoins.
         * @summary UnderlyingCoins (historical)
         * @throws {RequiredError}
         */
        curveGetUnderlyingCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/underlyingCoins/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets votingApps.
         * @summary VotingApps (historical)
         * @throws {RequiredError}
         */
        curveGetVotingAppsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/votingApps/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = ((address:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets weeklyVolumes.
         * @summary WeeklyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetWeeklyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/weeklyVolumes/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets hourlyVolumes.
         * @summary HourlyVolumes (current)
         * @throws {RequiredError}
         */
        curveHourlyVolumesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/hourlyVolumes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets lpTokens.
         * @summary LpTokens (current)
         * @throws {RequiredError}
         */
        curveLpTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/lpTokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (current)
         * @throws {RequiredError}
         */
        curvePoolsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/pools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets proposalVotes.
         * @summary ProposalVotes (current)
         * @throws {RequiredError}
         */
        curveProposalVotesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/proposalVotes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets proposals.
         * @summary Proposals (current)
         * @throws {RequiredError}
         */
        curveProposalsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/proposals/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets removeLiquidityEvents.
         * @summary RemoveLiquidityEvents (current)
         * @throws {RequiredError}
         */
        curveRemoveLiquidityEventsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/removeLiquidityEvents/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets removeLiquidityOneEvents.
         * @summary RemoveLiquidityOneEvents (current)
         * @throws {RequiredError}
         */
        curveRemoveLiquidityOneEventsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/removeLiquidityOneEvents/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets systemStates.
         * @summary SystemStates (current)
         * @throws {RequiredError}
         */
        curveSystemStatesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/systemStates/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        curveTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transferOwnershipEvents.
         * @summary TransferOwnershipEvents (current)
         * @throws {RequiredError}
         */
        curveTransferOwnershipEventsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/transferOwnershipEvents/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets underlyingCoins.
         * @summary UnderlyingCoins (current)
         * @throws {RequiredError}
         */
        curveUnderlyingCoinsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/underlyingCoins/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets votingApps.
         * @summary VotingApps (current)
         * @throws {RequiredError}
         */
        curveVotingAppsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/votingApps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets weeklyVolumes.
         * @summary WeeklyVolumes (current)
         * @throws {RequiredError}
         */
        curveWeeklyVolumesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/weeklyVolumes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CurveApiType = { 
    curveAccountsCurrent(options?: RequestOptions): Promise<Array<CurveAccountDTO>>,

    curveAddLiquidityEventsCurrent(options?: RequestOptions): Promise<Array<CurveAddLiquidityEventDTO>>,

    curveAdminFeeChangeLogsCurrent(options?: RequestOptions): Promise<Array<CurveAdminFeeChangeLogDTO>>,

    curveAmplificationCoeffChangeLogsCurrent(options?: RequestOptions): Promise<Array<CurveAmplificationCoeffChangeLogDTO>>,

    curveCoinsCurrent(options?: RequestOptions): Promise<Array<CurveCoinDTO>>,

    curveContractVersionsCurrent(options?: RequestOptions): Promise<Array<CurveContractVersionDTO>>,

    curveContractsCurrent(options?: RequestOptions): Promise<Array<CurveContractDTO>>,

    curveDailyVolumesCurrent(options?: RequestOptions): Promise<Array<CurveDailyVolumeDTO>>,

    curveExchangesCurrent(pool?: string, options?: RequestOptions): Promise<Array<CurveExchangeDTO>>,

    curveFeeChangeLogsCurrent(options?: RequestOptions): Promise<Array<CurveFeeChangeLogDTO>>,

    curveGaugeDepositsCurrent(options?: RequestOptions): Promise<Array<CurveGaugeDepositDTO>>,

    curveGaugeLiquiditiesCurrent(options?: RequestOptions): Promise<Array<CurveGaugeLiquidityDTO>>,

    curveGaugeTotalWeightsCurrent(options?: RequestOptions): Promise<Array<CurveGaugeTotalWeightDTO>>,

    curveGaugeTypeWeightsCurrent(options?: RequestOptions): Promise<Array<CurveGaugeTypeWeightDTO>>,

    curveGaugeTypesCurrent(options?: RequestOptions): Promise<Array<CurveGaugeTypeDTO>>,

    curveGaugeWeightVotesCurrent(options?: RequestOptions): Promise<Array<CurveGaugeWeightVoteDTO>>,

    curveGaugeWeightsCurrent(options?: RequestOptions): Promise<Array<CurveGaugeWeightDTO>>,

    curveGaugeWithdrawsCurrent(options?: RequestOptions): Promise<Array<CurveGaugeWithdrawDTO>>,

    curveGaugesCurrent(options?: RequestOptions): Promise<Array<CurveGaugeDTO>>,

    curveGetAccountsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options?: RequestOptions): Promise<Array<CurveAccountDTO>>,

    curveGetAddLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveAddLiquidityEventDTO>>,

    curveGetAdminFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveAdminFeeChangeLogDTO>>,

    curveGetAmplificationCoeffChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveAmplificationCoeffChangeLogDTO>>,

    curveGetCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveCoinDTO>>,

    curveGetContractVersionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options?: RequestOptions): Promise<Array<CurveContractVersionDTO>>,

    curveGetContractsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CurveContractDTO>>,

    curveGetDailyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveDailyVolumeDTO>>,

    curveGetExchangesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveExchangeDTO>>,

    curveGetFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveFeeChangeLogDTO>>,

    curveGetGaugeDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CurveGaugeDepositDTO>>,

    curveGetGaugeLiquiditiesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options?: RequestOptions): Promise<Array<CurveGaugeLiquidityDTO>>,

    curveGetGaugeTotalWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CurveGaugeTotalWeightDTO>>,

    curveGetGaugeTypeWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CurveGaugeTypeWeightDTO>>,

    curveGetGaugeTypesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, name?: string, options?: RequestOptions): Promise<Array<CurveGaugeTypeDTO>>,

    curveGetGaugeWeightVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options?: RequestOptions): Promise<Array<CurveGaugeWeightVoteDTO>>,

    curveGetGaugeWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CurveGaugeWeightDTO>>,

    curveGetGaugeWithdrawsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CurveGaugeWithdrawDTO>>,

    curveGetGaugesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveGaugeDTO>>,

    curveGetHourlyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveHourlyVolumeDTO>>,

    curveGetLpTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, name?: string, symbol?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveLpTokenDTO>>,

    curveGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, name?: string, options?: RequestOptions): Promise<Array<CurvePoolDTO>>,

    curveGetProposalVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CurveProposalVoteDTO>>,

    curveGetProposalsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CurveProposalDTO>>,

    curveGetRemoveLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveRemoveLiquidityEventDTO>>,

    curveGetRemoveLiquidityOneEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveRemoveLiquidityOneEventDTO>>,

    curveGetSystemStatesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<CurveSystemStateDTO>>,

    curveGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, name?: string, symbol?: string, options?: RequestOptions): Promise<Array<CurveTokenDTO>>,

    curveGetTransferOwnershipEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveTransferOwnershipEventDTO>>,

    curveGetUnderlyingCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveUnderlyingCoinDTO>>,

    curveGetVotingAppsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options?: RequestOptions): Promise<Array<CurveVotingAppDTO>>,

    curveGetWeeklyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<CurveWeeklyVolumeDTO>>,

    curveHourlyVolumesCurrent(options?: RequestOptions): Promise<Array<CurveHourlyVolumeDTO>>,

    curveLpTokensCurrent(options?: RequestOptions): Promise<Array<CurveLpTokenDTO>>,

    curvePoolsCurrent(id?: string, options?: RequestOptions): Promise<Array<CurvePoolDTO>>,

    curveProposalVotesCurrent(options?: RequestOptions): Promise<Array<CurveProposalVoteDTO>>,

    curveProposalsCurrent(options?: RequestOptions): Promise<Array<CurveProposalDTO>>,

    curveRemoveLiquidityEventsCurrent(options?: RequestOptions): Promise<Array<CurveRemoveLiquidityEventDTO>>,

    curveRemoveLiquidityOneEventsCurrent(options?: RequestOptions): Promise<Array<CurveRemoveLiquidityOneEventDTO>>,

    curveSystemStatesCurrent(options?: RequestOptions): Promise<Array<CurveSystemStateDTO>>,

    curveTokensCurrent(options?: RequestOptions): Promise<Array<CurveTokenDTO>>,

    curveTransferOwnershipEventsCurrent(options?: RequestOptions): Promise<Array<CurveTransferOwnershipEventDTO>>,

    curveUnderlyingCoinsCurrent(options?: RequestOptions): Promise<Array<CurveUnderlyingCoinDTO>>,

    curveVotingAppsCurrent(options?: RequestOptions): Promise<Array<CurveVotingAppDTO>>,

    curveWeeklyVolumesCurrent(options?: RequestOptions): Promise<Array<CurveWeeklyVolumeDTO>>,
}

/**
 * CurveApi - factory function to inject configuration 
 * @export
 */
export const CurveApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CurveApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        curveAccountsCurrent(options?: RequestOptions = {}): Promise<Array<CurveAccountDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets addLiquidityEvents.
         * @summary AddLiquidityEvents (current)
         * @throws {RequiredError}
         */
        curveAddLiquidityEventsCurrent(options?: RequestOptions = {}): Promise<Array<CurveAddLiquidityEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveAddLiquidityEventsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets adminFeeChangeLogs.
         * @summary AdminFeeChangeLogs (current)
         * @throws {RequiredError}
         */
        curveAdminFeeChangeLogsCurrent(options?: RequestOptions = {}): Promise<Array<CurveAdminFeeChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveAdminFeeChangeLogsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets amplificationCoeffChangeLogs.
         * @summary AmplificationCoeffChangeLogs (current)
         * @throws {RequiredError}
         */
        curveAmplificationCoeffChangeLogsCurrent(options?: RequestOptions = {}): Promise<Array<CurveAmplificationCoeffChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveAmplificationCoeffChangeLogsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets coins.
         * @summary Coins (current)
         * @throws {RequiredError}
         */
        curveCoinsCurrent(options?: RequestOptions = {}): Promise<Array<CurveCoinDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveCoinsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets contractVersions.
         * @summary ContractVersions (current)
         * @throws {RequiredError}
         */
        curveContractVersionsCurrent(options?: RequestOptions = {}): Promise<Array<CurveContractVersionDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveContractVersionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets contracts.
         * @summary Contracts (current)
         * @throws {RequiredError}
         */
        curveContractsCurrent(options?: RequestOptions = {}): Promise<Array<CurveContractDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveContractsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dailyVolumes.
         * @summary DailyVolumes (current)
         * @throws {RequiredError}
         */
        curveDailyVolumesCurrent(options?: RequestOptions = {}): Promise<Array<CurveDailyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveDailyVolumesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets exchanges.
         * @summary Exchanges (current)
         * @throws {RequiredError}
         */
        curveExchangesCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<CurveExchangeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveExchangesCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets feeChangeLogs.
         * @summary FeeChangeLogs (current)
         * @throws {RequiredError}
         */
        curveFeeChangeLogsCurrent(options?: RequestOptions = {}): Promise<Array<CurveFeeChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveFeeChangeLogsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeDeposits.
         * @summary GaugeDeposits (current)
         * @throws {RequiredError}
         */
        curveGaugeDepositsCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeDepositDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeLiquidities.
         * @summary GaugeLiquidities (current)
         * @throws {RequiredError}
         */
        curveGaugeLiquiditiesCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeLiquidityDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeLiquiditiesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeTotalWeights.
         * @summary GaugeTotalWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeTotalWeightsCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeTotalWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeTotalWeightsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeTypeWeights.
         * @summary GaugeTypeWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeTypeWeightsCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeTypeWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeTypeWeightsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeTypes.
         * @summary GaugeTypes (current)
         * @throws {RequiredError}
         */
        curveGaugeTypesCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeTypeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeTypesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeWeightVotes.
         * @summary GaugeWeightVotes (current)
         * @throws {RequiredError}
         */
        curveGaugeWeightVotesCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeWeightVoteDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeWeightVotesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeWeights.
         * @summary GaugeWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeWeightsCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeWeightsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeWithdraws.
         * @summary GaugeWithdraws (current)
         * @throws {RequiredError}
         */
        curveGaugeWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeWithdrawDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges.
         * @summary Gauges (current)
         * @throws {RequiredError}
         */
        curveGaugesCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets accounts.
         * @summary Accounts (historical)
         * @throws {RequiredError}
         */
        curveGetAccountsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options?: RequestOptions = {}): Promise<Array<CurveAccountDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetAccountsHistorical(startBlock, endBlock, startDate, endDate, id, address, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets addLiquidityEvents.
         * @summary AddLiquidityEvents (historical)
         * @throws {RequiredError}
         */
        curveGetAddLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveAddLiquidityEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetAddLiquidityEventsHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets adminFeeChangeLogs.
         * @summary AdminFeeChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetAdminFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveAdminFeeChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetAdminFeeChangeLogsHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets amplificationCoeffChangeLogs.
         * @summary AmplificationCoeffChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetAmplificationCoeffChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveAmplificationCoeffChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetAmplificationCoeffChangeLogsHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets coins.
         * @summary Coins (historical)
         * @throws {RequiredError}
         */
        curveGetCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveCoinDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetCoinsHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets contractVersions.
         * @summary ContractVersions (historical)
         * @throws {RequiredError}
         */
        curveGetContractVersionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options?: RequestOptions = {}): Promise<Array<CurveContractVersionDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetContractVersionsHistorical(startBlock, endBlock, startDate, endDate, id, address, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets contracts.
         * @summary Contracts (historical)
         * @throws {RequiredError}
         */
        curveGetContractsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CurveContractDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetContractsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dailyVolumes.
         * @summary DailyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetDailyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveDailyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetDailyVolumesHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets exchanges.
         * @summary Exchanges (historical)
         * @throws {RequiredError}
         */
        curveGetExchangesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveExchangeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetExchangesHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets feeChangeLogs.
         * @summary FeeChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveFeeChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetFeeChangeLogsHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeDeposits.
         * @summary GaugeDeposits (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CurveGaugeDepositDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugeDepositsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeLiquidities.
         * @summary GaugeLiquidities (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeLiquiditiesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options?: RequestOptions = {}): Promise<Array<CurveGaugeLiquidityDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugeLiquiditiesHistorical(startBlock, endBlock, startDate, endDate, id, user, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeTotalWeights.
         * @summary GaugeTotalWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeTotalWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CurveGaugeTotalWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugeTotalWeightsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeTypeWeights.
         * @summary GaugeTypeWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeTypeWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CurveGaugeTypeWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugeTypeWeightsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeTypes.
         * @summary GaugeTypes (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeTypesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, name?: string, options?: RequestOptions = {}): Promise<Array<CurveGaugeTypeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugeTypesHistorical(startBlock, endBlock, startDate, endDate, id, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeWeightVotes.
         * @summary GaugeWeightVotes (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeWeightVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options?: RequestOptions = {}): Promise<Array<CurveGaugeWeightVoteDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugeWeightVotesHistorical(startBlock, endBlock, startDate, endDate, id, user, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeWeights.
         * @summary GaugeWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CurveGaugeWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugeWeightsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeWithdraws.
         * @summary GaugeWithdraws (historical)
         * @throws {RequiredError}
         */
        curveGetGaugeWithdrawsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CurveGaugeWithdrawDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugeWithdrawsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges.
         * @summary Gauges (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveGaugeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugesHistorical(startBlock, endBlock, startDate, endDate, id, address, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets hourlyVolumes.
         * @summary HourlyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetHourlyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveHourlyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetHourlyVolumesHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets lpTokens.
         * @summary LpTokens (historical)
         * @throws {RequiredError}
         */
        curveGetLpTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, name?: string, symbol?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveLpTokenDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetLpTokensHistorical(startBlock, endBlock, startDate, endDate, id, address, name, symbol, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (historical)
         * @throws {RequiredError}
         */
        curveGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, name?: string, options?: RequestOptions = {}): Promise<Array<CurvePoolDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetPoolsHistorical(startBlock, endBlock, startDate, endDate, id, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets proposalVotes.
         * @summary ProposalVotes (historical)
         * @throws {RequiredError}
         */
        curveGetProposalVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CurveProposalVoteDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetProposalVotesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets proposals.
         * @summary Proposals (historical)
         * @throws {RequiredError}
         */
        curveGetProposalsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CurveProposalDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetProposalsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets removeLiquidityEvents.
         * @summary RemoveLiquidityEvents (historical)
         * @throws {RequiredError}
         */
        curveGetRemoveLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveRemoveLiquidityEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetRemoveLiquidityEventsHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets removeLiquidityOneEvents.
         * @summary RemoveLiquidityOneEvents (historical)
         * @throws {RequiredError}
         */
        curveGetRemoveLiquidityOneEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveRemoveLiquidityOneEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetRemoveLiquidityOneEventsHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets systemStates.
         * @summary SystemStates (historical)
         * @throws {RequiredError}
         */
        curveGetSystemStatesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<CurveSystemStateDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetSystemStatesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        curveGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, name?: string, symbol?: string, options?: RequestOptions = {}): Promise<Array<CurveTokenDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetTokensHistorical(startBlock, endBlock, startDate, endDate, id, address, name, symbol, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transferOwnershipEvents.
         * @summary TransferOwnershipEvents (historical)
         * @throws {RequiredError}
         */
        curveGetTransferOwnershipEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveTransferOwnershipEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetTransferOwnershipEventsHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets underlyingCoins.
         * @summary UnderlyingCoins (historical)
         * @throws {RequiredError}
         */
        curveGetUnderlyingCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveUnderlyingCoinDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetUnderlyingCoinsHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets votingApps.
         * @summary VotingApps (historical)
         * @throws {RequiredError}
         */
        curveGetVotingAppsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, options?: RequestOptions = {}): Promise<Array<CurveVotingAppDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetVotingAppsHistorical(startBlock, endBlock, startDate, endDate, id, address, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets weeklyVolumes.
         * @summary WeeklyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetWeeklyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<CurveWeeklyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetWeeklyVolumesHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets hourlyVolumes.
         * @summary HourlyVolumes (current)
         * @throws {RequiredError}
         */
        curveHourlyVolumesCurrent(options?: RequestOptions = {}): Promise<Array<CurveHourlyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveHourlyVolumesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets lpTokens.
         * @summary LpTokens (current)
         * @throws {RequiredError}
         */
        curveLpTokensCurrent(options?: RequestOptions = {}): Promise<Array<CurveLpTokenDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveLpTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (current)
         * @throws {RequiredError}
         */
        curvePoolsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<CurvePoolDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curvePoolsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets proposalVotes.
         * @summary ProposalVotes (current)
         * @throws {RequiredError}
         */
        curveProposalVotesCurrent(options?: RequestOptions = {}): Promise<Array<CurveProposalVoteDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveProposalVotesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets proposals.
         * @summary Proposals (current)
         * @throws {RequiredError}
         */
        curveProposalsCurrent(options?: RequestOptions = {}): Promise<Array<CurveProposalDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveProposalsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets removeLiquidityEvents.
         * @summary RemoveLiquidityEvents (current)
         * @throws {RequiredError}
         */
        curveRemoveLiquidityEventsCurrent(options?: RequestOptions = {}): Promise<Array<CurveRemoveLiquidityEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveRemoveLiquidityEventsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets removeLiquidityOneEvents.
         * @summary RemoveLiquidityOneEvents (current)
         * @throws {RequiredError}
         */
        curveRemoveLiquidityOneEventsCurrent(options?: RequestOptions = {}): Promise<Array<CurveRemoveLiquidityOneEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveRemoveLiquidityOneEventsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets systemStates.
         * @summary SystemStates (current)
         * @throws {RequiredError}
         */
        curveSystemStatesCurrent(options?: RequestOptions = {}): Promise<Array<CurveSystemStateDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveSystemStatesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        curveTokensCurrent(options?: RequestOptions = {}): Promise<Array<CurveTokenDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transferOwnershipEvents.
         * @summary TransferOwnershipEvents (current)
         * @throws {RequiredError}
         */
        curveTransferOwnershipEventsCurrent(options?: RequestOptions = {}): Promise<Array<CurveTransferOwnershipEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveTransferOwnershipEventsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets underlyingCoins.
         * @summary UnderlyingCoins (current)
         * @throws {RequiredError}
         */
        curveUnderlyingCoinsCurrent(options?: RequestOptions = {}): Promise<Array<CurveUnderlyingCoinDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveUnderlyingCoinsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets votingApps.
         * @summary VotingApps (current)
         * @throws {RequiredError}
         */
        curveVotingAppsCurrent(options?: RequestOptions = {}): Promise<Array<CurveVotingAppDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveVotingAppsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets weeklyVolumes.
         * @summary WeeklyVolumes (current)
         * @throws {RequiredError}
         */
        curveWeeklyVolumesCurrent(options?: RequestOptions = {}): Promise<Array<CurveWeeklyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveWeeklyVolumesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * DexApi - fetch parameter creator
 * @export
 */
export const DexApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets batches.
         * @summary Batches (current)
         * @throws {RequiredError}
         */
        dexBatchesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/batches/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        dexDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/deposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets batches.
         * @summary Batches (historical)
         * @throws {RequiredError}
         */
        dexGetBatchesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/batches/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (historical)
         * @throws {RequiredError}
         */
        dexGetDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/deposits/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = ((user:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets orders.
         * @summary Orders (historical)
         * @throws {RequiredError}
         */
        dexGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, buyToken?: string, sellToken?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/orders/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (buyToken !== undefined) {
                localVarQueryParameter['buy_token'] = ((buyToken:any):string);
            }

            if (sellToken !== undefined) {
                localVarQueryParameter['sell_token'] = ((sellToken:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets prices.
         * @summary Prices (historical)
         * @throws {RequiredError}
         */
        dexGetPricesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/prices/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets solutions.
         * @summary Solutions (historical)
         * @throws {RequiredError}
         */
        dexGetSolutionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/solutions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets stats.
         * @summary Stats (historical)
         * @throws {RequiredError}
         */
        dexGetStatsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/stats/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        dexGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, symbol?: string, name?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = ((address:any):string);
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = ((symbol:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (historical)
         * @throws {RequiredError}
         */
        dexGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, buyToken?: string, sellToken?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/trades/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (buyToken !== undefined) {
                localVarQueryParameter['buy_token'] = ((buyToken:any):string);
            }

            if (sellToken !== undefined) {
                localVarQueryParameter['sell_token'] = ((sellToken:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        dexGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/users/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdrawRequests.
         * @summary WithdrawRequests (historical)
         * @throws {RequiredError}
         */
        dexGetWithdrawRequestsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/withdrawRequests/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = ((user:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (historical)
         * @throws {RequiredError}
         */
        dexGetWithdrawsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/withdraws/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = ((user:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets orders.
         * @summary Orders (current)
         * @throws {RequiredError}
         */
        dexOrdersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/orders/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets prices.
         * @summary Prices (current)
         * @throws {RequiredError}
         */
        dexPricesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/prices/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets solutions.
         * @summary Solutions (current)
         * @throws {RequiredError}
         */
        dexSolutionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/solutions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets stats.
         * @summary Stats (current)
         * @throws {RequiredError}
         */
        dexStatsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/stats/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        dexTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        dexTradesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/trades/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        dexUsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdrawRequests.
         * @summary WithdrawRequests (current)
         * @throws {RequiredError}
         */
        dexWithdrawRequestsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/withdrawRequests/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        dexWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/withdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type DexApiType = { 
    dexBatchesCurrent(options?: RequestOptions): Promise<Array<DexBatchDTO>>,

    dexDepositsCurrent(options?: RequestOptions): Promise<Array<DexDepositDTO>>,

    dexGetBatchesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<DexBatchDTO>>,

    dexGetDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options?: RequestOptions): Promise<Array<DexDepositDTO>>,

    dexGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, buyToken?: string, sellToken?: string, options?: RequestOptions): Promise<Array<DexOrderDTO>>,

    dexGetPricesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<DexPriceDTO>>,

    dexGetSolutionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<DexSolutionDTO>>,

    dexGetStatsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<DexStatsDTO>>,

    dexGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, symbol?: string, name?: string, options?: RequestOptions): Promise<Array<DexTokenDTO>>,

    dexGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, buyToken?: string, sellToken?: string, options?: RequestOptions): Promise<Array<DexTradeDTO>>,

    dexGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<DexUserDTO>>,

    dexGetWithdrawRequestsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options?: RequestOptions): Promise<Array<DexWithdrawRequestDTO>>,

    dexGetWithdrawsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options?: RequestOptions): Promise<Array<DexWithdrawDTO>>,

    dexOrdersCurrent(options?: RequestOptions): Promise<Array<DexOrderDTO>>,

    dexPricesCurrent(options?: RequestOptions): Promise<Array<DexPriceDTO>>,

    dexSolutionsCurrent(options?: RequestOptions): Promise<Array<DexSolutionDTO>>,

    dexStatsCurrent(options?: RequestOptions): Promise<Array<DexStatsDTO>>,

    dexTokensCurrent(options?: RequestOptions): Promise<Array<DexTokenDTO>>,

    dexTradesCurrent(options?: RequestOptions): Promise<Array<DexTradeDTO>>,

    dexUsersCurrent(options?: RequestOptions): Promise<Array<DexUserDTO>>,

    dexWithdrawRequestsCurrent(options?: RequestOptions): Promise<Array<DexWithdrawRequestDTO>>,

    dexWithdrawsCurrent(options?: RequestOptions): Promise<Array<DexWithdrawDTO>>,
}

/**
 * DexApi - factory function to inject configuration 
 * @export
 */
export const DexApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): DexApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets batches.
         * @summary Batches (current)
         * @throws {RequiredError}
         */
        dexBatchesCurrent(options?: RequestOptions = {}): Promise<Array<DexBatchDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexBatchesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        dexDepositsCurrent(options?: RequestOptions = {}): Promise<Array<DexDepositDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets batches.
         * @summary Batches (historical)
         * @throws {RequiredError}
         */
        dexGetBatchesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<DexBatchDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetBatchesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (historical)
         * @throws {RequiredError}
         */
        dexGetDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options?: RequestOptions = {}): Promise<Array<DexDepositDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetDepositsHistorical(startBlock, endBlock, startDate, endDate, id, user, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets orders.
         * @summary Orders (historical)
         * @throws {RequiredError}
         */
        dexGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, buyToken?: string, sellToken?: string, options?: RequestOptions = {}): Promise<Array<DexOrderDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetOrdersHistorical(startBlock, endBlock, startDate, endDate, id, buyToken, sellToken, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets prices.
         * @summary Prices (historical)
         * @throws {RequiredError}
         */
        dexGetPricesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<DexPriceDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetPricesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets solutions.
         * @summary Solutions (historical)
         * @throws {RequiredError}
         */
        dexGetSolutionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<DexSolutionDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetSolutionsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets stats.
         * @summary Stats (historical)
         * @throws {RequiredError}
         */
        dexGetStatsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<DexStatsDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetStatsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        dexGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, address?: string, symbol?: string, name?: string, options?: RequestOptions = {}): Promise<Array<DexTokenDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetTokensHistorical(startBlock, endBlock, startDate, endDate, id, address, symbol, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (historical)
         * @throws {RequiredError}
         */
        dexGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, buyToken?: string, sellToken?: string, options?: RequestOptions = {}): Promise<Array<DexTradeDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetTradesHistorical(startBlock, endBlock, startDate, endDate, id, buyToken, sellToken, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        dexGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<DexUserDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetUsersHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdrawRequests.
         * @summary WithdrawRequests (historical)
         * @throws {RequiredError}
         */
        dexGetWithdrawRequestsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options?: RequestOptions = {}): Promise<Array<DexWithdrawRequestDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetWithdrawRequestsHistorical(startBlock, endBlock, startDate, endDate, id, user, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (historical)
         * @throws {RequiredError}
         */
        dexGetWithdrawsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, options?: RequestOptions = {}): Promise<Array<DexWithdrawDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetWithdrawsHistorical(startBlock, endBlock, startDate, endDate, id, user, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets orders.
         * @summary Orders (current)
         * @throws {RequiredError}
         */
        dexOrdersCurrent(options?: RequestOptions = {}): Promise<Array<DexOrderDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexOrdersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets prices.
         * @summary Prices (current)
         * @throws {RequiredError}
         */
        dexPricesCurrent(options?: RequestOptions = {}): Promise<Array<DexPriceDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexPricesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets solutions.
         * @summary Solutions (current)
         * @throws {RequiredError}
         */
        dexSolutionsCurrent(options?: RequestOptions = {}): Promise<Array<DexSolutionDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexSolutionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets stats.
         * @summary Stats (current)
         * @throws {RequiredError}
         */
        dexStatsCurrent(options?: RequestOptions = {}): Promise<Array<DexStatsDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexStatsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        dexTokensCurrent(options?: RequestOptions = {}): Promise<Array<DexTokenDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        dexTradesCurrent(options?: RequestOptions = {}): Promise<Array<DexTradeDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexTradesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        dexUsersCurrent(options?: RequestOptions = {}): Promise<Array<DexUserDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexUsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdrawRequests.
         * @summary WithdrawRequests (current)
         * @throws {RequiredError}
         */
        dexWithdrawRequestsCurrent(options?: RequestOptions = {}): Promise<Array<DexWithdrawRequestDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexWithdrawRequestsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        dexWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<DexWithdrawDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * MetadataApi - fetch parameter creator
 * @export
 */
export const MetadataApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all chains.
         * @throws {RequiredError}
         */
        metadataChainsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/chains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets dapp by name.
         * @throws {RequiredError}
         */
        metadataDappsDappNameGet(dappName: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'dappName' is not null or undefined
            if (dappName === null || dappName === undefined) {
                throw new RequiredError('dappName','Required parameter dappName was null or undefined when calling metadataDappsDappNameGet.');
            }
            const localVarPath = `/metadata/dapps/{dappName}`
                .replace(`{${"dappName"}}`, encodeURIComponent(String(dappName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all decentralized applications.
         * @throws {RequiredError}
         */
        metadataDappsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/dapps`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MetadataApiType = { 
    metadataChainsGet(options?: RequestOptions): Promise<Response>,

    metadataDappsDappNameGet(dappName: string, options?: RequestOptions): Promise<Response>,

    metadataDappsGet(options?: RequestOptions): Promise<Response>,
}

/**
 * MetadataApi - factory function to inject configuration 
 * @export
 */
export const MetadataApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MetadataApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List all chains.
         * @throws {RequiredError}
         */
        metadataChainsGet(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataChainsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Gets dapp by name.
         * @throws {RequiredError}
         */
        metadataDappsDappNameGet(dappName: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataDappsDappNameGet(dappName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List all decentralized applications.
         * @throws {RequiredError}
         */
        metadataDappsGet(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataDappsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * SushiswapApi - fetch parameter creator
 * @export
 */
export const SushiswapApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        sushiswapBundlesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/bundles/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        sushiswapBurnsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/burns/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dayData.
         * @summary DayData (current)
         * @throws {RequiredError}
         */
        sushiswapDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/dayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factories.
         * @summary Factories (current)
         * @throws {RequiredError}
         */
        sushiswapFactoriesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/factories/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/bundles/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/burns/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dayData.
         * @summary DayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/dayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factories.
         * @summary Factories (historical)
         * @throws {RequiredError}
         */
        sushiswapGetFactoriesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/factories/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets hourData.
         * @summary HourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/hourData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/liquidityPositionSnapshots/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = ((user:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/liquidityPositions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = ((user:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        sushiswapGetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/mints/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPairDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, token0?: string, token1?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pairDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            if (token0 !== undefined) {
                localVarQueryParameter['token_0'] = ((token0:any):string);
            }

            if (token1 !== undefined) {
                localVarQueryParameter['token_1'] = ((token1:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPairHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pairHourData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairs.
         * @summary Pairs (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPairsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, name?: string, token0?: string, token1?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pairs/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (token0 !== undefined) {
                localVarQueryParameter['token_0'] = ((token0:any):string);
            }

            if (token1 !== undefined) {
                localVarQueryParameter['token_1'] = ((token1:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (historical)
         * @throws {RequiredError}
         */
        sushiswapGetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/swaps/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTokenDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokenDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, symbol?: string, name?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = ((symbol:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/transactions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        sushiswapGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/users/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets hourData.
         * @summary HourData (current)
         * @throws {RequiredError}
         */
        sushiswapHourDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/hourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (current)
         * @throws {RequiredError}
         */
        sushiswapLiquidityPositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/liquidityPositionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (current)
         * @throws {RequiredError}
         */
        sushiswapLiquidityPositionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/liquidityPositions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        sushiswapMintsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/mints/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (current)
         * @throws {RequiredError}
         */
        sushiswapPairDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pairDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (current)
         * @throws {RequiredError}
         */
        sushiswapPairHourDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pairHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairs.
         * @summary Pairs (current)
         * @throws {RequiredError}
         */
        sushiswapPairsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pairs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        sushiswapSwapsCurrent(pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (current)
         * @throws {RequiredError}
         */
        sushiswapTokenDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokenDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        sushiswapTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        sushiswapTransactionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/transactions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        sushiswapUsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SushiswapApiType = { 
    sushiswapBundlesCurrent(options?: RequestOptions): Promise<Array<SushiswapBundleDTO>>,

    sushiswapBurnsCurrent(options?: RequestOptions): Promise<Array<SushiswapBurnDTO>>,

    sushiswapDayDataCurrent(options?: RequestOptions): Promise<Array<SushiswapDayDataDTO>>,

    sushiswapFactoriesCurrent(options?: RequestOptions): Promise<Array<SushiswapFactoryDTO>>,

    sushiswapGetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<SushiswapBundleDTO>>,

    sushiswapGetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions): Promise<Array<SushiswapBurnDTO>>,

    sushiswapGetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<SushiswapDayDataDTO>>,

    sushiswapGetFactoriesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<SushiswapFactoryDTO>>,

    sushiswapGetHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<SushiswapHourDataDTO>>,

    sushiswapGetLiquidityPositionSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options?: RequestOptions): Promise<Array<SushiswapLiquidityPositionSnapshotDTO>>,

    sushiswapGetLiquidityPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options?: RequestOptions): Promise<Array<SushiswapLiquidityPositionDTO>>,

    sushiswapGetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions): Promise<Array<SushiswapMintDTO>>,

    sushiswapGetPairDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, token0?: string, token1?: string, options?: RequestOptions): Promise<Array<SushiswapPairDayDataDTO>>,

    sushiswapGetPairHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions): Promise<Array<SushiswapPairHourDataDTO>>,

    sushiswapGetPairsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, name?: string, token0?: string, token1?: string, options?: RequestOptions): Promise<Array<SushiswapPairDTO>>,

    sushiswapGetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions): Promise<Array<SushiswapSwapDTO>>,

    sushiswapGetTokenDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<SushiswapTokenDayDataDTO>>,

    sushiswapGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, symbol?: string, name?: string, options?: RequestOptions): Promise<Array<SushiswapTokenDTO>>,

    sushiswapGetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<SushiswapTransactionDTO>>,

    sushiswapGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<SushiswapUserDTO>>,

    sushiswapHourDataCurrent(options?: RequestOptions): Promise<Array<SushiswapHourDataDTO>>,

    sushiswapLiquidityPositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<SushiswapLiquidityPositionSnapshotDTO>>,

    sushiswapLiquidityPositionsCurrent(options?: RequestOptions): Promise<Array<SushiswapLiquidityPositionDTO>>,

    sushiswapMintsCurrent(options?: RequestOptions): Promise<Array<SushiswapMintDTO>>,

    sushiswapPairDayDataCurrent(options?: RequestOptions): Promise<Array<SushiswapPairDayDataDTO>>,

    sushiswapPairHourDataCurrent(options?: RequestOptions): Promise<Array<SushiswapPairHourDataDTO>>,

    sushiswapPairsCurrent(id?: string, options?: RequestOptions): Promise<Array<SushiswapPairDTO>>,

    sushiswapSwapsCurrent(pair?: string, options?: RequestOptions): Promise<Array<SushiswapSwapDTO>>,

    sushiswapTokenDayDataCurrent(options?: RequestOptions): Promise<Array<SushiswapTokenDayDataDTO>>,

    sushiswapTokensCurrent(options?: RequestOptions): Promise<Array<SushiswapTokenDTO>>,

    sushiswapTransactionsCurrent(options?: RequestOptions): Promise<Array<SushiswapTransactionDTO>>,

    sushiswapUsersCurrent(options?: RequestOptions): Promise<Array<SushiswapUserDTO>>,
}

/**
 * SushiswapApi - factory function to inject configuration 
 * @export
 */
export const SushiswapApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SushiswapApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        sushiswapBundlesCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapBundleDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapBundlesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        sushiswapBurnsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapBurnDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapBurnsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dayData.
         * @summary DayData (current)
         * @throws {RequiredError}
         */
        sushiswapDayDataCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factories.
         * @summary Factories (current)
         * @throws {RequiredError}
         */
        sushiswapFactoriesCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapFactoryDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapFactoriesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<SushiswapBundleDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetBundlesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<SushiswapBurnDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetBurnsHistorical(startBlock, endBlock, startDate, endDate, id, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dayData.
         * @summary DayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<SushiswapDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetDayDataHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factories.
         * @summary Factories (historical)
         * @throws {RequiredError}
         */
        sushiswapGetFactoriesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<SushiswapFactoryDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetFactoriesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets hourData.
         * @summary HourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<SushiswapHourDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetHourDataHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<SushiswapLiquidityPositionSnapshotDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetLiquidityPositionSnapshotsHistorical(startBlock, endBlock, startDate, endDate, id, user, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<SushiswapLiquidityPositionDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetLiquidityPositionsHistorical(startBlock, endBlock, startDate, endDate, id, user, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        sushiswapGetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<SushiswapMintDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetMintsHistorical(startBlock, endBlock, startDate, endDate, id, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPairDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, token0?: string, token1?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPairDayDataHistorical(startBlock, endBlock, startDate, endDate, id, pair, token0, token1, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPairHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairHourDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPairHourDataHistorical(startBlock, endBlock, startDate, endDate, id, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairs.
         * @summary Pairs (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPairsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, name?: string, token0?: string, token1?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPairsHistorical(startBlock, endBlock, startDate, endDate, id, name, token0, token1, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (historical)
         * @throws {RequiredError}
         */
        sushiswapGetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<SushiswapSwapDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetSwapsHistorical(startBlock, endBlock, startDate, endDate, id, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTokenDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<SushiswapTokenDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTokenDayDataHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, symbol?: string, name?: string, options?: RequestOptions = {}): Promise<Array<SushiswapTokenDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTokensHistorical(startBlock, endBlock, startDate, endDate, id, symbol, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<SushiswapTransactionDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTransactionsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        sushiswapGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<SushiswapUserDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetUsersHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets hourData.
         * @summary HourData (current)
         * @throws {RequiredError}
         */
        sushiswapHourDataCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapHourDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapHourDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (current)
         * @throws {RequiredError}
         */
        sushiswapLiquidityPositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapLiquidityPositionSnapshotDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapLiquidityPositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (current)
         * @throws {RequiredError}
         */
        sushiswapLiquidityPositionsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapLiquidityPositionDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapLiquidityPositionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        sushiswapMintsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapMintDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapMintsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (current)
         * @throws {RequiredError}
         */
        sushiswapPairDayDataCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapPairDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapPairDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (current)
         * @throws {RequiredError}
         */
        sushiswapPairHourDataCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapPairHourDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapPairHourDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairs.
         * @summary Pairs (current)
         * @throws {RequiredError}
         */
        sushiswapPairsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapPairsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        sushiswapSwapsCurrent(pair?: string, options?: RequestOptions = {}): Promise<Array<SushiswapSwapDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapSwapsCurrent(pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (current)
         * @throws {RequiredError}
         */
        sushiswapTokenDayDataCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapTokenDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapTokenDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        sushiswapTokensCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapTokenDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        sushiswapTransactionsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapTransactionDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapTransactionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        sushiswapUsersCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapUserDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapUsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UniswapV2Api - fetch parameter creator
 * @export
 */
export const UniswapV2ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        uniswapV2BundlesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/bundles/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        uniswapV2BurnsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/burns/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/bundles/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/burns/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetLiquidityPositionSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/liquidityPositionSnapshots/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = ((user:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetLiquidityPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/liquidityPositions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = ((user:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/mints/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetPairDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, token0?: string, token1?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pairDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (token0 !== undefined) {
                localVarQueryParameter['token_0'] = ((token0:any):string);
            }

            if (token1 !== undefined) {
                localVarQueryParameter['token_1'] = ((token1:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetPairHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pairHourData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairs.
         * @summary Pairs (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetPairsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, token0?: string, token1?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pairs/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (token0 !== undefined) {
                localVarQueryParameter['token_0'] = ((token0:any):string);
            }

            if (token1 !== undefined) {
                localVarQueryParameter['token_1'] = ((token1:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/swaps/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetTokenDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokenDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, symbol?: string, name?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = ((symbol:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/transactions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetUniswapDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/uniswapDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapFactories.
         * @summary UniswapFactories (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetUniswapFactoriesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/uniswapFactories/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/users/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (current)
         * @throws {RequiredError}
         */
        uniswapV2LiquidityPositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/liquidityPositionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (current)
         * @throws {RequiredError}
         */
        uniswapV2LiquidityPositionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/liquidityPositions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        uniswapV2MintsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/mints/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2PairDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pairDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (current)
         * @throws {RequiredError}
         */
        uniswapV2PairHourDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pairHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairs.
         * @summary Pairs (current)
         * @throws {RequiredError}
         */
        uniswapV2PairsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pairs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uniswapV2SwapsCurrent(pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2TokenDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokenDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uniswapV2TokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        uniswapV2TransactionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/transactions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2UniswapDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/uniswapDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapFactories.
         * @summary UniswapFactories (current)
         * @throws {RequiredError}
         */
        uniswapV2UniswapFactoriesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/uniswapFactories/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        uniswapV2UsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UniswapV2ApiType = { 
    uniswapV2BundlesCurrent(options?: RequestOptions): Promise<Array<UniswapV2BundleDTO>>,

    uniswapV2BurnsCurrent(options?: RequestOptions): Promise<Array<UniswapV2BurnDTO>>,

    uniswapV2GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV2BundleDTO>>,

    uniswapV2GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions): Promise<Array<UniswapV2BurnDTO>>,

    uniswapV2GetLiquidityPositionSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options?: RequestOptions): Promise<Array<UniswapV2LiquidityPositionSnapshotDTO>>,

    uniswapV2GetLiquidityPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options?: RequestOptions): Promise<Array<UniswapV2LiquidityPositionDTO>>,

    uniswapV2GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions): Promise<Array<UniswapV2MintDTO>>,

    uniswapV2GetPairDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, token0?: string, token1?: string, options?: RequestOptions): Promise<Array<UniswapV2PairDayDataDTO>>,

    uniswapV2GetPairHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions): Promise<Array<UniswapV2PairHourDataDTO>>,

    uniswapV2GetPairsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, token0?: string, token1?: string, options?: RequestOptions): Promise<Array<UniswapV2PairDTO>>,

    uniswapV2GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions): Promise<Array<UniswapV2SwapDTO>>,

    uniswapV2GetTokenDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV2TokenDayDataDTO>>,

    uniswapV2GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, symbol?: string, name?: string, options?: RequestOptions): Promise<Array<UniswapV2TokenDTO>>,

    uniswapV2GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV2TransactionDTO>>,

    uniswapV2GetUniswapDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV2UniswapDayDataDTO>>,

    uniswapV2GetUniswapFactoriesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV2UniswapFactoryDTO>>,

    uniswapV2GetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV2UserDTO>>,

    uniswapV2LiquidityPositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<UniswapV2LiquidityPositionSnapshotDTO>>,

    uniswapV2LiquidityPositionsCurrent(options?: RequestOptions): Promise<Array<UniswapV2LiquidityPositionDTO>>,

    uniswapV2MintsCurrent(options?: RequestOptions): Promise<Array<UniswapV2MintDTO>>,

    uniswapV2PairDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV2PairDayDataDTO>>,

    uniswapV2PairHourDataCurrent(options?: RequestOptions): Promise<Array<UniswapV2PairHourDataDTO>>,

    uniswapV2PairsCurrent(id?: string, options?: RequestOptions): Promise<Array<UniswapV2PairDTO>>,

    uniswapV2SwapsCurrent(pair?: string, options?: RequestOptions): Promise<Array<UniswapV2SwapDTO>>,

    uniswapV2TokenDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV2TokenDayDataDTO>>,

    uniswapV2TokensCurrent(options?: RequestOptions): Promise<Array<UniswapV2TokenDTO>>,

    uniswapV2TransactionsCurrent(options?: RequestOptions): Promise<Array<UniswapV2TransactionDTO>>,

    uniswapV2UniswapDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV2UniswapDayDataDTO>>,

    uniswapV2UniswapFactoriesCurrent(options?: RequestOptions): Promise<Array<UniswapV2UniswapFactoryDTO>>,

    uniswapV2UsersCurrent(options?: RequestOptions): Promise<Array<UniswapV2UserDTO>>,
}

/**
 * UniswapV2Api - factory function to inject configuration 
 * @export
 */
export const UniswapV2Api = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UniswapV2ApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        uniswapV2BundlesCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2BundleDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2BundlesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        uniswapV2BurnsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2BurnDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2BurnsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2BundleDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetBundlesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2BurnDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetBurnsHistorical(startBlock, endBlock, startDate, endDate, id, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetLiquidityPositionSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2LiquidityPositionSnapshotDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetLiquidityPositionSnapshotsHistorical(startBlock, endBlock, startDate, endDate, id, user, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetLiquidityPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, user?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2LiquidityPositionDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetLiquidityPositionsHistorical(startBlock, endBlock, startDate, endDate, id, user, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2MintDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetMintsHistorical(startBlock, endBlock, startDate, endDate, id, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetPairDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, token0?: string, token1?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2PairDayDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetPairDayDataHistorical(startBlock, endBlock, startDate, endDate, id, token0, token1, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetPairHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2PairHourDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetPairHourDataHistorical(startBlock, endBlock, startDate, endDate, id, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairs.
         * @summary Pairs (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetPairsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, token0?: string, token1?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2PairDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetPairsHistorical(startBlock, endBlock, startDate, endDate, id, token0, token1, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pair?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2SwapDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetSwapsHistorical(startBlock, endBlock, startDate, endDate, id, pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetTokenDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2TokenDayDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetTokenDayDataHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, symbol?: string, name?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2TokenDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetTokensHistorical(startBlock, endBlock, startDate, endDate, id, symbol, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2TransactionDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetTransactionsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetUniswapDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2UniswapDayDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetUniswapDayDataHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapFactories.
         * @summary UniswapFactories (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetUniswapFactoriesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2UniswapFactoryDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetUniswapFactoriesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2UserDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetUsersHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (current)
         * @throws {RequiredError}
         */
        uniswapV2LiquidityPositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2LiquidityPositionSnapshotDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2LiquidityPositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (current)
         * @throws {RequiredError}
         */
        uniswapV2LiquidityPositionsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2LiquidityPositionDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2LiquidityPositionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        uniswapV2MintsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2MintDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2MintsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2PairDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2PairDayDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2PairDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (current)
         * @throws {RequiredError}
         */
        uniswapV2PairHourDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2PairHourDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2PairHourDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairs.
         * @summary Pairs (current)
         * @throws {RequiredError}
         */
        uniswapV2PairsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2PairDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2PairsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uniswapV2SwapsCurrent(pair?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2SwapDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2SwapsCurrent(pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2TokenDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2TokenDayDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2TokenDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uniswapV2TokensCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2TokenDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2TokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        uniswapV2TransactionsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2TransactionDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2TransactionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2UniswapDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2UniswapDayDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2UniswapDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapFactories.
         * @summary UniswapFactories (current)
         * @throws {RequiredError}
         */
        uniswapV2UniswapFactoriesCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2UniswapFactoryDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2UniswapFactoriesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        uniswapV2UsersCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2UserDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2UsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UniswapV3Api - fetch parameter creator
 * @export
 */
export const UniswapV3ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        uniswapV3BundlesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/bundles/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        uniswapV3BurnsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/burns/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factories.
         * @summary Factories (current)
         * @throws {RequiredError}
         */
        uniswapV3FactoriesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/factories/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/bundles/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/burns/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            if (token0 !== undefined) {
                localVarQueryParameter['token_0'] = ((token0:any):string);
            }

            if (token1 !== undefined) {
                localVarQueryParameter['token_1'] = ((token1:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factories.
         * @summary Factories (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetFactoriesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/factories/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/mints/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            if (token0 !== undefined) {
                localVarQueryParameter['token_0'] = ((token0:any):string);
            }

            if (token1 !== undefined) {
                localVarQueryParameter['token_1'] = ((token1:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets poolDayData.
         * @summary PoolDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets poolHourData.
         * @summary PoolHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolHourData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, token0?: string, token1?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/pools/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (token0 !== undefined) {
                localVarQueryParameter['token_0'] = ((token0:any):string);
            }

            if (token1 !== undefined) {
                localVarQueryParameter['token_1'] = ((token1:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positionSnapshots/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions.
         * @summary Positions (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            if (token0 !== undefined) {
                localVarQueryParameter['token_0'] = ((token0:any):string);
            }

            if (token1 !== undefined) {
                localVarQueryParameter['token_1'] = ((token1:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/swaps/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            if (token0 !== undefined) {
                localVarQueryParameter['token_0'] = ((token0:any):string);
            }

            if (token1 !== undefined) {
                localVarQueryParameter['token_1'] = ((token1:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickDayData.
         * @summary TickDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTickDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tickDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks.
         * @summary Ticks (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTicksHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/ticks/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenHourData.
         * @summary TokenHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTokenHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokenHourData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenV3DayData.
         * @summary TokenV3DayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTokenV3DayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokenV3DayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, symbol?: string, name?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokens/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = ((symbol:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/transactions/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetUniswapDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/uniswapDayData/historical`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        uniswapV3MintsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/mints/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets poolDayData.
         * @summary PoolDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets poolHourData.
         * @summary PoolHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolHourDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/pools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        uniswapV3PositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uniswapV3PositionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uniswapV3SwapsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickDayData.
         * @summary TickDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3TickDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tickDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uniswapV3TicksCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/ticks/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenHourData.
         * @summary TokenHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3TokenHourDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokenHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenV3DayData.
         * @summary TokenV3DayData (current)
         * @throws {RequiredError}
         */
        uniswapV3TokenV3DayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokenV3DayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uniswapV3TokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        uniswapV3TransactionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/transactions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3UniswapDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/uniswapDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UniswapV3ApiType = { 
    uniswapV3BundlesCurrent(options?: RequestOptions): Promise<Array<UniswapV3BundleDTO>>,

    uniswapV3BurnsCurrent(options?: RequestOptions): Promise<Array<UniswapV3BurnDTO>>,

    uniswapV3FactoriesCurrent(options?: RequestOptions): Promise<Array<UniswapV3FactoryDTO>>,

    uniswapV3GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV3BundleDTO>>,

    uniswapV3GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options?: RequestOptions): Promise<Array<UniswapV3BurnDTO>>,

    uniswapV3GetFactoriesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV3FactoryDTO>>,

    uniswapV3GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options?: RequestOptions): Promise<Array<UniswapV3MintDTO>>,

    uniswapV3GetPoolDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolDayDataDTO>>,

    uniswapV3GetPoolHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolHourDataDTO>>,

    uniswapV3GetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, token0?: string, token1?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolDTO>>,

    uniswapV3GetPositionSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<UniswapV3PositionSnapshotDTO>>,

    uniswapV3GetPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options?: RequestOptions): Promise<Array<UniswapV3PositionDTO>>,

    uniswapV3GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options?: RequestOptions): Promise<Array<UniswapV3SwapDTO>>,

    uniswapV3GetTickDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<UniswapV3TickDayDataDTO>>,

    uniswapV3GetTicksHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions): Promise<Array<UniswapV3TickDTO>>,

    uniswapV3GetTokenHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenHourDataDTO>>,

    uniswapV3GetTokenV3DayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenV3DayDataDTO>>,

    uniswapV3GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, symbol?: string, name?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenDTO>>,

    uniswapV3GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV3TransactionDTO>>,

    uniswapV3GetUniswapDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions): Promise<Array<UniswapV3UniswapDayDataDTO>>,

    uniswapV3MintsCurrent(options?: RequestOptions): Promise<Array<UniswapV3MintDTO>>,

    uniswapV3PoolDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3PoolDayDataDTO>>,

    uniswapV3PoolHourDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3PoolHourDataDTO>>,

    uniswapV3PoolsCurrent(id?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolDTO>>,

    uniswapV3PositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<UniswapV3PositionSnapshotDTO>>,

    uniswapV3PositionsCurrent(options?: RequestOptions): Promise<Array<UniswapV3PositionDTO>>,

    uniswapV3SwapsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UniswapV3SwapDTO>>,

    uniswapV3TickDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3TickDayDataDTO>>,

    uniswapV3TicksCurrent(options?: RequestOptions): Promise<Array<UniswapV3TickDTO>>,

    uniswapV3TokenHourDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3TokenHourDataDTO>>,

    uniswapV3TokenV3DayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3TokenV3DayDataDTO>>,

    uniswapV3TokensCurrent(options?: RequestOptions): Promise<Array<UniswapV3TokenDTO>>,

    uniswapV3TransactionsCurrent(options?: RequestOptions): Promise<Array<UniswapV3TransactionDTO>>,

    uniswapV3UniswapDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3UniswapDayDataDTO>>,
}

/**
 * UniswapV3Api - factory function to inject configuration 
 * @export
 */
export const UniswapV3Api = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UniswapV3ApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        uniswapV3BundlesCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3BundleDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3BundlesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        uniswapV3BurnsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3BurnDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3BurnsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factories.
         * @summary Factories (current)
         * @throws {RequiredError}
         */
        uniswapV3FactoriesCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3FactoryDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3FactoriesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3BundleDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetBundlesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3BurnDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetBurnsHistorical(startBlock, endBlock, startDate, endDate, id, pool, token0, token1, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factories.
         * @summary Factories (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetFactoriesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3FactoryDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetFactoriesHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3MintDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetMintsHistorical(startBlock, endBlock, startDate, endDate, id, pool, token0, token1, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets poolDayData.
         * @summary PoolDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolDayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPoolDayDataHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets poolHourData.
         * @summary PoolHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolHourDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPoolHourDataHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, token0?: string, token1?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPoolsHistorical(startBlock, endBlock, startDate, endDate, id, token0, token1, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PositionSnapshotDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPositionSnapshotsHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions.
         * @summary Positions (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PositionDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPositionsHistorical(startBlock, endBlock, startDate, endDate, id, pool, token0, token1, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, token0?: string, token1?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3SwapDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetSwapsHistorical(startBlock, endBlock, startDate, endDate, id, pool, token0, token1, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickDayData.
         * @summary TickDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTickDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TickDayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTickDayDataHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks.
         * @summary Ticks (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTicksHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, pool?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TickDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTicksHistorical(startBlock, endBlock, startDate, endDate, id, pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenHourData.
         * @summary TokenHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTokenHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenHourDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTokenHourDataHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenV3DayData.
         * @summary TokenV3DayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTokenV3DayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenV3DayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTokenV3DayDataHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, symbol?: string, name?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTokensHistorical(startBlock, endBlock, startDate, endDate, id, symbol, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TransactionDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTransactionsHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetUniswapDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3UniswapDayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetUniswapDayDataHistorical(startBlock, endBlock, startDate, endDate, id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        uniswapV3MintsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3MintDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3MintsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets poolDayData.
         * @summary PoolDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3PoolDayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3PoolDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets poolHourData.
         * @summary PoolHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolHourDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3PoolHourDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3PoolHourDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3PoolsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        uniswapV3PositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3PositionSnapshotDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3PositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uniswapV3PositionsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3PositionDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3PositionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uniswapV3SwapsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3SwapDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3SwapsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickDayData.
         * @summary TickDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3TickDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TickDayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TickDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uniswapV3TicksCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TickDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TicksCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenHourData.
         * @summary TokenHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3TokenHourDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TokenHourDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TokenHourDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenV3DayData.
         * @summary TokenV3DayData (current)
         * @throws {RequiredError}
         */
        uniswapV3TokenV3DayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TokenV3DayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TokenV3DayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uniswapV3TokensCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TokenDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        uniswapV3TransactionsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TransactionDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TransactionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3UniswapDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3UniswapDayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3UniswapDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    CRYPTOPUNKSApi: CRYPTOPUNKSApiType,

    CowApi: CowApiType,

    CurveApi: CurveApiType,

    DexApi: DexApiType,

    MetadataApi: MetadataApiType,

    SushiswapApi: SushiswapApiType,

    UniswapV2Api: UniswapV2ApiType,

    UniswapV3Api: UniswapV3ApiType,
 }
