note
 description:"[
		OnChain API
 		 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             
  		The version of the OpenAPI document: v1
 	    Contact: support@coinapi.io

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	UNISWAPV3_API

inherit

    API_I


feature -- API Access


	chains_chain_id_dapps_uniswapv3_bundle_current_get (chain_id: STRING_32): detachable LIST [BUNDLE_V3_DTO]
			-- GetBundles
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- 
			-- Result LIST [BUNDLE_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/bundle/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [BUNDLE_V3_DTO] } l_response.data ({ LIST [BUNDLE_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_burns_current_get (chain_id: STRING_32; filter_pool_id: STRING_32): detachable LIST [BURN_V3_DTO]
			-- GetBurns
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_pool_id Filter pool id (optional, default to null)
			-- 
			-- 
			-- Result LIST [BURN_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/burns/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_pool_id", filter_pool_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [BURN_V3_DTO] } l_response.data ({ LIST [BURN_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_factory_current_get (chain_id: STRING_32): detachable LIST [FACTORY_V3_DTO]
			-- GetFactory
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- 
			-- Result LIST [FACTORY_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/factory/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [FACTORY_V3_DTO] } l_response.data ({ LIST [FACTORY_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_mints_current_get (chain_id: STRING_32; filter_pool_id: STRING_32): detachable LIST [MINT_V3_DTO]
			-- GetMints
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_pool_id Filter pool id (optional, default to null)
			-- 
			-- 
			-- Result LIST [MINT_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/mints/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_pool_id", filter_pool_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [MINT_V3_DTO] } l_response.data ({ LIST [MINT_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_pools_current_get (chain_id: STRING_32; filter_pool_id: STRING_32): detachable LIST [POOL_V3_DTO]
			-- GetPools
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_pool_id Filter pool id (optional, default to null)
			-- 
			-- 
			-- Result LIST [POOL_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/pools/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_pool_id", filter_pool_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [POOL_V3_DTO] } l_response.data ({ LIST [POOL_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_pools_day_data_current_get (chain_id: STRING_32; filter_pool_id: STRING_32): detachable LIST [POOL_DAY_DATA_V3_DTO]
			-- GetPoolsDayData
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_pool_id Filter pool id (optional, default to null)
			-- 
			-- 
			-- Result LIST [POOL_DAY_DATA_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/poolsDayData/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_pool_id", filter_pool_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [POOL_DAY_DATA_V3_DTO] } l_response.data ({ LIST [POOL_DAY_DATA_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_pools_hour_data_current_get (chain_id: STRING_32; filter_pool_id: STRING_32): detachable LIST [POOL_HOUR_DATA_V3_DTO]
			-- GetPoolsHourData
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_pool_id Filter pool id (optional, default to null)
			-- 
			-- 
			-- Result LIST [POOL_HOUR_DATA_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/poolsHourData/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_pool_id", filter_pool_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [POOL_HOUR_DATA_V3_DTO] } l_response.data ({ LIST [POOL_HOUR_DATA_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_position_snapshots_current_get (chain_id: STRING_32; filter_pool_id: STRING_32): detachable LIST [POSITION_SNAPSHOT_V3_DTO]
			-- GetPositionSnapshot
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_pool_id Filter pool id (optional, default to null)
			-- 
			-- 
			-- Result LIST [POSITION_SNAPSHOT_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/positionSnapshots/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_pool_id", filter_pool_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [POSITION_SNAPSHOT_V3_DTO] } l_response.data ({ LIST [POSITION_SNAPSHOT_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_positions_current_get (chain_id: STRING_32; filter_pool_id: STRING_32): detachable LIST [POSITION_V3_DTO]
			-- GetPositions
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_pool_id Filter pool id (optional, default to null)
			-- 
			-- 
			-- Result LIST [POSITION_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/positions/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_pool_id", filter_pool_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [POSITION_V3_DTO] } l_response.data ({ LIST [POSITION_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_swaps_current_get (chain_id: STRING_32; filter_pool_id: STRING_32): detachable LIST [SWAP_V3_DTO]
			-- GetSwaps
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_pool_id Filter pool id (optional, default to null)
			-- 
			-- 
			-- Result LIST [SWAP_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/swaps/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_pool_id", filter_pool_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [SWAP_V3_DTO] } l_response.data ({ LIST [SWAP_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_ticks_current_get (chain_id: STRING_32; filter_pool_id: STRING_32): detachable LIST [TICK_V3_DTO]
			-- GetTicks
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_pool_id Filter pool id (optional, default to null)
			-- 
			-- 
			-- Result LIST [TICK_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/ticks/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_pool_id", filter_pool_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [TICK_V3_DTO] } l_response.data ({ LIST [TICK_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_ticks_day_data_current_get (chain_id: STRING_32; filter_pool_id: STRING_32): detachable LIST [TICK_DAY_DATA_V3_DTO]
			-- GetTicksDayData
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_pool_id Filter pool id (optional, default to null)
			-- 
			-- 
			-- Result LIST [TICK_DAY_DATA_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/ticksDayData/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_pool_id", filter_pool_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [TICK_DAY_DATA_V3_DTO] } l_response.data ({ LIST [TICK_DAY_DATA_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_tokens_current_get (chain_id: STRING_32; filter_token_id: STRING_32): detachable LIST [TOKEN_V3_DTO]
			-- GetTokens
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_token_id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [TOKEN_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/tokens/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_token_id", filter_token_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [TOKEN_V3_DTO] } l_response.data ({ LIST [TOKEN_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_tokens_day_data_current_get (chain_id: STRING_32; filter_token_id: STRING_32): detachable LIST [TOKEN_V3_DAY_DATA_DTO]
			-- GetTokensDayData
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_token_id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [TOKEN_V3_DAY_DATA_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/tokensDayData/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_token_id", filter_token_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [TOKEN_V3_DAY_DATA_DTO] } l_response.data ({ LIST [TOKEN_V3_DAY_DATA_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_tokens_hour_data_current_get (chain_id: STRING_32; filter_token_id: STRING_32): detachable LIST [TOKEN_HOUR_DATA_V3_DTO]
			-- GetTokensHourData
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- argument: filter_token_id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [TOKEN_HOUR_DATA_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/tokensHourData/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter_token_id", filter_token_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [TOKEN_HOUR_DATA_V3_DTO] } l_response.data ({ LIST [TOKEN_HOUR_DATA_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	chains_chain_id_dapps_uniswapv3_uniswap_day_data_current_get (chain_id: STRING_32): detachable LIST [UNISWAP_DAY_DATA_V3_DTO]
			-- GetUniswapDayData
			-- 
			-- 
			-- argument: chain_id Chain id (required)
			-- 
			-- 
			-- Result LIST [UNISWAP_DAY_DATA_V3_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/chains/{chain_id}/dapps/uniswapv3/uniswapDayData/current"
			l_path.replace_substring_all ("{"+"chain_id"+"}", api_client.url_encode (chain_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [UNISWAP_DAY_DATA_V3_DTO] } l_response.data ({ LIST [UNISWAP_DAY_DATA_V3_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end


end
