note
 description:"[
		OnChain API
 		 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             
  		The version of the OpenAPI document: v1
 	    Contact: support@coinapi.io

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	CURVE_API

inherit

    API_I


feature -- API Access


	curve_get_accounts_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; address: STRING_32): detachable LIST [CURVE_ACCOUNT_DTO]
			-- Accounts (historical) ðŸ”¥
			-- Gets accounts.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: address  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_ACCOUNT_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/accounts/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "address", address));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_ACCOUNT_DTO] } l_response.data ({ LIST [CURVE_ACCOUNT_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_add_liquidity_events_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_ADD_LIQUIDITY_EVENT_DTO]
			-- AddLiquidityEvents (historical) ðŸ”¥
			-- Gets addliquidityevents.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_ADD_LIQUIDITY_EVENT_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/addliquidityevents/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_ADD_LIQUIDITY_EVENT_DTO] } l_response.data ({ LIST [CURVE_ADD_LIQUIDITY_EVENT_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_admin_fee_change_logs_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_ADMIN_FEE_CHANGE_LOG_DTO]
			-- AdminFeeChangeLogs (historical) ðŸ”¥
			-- Gets adminfeechangelogs.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_ADMIN_FEE_CHANGE_LOG_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/adminfeechangelogs/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_ADMIN_FEE_CHANGE_LOG_DTO] } l_response.data ({ LIST [CURVE_ADMIN_FEE_CHANGE_LOG_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_amplification_coeff_change_logs_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_AMPLIFICATION_COEFF_CHANGE_LOG_DTO]
			-- AmplificationCoeffChangeLogs (historical) ðŸ”¥
			-- Gets amplificationcoeffchangelogs.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_AMPLIFICATION_COEFF_CHANGE_LOG_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/amplificationcoeffchangelogs/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_AMPLIFICATION_COEFF_CHANGE_LOG_DTO] } l_response.data ({ LIST [CURVE_AMPLIFICATION_COEFF_CHANGE_LOG_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_coins_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_COIN_DTO]
			-- Coins (historical) ðŸ”¥
			-- Gets coins.
			-- 
			-- argument: start_block  (optional, default to null)
			-- 
			-- argument: end_block  (optional, default to null)
			-- 
			-- argument: start_date  (optional, default to null)
			-- 
			-- argument: end_date  (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_COIN_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/coins/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_COIN_DTO] } l_response.data ({ LIST [CURVE_COIN_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_contract_versions_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; address: STRING_32): detachable LIST [CURVE_CONTRACT_VERSION_DTO]
			-- ContractVersions (historical) ðŸ”¥
			-- Gets contractversions.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: address  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_CONTRACT_VERSION_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/contractversions/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "address", address));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_CONTRACT_VERSION_DTO] } l_response.data ({ LIST [CURVE_CONTRACT_VERSION_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_contracts_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32): detachable LIST [CURVE_CONTRACT_DTO]
			-- Contracts (historical) ðŸ”¥
			-- Gets contracts.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_CONTRACT_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/contracts/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_CONTRACT_DTO] } l_response.data ({ LIST [CURVE_CONTRACT_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_daily_volumes_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_DAILY_VOLUME_DTO]
			-- DailyVolumes (historical) ðŸ”¥
			-- Gets dailyvolumes.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_DAILY_VOLUME_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/dailyvolumes/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_DAILY_VOLUME_DTO] } l_response.data ({ LIST [CURVE_DAILY_VOLUME_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_exchanges_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_EXCHANGE_DTO]
			-- Exchanges (historical) ðŸ”¥
			-- Gets exchanges.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_EXCHANGE_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/exchanges/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_EXCHANGE_DTO] } l_response.data ({ LIST [CURVE_EXCHANGE_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_fee_change_logs_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_FEE_CHANGE_LOG_DTO]
			-- FeeChangeLogs (historical) ðŸ”¥
			-- Gets feechangelogs.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_FEE_CHANGE_LOG_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/feechangelogs/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_FEE_CHANGE_LOG_DTO] } l_response.data ({ LIST [CURVE_FEE_CHANGE_LOG_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_gauge_deposits_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32): detachable LIST [CURVE_GAUGE_DEPOSIT_DTO]
			-- GaugeDeposits (historical) ðŸ”¥
			-- Gets gaugedeposits.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_GAUGE_DEPOSIT_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/gaugedeposits/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_GAUGE_DEPOSIT_DTO] } l_response.data ({ LIST [CURVE_GAUGE_DEPOSIT_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_gauge_liquiditys_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; user: STRING_32): detachable LIST [CURVE_GAUGE_LIQUIDITY_DTO]
			-- GaugeLiquiditys (historical) ðŸ”¥
			-- Gets gaugeliquiditys.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: user  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_GAUGE_LIQUIDITY_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/gaugeliquiditys/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user", user));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_GAUGE_LIQUIDITY_DTO] } l_response.data ({ LIST [CURVE_GAUGE_LIQUIDITY_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_gauge_total_weights_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32): detachable LIST [CURVE_GAUGE_TOTAL_WEIGHT_DTO]
			-- GaugeTotalWeights (historical) ðŸ”¥
			-- Gets gaugetotalweights.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_GAUGE_TOTAL_WEIGHT_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/gaugetotalweights/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_GAUGE_TOTAL_WEIGHT_DTO] } l_response.data ({ LIST [CURVE_GAUGE_TOTAL_WEIGHT_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_gauge_type_weights_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32): detachable LIST [CURVE_GAUGE_TYPE_WEIGHT_DTO]
			-- GaugeTypeWeights (historical) ðŸ”¥
			-- Gets gaugetypeweights.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_GAUGE_TYPE_WEIGHT_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/gaugetypeweights/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_GAUGE_TYPE_WEIGHT_DTO] } l_response.data ({ LIST [CURVE_GAUGE_TYPE_WEIGHT_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_gauge_types_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; name: STRING_32): detachable LIST [CURVE_GAUGE_TYPE_DTO]
			-- GaugeTypes (historical) ðŸ”¥
			-- Gets gaugetypes.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: name  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_GAUGE_TYPE_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/gaugetypes/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_GAUGE_TYPE_DTO] } l_response.data ({ LIST [CURVE_GAUGE_TYPE_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_gauge_weight_votes_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; user: STRING_32): detachable LIST [CURVE_GAUGE_WEIGHT_VOTE_DTO]
			-- GaugeWeightVotes (historical) ðŸ”¥
			-- Gets gaugeweightvotes.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: user  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_GAUGE_WEIGHT_VOTE_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/gaugeweightvotes/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user", user));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_GAUGE_WEIGHT_VOTE_DTO] } l_response.data ({ LIST [CURVE_GAUGE_WEIGHT_VOTE_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_gauge_weights_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32): detachable LIST [CURVE_GAUGE_WEIGHT_DTO]
			-- GaugeWeights (historical) ðŸ”¥
			-- Gets gaugeweights.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_GAUGE_WEIGHT_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/gaugeweights/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_GAUGE_WEIGHT_DTO] } l_response.data ({ LIST [CURVE_GAUGE_WEIGHT_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_gauge_withdraws_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32): detachable LIST [CURVE_GAUGE_WITHDRAW_DTO]
			-- GaugeWithdraws (historical) ðŸ”¥
			-- Gets gaugewithdraws.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_GAUGE_WITHDRAW_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/gaugewithdraws/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_GAUGE_WITHDRAW_DTO] } l_response.data ({ LIST [CURVE_GAUGE_WITHDRAW_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_gauges_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; address: STRING_32; pool: STRING_32): detachable LIST [CURVE_GAUGE_DTO]
			-- Gauges (historical) ðŸ”¥
			-- Gets gauges.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: address  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_GAUGE_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/gauges/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "address", address));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_GAUGE_DTO] } l_response.data ({ LIST [CURVE_GAUGE_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_hourly_volumes_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_HOURLY_VOLUME_DTO]
			-- HourlyVolumes (historical) ðŸ”¥
			-- Gets hourlyvolumes.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_HOURLY_VOLUME_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/hourlyvolumes/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_HOURLY_VOLUME_DTO] } l_response.data ({ LIST [CURVE_HOURLY_VOLUME_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_lp_tokens_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; address: STRING_32; name: STRING_32; symbol: STRING_32; pool: STRING_32): detachable LIST [CURVE_LP_TOKEN_DTO]
			-- LpTokens (historical) ðŸ”¥
			-- Gets lptokens.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: address  (optional, default to null)
			-- 
			-- argument: name  (optional, default to null)
			-- 
			-- argument: symbol  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_LP_TOKEN_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/lptokens/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "address", address));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "symbol", symbol));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_LP_TOKEN_DTO] } l_response.data ({ LIST [CURVE_LP_TOKEN_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_pools_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; name: STRING_32): detachable LIST [CURVE_POOL_DTO]
			-- Pools (historical) ðŸ”¥
			-- Gets pools.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id Pool address. (optional, default to null)
			-- 
			-- argument: name Pool&#39;s human-readable name. (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_POOL_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/pools/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_POOL_DTO] } l_response.data ({ LIST [CURVE_POOL_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_proposal_votes_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32): detachable LIST [CURVE_PROPOSAL_VOTE_DTO]
			-- ProposalVotes (historical) ðŸ”¥
			-- Gets proposalvotes.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_PROPOSAL_VOTE_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/proposalvotes/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_PROPOSAL_VOTE_DTO] } l_response.data ({ LIST [CURVE_PROPOSAL_VOTE_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_proposals_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32): detachable LIST [CURVE_PROPOSAL_DTO]
			-- Proposals (historical) ðŸ”¥
			-- Gets proposals.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_PROPOSAL_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/proposals/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_PROPOSAL_DTO] } l_response.data ({ LIST [CURVE_PROPOSAL_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_remove_liquidity_events_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_REMOVE_LIQUIDITY_EVENT_DTO]
			-- RemoveLiquidityEvents (historical) ðŸ”¥
			-- Gets removeliquidityevents.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_REMOVE_LIQUIDITY_EVENT_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/removeliquidityevents/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_REMOVE_LIQUIDITY_EVENT_DTO] } l_response.data ({ LIST [CURVE_REMOVE_LIQUIDITY_EVENT_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_remove_liquidity_one_events_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_REMOVE_LIQUIDITY_ONE_EVENT_DTO]
			-- RemoveLiquidityOneEvents (historical) ðŸ”¥
			-- Gets removeliquidityoneevents.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_REMOVE_LIQUIDITY_ONE_EVENT_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/removeliquidityoneevents/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_REMOVE_LIQUIDITY_ONE_EVENT_DTO] } l_response.data ({ LIST [CURVE_REMOVE_LIQUIDITY_ONE_EVENT_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_system_states_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32): detachable LIST [CURVE_SYSTEM_STATE_DTO]
			-- SystemStates (historical) ðŸ”¥
			-- Gets systemstates.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id Singleton ID, equals to &#39;current&#39;. (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_SYSTEM_STATE_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/systemstates/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_SYSTEM_STATE_DTO] } l_response.data ({ LIST [CURVE_SYSTEM_STATE_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_tokens_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; address: STRING_32; name: STRING_32; symbol: STRING_32): detachable LIST [CURVE_TOKEN_DTO]
			-- Tokens (historical) ðŸ”¥
			-- Gets tokens.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: address  (optional, default to null)
			-- 
			-- argument: name  (optional, default to null)
			-- 
			-- argument: symbol  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_TOKEN_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/tokens/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "address", address));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "name", name));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "symbol", symbol));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_TOKEN_DTO] } l_response.data ({ LIST [CURVE_TOKEN_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_transfer_ownership_events_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_TRANSFER_OWNERSHIP_EVENT_DTO]
			-- TransferOwnershipEvents (historical) ðŸ”¥
			-- Gets transferownershipevents.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_TRANSFER_OWNERSHIP_EVENT_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/transferownershipevents/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_TRANSFER_OWNERSHIP_EVENT_DTO] } l_response.data ({ LIST [CURVE_TRANSFER_OWNERSHIP_EVENT_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_underlying_coins_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_UNDERLYING_COIN_DTO]
			-- UnderlyingCoins (historical) ðŸ”¥
			-- Gets underlyingcoins.
			-- 
			-- argument: start_block  (optional, default to null)
			-- 
			-- argument: end_block  (optional, default to null)
			-- 
			-- argument: start_date  (optional, default to null)
			-- 
			-- argument: end_date  (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_UNDERLYING_COIN_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/underlyingcoins/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_UNDERLYING_COIN_DTO] } l_response.data ({ LIST [CURVE_UNDERLYING_COIN_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_voting_apps_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; address: STRING_32): detachable LIST [CURVE_VOTING_APP_DTO]
			-- VotingApps (historical) ðŸ”¥
			-- Gets votingapps.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id App address. (optional, default to null)
			-- 
			-- argument: address  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_VOTING_APP_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/votingapps/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "address", address));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_VOTING_APP_DTO] } l_response.data ({ LIST [CURVE_VOTING_APP_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	curve_get_weekly_volumes_historical (start_block: INTEGER_64; end_block: INTEGER_64; start_date: DATE_TIME; end_date: DATE_TIME; id: STRING_32; pool: STRING_32): detachable LIST [CURVE_WEEKLY_VOLUME_DTO]
			-- WeeklyVolumes (historical) ðŸ”¥
			-- Gets weeklyvolumes.
			-- 
			-- argument: start_block The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional, default to null)
			-- 
			-- argument: end_block The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional, default to null)
			-- 
			-- argument: start_date The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional, default to null)
			-- 
			-- argument: end_date The end date of timeframe. (optional, default to null)
			-- 
			-- argument: id  (optional, default to null)
			-- 
			-- argument: pool  (optional, default to null)
			-- 
			-- 
			-- Result LIST [CURVE_WEEKLY_VOLUME_DTO]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/dapps/curve/weeklyvolumes/historical"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startBlock", start_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endBlock", end_block));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "startDate", start_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "endDate", end_date));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "id", id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pool", pool));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain", "application/json", "text/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [CURVE_WEEKLY_VOLUME_DTO] } l_response.data ({ LIST [CURVE_WEEKLY_VOLUME_DTO] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end


end
