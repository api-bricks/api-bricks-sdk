{-
   EMS - REST API

   This section will provide necessary information about the `CoinAPI EMS REST API` protocol. <br/> This API is also available in the Postman application: <a href=\"https://postman.coinapi.io/\" target=\"_blank\">https://postman.coinapi.io/</a>       <br/><br/> Implemented Standards:    * [HTTP1.0](https://datatracker.ietf.org/doc/html/rfc1945)   * [HTTP1.1](https://datatracker.ietf.org/doc/html/rfc2616)   * [HTTP2.0](https://datatracker.ietf.org/doc/html/rfc7540)     ### Endpoints <table>   <thead>     <tr>       <th>Deployment method</th>       <th>Environment</th>       <th>Url</th>     </tr>   </thead>   <tbody>     <tr>       <td>Managed Cloud</td>       <td>Production</td>       <td>Use <a href=\"#ems-docs-sh\">Managed Cloud REST API /v1/locations</a> to get specific endpoints to each server site where your deployments span</td>     </tr>     <tr>       <td>Managed Cloud</td>       <td>Sandbox</td>       <td><code>https://ems-gateway-aws-eu-central-1-dev.coinapi.io/</code></td>     </tr>     <tr>       <td>Self Hosted</td>       <td>Production</td>       <td>IP Address of the <code>ems-gateway</code> container/excecutable in the closest server site to the caller location</td>     </tr>     <tr>       <td>Self Hosted</td>       <td>Sandbox</td>       <td>IP Address of the <code>ems-gateway</code> container/excecutable in the closest server site to the caller location</td>     </tr>   </tbody> </table>  ### Authentication If the software is deployed as `Self-Hosted` then API do not require authentication as inside your infrastructure, your company is responsible for the security and access controls.  <br/><br/> If the software is deployed in our `Managed Cloud`, there are 2 methods for authenticating with us, you only need to use one:   1. Custom authorization header named `X-CoinAPI-Key` with the API Key  2. Query string parameter named `apikey` with the API Key  3. <a href=\"#certificate\">TLS Client Certificate</a> from the `Managed Cloud REST API` (/v1/certificate/pem endpoint) while establishing a TLS session with us.  #### Custom authorization header You can authorize by providing additional custom header named `X-CoinAPI-Key` and API key as its value. Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY`, then the authorization header you should send to us will look like: <br/><br/> `X-CoinAPI-Key: 73034021-THIS-IS-SAMPLE-KEY` <aside class=\"success\">This method is recommended by us and you should use it in production environments.</aside> #### Query string authorization parameter You can authorize by providing an additional parameter named `apikey` with a value equal to your API key in the query string of your HTTP request. Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY` and that you want to request all balances, then your query string should look like this:  <br/><br/> `GET /v1/balances?apikey=73034021-THIS-IS-SAMPLE-KEY` <aside class=\"notice\">Query string method may be more practical for development activities.</aside> 

   OpenAPI Version: 3.0.0
   EMS - REST API API version: v1
   Contact: support@coinapi.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : EMS-REST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module EMS-REST.Model where

import EMS-REST.Core
import EMS-REST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** ClientOrderId
newtype ClientOrderId = ClientOrderId { unClientOrderId :: Text } deriving (P.Eq, P.Show)

-- ** ExchangeId
newtype ExchangeId = ExchangeId { unExchangeId :: Text } deriving (P.Eq, P.Show)

-- ** TimeEnd
newtype TimeEnd = TimeEnd { unTimeEnd :: Text } deriving (P.Eq, P.Show)

-- ** TimeStart
newtype TimeStart = TimeStart { unTimeStart :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Balance
-- | Balance
data Balance = Balance
  { balanceExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier used to identify the routing destination.
  , balanceData :: !(Maybe [BalanceDataInner]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Balance
instance A.FromJSON Balance where
  parseJSON = A.withObject "Balance" $ \o ->
    Balance
      <$> (o .:? "exchange_id")
      <*> (o .:? "data")

-- | ToJSON Balance
instance A.ToJSON Balance where
  toJSON Balance {..} =
   _omitNulls
      [ "exchange_id" .= balanceExchangeId
      , "data" .= balanceData
      ]


-- | Construct a value of type 'Balance' (by applying it's required fields, if any)
mkBalance
  :: Balance
mkBalance =
  Balance
  { balanceExchangeId = Nothing
  , balanceData = Nothing
  }

-- ** BalanceDataInner
-- | BalanceDataInner
data BalanceDataInner = BalanceDataInner
  { balanceDataInnerAssetIdExchange :: !(Maybe Text) -- ^ "asset_id_exchange" - Exchange currency code.
  , balanceDataInnerAssetIdCoinapi :: !(Maybe Text) -- ^ "asset_id_coinapi" - CoinAPI currency code.
  , balanceDataInnerBalance :: !(Maybe Double) -- ^ "balance" - Value of the current total currency balance on the exchange.
  , balanceDataInnerAvailable :: !(Maybe Double) -- ^ "available" - Value of the current available currency balance on the exchange that can be used as collateral.
  , balanceDataInnerLocked :: !(Maybe Double) -- ^ "locked" - Value of the current locked currency balance by the exchange.
  , balanceDataInnerLastUpdatedBy :: !(Maybe E'LastUpdatedBy) -- ^ "last_updated_by" - Source of the last modification. 
  , balanceDataInnerRateUsd :: !(Maybe Double) -- ^ "rate_usd" - Current exchange rate to the USD for the single unit of the currency. 
  , balanceDataInnerTraded :: !(Maybe Double) -- ^ "traded" - Value of the current total traded.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BalanceDataInner
instance A.FromJSON BalanceDataInner where
  parseJSON = A.withObject "BalanceDataInner" $ \o ->
    BalanceDataInner
      <$> (o .:? "asset_id_exchange")
      <*> (o .:? "asset_id_coinapi")
      <*> (o .:? "balance")
      <*> (o .:? "available")
      <*> (o .:? "locked")
      <*> (o .:? "last_updated_by")
      <*> (o .:? "rate_usd")
      <*> (o .:? "traded")

-- | ToJSON BalanceDataInner
instance A.ToJSON BalanceDataInner where
  toJSON BalanceDataInner {..} =
   _omitNulls
      [ "asset_id_exchange" .= balanceDataInnerAssetIdExchange
      , "asset_id_coinapi" .= balanceDataInnerAssetIdCoinapi
      , "balance" .= balanceDataInnerBalance
      , "available" .= balanceDataInnerAvailable
      , "locked" .= balanceDataInnerLocked
      , "last_updated_by" .= balanceDataInnerLastUpdatedBy
      , "rate_usd" .= balanceDataInnerRateUsd
      , "traded" .= balanceDataInnerTraded
      ]


-- | Construct a value of type 'BalanceDataInner' (by applying it's required fields, if any)
mkBalanceDataInner
  :: BalanceDataInner
mkBalanceDataInner =
  BalanceDataInner
  { balanceDataInnerAssetIdExchange = Nothing
  , balanceDataInnerAssetIdCoinapi = Nothing
  , balanceDataInnerBalance = Nothing
  , balanceDataInnerAvailable = Nothing
  , balanceDataInnerLocked = Nothing
  , balanceDataInnerLastUpdatedBy = Nothing
  , balanceDataInnerRateUsd = Nothing
  , balanceDataInnerTraded = Nothing
  }

-- ** Fills
-- | Fills
-- Relay fill information on working orders.
-- 
data Fills = Fills
  { fillsTime :: !(Maybe Date) -- ^ "time" - Execution time.
  , fillsPrice :: !(Maybe Double) -- ^ "price" - Execution price.
  , fillsAmount :: !(Maybe Double) -- ^ "amount" - Executed quantity.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Fills
instance A.FromJSON Fills where
  parseJSON = A.withObject "Fills" $ \o ->
    Fills
      <$> (o .:? "time")
      <*> (o .:? "price")
      <*> (o .:? "amount")

-- | ToJSON Fills
instance A.ToJSON Fills where
  toJSON Fills {..} =
   _omitNulls
      [ "time" .= fillsTime
      , "price" .= fillsPrice
      , "amount" .= fillsAmount
      ]


-- | Construct a value of type 'Fills' (by applying it's required fields, if any)
mkFills
  :: Fills
mkFills =
  Fills
  { fillsTime = Nothing
  , fillsPrice = Nothing
  , fillsAmount = Nothing
  }

-- ** MessageError
-- | MessageError
-- MessageError object.
-- 
data MessageError = MessageError
  { messageErrorMessage :: !(Maybe Text) -- ^ "message" - Message text.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageError
instance A.FromJSON MessageError where
  parseJSON = A.withObject "MessageError" $ \o ->
    MessageError
      <$> (o .:? "message")

-- | ToJSON MessageError
instance A.ToJSON MessageError where
  toJSON MessageError {..} =
   _omitNulls
      [ "message" .= messageErrorMessage
      ]


-- | Construct a value of type 'MessageError' (by applying it's required fields, if any)
mkMessageError
  :: MessageError
mkMessageError =
  MessageError
  { messageErrorMessage = Nothing
  }

-- ** MessageReject
-- | MessageReject
-- MessageReject object.
-- 
data MessageReject = MessageReject
  { messageRejectType :: !(Maybe Text) -- ^ "type" - Message type, constant.
  , messageRejectRejectReason :: !(Maybe RejectReason) -- ^ "reject_reason"
  , messageRejectExchangeId :: !(Maybe Text) -- ^ "exchange_id" - If the message related to exchange, then the identifier of the exchange will be provided.
  , messageRejectMessage :: !(Maybe Text) -- ^ "message" - Message text.
  , messageRejectRejectedMessage :: !(Maybe Text) -- ^ "rejected_message" - Value of rejected request, if available.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageReject
instance A.FromJSON MessageReject where
  parseJSON = A.withObject "MessageReject" $ \o ->
    MessageReject
      <$> (o .:? "type")
      <*> (o .:? "reject_reason")
      <*> (o .:? "exchange_id")
      <*> (o .:? "message")
      <*> (o .:? "rejected_message")

-- | ToJSON MessageReject
instance A.ToJSON MessageReject where
  toJSON MessageReject {..} =
   _omitNulls
      [ "type" .= messageRejectType
      , "reject_reason" .= messageRejectRejectReason
      , "exchange_id" .= messageRejectExchangeId
      , "message" .= messageRejectMessage
      , "rejected_message" .= messageRejectRejectedMessage
      ]


-- | Construct a value of type 'MessageReject' (by applying it's required fields, if any)
mkMessageReject
  :: MessageReject
mkMessageReject =
  MessageReject
  { messageRejectType = Nothing
  , messageRejectRejectReason = Nothing
  , messageRejectExchangeId = Nothing
  , messageRejectMessage = Nothing
  , messageRejectRejectedMessage = Nothing
  }

-- ** OrderCancelAllRequest
-- | OrderCancelAllRequest
-- Cancel all orders request object.
data OrderCancelAllRequest = OrderCancelAllRequest
  { orderCancelAllRequestExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Identifier of the exchange from which active orders should be canceled.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderCancelAllRequest
instance A.FromJSON OrderCancelAllRequest where
  parseJSON = A.withObject "OrderCancelAllRequest" $ \o ->
    OrderCancelAllRequest
      <$> (o .:  "exchange_id")

-- | ToJSON OrderCancelAllRequest
instance A.ToJSON OrderCancelAllRequest where
  toJSON OrderCancelAllRequest {..} =
   _omitNulls
      [ "exchange_id" .= orderCancelAllRequestExchangeId
      ]


-- | Construct a value of type 'OrderCancelAllRequest' (by applying it's required fields, if any)
mkOrderCancelAllRequest
  :: Text -- ^ 'orderCancelAllRequestExchangeId': Identifier of the exchange from which active orders should be canceled.
  -> OrderCancelAllRequest
mkOrderCancelAllRequest orderCancelAllRequestExchangeId =
  OrderCancelAllRequest
  { orderCancelAllRequestExchangeId
  }

-- ** OrderCancelSingleRequest
-- | OrderCancelSingleRequest
-- Cancel single order request object.
data OrderCancelSingleRequest = OrderCancelSingleRequest
  { orderCancelSingleRequestExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier used to identify the routing destination.
  , orderCancelSingleRequestExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Unique identifier of the order assigned by the exchange or executing system. One of the properties (&#x60;exchange_order_id&#x60;, &#x60;client_order_id&#x60;) is required to identify the new order.
  , orderCancelSingleRequestClientOrderId :: !(Maybe Text) -- ^ "client_order_id" - The unique identifier of the order assigned by the client. One of the properties (&#x60;exchange_order_id&#x60;, &#x60;client_order_id&#x60;) is required to identify the new order.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderCancelSingleRequest
instance A.FromJSON OrderCancelSingleRequest where
  parseJSON = A.withObject "OrderCancelSingleRequest" $ \o ->
    OrderCancelSingleRequest
      <$> (o .:  "exchange_id")
      <*> (o .:? "exchange_order_id")
      <*> (o .:? "client_order_id")

-- | ToJSON OrderCancelSingleRequest
instance A.ToJSON OrderCancelSingleRequest where
  toJSON OrderCancelSingleRequest {..} =
   _omitNulls
      [ "exchange_id" .= orderCancelSingleRequestExchangeId
      , "exchange_order_id" .= orderCancelSingleRequestExchangeOrderId
      , "client_order_id" .= orderCancelSingleRequestClientOrderId
      ]


-- | Construct a value of type 'OrderCancelSingleRequest' (by applying it's required fields, if any)
mkOrderCancelSingleRequest
  :: Text -- ^ 'orderCancelSingleRequestExchangeId': Exchange identifier used to identify the routing destination.
  -> OrderCancelSingleRequest
mkOrderCancelSingleRequest orderCancelSingleRequestExchangeId =
  OrderCancelSingleRequest
  { orderCancelSingleRequestExchangeId
  , orderCancelSingleRequestExchangeOrderId = Nothing
  , orderCancelSingleRequestClientOrderId = Nothing
  }

-- ** OrderExecutionReport
-- | OrderExecutionReport
-- The order execution report object.
data OrderExecutionReport = OrderExecutionReport
  { orderExecutionReportExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier used to identify the routing destination.
  , orderExecutionReportClientOrderId :: !(Text) -- ^ /Required/ "client_order_id" - The unique identifier of the order assigned by the client.
  , orderExecutionReportSymbolIdExchange :: !(Maybe Text) -- ^ "symbol_id_exchange" - Exchange symbol. One of the properties (&#x60;symbol_id_exchange&#x60;, &#x60;symbol_id_coinapi&#x60;) is required to identify the market for the new order.
  , orderExecutionReportSymbolIdCoinapi :: !(Maybe Text) -- ^ "symbol_id_coinapi" - CoinAPI symbol. One of the properties (&#x60;symbol_id_exchange&#x60;, &#x60;symbol_id_coinapi&#x60;) is required to identify the market for the new order.
  , orderExecutionReportAmountOrder :: !(Double) -- ^ /Required/ "amount_order" - Order quantity.
  , orderExecutionReportPrice :: !(Double) -- ^ /Required/ "price" - Order price.
  , orderExecutionReportSide :: !(OrdSide) -- ^ /Required/ "side"
  , orderExecutionReportOrderType :: !(OrdType) -- ^ /Required/ "order_type"
  , orderExecutionReportTimeInForce :: !(TimeInForce) -- ^ /Required/ "time_in_force"
  , orderExecutionReportExpireTime :: !(Maybe Date) -- ^ "expire_time" - Expiration time. Conditionaly required for orders with time_in_force &#x3D; &#x60;GOOD_TILL_TIME_EXCHANGE&#x60; or &#x60;GOOD_TILL_TIME_OEML&#x60;.
  , orderExecutionReportExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - Order execution instructions are documented in the separate section: &lt;a href&#x3D;\&quot;#ems-order-params-exec\&quot;&gt;EMS / Starter Guide / Order parameters / Execution instructions&lt;/a&gt; 
  , orderExecutionReportClientOrderIdFormatExchange :: !(Text) -- ^ /Required/ "client_order_id_format_exchange" - The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  , orderExecutionReportExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Unique identifier of the order assigned by the exchange or executing system.
  , orderExecutionReportAmountOpen :: !(Double) -- ^ /Required/ "amount_open" - Quantity open for further execution. &#x60;amount_open&#x60; &#x3D; &#x60;amount_order&#x60; - &#x60;amount_filled&#x60;
  , orderExecutionReportAmountFilled :: !(Double) -- ^ /Required/ "amount_filled" - Total quantity filled.
  , orderExecutionReportAvgPx :: !(Maybe Double) -- ^ "avg_px" - Calculated average price of all fills on this order.
  , orderExecutionReportStatus :: !(OrdStatus) -- ^ /Required/ "status"
  , orderExecutionReportStatusHistory :: !(Maybe [[Text]]) -- ^ "status_history" - Timestamped history of order status changes.
  , orderExecutionReportErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message.
  , orderExecutionReportFills :: !(Maybe [Fills]) -- ^ "fills" - Relay fill information on working orders.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderExecutionReport
instance A.FromJSON OrderExecutionReport where
  parseJSON = A.withObject "OrderExecutionReport" $ \o ->
    OrderExecutionReport
      <$> (o .:  "exchange_id")
      <*> (o .:  "client_order_id")
      <*> (o .:? "symbol_id_exchange")
      <*> (o .:? "symbol_id_coinapi")
      <*> (o .:  "amount_order")
      <*> (o .:  "price")
      <*> (o .:  "side")
      <*> (o .:  "order_type")
      <*> (o .:  "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")
      <*> (o .:  "client_order_id_format_exchange")
      <*> (o .:? "exchange_order_id")
      <*> (o .:  "amount_open")
      <*> (o .:  "amount_filled")
      <*> (o .:? "avg_px")
      <*> (o .:  "status")
      <*> (o .:? "status_history")
      <*> (o .:? "error_message")
      <*> (o .:? "fills")

-- | ToJSON OrderExecutionReport
instance A.ToJSON OrderExecutionReport where
  toJSON OrderExecutionReport {..} =
   _omitNulls
      [ "exchange_id" .= orderExecutionReportExchangeId
      , "client_order_id" .= orderExecutionReportClientOrderId
      , "symbol_id_exchange" .= orderExecutionReportSymbolIdExchange
      , "symbol_id_coinapi" .= orderExecutionReportSymbolIdCoinapi
      , "amount_order" .= orderExecutionReportAmountOrder
      , "price" .= orderExecutionReportPrice
      , "side" .= orderExecutionReportSide
      , "order_type" .= orderExecutionReportOrderType
      , "time_in_force" .= orderExecutionReportTimeInForce
      , "expire_time" .= orderExecutionReportExpireTime
      , "exec_inst" .= orderExecutionReportExecInst
      , "client_order_id_format_exchange" .= orderExecutionReportClientOrderIdFormatExchange
      , "exchange_order_id" .= orderExecutionReportExchangeOrderId
      , "amount_open" .= orderExecutionReportAmountOpen
      , "amount_filled" .= orderExecutionReportAmountFilled
      , "avg_px" .= orderExecutionReportAvgPx
      , "status" .= orderExecutionReportStatus
      , "status_history" .= orderExecutionReportStatusHistory
      , "error_message" .= orderExecutionReportErrorMessage
      , "fills" .= orderExecutionReportFills
      ]


-- | Construct a value of type 'OrderExecutionReport' (by applying it's required fields, if any)
mkOrderExecutionReport
  :: Text -- ^ 'orderExecutionReportExchangeId': Exchange identifier used to identify the routing destination.
  -> Text -- ^ 'orderExecutionReportClientOrderId': The unique identifier of the order assigned by the client.
  -> Double -- ^ 'orderExecutionReportAmountOrder': Order quantity.
  -> Double -- ^ 'orderExecutionReportPrice': Order price.
  -> OrdSide -- ^ 'orderExecutionReportSide' 
  -> OrdType -- ^ 'orderExecutionReportOrderType' 
  -> TimeInForce -- ^ 'orderExecutionReportTimeInForce' 
  -> Text -- ^ 'orderExecutionReportClientOrderIdFormatExchange': The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  -> Double -- ^ 'orderExecutionReportAmountOpen': Quantity open for further execution. `amount_open` = `amount_order` - `amount_filled`
  -> Double -- ^ 'orderExecutionReportAmountFilled': Total quantity filled.
  -> OrdStatus -- ^ 'orderExecutionReportStatus' 
  -> OrderExecutionReport
mkOrderExecutionReport orderExecutionReportExchangeId orderExecutionReportClientOrderId orderExecutionReportAmountOrder orderExecutionReportPrice orderExecutionReportSide orderExecutionReportOrderType orderExecutionReportTimeInForce orderExecutionReportClientOrderIdFormatExchange orderExecutionReportAmountOpen orderExecutionReportAmountFilled orderExecutionReportStatus =
  OrderExecutionReport
  { orderExecutionReportExchangeId
  , orderExecutionReportClientOrderId
  , orderExecutionReportSymbolIdExchange = Nothing
  , orderExecutionReportSymbolIdCoinapi = Nothing
  , orderExecutionReportAmountOrder
  , orderExecutionReportPrice
  , orderExecutionReportSide
  , orderExecutionReportOrderType
  , orderExecutionReportTimeInForce
  , orderExecutionReportExpireTime = Nothing
  , orderExecutionReportExecInst = Nothing
  , orderExecutionReportClientOrderIdFormatExchange
  , orderExecutionReportExchangeOrderId = Nothing
  , orderExecutionReportAmountOpen
  , orderExecutionReportAmountFilled
  , orderExecutionReportAvgPx = Nothing
  , orderExecutionReportStatus
  , orderExecutionReportStatusHistory = Nothing
  , orderExecutionReportErrorMessage = Nothing
  , orderExecutionReportFills = Nothing
  }

-- ** OrderExecutionReportAllOf
-- | OrderExecutionReportAllOf
-- The order execution report message.
data OrderExecutionReportAllOf = OrderExecutionReportAllOf
  { orderExecutionReportAllOfClientOrderIdFormatExchange :: !(Text) -- ^ /Required/ "client_order_id_format_exchange" - The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  , orderExecutionReportAllOfExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Unique identifier of the order assigned by the exchange or executing system.
  , orderExecutionReportAllOfAmountOpen :: !(Double) -- ^ /Required/ "amount_open" - Quantity open for further execution. &#x60;amount_open&#x60; &#x3D; &#x60;amount_order&#x60; - &#x60;amount_filled&#x60;
  , orderExecutionReportAllOfAmountFilled :: !(Double) -- ^ /Required/ "amount_filled" - Total quantity filled.
  , orderExecutionReportAllOfAvgPx :: !(Maybe Double) -- ^ "avg_px" - Calculated average price of all fills on this order.
  , orderExecutionReportAllOfStatus :: !(OrdStatus) -- ^ /Required/ "status"
  , orderExecutionReportAllOfStatusHistory :: !(Maybe [[Text]]) -- ^ "status_history" - Timestamped history of order status changes.
  , orderExecutionReportAllOfErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message.
  , orderExecutionReportAllOfFills :: !(Maybe [Fills]) -- ^ "fills" - Relay fill information on working orders.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderExecutionReportAllOf
instance A.FromJSON OrderExecutionReportAllOf where
  parseJSON = A.withObject "OrderExecutionReportAllOf" $ \o ->
    OrderExecutionReportAllOf
      <$> (o .:  "client_order_id_format_exchange")
      <*> (o .:? "exchange_order_id")
      <*> (o .:  "amount_open")
      <*> (o .:  "amount_filled")
      <*> (o .:? "avg_px")
      <*> (o .:  "status")
      <*> (o .:? "status_history")
      <*> (o .:? "error_message")
      <*> (o .:? "fills")

-- | ToJSON OrderExecutionReportAllOf
instance A.ToJSON OrderExecutionReportAllOf where
  toJSON OrderExecutionReportAllOf {..} =
   _omitNulls
      [ "client_order_id_format_exchange" .= orderExecutionReportAllOfClientOrderIdFormatExchange
      , "exchange_order_id" .= orderExecutionReportAllOfExchangeOrderId
      , "amount_open" .= orderExecutionReportAllOfAmountOpen
      , "amount_filled" .= orderExecutionReportAllOfAmountFilled
      , "avg_px" .= orderExecutionReportAllOfAvgPx
      , "status" .= orderExecutionReportAllOfStatus
      , "status_history" .= orderExecutionReportAllOfStatusHistory
      , "error_message" .= orderExecutionReportAllOfErrorMessage
      , "fills" .= orderExecutionReportAllOfFills
      ]


-- | Construct a value of type 'OrderExecutionReportAllOf' (by applying it's required fields, if any)
mkOrderExecutionReportAllOf
  :: Text -- ^ 'orderExecutionReportAllOfClientOrderIdFormatExchange': The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  -> Double -- ^ 'orderExecutionReportAllOfAmountOpen': Quantity open for further execution. `amount_open` = `amount_order` - `amount_filled`
  -> Double -- ^ 'orderExecutionReportAllOfAmountFilled': Total quantity filled.
  -> OrdStatus -- ^ 'orderExecutionReportAllOfStatus' 
  -> OrderExecutionReportAllOf
mkOrderExecutionReportAllOf orderExecutionReportAllOfClientOrderIdFormatExchange orderExecutionReportAllOfAmountOpen orderExecutionReportAllOfAmountFilled orderExecutionReportAllOfStatus =
  OrderExecutionReportAllOf
  { orderExecutionReportAllOfClientOrderIdFormatExchange
  , orderExecutionReportAllOfExchangeOrderId = Nothing
  , orderExecutionReportAllOfAmountOpen
  , orderExecutionReportAllOfAmountFilled
  , orderExecutionReportAllOfAvgPx = Nothing
  , orderExecutionReportAllOfStatus
  , orderExecutionReportAllOfStatusHistory = Nothing
  , orderExecutionReportAllOfErrorMessage = Nothing
  , orderExecutionReportAllOfFills = Nothing
  }

-- ** OrderHistory
-- | OrderHistory
-- Order history
-- 
data OrderHistory = OrderHistory
  { orderHistoryApikey :: !(Maybe Text) -- ^ "apikey" - Apikey
  , orderHistoryExchangeId :: !(Maybe Text) -- ^ "exchangeId" - Exchange id
  , orderHistoryClientOrderId :: !(Maybe Text) -- ^ "clientOrderId" - Client order id
  , orderHistorySymbolIdExchange :: !(Maybe Text) -- ^ "symbolIdExchange" - Symbol id exchange
  , orderHistorySymbolIdCoinapi :: !(Maybe Text) -- ^ "symbolIdCoinapi" - Symbol id in coinapi
  , orderHistoryAmountOrder :: !(Maybe Double) -- ^ "amountOrder" - Amount
  , orderHistoryPrice :: !(Maybe Double) -- ^ "price" - Price
  , orderHistorySide :: !(Maybe Double) -- ^ "side" - 1-buy, 2-sell
  , orderHistoryOrderType :: !(Maybe Text) -- ^ "orderType" - Order type
  , orderHistoryTimeInForce :: !(Maybe Text) -- ^ "timeInForce" - Time in force
  , orderHistoryExpireTime :: !(Maybe Date) -- ^ "expireTime" - Expire time
  , orderHistoryExecInst :: !(Maybe [Text]) -- ^ "execInst" - Exec inst
  , orderHistoryClientOrderIdFormatExchange :: !(Maybe Text) -- ^ "clientOrderIdFormatExchange" - Client order id format
  , orderHistoryExchangeOrderId :: !(Maybe Text) -- ^ "exchangeOrderId" - Exchange order id
  , orderHistoryAmountOpen :: !(Maybe Double) -- ^ "amountOpen" - Amount open
  , orderHistoryAmountFilled :: !(Maybe Double) -- ^ "amountFilled" - Amount filled
  , orderHistoryAvgPx :: !(Maybe Double) -- ^ "avgPx" - Average price
  , orderHistoryStatus :: !(Maybe Text) -- ^ "status" - Status
  , orderHistoryStatusHistoryStatus :: !(Maybe [Text]) -- ^ "statusHistoryStatus" - History status
  , orderHistoryStatusHistoryTime :: !(Maybe [Date]) -- ^ "statusHistoryTime" - History status time
  , orderHistoryErrorMessageResult :: !(Maybe Text) -- ^ "errorMessageResult" - Error message
  , orderHistoryErrorMessageReason :: !(Maybe Text) -- ^ "errorMessageReason" - Error message reason
  , orderHistoryErrorMessageMessage :: !(Maybe Text) -- ^ "errorMessageMessage" - Error message
  , orderHistoryFillsTime :: !(Maybe [Date]) -- ^ "fillsTime" - Fills time
  , orderHistoryFillsPrice :: !(Maybe [Double]) -- ^ "fillsPrice" - Fills price
  , orderHistoryFillsAmount :: !(Maybe [Double]) -- ^ "fillsAmount" - Fills amount
  , orderHistoryCreatedTime :: !(Maybe Date) -- ^ "createdTime" - Created time
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderHistory
instance A.FromJSON OrderHistory where
  parseJSON = A.withObject "OrderHistory" $ \o ->
    OrderHistory
      <$> (o .:? "apikey")
      <*> (o .:? "exchangeId")
      <*> (o .:? "clientOrderId")
      <*> (o .:? "symbolIdExchange")
      <*> (o .:? "symbolIdCoinapi")
      <*> (o .:? "amountOrder")
      <*> (o .:? "price")
      <*> (o .:? "side")
      <*> (o .:? "orderType")
      <*> (o .:? "timeInForce")
      <*> (o .:? "expireTime")
      <*> (o .:? "execInst")
      <*> (o .:? "clientOrderIdFormatExchange")
      <*> (o .:? "exchangeOrderId")
      <*> (o .:? "amountOpen")
      <*> (o .:? "amountFilled")
      <*> (o .:? "avgPx")
      <*> (o .:? "status")
      <*> (o .:? "statusHistoryStatus")
      <*> (o .:? "statusHistoryTime")
      <*> (o .:? "errorMessageResult")
      <*> (o .:? "errorMessageReason")
      <*> (o .:? "errorMessageMessage")
      <*> (o .:? "fillsTime")
      <*> (o .:? "fillsPrice")
      <*> (o .:? "fillsAmount")
      <*> (o .:? "createdTime")

-- | ToJSON OrderHistory
instance A.ToJSON OrderHistory where
  toJSON OrderHistory {..} =
   _omitNulls
      [ "apikey" .= orderHistoryApikey
      , "exchangeId" .= orderHistoryExchangeId
      , "clientOrderId" .= orderHistoryClientOrderId
      , "symbolIdExchange" .= orderHistorySymbolIdExchange
      , "symbolIdCoinapi" .= orderHistorySymbolIdCoinapi
      , "amountOrder" .= orderHistoryAmountOrder
      , "price" .= orderHistoryPrice
      , "side" .= orderHistorySide
      , "orderType" .= orderHistoryOrderType
      , "timeInForce" .= orderHistoryTimeInForce
      , "expireTime" .= orderHistoryExpireTime
      , "execInst" .= orderHistoryExecInst
      , "clientOrderIdFormatExchange" .= orderHistoryClientOrderIdFormatExchange
      , "exchangeOrderId" .= orderHistoryExchangeOrderId
      , "amountOpen" .= orderHistoryAmountOpen
      , "amountFilled" .= orderHistoryAmountFilled
      , "avgPx" .= orderHistoryAvgPx
      , "status" .= orderHistoryStatus
      , "statusHistoryStatus" .= orderHistoryStatusHistoryStatus
      , "statusHistoryTime" .= orderHistoryStatusHistoryTime
      , "errorMessageResult" .= orderHistoryErrorMessageResult
      , "errorMessageReason" .= orderHistoryErrorMessageReason
      , "errorMessageMessage" .= orderHistoryErrorMessageMessage
      , "fillsTime" .= orderHistoryFillsTime
      , "fillsPrice" .= orderHistoryFillsPrice
      , "fillsAmount" .= orderHistoryFillsAmount
      , "createdTime" .= orderHistoryCreatedTime
      ]


-- | Construct a value of type 'OrderHistory' (by applying it's required fields, if any)
mkOrderHistory
  :: OrderHistory
mkOrderHistory =
  OrderHistory
  { orderHistoryApikey = Nothing
  , orderHistoryExchangeId = Nothing
  , orderHistoryClientOrderId = Nothing
  , orderHistorySymbolIdExchange = Nothing
  , orderHistorySymbolIdCoinapi = Nothing
  , orderHistoryAmountOrder = Nothing
  , orderHistoryPrice = Nothing
  , orderHistorySide = Nothing
  , orderHistoryOrderType = Nothing
  , orderHistoryTimeInForce = Nothing
  , orderHistoryExpireTime = Nothing
  , orderHistoryExecInst = Nothing
  , orderHistoryClientOrderIdFormatExchange = Nothing
  , orderHistoryExchangeOrderId = Nothing
  , orderHistoryAmountOpen = Nothing
  , orderHistoryAmountFilled = Nothing
  , orderHistoryAvgPx = Nothing
  , orderHistoryStatus = Nothing
  , orderHistoryStatusHistoryStatus = Nothing
  , orderHistoryStatusHistoryTime = Nothing
  , orderHistoryErrorMessageResult = Nothing
  , orderHistoryErrorMessageReason = Nothing
  , orderHistoryErrorMessageMessage = Nothing
  , orderHistoryFillsTime = Nothing
  , orderHistoryFillsPrice = Nothing
  , orderHistoryFillsAmount = Nothing
  , orderHistoryCreatedTime = Nothing
  }

-- ** OrderNewSingleRequest
-- | OrderNewSingleRequest
-- The new order message.
data OrderNewSingleRequest = OrderNewSingleRequest
  { orderNewSingleRequestExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier used to identify the routing destination.
  , orderNewSingleRequestClientOrderId :: !(Text) -- ^ /Required/ "client_order_id" - The unique identifier of the order assigned by the client.
  , orderNewSingleRequestSymbolIdExchange :: !(Maybe Text) -- ^ "symbol_id_exchange" - Exchange symbol. One of the properties (&#x60;symbol_id_exchange&#x60;, &#x60;symbol_id_coinapi&#x60;) is required to identify the market for the new order.
  , orderNewSingleRequestSymbolIdCoinapi :: !(Maybe Text) -- ^ "symbol_id_coinapi" - CoinAPI symbol. One of the properties (&#x60;symbol_id_exchange&#x60;, &#x60;symbol_id_coinapi&#x60;) is required to identify the market for the new order.
  , orderNewSingleRequestAmountOrder :: !(Double) -- ^ /Required/ "amount_order" - Order quantity.
  , orderNewSingleRequestPrice :: !(Double) -- ^ /Required/ "price" - Order price.
  , orderNewSingleRequestSide :: !(OrdSide) -- ^ /Required/ "side"
  , orderNewSingleRequestOrderType :: !(OrdType) -- ^ /Required/ "order_type"
  , orderNewSingleRequestTimeInForce :: !(TimeInForce) -- ^ /Required/ "time_in_force"
  , orderNewSingleRequestExpireTime :: !(Maybe Date) -- ^ "expire_time" - Expiration time. Conditionaly required for orders with time_in_force &#x3D; &#x60;GOOD_TILL_TIME_EXCHANGE&#x60; or &#x60;GOOD_TILL_TIME_OEML&#x60;.
  , orderNewSingleRequestExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - Order execution instructions are documented in the separate section: &lt;a href&#x3D;\&quot;#ems-order-params-exec\&quot;&gt;EMS / Starter Guide / Order parameters / Execution instructions&lt;/a&gt; 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderNewSingleRequest
instance A.FromJSON OrderNewSingleRequest where
  parseJSON = A.withObject "OrderNewSingleRequest" $ \o ->
    OrderNewSingleRequest
      <$> (o .:  "exchange_id")
      <*> (o .:  "client_order_id")
      <*> (o .:? "symbol_id_exchange")
      <*> (o .:? "symbol_id_coinapi")
      <*> (o .:  "amount_order")
      <*> (o .:  "price")
      <*> (o .:  "side")
      <*> (o .:  "order_type")
      <*> (o .:  "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")

-- | ToJSON OrderNewSingleRequest
instance A.ToJSON OrderNewSingleRequest where
  toJSON OrderNewSingleRequest {..} =
   _omitNulls
      [ "exchange_id" .= orderNewSingleRequestExchangeId
      , "client_order_id" .= orderNewSingleRequestClientOrderId
      , "symbol_id_exchange" .= orderNewSingleRequestSymbolIdExchange
      , "symbol_id_coinapi" .= orderNewSingleRequestSymbolIdCoinapi
      , "amount_order" .= orderNewSingleRequestAmountOrder
      , "price" .= orderNewSingleRequestPrice
      , "side" .= orderNewSingleRequestSide
      , "order_type" .= orderNewSingleRequestOrderType
      , "time_in_force" .= orderNewSingleRequestTimeInForce
      , "expire_time" .= orderNewSingleRequestExpireTime
      , "exec_inst" .= orderNewSingleRequestExecInst
      ]


-- | Construct a value of type 'OrderNewSingleRequest' (by applying it's required fields, if any)
mkOrderNewSingleRequest
  :: Text -- ^ 'orderNewSingleRequestExchangeId': Exchange identifier used to identify the routing destination.
  -> Text -- ^ 'orderNewSingleRequestClientOrderId': The unique identifier of the order assigned by the client.
  -> Double -- ^ 'orderNewSingleRequestAmountOrder': Order quantity.
  -> Double -- ^ 'orderNewSingleRequestPrice': Order price.
  -> OrdSide -- ^ 'orderNewSingleRequestSide' 
  -> OrdType -- ^ 'orderNewSingleRequestOrderType' 
  -> TimeInForce -- ^ 'orderNewSingleRequestTimeInForce' 
  -> OrderNewSingleRequest
mkOrderNewSingleRequest orderNewSingleRequestExchangeId orderNewSingleRequestClientOrderId orderNewSingleRequestAmountOrder orderNewSingleRequestPrice orderNewSingleRequestSide orderNewSingleRequestOrderType orderNewSingleRequestTimeInForce =
  OrderNewSingleRequest
  { orderNewSingleRequestExchangeId
  , orderNewSingleRequestClientOrderId
  , orderNewSingleRequestSymbolIdExchange = Nothing
  , orderNewSingleRequestSymbolIdCoinapi = Nothing
  , orderNewSingleRequestAmountOrder
  , orderNewSingleRequestPrice
  , orderNewSingleRequestSide
  , orderNewSingleRequestOrderType
  , orderNewSingleRequestTimeInForce
  , orderNewSingleRequestExpireTime = Nothing
  , orderNewSingleRequestExecInst = Nothing
  }

-- ** Position
-- | Position
data Position = Position
  { positionExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier used to identify the routing destination.
  , positionData :: !(Maybe [PositionDataInner]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Position
instance A.FromJSON Position where
  parseJSON = A.withObject "Position" $ \o ->
    Position
      <$> (o .:? "exchange_id")
      <*> (o .:? "data")

-- | ToJSON Position
instance A.ToJSON Position where
  toJSON Position {..} =
   _omitNulls
      [ "exchange_id" .= positionExchangeId
      , "data" .= positionData
      ]


-- | Construct a value of type 'Position' (by applying it's required fields, if any)
mkPosition
  :: Position
mkPosition =
  Position
  { positionExchangeId = Nothing
  , positionData = Nothing
  }

-- ** PositionDataInner
-- | PositionDataInner
-- The Position object.
data PositionDataInner = PositionDataInner
  { positionDataInnerSymbolIdExchange :: !(Maybe Text) -- ^ "symbol_id_exchange" - Exchange symbol.
  , positionDataInnerSymbolIdCoinapi :: !(Maybe Text) -- ^ "symbol_id_coinapi" - CoinAPI symbol.
  , positionDataInnerAvgEntryPrice :: !(Maybe Double) -- ^ "avg_entry_price" - Calculated average price of all fills on this position.
  , positionDataInnerQuantity :: !(Maybe Double) -- ^ "quantity" - The current position quantity.
  , positionDataInnerSide :: !(Maybe OrdSide) -- ^ "side"
  , positionDataInnerUnrealizedPnl :: !(Maybe Double) -- ^ "unrealized_pnl" - Unrealised profit or loss (PNL) of this position.
  , positionDataInnerLeverage :: !(Maybe Double) -- ^ "leverage" - Leverage for this position reported by the exchange.
  , positionDataInnerCrossMargin :: !(Maybe Bool) -- ^ "cross_margin" - Is cross margin mode enable for this position?
  , positionDataInnerLiquidationPrice :: !(Maybe Double) -- ^ "liquidation_price" - Liquidation price. If mark price will reach this value, the position will be liquidated.
  , positionDataInnerRawData :: !(Maybe A.Value) -- ^ "raw_data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PositionDataInner
instance A.FromJSON PositionDataInner where
  parseJSON = A.withObject "PositionDataInner" $ \o ->
    PositionDataInner
      <$> (o .:? "symbol_id_exchange")
      <*> (o .:? "symbol_id_coinapi")
      <*> (o .:? "avg_entry_price")
      <*> (o .:? "quantity")
      <*> (o .:? "side")
      <*> (o .:? "unrealized_pnl")
      <*> (o .:? "leverage")
      <*> (o .:? "cross_margin")
      <*> (o .:? "liquidation_price")
      <*> (o .:? "raw_data")

-- | ToJSON PositionDataInner
instance A.ToJSON PositionDataInner where
  toJSON PositionDataInner {..} =
   _omitNulls
      [ "symbol_id_exchange" .= positionDataInnerSymbolIdExchange
      , "symbol_id_coinapi" .= positionDataInnerSymbolIdCoinapi
      , "avg_entry_price" .= positionDataInnerAvgEntryPrice
      , "quantity" .= positionDataInnerQuantity
      , "side" .= positionDataInnerSide
      , "unrealized_pnl" .= positionDataInnerUnrealizedPnl
      , "leverage" .= positionDataInnerLeverage
      , "cross_margin" .= positionDataInnerCrossMargin
      , "liquidation_price" .= positionDataInnerLiquidationPrice
      , "raw_data" .= positionDataInnerRawData
      ]


-- | Construct a value of type 'PositionDataInner' (by applying it's required fields, if any)
mkPositionDataInner
  :: PositionDataInner
mkPositionDataInner =
  PositionDataInner
  { positionDataInnerSymbolIdExchange = Nothing
  , positionDataInnerSymbolIdCoinapi = Nothing
  , positionDataInnerAvgEntryPrice = Nothing
  , positionDataInnerQuantity = Nothing
  , positionDataInnerSide = Nothing
  , positionDataInnerUnrealizedPnl = Nothing
  , positionDataInnerLeverage = Nothing
  , positionDataInnerCrossMargin = Nothing
  , positionDataInnerLiquidationPrice = Nothing
  , positionDataInnerRawData = Nothing
  }

-- ** ValidationError
-- | ValidationError
-- JSON validation error.
-- 
data ValidationError = ValidationError
  { validationErrorType :: !(Maybe Text) -- ^ "type"
  , validationErrorTitle :: !(Maybe Text) -- ^ "title"
  , validationErrorStatus :: !(Maybe Double) -- ^ "status"
  , validationErrorTraceId :: !(Maybe Text) -- ^ "traceId"
  , validationErrorErrors :: !(Maybe Text) -- ^ "errors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ValidationError
instance A.FromJSON ValidationError where
  parseJSON = A.withObject "ValidationError" $ \o ->
    ValidationError
      <$> (o .:? "type")
      <*> (o .:? "title")
      <*> (o .:? "status")
      <*> (o .:? "traceId")
      <*> (o .:? "errors")

-- | ToJSON ValidationError
instance A.ToJSON ValidationError where
  toJSON ValidationError {..} =
   _omitNulls
      [ "type" .= validationErrorType
      , "title" .= validationErrorTitle
      , "status" .= validationErrorStatus
      , "traceId" .= validationErrorTraceId
      , "errors" .= validationErrorErrors
      ]


-- | Construct a value of type 'ValidationError' (by applying it's required fields, if any)
mkValidationError
  :: ValidationError
mkValidationError =
  ValidationError
  { validationErrorType = Nothing
  , validationErrorTitle = Nothing
  , validationErrorStatus = Nothing
  , validationErrorTraceId = Nothing
  , validationErrorErrors = Nothing
  }


-- * Enums


-- ** E'ExecInst

-- | Enum of 'Text'
data E'ExecInst
  = E'ExecInst'MAKER_OR_CANCEL -- ^ @"MAKER_OR_CANCEL"@
  | E'ExecInst'AUCTION_ONLY -- ^ @"AUCTION_ONLY"@
  | E'ExecInst'INDICATION_OF_INTEREST -- ^ @"INDICATION_OF_INTEREST"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ExecInst where toJSON = A.toJSON . fromE'ExecInst
instance A.FromJSON E'ExecInst where parseJSON o = P.either P.fail (pure . P.id) . toE'ExecInst =<< A.parseJSON o
instance WH.ToHttpApiData E'ExecInst where toQueryParam = WH.toQueryParam . fromE'ExecInst
instance WH.FromHttpApiData E'ExecInst where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ExecInst
instance MimeRender MimeMultipartFormData E'ExecInst where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ExecInst' enum
fromE'ExecInst :: E'ExecInst -> Text
fromE'ExecInst = \case
  E'ExecInst'MAKER_OR_CANCEL -> "MAKER_OR_CANCEL"
  E'ExecInst'AUCTION_ONLY -> "AUCTION_ONLY"
  E'ExecInst'INDICATION_OF_INTEREST -> "INDICATION_OF_INTEREST"

-- | parse 'E'ExecInst' enum
toE'ExecInst :: Text -> P.Either String E'ExecInst
toE'ExecInst = \case
  "MAKER_OR_CANCEL" -> P.Right E'ExecInst'MAKER_OR_CANCEL
  "AUCTION_ONLY" -> P.Right E'ExecInst'AUCTION_ONLY
  "INDICATION_OF_INTEREST" -> P.Right E'ExecInst'INDICATION_OF_INTEREST
  s -> P.Left $ "toE'ExecInst: enum parse failure: " P.++ P.show s


-- ** E'LastUpdatedBy

-- | Enum of 'Text' .
-- Source of the last modification. 
data E'LastUpdatedBy
  = E'LastUpdatedBy'INITIALIZATION -- ^ @"INITIALIZATION"@
  | E'LastUpdatedBy'BALANCE_MANAGER -- ^ @"BALANCE_MANAGER"@
  | E'LastUpdatedBy'EXCHANGE -- ^ @"EXCHANGE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'LastUpdatedBy where toJSON = A.toJSON . fromE'LastUpdatedBy
instance A.FromJSON E'LastUpdatedBy where parseJSON o = P.either P.fail (pure . P.id) . toE'LastUpdatedBy =<< A.parseJSON o
instance WH.ToHttpApiData E'LastUpdatedBy where toQueryParam = WH.toQueryParam . fromE'LastUpdatedBy
instance WH.FromHttpApiData E'LastUpdatedBy where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'LastUpdatedBy
instance MimeRender MimeMultipartFormData E'LastUpdatedBy where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'LastUpdatedBy' enum
fromE'LastUpdatedBy :: E'LastUpdatedBy -> Text
fromE'LastUpdatedBy = \case
  E'LastUpdatedBy'INITIALIZATION -> "INITIALIZATION"
  E'LastUpdatedBy'BALANCE_MANAGER -> "BALANCE_MANAGER"
  E'LastUpdatedBy'EXCHANGE -> "EXCHANGE"

-- | parse 'E'LastUpdatedBy' enum
toE'LastUpdatedBy :: Text -> P.Either String E'LastUpdatedBy
toE'LastUpdatedBy = \case
  "INITIALIZATION" -> P.Right E'LastUpdatedBy'INITIALIZATION
  "BALANCE_MANAGER" -> P.Right E'LastUpdatedBy'BALANCE_MANAGER
  "EXCHANGE" -> P.Right E'LastUpdatedBy'EXCHANGE
  s -> P.Left $ "toE'LastUpdatedBy: enum parse failure: " P.++ P.show s


-- ** OrdSide

-- | Enum of 'Text' .
-- Side of order. 
data OrdSide
  = OrdSide'BUY -- ^ @"BUY"@
  | OrdSide'SELL -- ^ @"SELL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdSide where toJSON = A.toJSON . fromOrdSide
instance A.FromJSON OrdSide where parseJSON o = P.either P.fail (pure . P.id) . toOrdSide =<< A.parseJSON o
instance WH.ToHttpApiData OrdSide where toQueryParam = WH.toQueryParam . fromOrdSide
instance WH.FromHttpApiData OrdSide where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdSide
instance MimeRender MimeMultipartFormData OrdSide where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdSide' enum
fromOrdSide :: OrdSide -> Text
fromOrdSide = \case
  OrdSide'BUY -> "BUY"
  OrdSide'SELL -> "SELL"

-- | parse 'OrdSide' enum
toOrdSide :: Text -> P.Either String OrdSide
toOrdSide = \case
  "BUY" -> P.Right OrdSide'BUY
  "SELL" -> P.Right OrdSide'SELL
  s -> P.Left $ "toOrdSide: enum parse failure: " P.++ P.show s


-- ** OrdStatus

-- | Enum of 'Text' .
-- Order statuses and the lifecycle are documented in the separate section: <a href=\"#ems-order-lifecycle\">EMS / Starter Guide / Order Lifecycle</a> 
data OrdStatus
  = OrdStatus'RECEIVED -- ^ @"RECEIVED"@
  | OrdStatus'ROUTING -- ^ @"ROUTING"@
  | OrdStatus'ROUTED -- ^ @"ROUTED"@
  | OrdStatus'NEW -- ^ @"NEW"@
  | OrdStatus'PENDING_CANCEL -- ^ @"PENDING_CANCEL"@
  | OrdStatus'PARTIALLY_FILLED -- ^ @"PARTIALLY_FILLED"@
  | OrdStatus'FILLED -- ^ @"FILLED"@
  | OrdStatus'CANCELED -- ^ @"CANCELED"@
  | OrdStatus'REJECTED -- ^ @"REJECTED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdStatus where toJSON = A.toJSON . fromOrdStatus
instance A.FromJSON OrdStatus where parseJSON o = P.either P.fail (pure . P.id) . toOrdStatus =<< A.parseJSON o
instance WH.ToHttpApiData OrdStatus where toQueryParam = WH.toQueryParam . fromOrdStatus
instance WH.FromHttpApiData OrdStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdStatus
instance MimeRender MimeMultipartFormData OrdStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdStatus' enum
fromOrdStatus :: OrdStatus -> Text
fromOrdStatus = \case
  OrdStatus'RECEIVED -> "RECEIVED"
  OrdStatus'ROUTING -> "ROUTING"
  OrdStatus'ROUTED -> "ROUTED"
  OrdStatus'NEW -> "NEW"
  OrdStatus'PENDING_CANCEL -> "PENDING_CANCEL"
  OrdStatus'PARTIALLY_FILLED -> "PARTIALLY_FILLED"
  OrdStatus'FILLED -> "FILLED"
  OrdStatus'CANCELED -> "CANCELED"
  OrdStatus'REJECTED -> "REJECTED"

-- | parse 'OrdStatus' enum
toOrdStatus :: Text -> P.Either String OrdStatus
toOrdStatus = \case
  "RECEIVED" -> P.Right OrdStatus'RECEIVED
  "ROUTING" -> P.Right OrdStatus'ROUTING
  "ROUTED" -> P.Right OrdStatus'ROUTED
  "NEW" -> P.Right OrdStatus'NEW
  "PENDING_CANCEL" -> P.Right OrdStatus'PENDING_CANCEL
  "PARTIALLY_FILLED" -> P.Right OrdStatus'PARTIALLY_FILLED
  "FILLED" -> P.Right OrdStatus'FILLED
  "CANCELED" -> P.Right OrdStatus'CANCELED
  "REJECTED" -> P.Right OrdStatus'REJECTED
  s -> P.Left $ "toOrdStatus: enum parse failure: " P.++ P.show s


-- ** OrdType

-- | Enum of 'Text' .
-- Order types are documented in the separate section: <a href=\"#ems-order-params-type\">EMS / Starter Guide / Order parameters / Order type</a> 
data OrdType
  = OrdType'LIMIT -- ^ @"LIMIT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdType where toJSON = A.toJSON . fromOrdType
instance A.FromJSON OrdType where parseJSON o = P.either P.fail (pure . P.id) . toOrdType =<< A.parseJSON o
instance WH.ToHttpApiData OrdType where toQueryParam = WH.toQueryParam . fromOrdType
instance WH.FromHttpApiData OrdType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdType
instance MimeRender MimeMultipartFormData OrdType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdType' enum
fromOrdType :: OrdType -> Text
fromOrdType = \case
  OrdType'LIMIT -> "LIMIT"

-- | parse 'OrdType' enum
toOrdType :: Text -> P.Either String OrdType
toOrdType = \case
  "LIMIT" -> P.Right OrdType'LIMIT
  s -> P.Left $ "toOrdType: enum parse failure: " P.++ P.show s


-- ** RejectReason

-- | Enum of 'Text' .
-- Cause of rejection.
data RejectReason
  = RejectReason'OTHER -- ^ @"OTHER"@
  | RejectReason'EXCHANGE_UNREACHABLE -- ^ @"EXCHANGE_UNREACHABLE"@
  | RejectReason'EXCHANGE_RESPONSE_TIMEOUT -- ^ @"EXCHANGE_RESPONSE_TIMEOUT"@
  | RejectReason'ORDER_ID_NOT_FOUND -- ^ @"ORDER_ID_NOT_FOUND"@
  | RejectReason'INVALID_TYPE -- ^ @"INVALID_TYPE"@
  | RejectReason'METHOD_NOT_SUPPORTED -- ^ @"METHOD_NOT_SUPPORTED"@
  | RejectReason'JSON_ERROR -- ^ @"JSON_ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RejectReason where toJSON = A.toJSON . fromRejectReason
instance A.FromJSON RejectReason where parseJSON o = P.either P.fail (pure . P.id) . toRejectReason =<< A.parseJSON o
instance WH.ToHttpApiData RejectReason where toQueryParam = WH.toQueryParam . fromRejectReason
instance WH.FromHttpApiData RejectReason where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRejectReason
instance MimeRender MimeMultipartFormData RejectReason where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RejectReason' enum
fromRejectReason :: RejectReason -> Text
fromRejectReason = \case
  RejectReason'OTHER -> "OTHER"
  RejectReason'EXCHANGE_UNREACHABLE -> "EXCHANGE_UNREACHABLE"
  RejectReason'EXCHANGE_RESPONSE_TIMEOUT -> "EXCHANGE_RESPONSE_TIMEOUT"
  RejectReason'ORDER_ID_NOT_FOUND -> "ORDER_ID_NOT_FOUND"
  RejectReason'INVALID_TYPE -> "INVALID_TYPE"
  RejectReason'METHOD_NOT_SUPPORTED -> "METHOD_NOT_SUPPORTED"
  RejectReason'JSON_ERROR -> "JSON_ERROR"

-- | parse 'RejectReason' enum
toRejectReason :: Text -> P.Either String RejectReason
toRejectReason = \case
  "OTHER" -> P.Right RejectReason'OTHER
  "EXCHANGE_UNREACHABLE" -> P.Right RejectReason'EXCHANGE_UNREACHABLE
  "EXCHANGE_RESPONSE_TIMEOUT" -> P.Right RejectReason'EXCHANGE_RESPONSE_TIMEOUT
  "ORDER_ID_NOT_FOUND" -> P.Right RejectReason'ORDER_ID_NOT_FOUND
  "INVALID_TYPE" -> P.Right RejectReason'INVALID_TYPE
  "METHOD_NOT_SUPPORTED" -> P.Right RejectReason'METHOD_NOT_SUPPORTED
  "JSON_ERROR" -> P.Right RejectReason'JSON_ERROR
  s -> P.Left $ "toRejectReason: enum parse failure: " P.++ P.show s


-- ** TimeInForce

-- | Enum of 'Text' .
-- Order time in force options are documented in the separate section: <a href=\"#ems-order-params-tif\">EMS / Starter Guide / Order parameters / Time in force</a> 
data TimeInForce
  = TimeInForce'GOOD_TILL_CANCEL -- ^ @"GOOD_TILL_CANCEL"@
  | TimeInForce'GOOD_TILL_TIME_EXCHANGE -- ^ @"GOOD_TILL_TIME_EXCHANGE"@
  | TimeInForce'GOOD_TILL_TIME_OMS -- ^ @"GOOD_TILL_TIME_OMS"@
  | TimeInForce'FILL_OR_KILL -- ^ @"FILL_OR_KILL"@
  | TimeInForce'IMMEDIATE_OR_CANCEL -- ^ @"IMMEDIATE_OR_CANCEL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TimeInForce where toJSON = A.toJSON . fromTimeInForce
instance A.FromJSON TimeInForce where parseJSON o = P.either P.fail (pure . P.id) . toTimeInForce =<< A.parseJSON o
instance WH.ToHttpApiData TimeInForce where toQueryParam = WH.toQueryParam . fromTimeInForce
instance WH.FromHttpApiData TimeInForce where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTimeInForce
instance MimeRender MimeMultipartFormData TimeInForce where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TimeInForce' enum
fromTimeInForce :: TimeInForce -> Text
fromTimeInForce = \case
  TimeInForce'GOOD_TILL_CANCEL -> "GOOD_TILL_CANCEL"
  TimeInForce'GOOD_TILL_TIME_EXCHANGE -> "GOOD_TILL_TIME_EXCHANGE"
  TimeInForce'GOOD_TILL_TIME_OMS -> "GOOD_TILL_TIME_OMS"
  TimeInForce'FILL_OR_KILL -> "FILL_OR_KILL"
  TimeInForce'IMMEDIATE_OR_CANCEL -> "IMMEDIATE_OR_CANCEL"

-- | parse 'TimeInForce' enum
toTimeInForce :: Text -> P.Either String TimeInForce
toTimeInForce = \case
  "GOOD_TILL_CANCEL" -> P.Right TimeInForce'GOOD_TILL_CANCEL
  "GOOD_TILL_TIME_EXCHANGE" -> P.Right TimeInForce'GOOD_TILL_TIME_EXCHANGE
  "GOOD_TILL_TIME_OMS" -> P.Right TimeInForce'GOOD_TILL_TIME_OMS
  "FILL_OR_KILL" -> P.Right TimeInForce'FILL_OR_KILL
  "IMMEDIATE_OR_CANCEL" -> P.Right TimeInForce'IMMEDIATE_OR_CANCEL
  s -> P.Left $ "toTimeInForce: enum parse failure: " P.++ P.show s



